IDProcess	IDApp	Name	Category	EngineVersion	RuntimeVersion	ObjectVersion	DescriptorType	Descriptor	DefinitionType	Definition	NewProcess	UniqueID	Description	IsInContent	ContentState	IsProtected	ID	StampActor	StampRecursive	StampTime	StampConstraint	StampStatus
B9EF2EEC-66DC-4F2E-B0A9-759394340542	5B75A1B7-7BBF-4FC0-BA59-AD11AA6EB965	AddElement_BANK	Cash_report	4.0	4.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Bool"" process-is-protected=""False"">
  <parameter-descriptor parameter-name=""olapserver"" parameter-type=""string"" parameter-description=""OLAP server name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""olapdatabase"" parameter-type=""string"" parameter-description=""OLAP database"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension name"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""Element name"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""description"" parameter-type=""string"" parameter-description=""Element description"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 4.0
#define RuntimeVersion 4.0


bool AddElement_BANK(string olapserver, string olapdatabase,
                string dimension, string name, string description)
	
@Description: ""Programe adds a new element to the dimension"";
@Category: ""Cash_report"";
	
@Parameter[olapserver]: ""OLAP server name"";
@Parameter[olapdatabase]: ""OLAP database"";
@Parameter[dimension]: ""Dimension name"";
@Parameter[name]: ""Element name"";
@Parameter[description]: ""Element description"";
	

@Returns: ""Bool"";
{

	string errorMessage = """";
	int errorCode = 0;
	bool success = true;
	DateTime date_time = CreateDateTime();
	string date_time_string = GetDateTimeAsString(date_time, ""yyyyMMddHHmm"");


	//string olapserver=""TBSeMun02Srv62"";
	//string olapdatabase=""Planning and Budgeting"";

	//string dimension = ""Bank"";
	string parentElement = ""Total"";
	string new_element = ""-1"";
	//string name= ""test"";
	//string description = ""test"";

	// utworz polaczenie z serverem OLAP i modelem HR
	OLAPConnection olapConnection = OLAPCreateConnection(olapserver + ""/"" + olapdatabase,""admin"",""R3p0s!t0r6Adm!N"");
	//OLAPConnection olapConnection = OLAPCreateConnection(olapserver + ""/"" + olapdatabase, ticket);


	//-----------------------------------------------------------------------------------------------------------------------
	// 1. dodaje nowy element do wymairu

	// wyznaczam Id nowego elementu
	NotifyInformation(""Adding a new element..."");

	OLAPElementList ElementList = OLAPGetElementList(olapConnection, dimension, true);

	int elements_number = Count(ElementList);
	WriteLine(""elements_number: "" + elements_number);

	string element_end = ToString(elements_number+1);
	int length_elements_number = StringLength(element_end);
	WriteLine(""length_elements_number: "" + length_elements_number);

	if(length_elements_number==0){NotifyError(errorMessage); return false;}
	else if(length_elements_number==1){new_element = ""00""+element_end;}
	else if(length_elements_number==2){new_element = ""0""+element_end;}
	else {new_element = element_end;}

	WriteLine(""new_element: "" + new_element);

	// dodaje nowy element
	try
	{
		//WriteLine(""parentElement: "" + parentElement);
		//WriteLine(""new_element: "" + element);
		OLAPCreateNumericalDimensionElement(olapConnection, dimension, new_element, parentElement, 1);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_NAME"", name);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_DESC"", description);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_ORDER"", ToString(ToInt(new_element)));
		
	}
	catch (errorMessage, errorCode)
	{
		NotifyError(errorMessage);
		return false;
	}


	NotifyInformation(""The new element "" + new_element + "" has been added to the dimension"");
	

	NotifyInformation(""Process completed"");
	OLAPDisconnect(olapConnection);
	return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 4.0
#define RuntimeVersion 4.0


bool AddElement_BANK(string olapserver, string olapdatabase,
                string dimension, string name, string description)
	
@Description: ""Programe adds a new element to the dimension"";
@Category: ""Cash_report"";
	
@Parameter[olapserver]: ""OLAP server name"";
@Parameter[olapdatabase]: ""OLAP database"";
@Parameter[dimension]: ""Dimension name"";
@Parameter[name]: ""Element name"";
@Parameter[description]: ""Element description"";
	

@Returns: ""Bool"";
{

	string errorMessage = """";
	int errorCode = 0;
	bool success = true;
	DateTime date_time = CreateDateTime();
	string date_time_string = GetDateTimeAsString(date_time, ""yyyyMMddHHmm"");


	//string olapserver=""TBSeMun02Srv62"";
	//string olapdatabase=""Planning and Budgeting"";

	//string dimension = ""Bank"";
	string parentElement = ""Total"";
	string new_element = ""-1"";
	//string name= ""test"";
	//string description = ""test"";

	// utworz polaczenie z serverem OLAP i modelem HR
	OLAPConnection olapConnection = OLAPCreateConnection(olapserver + ""/"" + olapdatabase,""admin"",""R3p0s!t0r6Adm!N"");
	//OLAPConnection olapConnection = OLAPCreateConnection(olapserver + ""/"" + olapdatabase, ticket);


	//-----------------------------------------------------------------------------------------------------------------------
	// 1. dodaje nowy element do wymairu

	// wyznaczam Id nowego elementu
	NotifyInformation(""Adding a new element..."");

	OLAPElementList ElementList = OLAPGetElementList(olapConnection, dimension, true);

	int elements_number = Count(ElementList);
	WriteLine(""elements_number: "" + elements_number);

	string element_end = ToString(elements_number+1);
	int length_elements_number = StringLength(element_end);
	WriteLine(""length_elements_number: "" + length_elements_number);

	if(length_elements_number==0){NotifyError(errorMessage); return false;}
	else if(length_elements_number==1){new_element = ""00""+element_end;}
	else if(length_elements_number==2){new_element = ""0""+element_end;}
	else {new_element = element_end;}

	WriteLine(""new_element: "" + new_element);

	// dodaje nowy element
	try
	{
		//WriteLine(""parentElement: "" + parentElement);
		//WriteLine(""new_element: "" + element);
		OLAPCreateNumericalDimensionElement(olapConnection, dimension, new_element, parentElement, 1);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_NAME"", name);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_DESC"", description);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_ORDER"", ToString(ToInt(new_element)));
		
	}
	catch (errorMessage, errorCode)
	{
		NotifyError(errorMessage);
		return false;
	}


	NotifyInformation(""The new element "" + new_element + "" has been added to the dimension"");
	

	NotifyInformation(""Process completed"");
	OLAPDisconnect(olapConnection);
	return true;
}"	1	651B3C7E-0969-4D4A-B220-CB5A6AF26C99	Programe adds a new element to the dimension	0	0	0	1430	NULL	0	45667.51072	0	0
42647714-A763-4A48-A1E5-7D2DC9437EFD	5B75A1B7-7BBF-4FC0-BA59-AD11AA6EB965	AddElement_BANK	Cash_report	5.0	5.0	2	1	"<process-descriptor return-type=""bool"" return-value-description=""Bool"" process-is-protected=""False"">
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""Element name"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""description"" parameter-type=""string"" parameter-description=""Element description"" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool AddElement_BANK(string dimension, string name, string description)
	
@Description: ""Programe adds a new element to the dimension"";
@Category: ""Cash_report"";
@Parameter[dimension]: ""Dimension name"";
@Parameter[name]: ""Element name"";
@Parameter[description]: ""Element description"";
	

@Returns: ""Bool"";
{

	string errorMessage = """";
	int errorCode = 0;
	bool success = true;
	DateTime date_time = CreateDateTime();
	string date_time_string = GetDateTimeAsString(date_time, ""yyyyMMddHHmm"");


	//string olapserver=""TBSeMun02Srv62"";
	//string olapdatabase=""Planning and Budgeting"";

	//string dimension = ""Bank"";
	string parentElement = ""Total"";
	string new_element = ""-1"";
	//string name= ""test"";
	//string description = ""test"";

	// utworz polaczenie z serverem OLAP i modelem HR
	OLAPConnection olapConnection = OLAPCreateNamedConnection(""Planning and Budgeting"");
	//OLAPConnection olapConnection =OLAPc


	//-----------------------------------------------------------------------------------------------------------------------
	// 1. dodaje nowy element do wymairu

	// wyznaczam Id nowego elementu
	NotifyInformation(""Adding a new element..."");

	OLAPElementList ElementList = OLAPGetElementList(olapConnection, dimension, true);

	int elements_number = Count(ElementList);
	WriteLine(""elements_number: "" + elements_number);

	string element_end = ToString(elements_number+1);
	int length_elements_number = StringLength(element_end);
	WriteLine(""length_elements_number: "" + length_elements_number);

	if(length_elements_number==0){NotifyError(errorMessage); return false;}
	else if(length_elements_number==1){new_element = ""00""+element_end;}
	else if(length_elements_number==2){new_element = ""0""+element_end;}
	else {new_element = element_end;}

	WriteLine(""new_element: "" + new_element);

	// dodaje nowy element
	try
	{
		//WriteLine(""parentElement: "" + parentElement);
		//WriteLine(""new_element: "" + element);
		OLAPCreateNumericalDimensionElement(olapConnection, dimension, new_element, parentElement, 1);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_NAME"", name);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_DESC"", description);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_ORDER"", ToString(ToInt(new_element)));
		
	}
	catch (errorMessage, errorCode)
	{
		NotifyError(errorMessage);
		return false;
	}


	NotifyInformation(""The new element "" + new_element + "" has been added to the dimension"");
	

	NotifyInformation(""Process completed"");
	OLAPDisconnect(olapConnection);
	return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool AddElement_BANK(string dimension, string name, string description)
	
@Description: ""Programe adds a new element to the dimension"";
@Category: ""Cash_report"";
@Parameter[dimension]: ""Dimension name"";
@Parameter[name]: ""Element name"";
@Parameter[description]: ""Element description"";
	

@Returns: ""Bool"";
{

	string errorMessage = """";
	int errorCode = 0;
	bool success = true;
	DateTime date_time = CreateDateTime();
	string date_time_string = GetDateTimeAsString(date_time, ""yyyyMMddHHmm"");


	//string olapserver=""TBSeMun02Srv62"";
	//string olapdatabase=""Planning and Budgeting"";

	//string dimension = ""Bank"";
	string parentElement = ""Total"";
	string new_element = ""-1"";
	//string name= ""test"";
	//string description = ""test"";

	// utworz polaczenie z serverem OLAP i modelem HR
	OLAPConnection olapConnection = OLAPCreateNamedConnection(""Planning and Budgeting"");
	//OLAPConnection olapConnection =OLAPc


	//-----------------------------------------------------------------------------------------------------------------------
	// 1. dodaje nowy element do wymairu

	// wyznaczam Id nowego elementu
	NotifyInformation(""Adding a new element..."");

	OLAPElementList ElementList = OLAPGetElementList(olapConnection, dimension, true);

	int elements_number = Count(ElementList);
	WriteLine(""elements_number: "" + elements_number);

	string element_end = ToString(elements_number+1);
	int length_elements_number = StringLength(element_end);
	WriteLine(""length_elements_number: "" + length_elements_number);

	if(length_elements_number==0){NotifyError(errorMessage); return false;}
	else if(length_elements_number==1){new_element = ""00""+element_end;}
	else if(length_elements_number==2){new_element = ""0""+element_end;}
	else {new_element = element_end;}

	WriteLine(""new_element: "" + new_element);

	// dodaje nowy element
	try
	{
		//WriteLine(""parentElement: "" + parentElement);
		//WriteLine(""new_element: "" + element);
		OLAPCreateNumericalDimensionElement(olapConnection, dimension, new_element, parentElement, 1);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_NAME"", name);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_DESC"", description);
		OLAPSetStringAttribute(olapConnection, dimension, new_element, ""MEM_ORDER"", ToString(ToInt(new_element)));
		
	}
	catch (errorMessage, errorCode)
	{
		NotifyError(errorMessage);
		return false;
	}


	NotifyInformation(""The new element "" + new_element + "" has been added to the dimension"");
	

	NotifyInformation(""Process completed"");
	OLAPDisconnect(olapConnection);
	return true;
}"	0	7C9A3A96-ECE9-472B-864B-91B3F79094F0	Programe adds a new element to the dimension	0	0	0	1492	NULL	0	45684.40669	0	0
61B43584-3856-4FA4-AD3A-AE430DE71211	CD491758-D9DF-4002-94C8-8006E1855F86	ADU_DownloadConfiguration	Additional Data Upload	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""File id of saved file in the repository"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapDb"" parameter-type=""string"" parameter-description=""Olap connection server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""fileName"" parameter-type=""string"" parameter-description=""File name prefix, final name will be append with current date"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cubeName"" parameter-type=""string"" parameter-description=""Cube name"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""rowHierarchies"" parameter-type=""string"" parameter-description=""csv values of hierarchies in rows"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""colHierarchies"" parameter-type=""string"" parameter-description=""csv values of hierarchies in columns"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""defaultElements"" parameter-type=""string"" parameter-description=""csv values of default elements UN"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""filterXml"" parameter-type=""string"" parameter-description=""xml with filter for load data from cube"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""separator"" parameter-type=""string"" parameter-description=""item separator in txtFile"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""elementExtXml"" parameter-type=""string"" parameter-description=""xml with elements to be replaced"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""orderElementCsv"" parameter-type=""string"" parameter-description=""csv elements, this top element will be used to get ordered dimension elements. only one element allowed for now"" parameter-order=""9"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string ADU_DownloadConfiguration(string olapDb, string fileName, string cubeName, string rowHierarchies, string colHierarchies, string defaultElements, string filterXml, string separator, string elementExtXml, string orderElementCsv)
@Description: ""Downloads configuration from cube and saves into the repository"";
@Category: ""Additional Data Upload"";
@Returns: ""File id of saved file in the repository"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[fileName]: ""File name prefix, final name will be append with current date"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[rowHierarchies]: ""csv values of hierarchies in rows"";
@Parameter[colHierarchies]: ""csv values of hierarchies in columns"";
@Parameter[defaultElements]: ""csv values of default elements UN"";
@Parameter[filterXml]: ""xml with filter for load data from cube"";
@Parameter[separator]: ""item separator in txtFile"";
@Parameter[elementExtXml]: ""xml with elements to be replaced"";
@Parameter[orderElementCsv]: ""csv elements, this top element will be used to get ordered dimension elements. only one element allowed for now"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_DownloadConfiguration_Internal(olapconnection, rc, fileName, cubeName, rowHierarchies, colHierarchies, defaultElements, filterXml, separator, elementExtXml, orderElementCsv);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string ADU_DownloadConfiguration(string olapDb, string fileName, string cubeName, string rowHierarchies, string colHierarchies, string defaultElements, string filterXml, string separator, string elementExtXml, string orderElementCsv)
@Description: ""Downloads configuration from cube and saves into the repository"";
@Category: ""Additional Data Upload"";
@Returns: ""File id of saved file in the repository"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[fileName]: ""File name prefix, final name will be append with current date"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[rowHierarchies]: ""csv values of hierarchies in rows"";
@Parameter[colHierarchies]: ""csv values of hierarchies in columns"";
@Parameter[defaultElements]: ""csv values of default elements UN"";
@Parameter[filterXml]: ""xml with filter for load data from cube"";
@Parameter[separator]: ""item separator in txtFile"";
@Parameter[elementExtXml]: ""xml with elements to be replaced"";
@Parameter[orderElementCsv]: ""csv elements, this top element will be used to get ordered dimension elements. only one element allowed for now"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_DownloadConfiguration_Internal(olapconnection, rc, fileName, cubeName, rowHierarchies, colHierarchies, defaultElements, filterXml, separator, elementExtXml, orderElementCsv);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}"	1	6801BB49-D884-4A91-A1A5-4184BB8FEBDF	Downloads configuration from cube and saves into the repository	1	1	1	1501	NULL	0	45708.67506	0	0
FDA8895D-DE64-4E18-9CC6-A0B832528490	CD491758-D9DF-4002-94C8-8006E1855F86	ADU_getCubeExampleData	Additional Data Upload	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Xml with cube data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapDb"" parameter-type=""string"" parameter-description=""Olap connection server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""repositoryName"" parameter-type=""string"" parameter-description=""Name of the repository to connect to"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""projectName"" parameter-type=""string"" parameter-description=""Name of the project in the repository"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""User credentials, as obtained from the AppStudio function GETTICKET()"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""cubeName"" parameter-type=""string"" parameter-description=""Cube name"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""txtFile"" parameter-type=""string"" parameter-description=""Attachment name in repository"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""isHeader"" parameter-type=""bool"" parameter-description=""true if input file contains heades, otherwise false"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""separator"" parameter-type=""string"" parameter-description=""item separator in txtFile"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_getCubeExampleData(string olapDb, string repositoryName, string projectName, string ticket, string cubeName, string txtFile, bool isHeader, string separator)
@Description: ""Loads cube data from txt file"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[repositoryName]: ""Name of the repository to connect to"";
@Parameter[projectName]: ""Name of the project in the repository"";
@Parameter[ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[txtFile]: ""Attachment name in repository"";
@Parameter[isHeader]: ""true if input file contains heades, otherwise false"";
@Parameter[separator]: ""item separator in txtFile"";
{
	string errorMessage = """";
	int errorNum = 0;

	OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
	RepositoryConnection rc = CreateRepositoryConnectionExisting();
	return ADU_GetCubeExample(olapconnection, rc, cubeName, txtFile, isHeader, separator);
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_getCubeExampleData(string olapDb, string repositoryName, string projectName, string ticket, string cubeName, string txtFile, bool isHeader, string separator)
@Description: ""Loads cube data from txt file"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[repositoryName]: ""Name of the repository to connect to"";
@Parameter[projectName]: ""Name of the project in the repository"";
@Parameter[ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[txtFile]: ""Attachment name in repository"";
@Parameter[isHeader]: ""true if input file contains heades, otherwise false"";
@Parameter[separator]: ""item separator in txtFile"";
{
	string errorMessage = """";
	int errorNum = 0;

	OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
	RepositoryConnection rc = CreateRepositoryConnectionExisting();
	return ADU_GetCubeExample(olapconnection, rc, cubeName, txtFile, isHeader, separator);
}"	1	2775AF88-D2D7-4978-A360-F027E91E80D8	Loads cube data from txt file	1	1	1	1502	NULL	0	45708.67508	0	0
3B456A3D-D7ED-47DD-8BE2-D4F243CB07F5	CD491758-D9DF-4002-94C8-8006E1855F86	ADU_loadOlapCubeFromTxt	Additional Data Upload	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Xml with cube data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapDb"" parameter-type=""string"" parameter-description=""Olap connection server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""repositoryName"" parameter-type=""string"" parameter-description=""Name of the repository to connect to"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""projectName"" parameter-type=""string"" parameter-description=""Name of the project in the repository"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""User credentials, as obtained from the AppStudio function GETTICKET()"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""cubeName"" parameter-type=""string"" parameter-description=""Cube name"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""txtFile"" parameter-type=""string"" parameter-description=""Attachment name in repository"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""isHeader"" parameter-type=""bool"" parameter-description=""true if input file contains heades, otherwise false"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""separator"" parameter-type=""string"" parameter-description=""item separator in txtFile"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_loadOlapCubeFromTxt(string olapDb, string repositoryName, string projectName, string ticket, string cubeName, string txtFile, bool isHeader, string separator)
@Description: ""Loads cube from txt file into olap"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[repositoryName]: ""Name of the repository to connect to"";
@Parameter[projectName]: ""Name of the project in the repository"";
@Parameter[ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[txtFile]: ""Attachment name in repository"";
@Parameter[isHeader]: ""true if input file contains heades, otherwise false"";
@Parameter[separator]: ""item separator in txtFile"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_LoadOlapCube(olapconnection, rc, cubeName, txtFile, isHeader, separator);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_loadOlapCubeFromTxt(string olapDb, string repositoryName, string projectName, string ticket, string cubeName, string txtFile, bool isHeader, string separator)
@Description: ""Loads cube from txt file into olap"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[repositoryName]: ""Name of the repository to connect to"";
@Parameter[projectName]: ""Name of the project in the repository"";
@Parameter[ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[txtFile]: ""Attachment name in repository"";
@Parameter[isHeader]: ""true if input file contains heades, otherwise false"";
@Parameter[separator]: ""item separator in txtFile"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_LoadOlapCube(olapconnection, rc, cubeName, txtFile, isHeader, separator);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}"	1	B12FF1DB-B7A0-4E31-A440-5F4F5552480E	Loads cube from txt file into olap	1	1	1	1503	NULL	0	45708.67505	0	0
360FB10B-8DD9-4E66-94FB-600F09DD1ACC	CD491758-D9DF-4002-94C8-8006E1855F86	ADU_UploadConfiguration	Additional Data Upload	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Xml with cube data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapDb"" parameter-type=""string"" parameter-description=""Olap connection server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""fileId"" parameter-type=""string"" parameter-description=""Attachment name in repository"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cubeName"" parameter-type=""string"" parameter-description=""Cube name"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""rowHierarchies"" parameter-type=""string"" parameter-description=""csv values of hierarchies in rows"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""colHierarchies"" parameter-type=""string"" parameter-description=""csv values of hierarchies in columns"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""defaultElements"" parameter-type=""string"" parameter-description=""csv values of default elements UN"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""separator"" parameter-type=""string"" parameter-description=""item separator in txtFile"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""elementExtXml"" parameter-type=""string"" parameter-description=""xml with elements to be replaced"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""deleteColDimensionCsv"" parameter-type=""string"" parameter-description=""csv values of dimensions from uploaded file to create dataarea for delete before upload. if empty values won't be deleted"" parameter-order=""8"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_UploadConfiguration(string olapDb, string fileId, string cubeName, string rowHierarchies, string colHierarchies, string defaultElements, string separator, string elementExtXml, string deleteColDimensionCsv)
@Description: ""Loads configuration from csv file into the OLAP database"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[fileId]: ""Attachment name in repository"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[rowHierarchies]: ""csv values of hierarchies in rows"";
@Parameter[colHierarchies]: ""csv values of hierarchies in columns"";
@Parameter[defaultElements]: ""csv values of default elements UN"";
@Parameter[separator]: ""item separator in txtFile"";
@Parameter[elementExtXml]: ""xml with elements to be replaced"";
@Parameter[deleteColDimensionCsv]: ""csv values of dimensions from uploaded file to create dataarea for delete before upload. if empty values won't be deleted"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_UploadConfiguration_Internal(olapconnection, rc, fileId, cubeName, rowHierarchies, colHierarchies, defaultElements, separator, elementExtXml, deleteColDimensionCsv);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0



string ADU_UploadConfiguration(string olapDb, string fileId, string cubeName, string rowHierarchies, string colHierarchies, string defaultElements, string separator, string elementExtXml, string deleteColDimensionCsv)
@Description: ""Loads configuration from csv file into the OLAP database"";
@Category: ""Additional Data Upload"";
@Returns: ""Xml with cube data"";
@Parameter[olapDb]: ""Olap connection server/database"";
@Parameter[fileId]: ""Attachment name in repository"";
@Parameter[cubeName]: ""Cube name"";
@Parameter[rowHierarchies]: ""csv values of hierarchies in rows"";
@Parameter[colHierarchies]: ""csv values of hierarchies in columns"";
@Parameter[defaultElements]: ""csv values of default elements UN"";
@Parameter[separator]: ""item separator in txtFile"";
@Parameter[elementExtXml]: ""xml with elements to be replaced"";
@Parameter[deleteColDimensionCsv]: ""csv values of dimensions from uploaded file to create dataarea for delete before upload. if empty values won't be deleted"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(olapDb);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		return ADU_UploadConfiguration_Internal(olapconnection, rc, fileId, cubeName, rowHierarchies, colHierarchies, defaultElements, separator, elementExtXml, deleteColDimensionCsv);
	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		return """";
	}
}"	1	7E29AB46-D67A-4C84-8842-7E5142124140	Loads configuration from csv file into the OLAP database	1	1	1	1504	NULL	0	45708.67507	0	0
D338743D-7EBA-4B19-8EEB-29738E054873	CD491758-D9DF-4002-94C8-8006E1855F86	AL_ClearConfiguration	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The cycle element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The entity element defining the allocation configuration"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""The iteration element defining the allocation configuration"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""accountUN"" parameter-type=""string"" parameter-description=""The account element defining the allocation configuration or * for all accounts"" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_ClearConfiguration(string server, string ticket, string cube, string cycleUN, string entityUN, string iterationUN, string accountUN)
@Description: ""This function is used to clear out the configuration for the specified parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The cycle element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[accountUN]: ""The account element defining the allocation configuration or * for all accounts"";
{
	LogDebug(""Entering AL_ClearConfiguration"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Cycle: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Account: "" + accountUN);

	string functionName = ""AL_ClearConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' cycle '"" + cycleUN + ""' Entity '"" + entityUN + ""' Iteration '"" + iterationUN + ""' accountUN + '"" + accountUN + ""'"");

	try {
		// Dimension and element names
		string parameterDimension = ""BPDPARAMETER"";
		string featureParent = ""FEATURE_AL_PARAM"";

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Resolve unique names
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = """";
		if ((StringLength(entityUN) &gt; 0) and (entityUN != ""*""))
		{
			ResolveUniqueName(connection, entityUN);
		}

		string iteration = ResolveUniqueName(connection, iterationUN);
		string account = """";
		if ((StringLength(accountUN) &gt; 0) and (accountUN != ""*""))
		{
			account = ResolveUniqueName(connection, accountUN);
		}

		// Get the dimensions to use for creating the data area
		StringListList dimensionsList = CreateStringListList();

		Append(dimensionsList, ConvertToStringList(cycle));
		if (StringLength(entity) &gt; 0)
		{
			Append(dimensionsList, ConvertToStringList(entity));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(iteration));
		if (StringLength(account) &gt; 0)
		{
			Append(dimensionsList, ConvertToStringList(account));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDVERSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // ALDDIMENSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDNO
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDPARAMETER

		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          dimensionsList);

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_ClearConfiguration"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_ClearConfiguration(string server, string ticket, string cube, string cycleUN, string entityUN, string iterationUN, string accountUN)
@Description: ""This function is used to clear out the configuration for the specified parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The cycle element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[accountUN]: ""The account element defining the allocation configuration or * for all accounts"";
{
	LogDebug(""Entering AL_ClearConfiguration"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Cycle: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Account: "" + accountUN);

	string functionName = ""AL_ClearConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' cycle '"" + cycleUN + ""' Entity '"" + entityUN + ""' Iteration '"" + iterationUN + ""' accountUN + '"" + accountUN + ""'"");

	try {
		// Dimension and element names
		string parameterDimension = ""BPDPARAMETER"";
		string featureParent = ""FEATURE_AL_PARAM"";

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Resolve unique names
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = """";
		if ((StringLength(entityUN) > 0) and (entityUN != ""*""))
		{
			ResolveUniqueName(connection, entityUN);
		}

		string iteration = ResolveUniqueName(connection, iterationUN);
		string account = """";
		if ((StringLength(accountUN) > 0) and (accountUN != ""*""))
		{
			account = ResolveUniqueName(connection, accountUN);
		}

		// Get the dimensions to use for creating the data area
		StringListList dimensionsList = CreateStringListList();

		Append(dimensionsList, ConvertToStringList(cycle));
		if (StringLength(entity) > 0)
		{
			Append(dimensionsList, ConvertToStringList(entity));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(iteration));
		if (StringLength(account) > 0)
		{
			Append(dimensionsList, ConvertToStringList(account));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDVERSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // ALDDIMENSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDNO
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDPARAMETER

		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          dimensionsList);

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_ClearConfiguration"");
	return ""FALSE"";
}"	1	D06978A4-4662-4D5E-BA17-30F0F678C8FF	This function is used to clear out the configuration for the specified parameters.	1	1	1	1505	NULL	0	45708.67503	0	0
98062AC6-2861-40D8-88BE-9675BBA9E3AA	CD491758-D9DF-4002-94C8-8006E1855F86	AL_ClearDataAreaByLevel	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""TRUE if successful, will error if unsuccessful"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycleUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Configuration set Dimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entityUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Entity Dimension"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""versionUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Version Dimension"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""timeUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Time Dimension"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""levelUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Level Dimension"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""followingLevels"" parameter-type=""bool"" parameter-description=""Selection for processing all following level members after the given one."" parameter-order=""7"" />
  <dependencies>
    <process process-name=""AL_GetCubeDimensions"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_GetCubeDimensions"", ""*""

bool AL_ClearDataAreaByLevel(string server, string ticket, string cycleUniqueName, string entityUniqueName, string versionUniqueName, string timeUniqueName, string levelUniqueName, bool followingLevels)
@Description: ""Describe your process here"";
@Category: ""Allocation Functions"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cycleUniqueName]: ""Unique name for the Configuration set Dimension"";
@Parameter[entityUniqueName]: ""Unique name for the Entity Dimension"";
@Parameter[versionUniqueName]: ""Unique name for the Version Dimension"";
@Parameter[timeUniqueName]: ""Unique name for the Time Dimension"";
@Parameter[levelUniqueName]: ""Unique name for the Level Dimension"";
@Parameter[followingLevels]: ""Selection for processing all following level members after the given one."";
@Returns: ""TRUE if successful, will error if unsuccessful"";
{
	LogDebug(""Entering AL_ClearDataAreaByLevel"");
	LogDebug(""Configuration set: "" + cycleUniqueName);
	LogDebug(""Entity: "" + entityUniqueName);
	LogDebug(""Version: "" + versionUniqueName);
	LogDebug(""Time: "" + timeUniqueName);
	LogDebug(""Level: "" + levelUniqueName);
	
	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	
	string cycle = ResolveUniqueName(connection, cycleUniqueName);
	string entity = ResolveUniqueName(connection, entityUniqueName);
	string version = ResolveUniqueName(connection, versionUniqueName);
	string level = ResolveUniqueName(connection, levelUniqueName);
	string time = ResolveUniqueName(connection, timeUniqueName);

	StringListList dimensionList = CreateStringListList();
	StringArray dimensions = AL_GetCubeDimensions(connection, ""BPCMAIN"");
	foreach (string dim in dimensions)
	{
		StringArray strings = CreateStringArray();

		if(dim == ""BPDENTITY""){
			Append(strings,entity);
		}
		else if (dim == ""BPDCYCLE""){
			Append(strings,cycle);
		}
		else if (dim == ""BPDTIME""){

			if(OLAPIsBaseElement(connection, ""BPDTIME"", time))
			{
				Append(strings,time);
			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection, ""BPDTIME"", time, true);
				foreach(OLAPElement timeElement in timeList)
				{
					Append(strings,timeElement);
				}
			}
		}
		else if (dim == ""BPDVERSION""){
			Append(strings,version);
		}
		else if (dim == ""BPDLEVEL""){
			if (followingLevels){
				int levelNumber = ToInt(StringSubstring(level, StringFind(level, ""0"", 0), StringLength(level)-StringFind(level, ""0"", 0)));
				bool continueLooping = true;
				while(continueLooping){
					string iterationLevel = ""AFTER_ITERATION_""+ToString(levelNumber,""0000"", """");
					string nextIterationLevelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
					string resolved = ResolveUniqueName(connection, nextIterationLevelUniqueName);
					if (StringLength(resolved)&gt;0){
						iterationLevel = ""ITERATION_""+ToString(levelNumber,""0000"", """");						
						Append(strings,iterationLevel+""_CHARGE"");
						Append(strings,iterationLevel+""_DISCHARGE"");
						levelNumber = levelNumber + 1;
					}
					else{
						continueLooping = false;
					}
				}
			}
			else{
				int levelNumber = ToInt(StringSubstring(level, StringFind(level, ""0"", 0), StringLength(level)-StringFind(level, ""0"", 0)));
				string iterationLevel = ""ITERATION_""+ToString(levelNumber,""0000"", """");
				Append(strings,iterationLevel+""_CHARGE"");
				Append(strings,iterationLevel+""_DISCHARGE"");
			}
		}
		else{
			OLAPElementList elementList = OLAPGetLevelElements(connection, dim, 0, false);
			foreach(OLAPElement element in elementList)
			{
				OLAPElementList elementList2 = OLAPGetChildElementList(connection, dim, element, true);
				foreach(OLAPElement element2 in elementList2)
				{
					Append(strings,element2);
				}
			}
		}

		Append(dimensionList, ConvertToStringList(strings));
	}

	OLAPDataArea dataArea = OLAPCreateDataArea(connection, ""BPCMAIN"", OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                           dimensionList);
	OLAPDeleteDataArea(dataArea);
	
	LogDebug(""Leaving AL_ClearDataAreaByLevel"");
	return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_GetCubeDimensions"", ""*""

bool AL_ClearDataAreaByLevel(string server, string ticket, string cycleUniqueName, string entityUniqueName, string versionUniqueName, string timeUniqueName, string levelUniqueName, bool followingLevels)
@Description: ""Describe your process here"";
@Category: ""Allocation Functions"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cycleUniqueName]: ""Unique name for the Configuration set Dimension"";
@Parameter[entityUniqueName]: ""Unique name for the Entity Dimension"";
@Parameter[versionUniqueName]: ""Unique name for the Version Dimension"";
@Parameter[timeUniqueName]: ""Unique name for the Time Dimension"";
@Parameter[levelUniqueName]: ""Unique name for the Level Dimension"";
@Parameter[followingLevels]: ""Selection for processing all following level members after the given one."";
@Returns: ""TRUE if successful, will error if unsuccessful"";
{
	LogDebug(""Entering AL_ClearDataAreaByLevel"");
	LogDebug(""Configuration set: "" + cycleUniqueName);
	LogDebug(""Entity: "" + entityUniqueName);
	LogDebug(""Version: "" + versionUniqueName);
	LogDebug(""Time: "" + timeUniqueName);
	LogDebug(""Level: "" + levelUniqueName);
	
	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	
	string cycle = ResolveUniqueName(connection, cycleUniqueName);
	string entity = ResolveUniqueName(connection, entityUniqueName);
	string version = ResolveUniqueName(connection, versionUniqueName);
	string level = ResolveUniqueName(connection, levelUniqueName);
	string time = ResolveUniqueName(connection, timeUniqueName);

	StringListList dimensionList = CreateStringListList();
	StringArray dimensions = AL_GetCubeDimensions(connection, ""BPCMAIN"");
	foreach (string dim in dimensions)
	{
		StringArray strings = CreateStringArray();

		if(dim == ""BPDENTITY""){
			Append(strings,entity);
		}
		else if (dim == ""BPDCYCLE""){
			Append(strings,cycle);
		}
		else if (dim == ""BPDTIME""){

			if(OLAPIsBaseElement(connection, ""BPDTIME"", time))
			{
				Append(strings,time);
			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection, ""BPDTIME"", time, true);
				foreach(OLAPElement timeElement in timeList)
				{
					Append(strings,timeElement);
				}
			}
		}
		else if (dim == ""BPDVERSION""){
			Append(strings,version);
		}
		else if (dim == ""BPDLEVEL""){
			if (followingLevels){
				int levelNumber = ToInt(StringSubstring(level, StringFind(level, ""0"", 0), StringLength(level)-StringFind(level, ""0"", 0)));
				bool continueLooping = true;
				while(continueLooping){
					string iterationLevel = ""AFTER_ITERATION_""+ToString(levelNumber,""0000"", """");
					string nextIterationLevelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
					string resolved = ResolveUniqueName(connection, nextIterationLevelUniqueName);
					if (StringLength(resolved)>0){
						iterationLevel = ""ITERATION_""+ToString(levelNumber,""0000"", """");						
						Append(strings,iterationLevel+""_CHARGE"");
						Append(strings,iterationLevel+""_DISCHARGE"");
						levelNumber = levelNumber + 1;
					}
					else{
						continueLooping = false;
					}
				}
			}
			else{
				int levelNumber = ToInt(StringSubstring(level, StringFind(level, ""0"", 0), StringLength(level)-StringFind(level, ""0"", 0)));
				string iterationLevel = ""ITERATION_""+ToString(levelNumber,""0000"", """");
				Append(strings,iterationLevel+""_CHARGE"");
				Append(strings,iterationLevel+""_DISCHARGE"");
			}
		}
		else{
			OLAPElementList elementList = OLAPGetLevelElements(connection, dim, 0, false);
			foreach(OLAPElement element in elementList)
			{
				OLAPElementList elementList2 = OLAPGetChildElementList(connection, dim, element, true);
				foreach(OLAPElement element2 in elementList2)
				{
					Append(strings,element2);
				}
			}
		}

		Append(dimensionList, ConvertToStringList(strings));
	}

	OLAPDataArea dataArea = OLAPCreateDataArea(connection, ""BPCMAIN"", OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                           dimensionList);
	OLAPDeleteDataArea(dataArea);
	
	LogDebug(""Leaving AL_ClearDataAreaByLevel"");
	return true;
}"	1	AD3ED674-BA9F-44E7-BFCD-7780B2F5D199	Describe your process here	1	1	1	1506	NULL	0	45708.67509	0	0
737A0969-6AFC-4B3D-8318-FFDACB82CFD6	CD491758-D9DF-4002-94C8-8006E1855F86	AL_CopyDriverActivation	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set element to copy from"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceEntityUN"" parameter-type=""string"" parameter-description=""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. Can be consolidated elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceAccountUN"" parameter-type=""string"" parameter-description=""The source Account element to copy from. A single or comma separated list. Can be consolidated elements."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration set element to copy to."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity element to copy to. Ignored if multiple enties are in source. Single or comma separated list."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""overwriteTarget"" parameter-type=""bool"" parameter-description=""Indicates if the copy should overwrite if there is any data in the target."" parameter-order=""7"" />
  <dependencies>
    <process process-name=""BP_GetCubeDimensions"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GenericCopy"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""AL_GetDimensionElementList"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""

int AL_CopyDriverActivation(string server, string ticket, string sourceCycleUN, string sourceEntityUN, string sourceAccountUN, string targetCycleUN, string targetEntityUN, bool overwriteTarget)
@Description: ""Copies the manual driver configuration and data"";
@Category: ""Allocation Functions"";
@Returns: ""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. Can be consolidated elements"";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. A single or comma separated list. Can be consolidated elements."";
@Parameter[targetCycleUN]: ""The target Configuration set element to copy to."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple enties are in source. Single or comma separated list."";
@Parameter[overwriteTarget]: ""Indicates if the copy should overwrite if there is any data in the target."";
{
	LogDebug(""Entering AL_CopyDriverActivation"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""Source Account: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Entity: "" + targetEntityUN);
	
	/*
	Acceptable Usages

	Normal (MultipleEntitiesSource):
	AL_CopyDriverActivation(connection, sourceCycle, sourceEntity (multiple or *), &lt;top level account&gt; (comma separated list), targetCycle, &lt;ignored&gt;) targetEntities = sourceEntities, all drivers under specified accounts

	Alternate 1 (SingleEntitySource):
	AL_CopyDriverActivation(connection, sourceCycle, sourceEntity (single), &lt;top level account&gt; (comma separated list), targetCycle, targetEntity (multiple))  single entity -&gt; multiple entities, all drivers under specified account
	 */

	string functionName = ""AL_CopyDriverActivation:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -&gt; Configuration set '"" + targetCycleUN + ""' Entity '"" + targetEntityUN + ""' OverwriteTarget '"" + overwriteTarget + ""'"");

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define cube and dimension names
		string configCube = ""ALCCONFIG_DRIVER"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string languageDimension = ""BPDLANGUAGE"";
		string defaultLanguage = ""Default"";

		int configCycleIndex = 0;
		int configEntityIndex = 1;
		int configAccountIndex = 2;
		int configParameterIndex = 4;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);

		// Validate the parameters
		if (StringLength(sourceCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceCycleUN parameter"");
			return 1;
		}
		if (StringLength(targetCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetCycleUN parameter"");
			return 1;
		}
		if (StringLength(sourceEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceEntityUN parameter"");
			return 1;
		}
		if (StringLength(sourceAccountUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceAccountUN parameter"");
			return 1;
		}

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		StringArray sourceEntities = CF_ElementStringSplit(sourceEntityUN);
		StringArray sourceAccounts = CF_ElementStringSplit(sourceAccountUN);
		StringArray targetEntities = CF_ElementStringSplit(targetEntityUN);

		// Determine the type of copy
		bool MultipleEntitiesSource = false;
		bool SingleEntitySource = false;

		if ((sourceEntities[0] == ""*"") or (Count(sourceEntities) &gt; 1)) {
			MultipleEntitiesSource = true;
		} else {
			SingleEntitySource = true;
		}

		// Get the lists to hold the source and target elements
		StringListList configCubeSource = CreateStringListList();
		StringArray configCubeTarget = CreateStringArray();

		// We need to see if any of the targets have data, so build up a selection to check that
		StringListList fullTargetConfigCubeDefinition = CreateStringListList();

		// Get the list of drivers that we will copy
		OLAPElementList accountList = CreateOLAPElementList();
		foreach (string accountUN in sourceAccounts)
		{
			string account = ResolveUniqueName(connection, accountUN);
			OLAPElementList baseAccounts = AL_GetDimensionElementList(connection, true, accountDimension, account);
			foreach(OLAPElement baseAccount in baseAccounts)
			{
				OLAPElementListAddElement(accountList, baseAccount);
			}
		}

		// Do the copy depending on the type
		string success = """";
		if (MultipleEntitiesSource)
		{
			LogInformation(functionName + ""Configuration set -&gt; Configuration set, targetEntities = sourceEntities, specified accounts"");

			if (sourceCycle == targetCycle)
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			OLAPElementList entityList = CreateOLAPElementList();
			if (sourceEntities[0] != ""*"")
			{
				foreach (string entityUN in sourceEntities)
				{
					string entity = ResolveUniqueName(connection, entityUN);
					OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
					foreach(OLAPElement baseEntity in baseEntities)
					{
						OLAPElementListAddElement(entityList, baseEntity);
					}
				}
			}

			// Get the source and target lists
			int index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeTarget, """");
					if (sourceEntities[0] == ""*"")
					{
						Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
					}
					else
					{
						Append(configCubeSource, ConvertToStringList(entityList));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
					}
				}
				else if (index == configAccountIndex) // account
				{
					Append(configCubeSource, ConvertToStringList(accountList));
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(accountList));
					Append(configCubeTarget, """");
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) &gt; 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			// Copy the config cube
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}
		}
		else
		{
			LogInformation(functionName + "" cycle -&gt; cycle, single entity -&gt; multiple entities, all specified accounts"");

			if ((sourceCycle == targetCycle) and (Count(targetEntities) == 1) and (targetEntityUN == sourceEntityUN))
			{
				LogDebug(functionName + "" source and target cycle cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);

			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			// Get the configuration information
			int index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(entityList));
				}
				else if (index == configAccountIndex) // account
				{
					Append(configCubeSource, ConvertToStringList(accountList));
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(accountList));
					Append(configCubeTarget, """");
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}
			
			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) &gt; 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			// Do a copy for each target entity in the config cube
			foreach(OLAPElement entity in entityList)
			{
				configCubeTarget[configEntityIndex] = entity;

				// copy
				success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}
		}
		
		return 0;

	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return 3;
	}

	LogDebug(""Leaving AL_CopyDriverActivation"");
	// This is only here because AppEngine won't compile unless it is.
	return 3;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""

int AL_CopyDriverActivation(string server, string ticket, string sourceCycleUN, string sourceEntityUN, string sourceAccountUN, string targetCycleUN, string targetEntityUN, bool overwriteTarget)
@Description: ""Copies the manual driver configuration and data"";
@Category: ""Allocation Functions"";
@Returns: ""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. Can be consolidated elements"";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. A single or comma separated list. Can be consolidated elements."";
@Parameter[targetCycleUN]: ""The target Configuration set element to copy to."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple enties are in source. Single or comma separated list."";
@Parameter[overwriteTarget]: ""Indicates if the copy should overwrite if there is any data in the target."";
{
	LogDebug(""Entering AL_CopyDriverActivation"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""Source Account: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Entity: "" + targetEntityUN);
	
	/*
	Acceptable Usages

	Normal (MultipleEntitiesSource):
	AL_CopyDriverActivation(connection, sourceCycle, sourceEntity (multiple or *), <top level account> (comma separated list), targetCycle, <ignored>) targetEntities = sourceEntities, all drivers under specified accounts

	Alternate 1 (SingleEntitySource):
	AL_CopyDriverActivation(connection, sourceCycle, sourceEntity (single), <top level account> (comma separated list), targetCycle, targetEntity (multiple))  single entity -> multiple entities, all drivers under specified account
	 */

	string functionName = ""AL_CopyDriverActivation:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -> Configuration set '"" + targetCycleUN + ""' Entity '"" + targetEntityUN + ""' OverwriteTarget '"" + overwriteTarget + ""'"");

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define cube and dimension names
		string configCube = ""ALCCONFIG_DRIVER"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string languageDimension = ""BPDLANGUAGE"";
		string defaultLanguage = ""Default"";

		int configCycleIndex = 0;
		int configEntityIndex = 1;
		int configAccountIndex = 2;
		int configParameterIndex = 4;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);

		// Validate the parameters
		if (StringLength(sourceCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceCycleUN parameter"");
			return 1;
		}
		if (StringLength(targetCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetCycleUN parameter"");
			return 1;
		}
		if (StringLength(sourceEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceEntityUN parameter"");
			return 1;
		}
		if (StringLength(sourceAccountUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceAccountUN parameter"");
			return 1;
		}

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		StringArray sourceEntities = CF_ElementStringSplit(sourceEntityUN);
		StringArray sourceAccounts = CF_ElementStringSplit(sourceAccountUN);
		StringArray targetEntities = CF_ElementStringSplit(targetEntityUN);

		// Determine the type of copy
		bool MultipleEntitiesSource = false;
		bool SingleEntitySource = false;

		if ((sourceEntities[0] == ""*"") or (Count(sourceEntities) > 1)) {
			MultipleEntitiesSource = true;
		} else {
			SingleEntitySource = true;
		}

		// Get the lists to hold the source and target elements
		StringListList configCubeSource = CreateStringListList();
		StringArray configCubeTarget = CreateStringArray();

		// We need to see if any of the targets have data, so build up a selection to check that
		StringListList fullTargetConfigCubeDefinition = CreateStringListList();

		// Get the list of drivers that we will copy
		OLAPElementList accountList = CreateOLAPElementList();
		foreach (string accountUN in sourceAccounts)
		{
			string account = ResolveUniqueName(connection, accountUN);
			OLAPElementList baseAccounts = AL_GetDimensionElementList(connection, true, accountDimension, account);
			foreach(OLAPElement baseAccount in baseAccounts)
			{
				OLAPElementListAddElement(accountList, baseAccount);
			}
		}

		// Do the copy depending on the type
		string success = """";
		if (MultipleEntitiesSource)
		{
			LogInformation(functionName + ""Configuration set -> Configuration set, targetEntities = sourceEntities, specified accounts"");

			if (sourceCycle == targetCycle)
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			OLAPElementList entityList = CreateOLAPElementList();
			if (sourceEntities[0] != ""*"")
			{
				foreach (string entityUN in sourceEntities)
				{
					string entity = ResolveUniqueName(connection, entityUN);
					OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
					foreach(OLAPElement baseEntity in baseEntities)
					{
						OLAPElementListAddElement(entityList, baseEntity);
					}
				}
			}

			// Get the source and target lists
			int index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeTarget, """");
					if (sourceEntities[0] == ""*"")
					{
						Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
					}
					else
					{
						Append(configCubeSource, ConvertToStringList(entityList));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
					}
				}
				else if (index == configAccountIndex) // account
				{
					Append(configCubeSource, ConvertToStringList(accountList));
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(accountList));
					Append(configCubeTarget, """");
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) > 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			// Copy the config cube
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}
		}
		else
		{
			LogInformation(functionName + "" cycle -> cycle, single entity -> multiple entities, all specified accounts"");

			if ((sourceCycle == targetCycle) and (Count(targetEntities) == 1) and (targetEntityUN == sourceEntityUN))
			{
				LogDebug(functionName + "" source and target cycle cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);

			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			// Get the configuration information
			int index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(entityList));
				}
				else if (index == configAccountIndex) // account
				{
					Append(configCubeSource, ConvertToStringList(accountList));
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(accountList));
					Append(configCubeTarget, """");
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}
			
			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) > 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			// Do a copy for each target entity in the config cube
			foreach(OLAPElement entity in entityList)
			{
				configCubeTarget[configEntityIndex] = entity;

				// copy
				success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}
		}
		
		return 0;

	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return 3;
	}

	LogDebug(""Leaving AL_CopyDriverActivation"");
	// This is only here because AppEngine won't compile unless it is.
	return 3;
}"	1	27473933-E2AF-4DB2-94C8-EBD8AD895107	Copies the manual driver configuration and data	1	1	1	1507	NULL	0	45708.67505	0	0
1ADB621F-6866-4E65-A900-01B57E028C14	CD491758-D9DF-4002-94C8-8006E1855F86	AL_CopyManualDriver	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set element to copy from"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceEntityUN"" parameter-type=""string"" parameter-description=""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceAccountUN"" parameter-type=""string"" parameter-description=""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetCycleUN"" parameter-type=""string"" parameter-description=""The target Planning Cycle element to copy to."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""includeData"" parameter-type=""bool"" parameter-description=""Indicates if the copy should include the data or just the activation and configuration."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""overwriteTarget"" parameter-type=""bool"" parameter-description=""Indicates if the copy should overwrite if there is any data in the target."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""copyIndicator"" parameter-type=""string"" parameter-description=""String to append to the description of the copied driver when copying selected drivers to new slots"" parameter-order=""9"" />
  <dependencies>
    <process process-name=""BP_GetCubeDimensions"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GenericCopy"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""AL_GetDimensionElementList"" process-version=""*"" process-id="""" />
    <process process-name=""AL_DataAreaHasValues"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetNextAllocationDriver"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""
#include ""AL_DataAreaHasValues"", ""*""
#include ""BP_GetNextAllocationDriver"", ""*""

int AL_CopyManualDriver(string server, string ticket, string sourceCycleUN, string sourceEntityUN, string sourceAccountUN, string targetCycleUN, string targetEntityUN, bool includeData, bool overwriteTarget, string copyIndicator)
@Description: ""Copies the manual driver configuration and data"";
@Category: ""Allocation Functions"";
@Returns: ""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."";
@Parameter[targetCycleUN]: ""The target Planning Cycle element to copy to."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"";
@Parameter[includeData]: ""Indicates if the copy should include the data or just the activation and configuration."";
@Parameter[overwriteTarget]: ""Indicates if the copy should overwrite if there is any data in the target."";
@Parameter[copyIndicator]: ""String to append to the description of the copied driver when copying selected drivers to new slots"";
{
	LogDebug(""Entering AL_CopyManualDriver"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""Source Account: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Entity: "" + targetEntityUN);

	/*
	Acceptable Usages

	Normal (allDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (multiple or *), *, targetCycle, *) targetEntities = sourceEntities, all drivers

	Alternate 1 (EntityToEntities_AllDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (single), *, targetCycle, targetEntity (multiple or *))  single entity -&gt; multiple entities, all drivers
	
	Alternate 2 (EntityToEntities_SelectedDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (single), source driver (multiple), targetCycle, targetEntity (multiple))  single entity -&gt; multiple entities, target drivers = source driver(s) in new slot
	 */

	string functionName = ""AL_CopyManualDriver:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -&gt; Configuration set '"" + targetCycleUN + ""' Entity '"" + targetEntityUN + ""' OverwriteTarget '"" + overwriteTarget + ""'"");

	try
	{

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceCycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		sourceAccountUN= ""[BPDACCOUNT].[DRIVER_0001].[1]"";
		targetCycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		targetEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		copyIndicator= """";*/

		// Define cube and dimension names
		string configCube = ""ALCCONFIG_DRIVER"";
		string mainCube = ""BPCMAIN"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string languageDimension = ""BPDLANGUAGE"";
		string totalEntity = ""TOTAL_ENTITY"";
		string allocationDriver = ""ALLOCATION_DRIVER"";
		string levelElement = ""INPUT_MAIN"";  // Avoids getting TOTAL_INPUT_ALLOCATION copied. This is where manual drivers are stored.
		string descriptionParameter = ""FEATURE_AL_DESCRIPTION"";
		string defaultLanguage = ""Default"";

		int cycleIndex = 1;
		int levelIndex = 3;
		int entityIndex = 5;
		int accountIndex = 8;
		int configCycleIndex = 0;
		int configEntityIndex = 1;
		int configAccountIndex = 2;
		int configParameterIndex = 4;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);
		StringArray mainCubeDimensions = BP_GetCubeDimensions(connection, mainCube);

		// Validate the parameters
		if (StringLength(sourceCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceCycleUN parameter"");
			return 1;
		}
		if (StringLength(targetCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetCycleUN parameter"");
			return 1;
		}
		if (StringLength(sourceEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceEntityUN parameter"");
			return 1;
		}
		if (StringLength(sourceAccountUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceAccountUN parameter"");
			return 1;
		}
		if (StringLength(targetEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetEntityUN parameter"");
			return 1;
		}

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		StringArray sourceEntities = CF_ElementStringSplit(sourceEntityUN);
		StringArray sourceAccounts = CF_ElementStringSplit(sourceAccountUN);
		StringArray targetEntities = CF_ElementStringSplit(targetEntityUN);

		// Determine the type of copy
		bool allDrivers = false;
		bool EntityToEntities_AllDrivers = false;
		bool EntityToEntities_SelectedDrivers = false;

		if ((sourceEntities[0] == ""*"") or (Count(sourceEntities) &gt; 1)) {
			allDrivers = true;
		} else if (sourceAccounts[0] == ""*"") {
			EntityToEntities_AllDrivers = true;
		} else {
			EntityToEntities_SelectedDrivers = true;
		}

		// Get the source and target main cube arrays initialized with common information
		StringListList mainCubeSource = CreateStringListList();
		StringArray mainCubeTarget = CreateStringArray();

		// We also need to see if any of the targets have data, so build up a selection to check that
		StringListList fullTargetCubeDefinition = CreateStringListList();
		StringListList fullTargetConfigCubeDefinition = CreateStringListList();

		int index = 0;
		foreach(string dimension in mainCubeDimensions)
		{
			if (index == cycleIndex)
			{
				Append(fullTargetCubeDefinition, ConvertToStringList(targetCycle));
				Append(mainCubeSource, ConvertToStringList(sourceCycle));
				if (targetCycle == sourceCycle)
				{
					Append(mainCubeTarget, """");
				}
				else
				{
					Append(mainCubeTarget, targetCycle);
				}
			}
			else if ((index == entityIndex) or (index == accountIndex))
			{
				// Will fill these in during specific copy cases
				Append(fullTargetCubeDefinition, CreateStringList());
				Append(mainCubeSource, CreateStringList());
				Append(mainCubeTarget, """");
			}
			else if (index == levelIndex)
			{
				Append(fullTargetCubeDefinition, ConvertToStringList(levelElement));
				Append(mainCubeSource, ConvertToStringList(levelElement));
				Append(mainCubeTarget, """");
			}
			else
			{
				// Use base cells for all other dimensions
				Append(fullTargetCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				Append(mainCubeSource, ConvertToStringList(OlapDataAreaBCells));
				Append(mainCubeTarget, """");
			}

			index = index + 1;
		}

		// Do the copy depending on the type
		string success = """";
		if (allDrivers)
		{
			LogInformation(functionName + ""Configuration set -&gt; cycle, targetEntities = sourceEntities, all drivers"");

			if (sourceCycle == targetCycle)
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			OLAPElementList entityList = CreateOLAPElementList();
			if (sourceEntities[0] == ""*"")
			{
				mainCubeSource[entityIndex] = ConvertToStringList(OlapDataAreaBCells);
				fullTargetCubeDefinition[entityIndex] = ConvertToStringList(OlapDataAreaBCells);
			}
			else
			{
				foreach (string entityUN in sourceEntities)
				{
					string entity = ResolveUniqueName(connection, entityUN);
					OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
					foreach(OLAPElement baseEntity in baseEntities)
					{
						OLAPElementListAddElement(entityList, baseEntity);
					}
				}

				mainCubeSource[entityIndex] = ConvertToStringList(entityList);
				fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);
			}


			// Get the configuration information
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeTarget, """");
					if (sourceEntities[0] == ""*"")
					{
						Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
					}
					else
					{
						Append(configCubeSource, ConvertToStringList(entityList));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
					}
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) &gt; 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			if (includeData)
			{
				// Set the allocation drivers as source list
				OLAPElementList driverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
				mainCubeSource[accountIndex] = ConvertToStringList(driverList);
				fullTargetCubeDefinition[accountIndex] = ConvertToStringList(driverList);

				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);

					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			} // includeData

			// Copy the config cube
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}

			// Total entity element holds the description of the drivers. It is not a base cell so can't include with * case. Copy separately.
			configCubeSource[configEntityIndex] = ConvertToStringList(totalEntity);
			configCubeSource[configParameterIndex] = ConvertToStringList(descriptionParameter);
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}

			// Copy the data.
			if (includeData)
			{
				success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			} // includeData
		}
		else if (EntityToEntities_AllDrivers)
		{
			LogInformation(functionName + "" single entity -&gt; multiple entities, all drivers"");

			if ((sourceCycle == targetCycle) and (Count(targetEntities) == 1) and (targetEntityUN == sourceEntityUN))
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
			mainCubeSource[entityIndex] = ConvertToStringList(sourceEntity);

			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);

			// Get the configuration information
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(entityList));
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}
			
			// See if we need to abort if any targets have data
			LogDebug(""Checking target config"");
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) &gt; 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			LogDebug(""Checking target main cube"");
			if (includeData)
			{
				// Set the allocation drivers as source list
				OLAPElementList driverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
				mainCubeSource[accountIndex] = ConvertToStringList(driverList);
				fullTargetCubeDefinition[accountIndex] = ConvertToStringList(driverList);
				
				LogDebug(""Checking target main cube data"");
				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);
					
					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			}

			LogDebug(""Copy config"");
			// Do a copy for each target entity in the config cube
			foreach(OLAPElement entity in entityList)
			{
				configCubeTarget[configEntityIndex] = entity;

				// copy
				success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}

			// Total entity element holds the description of the drivers. It is not a base cell so can't include with * case. Copy separately.
			if (targetCycle != sourceCycle)
			{
				configCubeSource[configEntityIndex] = ConvertToStringList(totalEntity);
				configCubeTarget[configEntityIndex] = """";
				configCubeSource[configParameterIndex] = ConvertToStringList(descriptionParameter);
				success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}

			LogDebug(""Copy main cube"");
			// Copy the data.
			if (includeData)
			{
				// Do a copy for each target entity
				foreach(OLAPElement entity in entityList)
				{
					mainCubeTarget[entityIndex] = entity;

					// copy
					success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
					if (success != ""TRUE"")
					{
						return 3;
					}
				}
			}
		}
		else
		{
			// EntityToEntities_SelectedDrivers
			LogInformation(functionName + "" single entity -&gt; multiple entities, target drivers = source driver(s) in new slot"");
			
			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
			mainCubeSource[entityIndex] = ConvertToStringList(sourceEntity);

			// Init the source and target arrays for copying the configuration information.
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
				}
				else if (index == configAccountIndex)
				{
					Append(configCubeSource, CreateStringList());
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  CreateStringList());
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// Get the destination drivers. These are determined by first driver without description
			OLAPElementList allDriverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
			OLAPDataArea configuredDriversData = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
			                                                        OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                                        targetCycle,
			                                                        totalEntity,
			                                                        allDriverList,
			                                                        defaultLanguage,
			                                                        descriptionParameter);

			StringArray configuredDrivers = CreateStringArray();
			foreach(OLAPCell cell in configuredDriversData)
			{
				string cellValue = cell;
				if (StringLength(cellValue) &gt; 0)
				{
					Append(configuredDrivers, OLAPCellGetElement(cell, accountDimension));
				}
			}

			int totalDriverCount = Count(sourceAccounts);
			OLAPElementList targetDriverList = CreateOLAPElementList();
			int driverCount = 0;
			foreach(OLAPElement driver in allDriverList)
			{
				if (driverCount &lt; totalDriverCount)
				{
					if (!Contains(configuredDrivers, driver))
					{
						OLAPElementListAddElement(targetDriverList, driver);
						driverCount = driverCount + 1;
					}
				}
			}
			if (Count(targetDriverList) == 0)
			{
				int i = 0;
				while(i&lt;Count(sourceAccounts))
				{
					string targetAccount = BP_GetNextAllocationDriver(server);
					targetAccount = ResolveUniqueName(connection,targetAccount);
					Append(targetDriverList, targetAccount);
					i = i + 1 ;
				}

			}

			if (Count(targetDriverList) != totalDriverCount)
			{
				LogWarning(functionName + "" Not enough driver elements available to copy."");
				return 3;
			}

			fullTargetCubeDefinition[accountIndex] = ConvertToStringList(targetDriverList);
			fullTargetConfigCubeDefinition[configAccountIndex] = ConvertToStringList(targetDriverList);

			// Check if there is existing data. Should abort the process before doing the copy.
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) &gt; 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			if (includeData)
			{
				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);

					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			}

			// Do a separate copy for each driver because the source and target accounts are different
			int driverIndex = 0;
			foreach(string account in sourceAccounts)
			{
				string driver = ResolveUniqueName(connection, account);
				configCubeSource[configAccountIndex] = ConvertToStringList(driver);
				mainCubeSource[accountIndex] = ConvertToStringList(driver);
				configCubeTarget[configAccountIndex] = targetDriverList[driverIndex];
				mainCubeTarget[accountIndex] = targetDriverList[driverIndex];

				// Do a separate copy for each entity because the source and target entities are different
				foreach (OLAPElement targetEntity in entityList)
				{
					configCubeTarget[configEntityIndex] = targetEntity;
					mainCubeTarget[entityIndex] = targetEntity;

					// Copy the configuration
					success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
					if (success != ""TRUE"")
					{
						return 3;
					}

					// Copy the data if specified
					if (includeData)
					{
						success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
						if (success != ""TRUE"")
						{
							return 3;
						}
					}
				}

				// Get the descriptions of the drivers from the source, and write it to the target driver appending (1)
				// Note that descriptions can be in several of the languages
				OLAPDataArea dataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                           sourceCycle,
				                                           totalEntity,
				                                           driver,
				                                           OlapDataAreaBCells,
				                                           descriptionParameter);
				foreach(OLAPCell cell in dataArea)
				{
					string languageElement = OLAPCellGetElement(cell, languageDimension);
					string driverDescription = OLAPCellReadString(connection, configCube, sourceCycle, totalEntity, driver, languageElement, descriptionParameter) + "" - "" + copyIndicator;
					OLAPCellWriteString(connection, configCube, driverDescription, targetCycle, totalEntity, targetDriverList[driverIndex], languageElement, descriptionParameter);
				}

				driverIndex = driverIndex + 1;
			}
		}

		return 0;

	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return 3;
	}

	LogDebug(""Leaving AL_CopyManualDriver"");
	// This is only here because AppEngine won't compile unless it is.
	return 3;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""
#include ""AL_DataAreaHasValues"", ""*""
#include ""BP_GetNextAllocationDriver"", ""*""

int AL_CopyManualDriver(string server, string ticket, string sourceCycleUN, string sourceEntityUN, string sourceAccountUN, string targetCycleUN, string targetEntityUN, bool includeData, bool overwriteTarget, string copyIndicator)
@Description: ""Copies the manual driver configuration and data"";
@Category: ""Allocation Functions"";
@Returns: ""0 for success, 1 if there is missing parameters, 2 if the target slice is not empty and overwriteTarget is false, 3 for other errors"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."";
@Parameter[targetCycleUN]: ""The target Planning Cycle element to copy to."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"";
@Parameter[includeData]: ""Indicates if the copy should include the data or just the activation and configuration."";
@Parameter[overwriteTarget]: ""Indicates if the copy should overwrite if there is any data in the target."";
@Parameter[copyIndicator]: ""String to append to the description of the copied driver when copying selected drivers to new slots"";
{
	LogDebug(""Entering AL_CopyManualDriver"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""Source Account: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Entity: "" + targetEntityUN);

	/*
	Acceptable Usages

	Normal (allDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (multiple or *), *, targetCycle, *) targetEntities = sourceEntities, all drivers

	Alternate 1 (EntityToEntities_AllDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (single), *, targetCycle, targetEntity (multiple or *))  single entity -> multiple entities, all drivers
	
	Alternate 2 (EntityToEntities_SelectedDrivers):
	AL_CopyManualDriver(connection, sourceCycle, sourceEntity (single), source driver (multiple), targetCycle, targetEntity (multiple))  single entity -> multiple entities, target drivers = source driver(s) in new slot
	 */

	string functionName = ""AL_CopyManualDriver:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -> Configuration set '"" + targetCycleUN + ""' Entity '"" + targetEntityUN + ""' OverwriteTarget '"" + overwriteTarget + ""'"");

	try
	{

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceCycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		sourceAccountUN= ""[BPDACCOUNT].[DRIVER_0001].[1]"";
		targetCycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		targetEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		copyIndicator= """";*/

		// Define cube and dimension names
		string configCube = ""ALCCONFIG_DRIVER"";
		string mainCube = ""BPCMAIN"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string languageDimension = ""BPDLANGUAGE"";
		string totalEntity = ""TOTAL_ENTITY"";
		string allocationDriver = ""ALLOCATION_DRIVER"";
		string levelElement = ""INPUT_MAIN"";  // Avoids getting TOTAL_INPUT_ALLOCATION copied. This is where manual drivers are stored.
		string descriptionParameter = ""FEATURE_AL_DESCRIPTION"";
		string defaultLanguage = ""Default"";

		int cycleIndex = 1;
		int levelIndex = 3;
		int entityIndex = 5;
		int accountIndex = 8;
		int configCycleIndex = 0;
		int configEntityIndex = 1;
		int configAccountIndex = 2;
		int configParameterIndex = 4;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);
		StringArray mainCubeDimensions = BP_GetCubeDimensions(connection, mainCube);

		// Validate the parameters
		if (StringLength(sourceCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceCycleUN parameter"");
			return 1;
		}
		if (StringLength(targetCycleUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetCycleUN parameter"");
			return 1;
		}
		if (StringLength(sourceEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceEntityUN parameter"");
			return 1;
		}
		if (StringLength(sourceAccountUN) == 0) {
			LogWarning(functionName + "" No value was provided for the sourceAccountUN parameter"");
			return 1;
		}
		if (StringLength(targetEntityUN) == 0) {
			LogWarning(functionName + "" No value was provided for the targetEntityUN parameter"");
			return 1;
		}

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		StringArray sourceEntities = CF_ElementStringSplit(sourceEntityUN);
		StringArray sourceAccounts = CF_ElementStringSplit(sourceAccountUN);
		StringArray targetEntities = CF_ElementStringSplit(targetEntityUN);

		// Determine the type of copy
		bool allDrivers = false;
		bool EntityToEntities_AllDrivers = false;
		bool EntityToEntities_SelectedDrivers = false;

		if ((sourceEntities[0] == ""*"") or (Count(sourceEntities) > 1)) {
			allDrivers = true;
		} else if (sourceAccounts[0] == ""*"") {
			EntityToEntities_AllDrivers = true;
		} else {
			EntityToEntities_SelectedDrivers = true;
		}

		// Get the source and target main cube arrays initialized with common information
		StringListList mainCubeSource = CreateStringListList();
		StringArray mainCubeTarget = CreateStringArray();

		// We also need to see if any of the targets have data, so build up a selection to check that
		StringListList fullTargetCubeDefinition = CreateStringListList();
		StringListList fullTargetConfigCubeDefinition = CreateStringListList();

		int index = 0;
		foreach(string dimension in mainCubeDimensions)
		{
			if (index == cycleIndex)
			{
				Append(fullTargetCubeDefinition, ConvertToStringList(targetCycle));
				Append(mainCubeSource, ConvertToStringList(sourceCycle));
				if (targetCycle == sourceCycle)
				{
					Append(mainCubeTarget, """");
				}
				else
				{
					Append(mainCubeTarget, targetCycle);
				}
			}
			else if ((index == entityIndex) or (index == accountIndex))
			{
				// Will fill these in during specific copy cases
				Append(fullTargetCubeDefinition, CreateStringList());
				Append(mainCubeSource, CreateStringList());
				Append(mainCubeTarget, """");
			}
			else if (index == levelIndex)
			{
				Append(fullTargetCubeDefinition, ConvertToStringList(levelElement));
				Append(mainCubeSource, ConvertToStringList(levelElement));
				Append(mainCubeTarget, """");
			}
			else
			{
				// Use base cells for all other dimensions
				Append(fullTargetCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				Append(mainCubeSource, ConvertToStringList(OlapDataAreaBCells));
				Append(mainCubeTarget, """");
			}

			index = index + 1;
		}

		// Do the copy depending on the type
		string success = """";
		if (allDrivers)
		{
			LogInformation(functionName + ""Configuration set -> cycle, targetEntities = sourceEntities, all drivers"");

			if (sourceCycle == targetCycle)
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			OLAPElementList entityList = CreateOLAPElementList();
			if (sourceEntities[0] == ""*"")
			{
				mainCubeSource[entityIndex] = ConvertToStringList(OlapDataAreaBCells);
				fullTargetCubeDefinition[entityIndex] = ConvertToStringList(OlapDataAreaBCells);
			}
			else
			{
				foreach (string entityUN in sourceEntities)
				{
					string entity = ResolveUniqueName(connection, entityUN);
					OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
					foreach(OLAPElement baseEntity in baseEntities)
					{
						OLAPElementListAddElement(entityList, baseEntity);
					}
				}

				mainCubeSource[entityIndex] = ConvertToStringList(entityList);
				fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);
			}


			// Get the configuration information
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeTarget, """");
					if (sourceEntities[0] == ""*"")
					{
						Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
					}
					else
					{
						Append(configCubeSource, ConvertToStringList(entityList));
						Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
					}
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// See if we need to abort if any targets have data
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) > 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			if (includeData)
			{
				// Set the allocation drivers as source list
				OLAPElementList driverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
				mainCubeSource[accountIndex] = ConvertToStringList(driverList);
				fullTargetCubeDefinition[accountIndex] = ConvertToStringList(driverList);

				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);

					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			} // includeData

			// Copy the config cube
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}

			// Total entity element holds the description of the drivers. It is not a base cell so can't include with * case. Copy separately.
			configCubeSource[configEntityIndex] = ConvertToStringList(totalEntity);
			configCubeSource[configParameterIndex] = ConvertToStringList(descriptionParameter);
			success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
			if (success != ""TRUE"")
			{
				return 3;
			}

			// Copy the data.
			if (includeData)
			{
				success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			} // includeData
		}
		else if (EntityToEntities_AllDrivers)
		{
			LogInformation(functionName + "" single entity -> multiple entities, all drivers"");

			if ((sourceCycle == targetCycle) and (Count(targetEntities) == 1) and (targetEntityUN == sourceEntityUN))
			{
				LogDebug(functionName + "" source and target Configuration set cannot be the same when targetEntities = sourceEntities and targetDrivers = sourceDrivers. Nothing to copy."");
				return 2;
			}

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
			mainCubeSource[entityIndex] = ConvertToStringList(sourceEntity);

			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);

			// Get the configuration information
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(entityList));
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition, ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}
			
			// See if we need to abort if any targets have data
			LogDebug(""Checking target config"");
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) > 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			LogDebug(""Checking target main cube"");
			if (includeData)
			{
				// Set the allocation drivers as source list
				OLAPElementList driverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
				mainCubeSource[accountIndex] = ConvertToStringList(driverList);
				fullTargetCubeDefinition[accountIndex] = ConvertToStringList(driverList);
				
				LogDebug(""Checking target main cube data"");
				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);
					
					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			}

			LogDebug(""Copy config"");
			// Do a copy for each target entity in the config cube
			foreach(OLAPElement entity in entityList)
			{
				configCubeTarget[configEntityIndex] = entity;

				// copy
				success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}

			// Total entity element holds the description of the drivers. It is not a base cell so can't include with * case. Copy separately.
			if (targetCycle != sourceCycle)
			{
				configCubeSource[configEntityIndex] = ConvertToStringList(totalEntity);
				configCubeTarget[configEntityIndex] = """";
				configCubeSource[configParameterIndex] = ConvertToStringList(descriptionParameter);
				success = BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
				if (success != ""TRUE"")
				{
					return 3;
				}
			}

			LogDebug(""Copy main cube"");
			// Copy the data.
			if (includeData)
			{
				// Do a copy for each target entity
				foreach(OLAPElement entity in entityList)
				{
					mainCubeTarget[entityIndex] = entity;

					// copy
					success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
					if (success != ""TRUE"")
					{
						return 3;
					}
				}
			}
		}
		else
		{
			// EntityToEntities_SelectedDrivers
			LogInformation(functionName + "" single entity -> multiple entities, target drivers = source driver(s) in new slot"");
			
			// Target entities
			OLAPElementList entityList = CreateOLAPElementList();
			foreach (string entityUN in targetEntities)
			{
				string entity = ResolveUniqueName(connection, entityUN);
				OLAPElementList baseEntities = AL_GetDimensionElementList(connection, true, entityDimension, entity);
				foreach(OLAPElement baseEntity in baseEntities)
				{
					OLAPElementListAddElement(entityList, baseEntity);
				}
			}

			fullTargetCubeDefinition[entityIndex] = ConvertToStringList(entityList);

			// Single source entity
			string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
			mainCubeSource[entityIndex] = ConvertToStringList(sourceEntity);

			// Init the source and target arrays for copying the configuration information.
			StringListList configCubeSource = CreateStringListList();
			StringArray configCubeTarget = CreateStringArray();
			index = 0;
			foreach(string dimension in configCubeDimensions)
			{
				if (index == configCycleIndex) // cycle
				{
					Append(configCubeSource, ConvertToStringList(sourceCycle));
					Append(configCubeTarget, targetCycle);
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(targetCycle));
				}
				else if (index == configEntityIndex) // entity
				{
					Append(configCubeSource, ConvertToStringList(sourceEntity));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(entityList));
				}
				else if (index == configAccountIndex)
				{
					Append(configCubeSource, CreateStringList());
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  CreateStringList());
				}
				else
				{
					Append(configCubeSource, ConvertToStringList(OlapDataAreaBCells));
					Append(configCubeTarget, """");
					Append(fullTargetConfigCubeDefinition,  ConvertToStringList(OlapDataAreaBCells));
				}

				index = index + 1;
			}

			// Get the destination drivers. These are determined by first driver without description
			OLAPElementList allDriverList = AL_GetDimensionElementList(connection, true, accountDimension, allocationDriver);
			OLAPDataArea configuredDriversData = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
			                                                        OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                                        targetCycle,
			                                                        totalEntity,
			                                                        allDriverList,
			                                                        defaultLanguage,
			                                                        descriptionParameter);

			StringArray configuredDrivers = CreateStringArray();
			foreach(OLAPCell cell in configuredDriversData)
			{
				string cellValue = cell;
				if (StringLength(cellValue) > 0)
				{
					Append(configuredDrivers, OLAPCellGetElement(cell, accountDimension));
				}
			}

			int totalDriverCount = Count(sourceAccounts);
			OLAPElementList targetDriverList = CreateOLAPElementList();
			int driverCount = 0;
			foreach(OLAPElement driver in allDriverList)
			{
				if (driverCount < totalDriverCount)
				{
					if (!Contains(configuredDrivers, driver))
					{
						OLAPElementListAddElement(targetDriverList, driver);
						driverCount = driverCount + 1;
					}
				}
			}
			if (Count(targetDriverList) == 0)
			{
				int i = 0;
				while(i<Count(sourceAccounts))
				{
					string targetAccount = BP_GetNextAllocationDriver(server);
					targetAccount = ResolveUniqueName(connection,targetAccount);
					Append(targetDriverList, targetAccount);
					i = i + 1 ;
				}

			}

			if (Count(targetDriverList) != totalDriverCount)
			{
				LogWarning(functionName + "" Not enough driver elements available to copy."");
				return 3;
			}

			fullTargetCubeDefinition[accountIndex] = ConvertToStringList(targetDriverList);
			fullTargetConfigCubeDefinition[configAccountIndex] = ConvertToStringList(targetDriverList);

			// Check if there is existing data. Should abort the process before doing the copy.
			if (overwriteTarget == false)
			{
				OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 fullTargetConfigCubeDefinition);

				bool hasValues = false;
				foreach(OLAPCell cell in targetDataArea) {
					if (StringLength(ToString(cell)) > 0) {
						hasValues = true;
					}
				}

				if (hasValues) {
					return 2;
				}
			}

			if (includeData)
			{
				if (overwriteTarget == false)
				{
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, mainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 fullTargetCubeDefinition);

					if (AL_DataAreaHasValues(connection, targetDataArea))
					{
						return 2;
					}
				}
			}

			// Do a separate copy for each driver because the source and target accounts are different
			int driverIndex = 0;
			foreach(string account in sourceAccounts)
			{
				string driver = ResolveUniqueName(connection, account);
				configCubeSource[configAccountIndex] = ConvertToStringList(driver);
				mainCubeSource[accountIndex] = ConvertToStringList(driver);
				configCubeTarget[configAccountIndex] = targetDriverList[driverIndex];
				mainCubeTarget[accountIndex] = targetDriverList[driverIndex];

				// Do a separate copy for each entity because the source and target entities are different
				foreach (OLAPElement targetEntity in entityList)
				{
					configCubeTarget[configEntityIndex] = targetEntity;
					mainCubeTarget[entityIndex] = targetEntity;

					// Copy the configuration
					success =  BP_GenericCopy(connection, configCube, configCubeDimensions, configCubeSource, configCubeTarget);
					if (success != ""TRUE"")
					{
						return 3;
					}

					// Copy the data if specified
					if (includeData)
					{
						success = BP_GenericCopy(connection, mainCube, mainCubeDimensions, mainCubeSource, mainCubeTarget);
						if (success != ""TRUE"")
						{
							return 3;
						}
					}
				}

				// Get the descriptions of the drivers from the source, and write it to the target driver appending (1)
				// Note that descriptions can be in several of the languages
				OLAPDataArea dataArea = OLAPCreateDataArea(connection, configCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                           sourceCycle,
				                                           totalEntity,
				                                           driver,
				                                           OlapDataAreaBCells,
				                                           descriptionParameter);
				foreach(OLAPCell cell in dataArea)
				{
					string languageElement = OLAPCellGetElement(cell, languageDimension);
					string driverDescription = OLAPCellReadString(connection, configCube, sourceCycle, totalEntity, driver, languageElement, descriptionParameter) + "" - "" + copyIndicator;
					OLAPCellWriteString(connection, configCube, driverDescription, targetCycle, totalEntity, targetDriverList[driverIndex], languageElement, descriptionParameter);
				}

				driverIndex = driverIndex + 1;
			}
		}

		return 0;

	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return 3;
	}

	LogDebug(""Leaving AL_CopyManualDriver"");
	// This is only here because AppEngine won't compile unless it is.
	return 3;
}"	1	B3063FDD-A7AD-4B8A-8889-FB3730D1A4A8	Copies the manual driver configuration and data	1	1	1	1508	NULL	0	45708.67508	0	0
F57D9722-3256-430E-BFFD-8974811D3B38	CD491758-D9DF-4002-94C8-8006E1855F86	AL_CopyParameterConfiguration	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server and database to connect to in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set element to copy from"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceIterationUN"" parameter-type=""string"" parameter-description=""The source iteration element to copy from. * for all Iterations; otherwise single value or comma separated list. If multiple, all entities and accounts are copied."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceEntityUN"" parameter-type=""string"" parameter-description=""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""sourceAccountUN"" parameter-type=""string"" parameter-description=""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetCycleUN"" parameter-type=""string"" parameter-description=""The target Planning Cycle element to copy to."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetIterationUN"" parameter-type=""string"" parameter-description=""The target Iteration element to copy to. Ignored if multiple iterations are in source."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""targetAccountUN"" parameter-type=""string"" parameter-description=""The target Account element to copy to. * for all Accounts; otherwise single or comma separated list. If list, all accounts are copied."" parameter-order=""9"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetCubeDimensions"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GenericCopy"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
    <process process-name=""AL_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""AL_GetDimensionElementList"" process-version=""*"" process-id="""" />
    <process process-name=""AL_CreateIterationElements"" process-version=""*"" process-id="""" />
    <process process-name=""AL_DimensionBaseElements"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""
#include ""AL_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""
#include ""AL_CreateIterationElements"", ""*""
#include ""AL_DimensionBaseElements"", ""*""

/*
string Test() {
	string result = AL_CopyParameterConfiguration(""infor-OLAP02/Infor_BI_Solution_Finance"","""",""[BPDCYCLE].[CYCLE_001].[1]"",""*"",""[BPDENTITY].[N.A.].[1]"",""[BPDACCOUNT].[92006025].[2]"",""[BPDCYCLE].[CYCLE_001].[1]"",""*"",""[BPDENTITY].[N.A.].[1]"",""*"");
	return result;
}
 */

string AL_CopyParameterConfiguration(string server,
                                     string ticket,
                                     string sourceCycleUN,
                                     string sourceIterationUN,
                                     string sourceEntityUN,
                                     string sourceAccountUN,
                                     string targetCycleUN,
                                     string targetIterationUN,
                                     string targetEntityUN,
                                     string targetAccountUN)
@Description: ""Copies allocation parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceIterationUN]: ""The source iteration element to copy from. * for all Iterations; otherwise single value or comma separated list. If multiple, all entities and accounts are copied."";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."";
@Parameter[targetCycleUN]: ""The target Planning Cycle element to copy to."";
@Parameter[targetIterationUN]: ""The target Iteration element to copy to. Ignored if multiple iterations are in source."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"";
@Parameter[targetAccountUN]: ""The target Account element to copy to. * for all Accounts; otherwise single or comma separated list. If list, all accounts are copied."";
{
	LogDebug(""Entering AL_CopyParameterConfiguration"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Iteration: "" + sourceIterationUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""SourceAccount: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Iteration: "" + targetIterationUN);
	LogDebug(""Target Entity: "" + targetEntityUN);
	LogDebug(""Target Account: "" + targetAccountUN);

	string functionName = ""AL_CopyParameterConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Iteration '"" + sourceIterationUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -&gt; Configuration set '"" + targetCycleUN + ""' Iteration '"" + targetIterationUN + ""' Entity '"" + targetEntityUN + ""' Account '"" + targetAccountUN + ""'"");

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");


		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		targetCycleUN = ""[BPDCYCLE].[CYCLE_006].[1]"";

		sourceEntityUN = ""*"";
		targetEntityUN = ""*"";
		targetIterationUN = ""*"";
		sourceIterationUN = ""*"";
		targetAccountUN = ""*"";
		sourceAccountUN = ""*"";*/

		// Define cube and dimension names
		string configCube = ""ALCCONFIG"";
		string iterationCube = ""ALCCONFIG_ITERATION"";
		string entityAccountCube = ""ALCCONFIG_ENTITY_ACCOUNT"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string iterationDimension = ""ALDITERATION"";
		string unassigned = ""N.A."";
		string descriptionParameter = ""FEATURE_AL_DESCRIPTION"";
		string activeParameter = ""FEATURE_AL_ACTIVE"";
		string defaultLanguage = ""Default"";
		string parameterLanguage = ""Parameter"";
		string iterationPrefix = ""ITERATION"";
		
		// ALCCONFIG Cube Indexes
		int iterationIndex = 2;
		int accountIndex = 3;
		int entityIndex = 1;
		
		// ALCCONFIG_ITERATION Cube Indexes
		int iterationIndexIteration = 2;
		int entityIndexIteration = 1;
		
		// ALCCONFIG_ENTITY_ACCOUNT Cube Indexes
		int accountIndexEntityAccount = 1;
		int iterationIndexEntityAccount = 2;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);
		StringArray iterationCubeDimensions = BP_GetCubeDimensions(connection, iterationCube);
		StringArray entityAccountDimensions = BP_GetCubeDimensions(connection, entityAccountCube);

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);
		string sourceAccount = ResolveUniqueName(connection, sourceAccountUN);

		// Parse out mutiple values for inputs
		// Make sure there are values in the source elements before trying to split and compare them
		StringArray sourceIterations = CreateStringArray();
		StringArray sourceAccounts = CreateStringArray();
		StringArray sourceEntities = CreateStringArray();
		StringArray targetIterations = CreateStringArray();
		StringArray targetAccounts = CreateStringArray();
		StringArray targetEntities = CreateStringArray();

		if (StringLength(sourceIterationUN) == 0 or sourceIterationUN == ""*"") {
			sourceIterations = AL_DimensionBaseElements(connection, ""ALDITERATION"", ToString(BP_GetTopElement(connection, ""ALDITERATION"")));
			LogDebug(""Source Iteration list: "" + sourceIterationUN);
		}
		else
		{
			sourceIterations = AL_ElementStringSplit(connection,sourceIterationUN);
		}

		if (StringLength(sourceAccountUN) == 0 or sourceAccountUN == ""*"") {
			sourceAccounts = AL_DimensionBaseElements(connection, ""BPDACCOUNT"", ToString(BP_GetTopElement(connection, ""BPDACCOUNT"")));//""TOTAL_BWA""
			LogDebug(""Source Account list: "" + sourceAccountUN);
		}
		else
		{
			sourceAccounts = AL_ElementStringSplit(connection,sourceAccountUN);
		}
		
		if (StringLength(sourceEntityUN) == 0 or sourceEntityUN == ""*"") {
			sourceEntities = AL_DimensionBaseElements(connection, ""BPDENTITY"", ToString(BP_GetTopElement(connection, ""BPDENTITY"")));
			LogDebug(""Source Entity list: "" + sourceEntityUN);
		}
		else
		{
			sourceEntities = AL_ElementStringSplit(connection,sourceEntityUN);
		}
		
		if (StringLength(targetIterationUN) == 0 or targetIterationUN == ""*"") {
			targetIterations = AL_DimensionBaseElements(connection, ""ALDITERATION"", ToString(BP_GetTopElement(connection, ""ALDITERATION"")));
			LogDebug(""Target Iteration list: "" + targetIterationUN);
		}
		else
		{
			targetIterations = AL_ElementStringSplit(connection,targetIterationUN);
		}
		
		if (StringLength(targetAccountUN) == 0 or targetAccountUN == ""*"") {
			targetAccounts = AL_DimensionBaseElements(connection, ""BPDACCOUNT"", ToString(BP_GetTopElement(connection, ""BPDACCOUNT"")));
			LogDebug(""Target Account list: "" + targetAccountUN);
		}
		else
		{
			targetAccounts = AL_ElementStringSplit(connection,targetAccountUN);
		}
		
		if (StringLength(targetEntityUN) == 0 or targetEntityUN == ""*"") {
			targetEntities = AL_DimensionBaseElements(connection, ""BPDENTITY"", ToString(BP_GetTopElement(connection, ""BPDENTITY"")));
			LogDebug(""Target Entity list: "" + targetEntityUN);
		}
		else
		{
			targetEntities = AL_ElementStringSplit(connection,targetEntityUN);
		}


		StringList sourceIterationsStringList = ToStringList(sourceIterations);
		Prepend(sourceIterationsStringList, """");

		StringList sourceEntitiesStringList = ToStringList(sourceEntities);
		Prepend(sourceEntitiesStringList, """");

		StringList sourceAccountsStringList = ToStringList(sourceAccounts);
		Prepend(sourceAccountsStringList, """");

		StringList targetIterationsStringList = ToStringList(targetIterations);
		Prepend(targetIterationsStringList, """");

		StringList targetAccountsStringList = ToStringList(targetAccounts);
		Prepend(targetAccountsStringList, """");

		StringList targetEntitiesStringList = ToStringList(targetEntities);
		Prepend(targetEntitiesStringList, """");

		double numberofSourceIttaretions = Count(sourceIterations);
		double numberofSourceEntities = Count(sourceEntities);
		double numberofSourceAccounts = Count(sourceAccounts);

		double numberofTargetIttaretions = Count(targetIterations);
		double numberofTargetEntities = Count(targetEntities);
		double numberofTargetAccounts = Count(targetAccounts);
		
		LogDebug(""Starting to copy ALCCONFIG values"");

		OLAPDataArea configCubeDataArea = OLAPCreateDataArea(connection, configCube,
		                                                     OlapDataAreaIncludeB |OlapDataAreaSuppressNull,
		                                                     OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                                     sourceCycle,
		                                                     sourceEntitiesStringList,
		                                                     sourceIterationsStringList,
		                                                     sourceAccountsStringList,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells);
		
		foreach (OLAPCell cell in configCubeDataArea)
		{
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string Iteratinon = OLAPCellGetElement(cell, ""ALDITERATION"");
			string version = OLAPCellGetElement(cell, ""BPDVERSION"");
			string Alddimension = OLAPCellGetElement(cell, ""ALDDIMENSION"");
			string Bpdno = OLAPCellGetElement(cell, ""BPDNO"");
			string Parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");

			string ALCCopyString = OLAPCellReadString(connection, configCube, sourceCycle, entity, Iteratinon, account , version, Alddimension, Bpdno , Parameter);


			if (ALCCopyString  != """")
			{
				// account all to all, iteration all to all, entity all to all, use case for different source and target cycle
				if(numberofSourceAccounts !=  1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1 and sourceCycle != targetCycle)
				{
					OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, Iteratinon, account , version, Alddimension, Bpdno , Parameter);
				}


				// account 1 to all, iteration all to all, entity all to all
				// account 1 to 1, iteration all to all, entity all to all
				if((numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1))

				{
					foreach(string accountHelp in targetAccounts)
					{
						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, Iteratinon, accountHelp, version, Alddimension, Bpdno , Parameter);
						
						if (account != accountHelp){
							// Always change source and target accounts to the new account (target), only change driver if it is the same.
							string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
							OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
							OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
							if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
							}
						}
					}

				}
				// account 1 to all, iteration 1 to 1, entity 1 to 1
				// account 1 to 1, iteration 1 to all, entity 1 to 1
				// account 1 to 1, iteration 1 to 1, entity  1 to 1
				// account 1 to 1, iteration 1 to 1, entity 1 to all.
				// account 1 to all, iteration 1 to all, entity 1 to 1.
				// account 1 to all, iteration 1 to 1, entity  1 to all
				// account 1 to 1, iteration 1 to all, entity 1 to all.
				// account 1 to all, iteration 1 to all, entity 1 to all



				if((numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) )

				{

					foreach(string accountHelp in targetAccounts)
					{
						foreach(string iterationHelp in targetIterations)
						{
							foreach(string entityHelp in targetEntities)
							{
								OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, iterationHelp, accountHelp, version, Alddimension, Bpdno , Parameter);
								if (account != accountHelp){
									// Always change source and target accounts to the new account (target), only change driver if it is the same.
									string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
									if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									}
								}

								else if (entity != entityHelp)
								{
									// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
									string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
									string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
									string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
									string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
									if (source == driver and driver == target)
									{
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
									}
									else
									{
										OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									}
								}

							}
						}
					}

				}
				// account all to all, iteration 1 to all, entity all to all
				// account all to all, iteration 1 to 1, entity all to all
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1))

				{
					foreach(string iterationHelp in targetIterations)
					{
						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, iterationHelp, account, version, Alddimension, Bpdno , Parameter);
					}
				}

				// account all to all, iteration all to all, entity 1 to 1.
				// account all to all, iteration all to all, entity 1 to all
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))
				{
					foreach(string entityHelp in targetEntities)
					{

						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, Iteratinon, account, version, Alddimension, Bpdno , Parameter);
						if (entity != entityHelp)
						{
							// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
							string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
							string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
							string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
							string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
							if (source == driver and driver == target)
							{
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
							}
							else
							{
								OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
							}
						}

					}
				}

				

				// account 1 to 1, iteration 1 to 1, entity all to all
				// account 1 to 1, iteration 1 to all, entity all to all
				// account 1 to all, iteration 1 to 1, entity all to all

				if((numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1)
				  )

				{
					foreach(string accountHelp in targetAccounts)
					{
						foreach(string iterationHelp in targetIterations)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, iterationHelp, accountHelp, version, Alddimension, Bpdno , Parameter);

							if (account != accountHelp){
								// Always change source and target accounts to the new account (target), only change driver if it is the same.
								string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity,iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, entity,  iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, iterationHelp, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									
								}
							}


						}

					}

				}

				// account 1 to 1, iteration all to all, entity 1 to 1
				// account 1 to all, iteration all to all, entity 1 to 1
				// account 1 to 1, iteration all to all, entity 1 to all
				if((numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1)or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))

				{
					foreach(string accountHelp in targetAccounts)
					{
						foreach(string entityHelp in targetEntities)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, Iteratinon, accountHelp, version, Alddimension, Bpdno , Parameter);
							if (account != accountHelp){
								// Always change source and target accounts to the new account (target), only change driver if it is the same.
								string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle,entityHelp, Iteratinon,  accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
								}
							}

							else if (entity != entityHelp)
							{
								// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
								string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
								string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
								string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
								string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
								if (source == driver and driver == target)
								{
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								}
								else
								{
									OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								}
							}

						}

					}

				}

				// account all to all iteration 1 to 1, entity 1 to 1
				// account all to all iteration 1 to All, entity 1 to 1
				// account all to all iteration 1 to 1, entity 1 to ALL
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))

				{
					foreach(string iterationHelp in targetIterations)
					{
						foreach(string entityHelp in targetEntities)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, iterationHelp, account, version, Alddimension, Bpdno , Parameter);
							
							if (entity != entityHelp)
							{
								// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
								string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
								string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetCubeDimensions"", ""*""
#include ""BP_GenericCopy"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""
#include ""AL_ElementStringSplit"", ""*""
#include ""AL_GetDimensionElementList"", ""*""
#include ""AL_CreateIterationElements"", ""*""
#include ""AL_DimensionBaseElements"", ""*""

/*
string Test() {
	string result = AL_CopyParameterConfiguration(""infor-OLAP02/Infor_BI_Solution_Finance"","""",""[BPDCYCLE].[CYCLE_001].[1]"",""*"",""[BPDENTITY].[N.A.].[1]"",""[BPDACCOUNT].[92006025].[2]"",""[BPDCYCLE].[CYCLE_001].[1]"",""*"",""[BPDENTITY].[N.A.].[1]"",""*"");
	return result;
}
 */

string AL_CopyParameterConfiguration(string server,
                                     string ticket,
                                     string sourceCycleUN,
                                     string sourceIterationUN,
                                     string sourceEntityUN,
                                     string sourceAccountUN,
                                     string targetCycleUN,
                                     string targetIterationUN,
                                     string targetEntityUN,
                                     string targetAccountUN)
@Description: ""Copies allocation parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceIterationUN]: ""The source iteration element to copy from. * for all Iterations; otherwise single value or comma separated list. If multiple, all entities and accounts are copied."";
@Parameter[sourceEntityUN]: ""The source Entity element to copy from. * for all Entities; otherwise single or comma separated list. If list, all accounts are copied."";
@Parameter[sourceAccountUN]: ""The source Account element to copy from. * for all Accounts; otherwise single or comma separated list."";
@Parameter[targetCycleUN]: ""The target Planning Cycle element to copy to."";
@Parameter[targetIterationUN]: ""The target Iteration element to copy to. Ignored if multiple iterations are in source."";
@Parameter[targetEntityUN]: ""The target Entity element to copy to. Ignored if multiple iterations or enties are in source"";
@Parameter[targetAccountUN]: ""The target Account element to copy to. * for all Accounts; otherwise single or comma separated list. If list, all accounts are copied."";
{
	LogDebug(""Entering AL_CopyParameterConfiguration"");
	LogDebug(""Source Configuration set: "" + sourceCycleUN);
	LogDebug(""Source Iteration: "" + sourceIterationUN);
	LogDebug(""Source Entity: "" + sourceEntityUN);
	LogDebug(""SourceAccount: "" + sourceAccountUN);
	LogDebug(""Target Configuration set: "" + targetCycleUN);
	LogDebug(""Target Iteration: "" + targetIterationUN);
	LogDebug(""Target Entity: "" + targetEntityUN);
	LogDebug(""Target Account: "" + targetAccountUN);

	string functionName = ""AL_CopyParameterConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + sourceCycleUN + ""' Iteration '"" + sourceIterationUN + ""' Entity '"" + sourceEntityUN + ""' Account '"" + sourceAccountUN + ""' -> Configuration set '"" + targetCycleUN + ""' Iteration '"" + targetIterationUN + ""' Entity '"" + targetEntityUN + ""' Account '"" + targetAccountUN + ""'"");

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");


		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		targetCycleUN = ""[BPDCYCLE].[CYCLE_006].[1]"";

		sourceEntityUN = ""*"";
		targetEntityUN = ""*"";
		targetIterationUN = ""*"";
		sourceIterationUN = ""*"";
		targetAccountUN = ""*"";
		sourceAccountUN = ""*"";*/

		// Define cube and dimension names
		string configCube = ""ALCCONFIG"";
		string iterationCube = ""ALCCONFIG_ITERATION"";
		string entityAccountCube = ""ALCCONFIG_ENTITY_ACCOUNT"";
		string parameterDimension = ""BPDPARAMETER"";
		string accountDimension = ""BPDACCOUNT"";
		string entityDimension = ""BPDENTITY"";
		string iterationDimension = ""ALDITERATION"";
		string unassigned = ""N.A."";
		string descriptionParameter = ""FEATURE_AL_DESCRIPTION"";
		string activeParameter = ""FEATURE_AL_ACTIVE"";
		string defaultLanguage = ""Default"";
		string parameterLanguage = ""Parameter"";
		string iterationPrefix = ""ITERATION"";
		
		// ALCCONFIG Cube Indexes
		int iterationIndex = 2;
		int accountIndex = 3;
		int entityIndex = 1;
		
		// ALCCONFIG_ITERATION Cube Indexes
		int iterationIndexIteration = 2;
		int entityIndexIteration = 1;
		
		// ALCCONFIG_ENTITY_ACCOUNT Cube Indexes
		int accountIndexEntityAccount = 1;
		int iterationIndexEntityAccount = 2;

		StringArray configCubeDimensions = BP_GetCubeDimensions(connection, configCube);
		StringArray iterationCubeDimensions = BP_GetCubeDimensions(connection, iterationCube);
		StringArray entityAccountDimensions = BP_GetCubeDimensions(connection, entityAccountCube);

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);
		string sourceAccount = ResolveUniqueName(connection, sourceAccountUN);

		// Parse out mutiple values for inputs
		// Make sure there are values in the source elements before trying to split and compare them
		StringArray sourceIterations = CreateStringArray();
		StringArray sourceAccounts = CreateStringArray();
		StringArray sourceEntities = CreateStringArray();
		StringArray targetIterations = CreateStringArray();
		StringArray targetAccounts = CreateStringArray();
		StringArray targetEntities = CreateStringArray();

		if (StringLength(sourceIterationUN) == 0 or sourceIterationUN == ""*"") {
			sourceIterations = AL_DimensionBaseElements(connection, ""ALDITERATION"", ToString(BP_GetTopElement(connection, ""ALDITERATION"")));
			LogDebug(""Source Iteration list: "" + sourceIterationUN);
		}
		else
		{
			sourceIterations = AL_ElementStringSplit(connection,sourceIterationUN);
		}

		if (StringLength(sourceAccountUN) == 0 or sourceAccountUN == ""*"") {
			sourceAccounts = AL_DimensionBaseElements(connection, ""BPDACCOUNT"", ToString(BP_GetTopElement(connection, ""BPDACCOUNT"")));//""TOTAL_BWA""
			LogDebug(""Source Account list: "" + sourceAccountUN);
		}
		else
		{
			sourceAccounts = AL_ElementStringSplit(connection,sourceAccountUN);
		}
		
		if (StringLength(sourceEntityUN) == 0 or sourceEntityUN == ""*"") {
			sourceEntities = AL_DimensionBaseElements(connection, ""BPDENTITY"", ToString(BP_GetTopElement(connection, ""BPDENTITY"")));
			LogDebug(""Source Entity list: "" + sourceEntityUN);
		}
		else
		{
			sourceEntities = AL_ElementStringSplit(connection,sourceEntityUN);
		}
		
		if (StringLength(targetIterationUN) == 0 or targetIterationUN == ""*"") {
			targetIterations = AL_DimensionBaseElements(connection, ""ALDITERATION"", ToString(BP_GetTopElement(connection, ""ALDITERATION"")));
			LogDebug(""Target Iteration list: "" + targetIterationUN);
		}
		else
		{
			targetIterations = AL_ElementStringSplit(connection,targetIterationUN);
		}
		
		if (StringLength(targetAccountUN) == 0 or targetAccountUN == ""*"") {
			targetAccounts = AL_DimensionBaseElements(connection, ""BPDACCOUNT"", ToString(BP_GetTopElement(connection, ""BPDACCOUNT"")));
			LogDebug(""Target Account list: "" + targetAccountUN);
		}
		else
		{
			targetAccounts = AL_ElementStringSplit(connection,targetAccountUN);
		}
		
		if (StringLength(targetEntityUN) == 0 or targetEntityUN == ""*"") {
			targetEntities = AL_DimensionBaseElements(connection, ""BPDENTITY"", ToString(BP_GetTopElement(connection, ""BPDENTITY"")));
			LogDebug(""Target Entity list: "" + targetEntityUN);
		}
		else
		{
			targetEntities = AL_ElementStringSplit(connection,targetEntityUN);
		}


		StringList sourceIterationsStringList = ToStringList(sourceIterations);
		Prepend(sourceIterationsStringList, """");

		StringList sourceEntitiesStringList = ToStringList(sourceEntities);
		Prepend(sourceEntitiesStringList, """");

		StringList sourceAccountsStringList = ToStringList(sourceAccounts);
		Prepend(sourceAccountsStringList, """");

		StringList targetIterationsStringList = ToStringList(targetIterations);
		Prepend(targetIterationsStringList, """");

		StringList targetAccountsStringList = ToStringList(targetAccounts);
		Prepend(targetAccountsStringList, """");

		StringList targetEntitiesStringList = ToStringList(targetEntities);
		Prepend(targetEntitiesStringList, """");

		double numberofSourceIttaretions = Count(sourceIterations);
		double numberofSourceEntities = Count(sourceEntities);
		double numberofSourceAccounts = Count(sourceAccounts);

		double numberofTargetIttaretions = Count(targetIterations);
		double numberofTargetEntities = Count(targetEntities);
		double numberofTargetAccounts = Count(targetAccounts);
		
		LogDebug(""Starting to copy ALCCONFIG values"");

		OLAPDataArea configCubeDataArea = OLAPCreateDataArea(connection, configCube,
		                                                     OlapDataAreaIncludeB |OlapDataAreaSuppressNull,
		                                                     OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                                     sourceCycle,
		                                                     sourceEntitiesStringList,
		                                                     sourceIterationsStringList,
		                                                     sourceAccountsStringList,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells,
		                                                     OlapDataAreaBCells);
		
		foreach (OLAPCell cell in configCubeDataArea)
		{
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string Iteratinon = OLAPCellGetElement(cell, ""ALDITERATION"");
			string version = OLAPCellGetElement(cell, ""BPDVERSION"");
			string Alddimension = OLAPCellGetElement(cell, ""ALDDIMENSION"");
			string Bpdno = OLAPCellGetElement(cell, ""BPDNO"");
			string Parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");

			string ALCCopyString = OLAPCellReadString(connection, configCube, sourceCycle, entity, Iteratinon, account , version, Alddimension, Bpdno , Parameter);


			if (ALCCopyString  != """")
			{
				// account all to all, iteration all to all, entity all to all, use case for different source and target cycle
				if(numberofSourceAccounts !=  1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1 and sourceCycle != targetCycle)
				{
					OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, Iteratinon, account , version, Alddimension, Bpdno , Parameter);
				}


				// account 1 to all, iteration all to all, entity all to all
				// account 1 to 1, iteration all to all, entity all to all
				if((numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1))

				{
					foreach(string accountHelp in targetAccounts)
					{
						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, Iteratinon, accountHelp, version, Alddimension, Bpdno , Parameter);
						
						if (account != accountHelp){
							// Always change source and target accounts to the new account (target), only change driver if it is the same.
							string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
							OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
							OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
							if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entity, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, Iteratinon, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
							}
						}
					}

				}
				// account 1 to all, iteration 1 to 1, entity 1 to 1
				// account 1 to 1, iteration 1 to all, entity 1 to 1
				// account 1 to 1, iteration 1 to 1, entity  1 to 1
				// account 1 to 1, iteration 1 to 1, entity 1 to all.
				// account 1 to all, iteration 1 to all, entity 1 to 1.
				// account 1 to all, iteration 1 to 1, entity  1 to all
				// account 1 to 1, iteration 1 to all, entity 1 to all.
				// account 1 to all, iteration 1 to all, entity 1 to all



				if((numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1) )

				{

					foreach(string accountHelp in targetAccounts)
					{
						foreach(string iterationHelp in targetIterations)
						{
							foreach(string entityHelp in targetEntities)
							{
								OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, iterationHelp, accountHelp, version, Alddimension, Bpdno , Parameter);
								if (account != accountHelp){
									// Always change source and target accounts to the new account (target), only change driver if it is the same.
									string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
									if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, iterationHelp, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									}
								}

								else if (entity != entityHelp)
								{
									// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
									string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
									string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
									string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
									string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
									if (source == driver and driver == target)
									{
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
										OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
									}
									else
									{
										OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									}
								}

							}
						}
					}

				}
				// account all to all, iteration 1 to all, entity all to all
				// account all to all, iteration 1 to 1, entity all to all
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1))

				{
					foreach(string iterationHelp in targetIterations)
					{
						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, iterationHelp, account, version, Alddimension, Bpdno , Parameter);
					}
				}

				// account all to all, iteration all to all, entity 1 to 1.
				// account all to all, iteration all to all, entity 1 to all
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))
				{
					foreach(string entityHelp in targetEntities)
					{

						OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, Iteratinon, account, version, Alddimension, Bpdno , Parameter);
						if (entity != entityHelp)
						{
							// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
							string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
							string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
							string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
							string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
							if (source == driver and driver == target)
							{
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
							}
							else
							{
								OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
							}
						}

					}
				}

				

				// account 1 to 1, iteration 1 to 1, entity all to all
				// account 1 to 1, iteration 1 to all, entity all to all
				// account 1 to all, iteration 1 to 1, entity all to all

				if((numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1)
				  )

				{
					foreach(string accountHelp in targetAccounts)
					{
						foreach(string iterationHelp in targetIterations)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entity, iterationHelp, accountHelp, version, Alddimension, Bpdno , Parameter);

							if (account != accountHelp){
								// Always change source and target accounts to the new account (target), only change driver if it is the same.
								string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity,iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, entity,  iterationHelp, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entity, iterationHelp, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									
								}
							}


						}

					}

				}

				// account 1 to 1, iteration all to all, entity 1 to 1
				// account 1 to all, iteration all to all, entity 1 to 1
				// account 1 to 1, iteration all to all, entity 1 to all
				if((numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1)or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts == 1 and numberofTargetAccounts == 1 and numberofSourceIttaretions != 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))

				{
					foreach(string accountHelp in targetAccounts)
					{
						foreach(string entityHelp in targetEntities)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, Iteratinon, accountHelp, version, Alddimension, Bpdno , Parameter);
							if (account != accountHelp){
								// Always change source and target accounts to the new account (target), only change driver if it is the same.
								string newTargetAccount = ""[BPDACCOUNT].["" + accountHelp + ""].[1]"";
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								if( BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle,entityHelp, Iteratinon,  accountHelp, ""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"")) == account){
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetAccount, targetCycle, entityHelp, Iteratinon, accountHelp ,""N.A."", ""BPDACCOUNT"", ""PNO_003"", ""FEATURE_AL_TYPE"");
								}
							}

							else if (entity != entityHelp)
							{
								// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
								string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
								string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
								string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
								string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
								if (source == driver and driver == target)
								{
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								}
								else
								{
									OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, Iteratinon, accountHelp, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								}
							}

						}

					}

				}

				// account all to all iteration 1 to 1, entity 1 to 1
				// account all to all iteration 1 to All, entity 1 to 1
				// account all to all iteration 1 to 1, entity 1 to ALL
				if((numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  != 1 and numberofSourceEntities == 1 and numberofTargetEntities == 1) or
				   (numberofSourceAccounts != 1 and numberofTargetAccounts != 1 and numberofSourceIttaretions == 1 and numberofTargetIttaretions  == 1 and numberofSourceEntities == 1 and numberofTargetEntities != 1))

				{
					foreach(string iterationHelp in targetIterations)
					{
						foreach(string entityHelp in targetEntities)
						{
							OLAPCellWriteBufferWriteString(buffer, configCube,ALCCopyString , targetCycle, entityHelp, iterationHelp, account, version, Alddimension, Bpdno , Parameter);
							
							if (entity != entityHelp)
							{
								// If the entity is different change it to the target entity. If all three are the same change all 3, if different only replace the source.
								string newTargetEntity = ""[BPDENTITY].["" + entityHelp + ""].[1]"";
								string source = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE""));
								string driver = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE""));
								string target = BP_GetResolvedUniqueName(connection, OLAPCellReadString(connection, configCube, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE""));
								if (source == driver and driver == target)
								{
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_003"", ""FEATURE_AL_TYPE"");
									OLAPCellWriteBufferWriteString(buffer, configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_004"", ""FEATURE_AL_TYPE"");
								}
								else
								{
									OLAPCellWriteBufferWriteString(buffer,  configCube, newTargetEntity, targetCycle, entityHelp, iterationHelp, account, ""N.A."", ""BPDENTITY"", ""PNO_002"", ""FEATURE_AL_TYPE"");
								}
							}

						}

					}

				}
			}
		}

		

		OLAPCommitCellWriteBuffer(buffer);

		

		// Copy ALCCONFIG_ITERATION and ALCCONFIG_ENTITY_ACCOUNT
		bool cycleDifferent = false;
		bool iterationDifferent = false;
		bool accountDifferent = false;
		bool entityDifferent = false;

		if(sourceCycle != targetCycle){
			cycleDifferent = true;
		}
		if (sourceIterationUN != targetIterationUN){
			iterationDifferent=true;
		}
		if (sourceAccountUN != targetAccountUN){
			accountDifferent=true;
		}
		if (sourceEntityUN != targetEntityUN){
			entityDifferent=true;
		}

		if (cycleDifferent or iterationDifferent or entityDifferent){
			LogDebug(""Starting to copy ALCCONFIG_ITERATION values"");

			// Check to see if we need to copy ALCCONFIG_ITERATION
			OLAPDataArea itterationCubeDataArea = OLAPCreateDataArea(connection, iterationCube,
			                                                         OlapDataAreaIncludeB |OlapDataAreaSuppressNull,
			                                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			                                                         sourceCycle,
			                                                         sourceEntitiesStringList,
			                                                         sourceIterationsStringList,
			                                                         OlapDataAreaBCells,
			                                                         OlapDataAreaBCells);
			
			foreach (OLAPCell cell in itterationCubeDataArea )
			{

				string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
				string Iteration = OLAPCellGetElement(cell, ""ALDITERATION"");
				string Language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
				string Parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");

				string ALCCopyString = OLAPCellReadString(connection, iterationCube, sourceCycle, entity, Iteration, Language, Parameter);


				if(numberofSourceIttaretions != 1 and numberofTargetIttaretions != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1 and sourceCycle != targetCycle)
				{
					OLAPCellWriteBufferWriteString(buffer, iterationCube,ALCCopyString, targetCycle, entity, Iteration, Language, Parameter);

				}

				if((numberofSourceIttaretions == 1 and numberofTargetIttaretions != 1 and numberofSourceEntities != 1 and numberofTargetEntities != 1) or
				   (numberofSourceIttaretions == 1 "	1	05FCC7A9-82B4-4879-BD98-9F031A6C3F6B	Copies allocation parameters.	1	1	1	1509	NULL	0	45708.67506	0	0
C7CD19AE-60EA-4363-8FCE-CD79B5DCC98D	CD491758-D9DF-4002-94C8-8006E1855F86	AL_CreateIterationElements	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The unique name of the first placeholder element created"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""number"" parameter-type=""int"" parameter-description=""The number of placeholder elements to create"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""BP_CreateNewPlaceholderElements"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateNewPlaceholderElements"", ""*""

string AL_CreateIterationElements(string server, string ticket, int number)
@Description: ""This function is used to create additional iteration placeholder elements."";
@Category: ""Allocation Functions"";
@Returns: ""The unique name of the first placeholder element created"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[number]: ""The number of placeholder elements to create"";
{
	LogDebug(""Entering AL_CreateIterationElements"");
	LogDebug(""Number: "" + number);

	string functionName = ""AL_CreateIterationElements:"";
	string errorMessage = """";
	int errorCode = 0;
	try {

		string iterationDimension = ""ALDITERATION"";
		string parent = ""TOTAL"";
		string prefix = ""ITERATION_"";
		int digitCount = 4;

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList dimensionElements = OLAPGetElementList(connection, iterationDimension, false);

		int highestValue = 1;
		foreach(OLAPElement dimElement in dimensionElements)
		{
			string elementToTest = dimElement;
			
			if(StringStartsWith(elementToTest, prefix))
			{
				elementToTest = StringReplace(elementToTest, prefix, """", true);
			}

			if(IsNumeric(elementToTest))
			{
				int value = ToInt(elementToTest);
				if(value &gt; highestValue)
				{
					highestValue = value;
				}
			}
		}
		string concatString = ""000"";
		int startNumber = highestValue + 1;
		int index = 0;
		string elementName = ToString(startNumber);
		if(StringLength(elementName) &lt; digitCount)
		{
			elementName = StringSubstring(concatString, 0, digitCount - StringLength(elementName)) + elementName;
		}

		elementName = prefix + elementName;

		string returnValue = BP_CreateNewPlaceholderElements(connection, iterationDimension, number, digitCount, prefix, parent);
		if (returnValue == ""TRUE"") {
			string valueToReturn = ""["" + iterationDimension + ""].["" + elementName + ""].[1]"";

			// PMMIS-8451: Set the name, element type and english.
			int i = startNumber;
			while(i &lt; startNumber + number)
			{
				string numberString = ToString(i);
				numberString = StringSubstring(concatString, 0, digitCount - StringLength(numberString)) + numberString;
				elementName = prefix + numberString;

				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""Name"", ""Step "" + numberString);
				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""English"", ""Step "" + numberString);
				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""ElemType"", ""N"");
				i = i + 1;
			}

			return valueToReturn;
		}

		return returnValue;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}

	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_CreateIterationElements"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateNewPlaceholderElements"", ""*""

string AL_CreateIterationElements(string server, string ticket, int number)
@Description: ""This function is used to create additional iteration placeholder elements."";
@Category: ""Allocation Functions"";
@Returns: ""The unique name of the first placeholder element created"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[number]: ""The number of placeholder elements to create"";
{
	LogDebug(""Entering AL_CreateIterationElements"");
	LogDebug(""Number: "" + number);

	string functionName = ""AL_CreateIterationElements:"";
	string errorMessage = """";
	int errorCode = 0;
	try {

		string iterationDimension = ""ALDITERATION"";
		string parent = ""TOTAL"";
		string prefix = ""ITERATION_"";
		int digitCount = 4;

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList dimensionElements = OLAPGetElementList(connection, iterationDimension, false);

		int highestValue = 1;
		foreach(OLAPElement dimElement in dimensionElements)
		{
			string elementToTest = dimElement;
			
			if(StringStartsWith(elementToTest, prefix))
			{
				elementToTest = StringReplace(elementToTest, prefix, """", true);
			}

			if(IsNumeric(elementToTest))
			{
				int value = ToInt(elementToTest);
				if(value > highestValue)
				{
					highestValue = value;
				}
			}
		}
		string concatString = ""000"";
		int startNumber = highestValue + 1;
		int index = 0;
		string elementName = ToString(startNumber);
		if(StringLength(elementName) < digitCount)
		{
			elementName = StringSubstring(concatString, 0, digitCount - StringLength(elementName)) + elementName;
		}

		elementName = prefix + elementName;

		string returnValue = BP_CreateNewPlaceholderElements(connection, iterationDimension, number, digitCount, prefix, parent);
		if (returnValue == ""TRUE"") {
			string valueToReturn = ""["" + iterationDimension + ""].["" + elementName + ""].[1]"";

			// PMMIS-8451: Set the name, element type and english.
			int i = startNumber;
			while(i < startNumber + number)
			{
				string numberString = ToString(i);
				numberString = StringSubstring(concatString, 0, digitCount - StringLength(numberString)) + numberString;
				elementName = prefix + numberString;

				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""Name"", ""Step "" + numberString);
				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""English"", ""Step "" + numberString);
				OLAPSetStringAttribute(connection, iterationDimension, elementName, ""ElemType"", ""N"");
				i = i + 1;
			}

			return valueToReturn;
		}

		return returnValue;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}

	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_CreateIterationElements"");
	return ""FALSE"";
}"	1	EDD68ED5-C36F-40A7-B38C-FBB22891DB15	This function is used to create additional iteration placeholder elements.	1	1	1	1510	NULL	0	45708.67509	0	0
EF73D51F-BC6D-4E1D-B969-BD7E4F824EF5	CD491758-D9DF-4002-94C8-8006E1855F86	AL_DataAreaHasValues	Internal Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if the data area has at least one value, false if they are all 0's"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the Olap server"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dataArea"" parameter-type=""OLAPDataArea"" parameter-description=""An OLAPDataArea to test"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool AL_DataAreaHasValues(OLAPConnection connection, OLAPDataArea dataArea)
@Description: ""Determines if the data area has values or is all 0's"";
@Category: ""Internal Allocation Functions"";
@Parameter[connection]: ""A connection to the Olap server"";
@Parameter[dataArea]: ""An OLAPDataArea to test"";
@Returns: ""true if the data area has at least one value, false if they are all 0's"";
{
	LogDebug(""Entering AL_DataAreaHasValues"");

	foreach (OLAPCell cell in dataArea)
	{
		double value = cell;
		if (value != 0.0)
		{
			return true;
		}
	}

	LogDebug(""Leaving AL_DataAreaHasValues"");
	return false;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool AL_DataAreaHasValues(OLAPConnection connection, OLAPDataArea dataArea)
@Description: ""Determines if the data area has values or is all 0's"";
@Category: ""Internal Allocation Functions"";
@Parameter[connection]: ""A connection to the Olap server"";
@Parameter[dataArea]: ""An OLAPDataArea to test"";
@Returns: ""true if the data area has at least one value, false if they are all 0's"";
{
	LogDebug(""Entering AL_DataAreaHasValues"");

	foreach (OLAPCell cell in dataArea)
	{
		double value = cell;
		if (value != 0.0)
		{
			return true;
		}
	}

	LogDebug(""Leaving AL_DataAreaHasValues"");
	return false;
}"	1	56A57F9A-C38D-4B81-9E1F-D6A073972F9C	Determines if the data area has values or is all 0's	1	1	1	1511	NULL	0	45708.67506	0	0
B70E1124-6628-4E4D-AE0C-4C414FFBFCAF	CD491758-D9DF-4002-94C8-8006E1855F86	AL_DeleteIterationConfiguration	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation iteration configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""The iteration element defining the allocation configuration"" parameter-order=""4"" />
  <dependencies>
    <process process-name=""AL_EditAllEntityActive"" process-version=""*"" process-id="""" />
    <process process-name=""AL_ClearConfiguration"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_EditAllEntityActive"", ""*""
#include ""AL_ClearConfiguration"", ""*""

string AL_DeleteIterationConfiguration(string server, string ticket, string cube, string cycleUN, string iterationUN)
@Description: ""Clears descriptions, active, and any defined configurations for an iteration."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation iteration configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
{
	LogDebug(""Entering AL_DeleteIterationConfiguration"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_DeleteIterationConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Iteration '"" + iterationUN + ""'"");

	try {
		string languageValueUN = ""[BPDLANGUAGE].[Value].[1]"";
		string parameterActiveUN = ""[BPDPARAMETER].[FEATURE_AL_ACTIVE].[1]"";
		string mainConfigCube = ""ALCCONFIG"";
		string iterationCube = ""ALCCONFIG_ITERATION"";
		string entityAccountCube = ""ALCCONFIG_ENTITY_ACCOUNT"";
		string unassigned = ""N.A."";
		string returnString = """";

		// First clear out the active flags
		string success = AL_EditAllEntityActive(server, ticket, cube, cycleUN, iterationUN, languageValueUN, parameterActiveUN, ""0"");
		if (success != ""TRUE"") {
			returnString = success;
		}

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string cycle = ResolveUniqueName(connection, cycleUN);
		string iteration = ResolveUniqueName(connection, iterationUN);
		OLAPDataArea iterationsData = OLAPCreateDataArea(connection, iterationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 cycle,
		                                                 unassigned,
		                                                 iteration,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells);
		OLAPDeleteDataArea(iterationsData);
		
		// Clear out Entity Account relations
		OLAPDataArea entityAccountData = OLAPCreateDataArea(connection, entityAccountCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                    OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                    cycle,
		                                                    OlapDataAreaBCells,
		                                                    iteration,
		                                                    OlapDataAreaBCells);
		OLAPDeleteDataArea(entityAccountData);

		// Clear out any configuration
		success = AL_ClearConfiguration(server, ticket, mainConfigCube, cycleUN, ""*"", iterationUN, ""*"");
		if (success != ""TRUE"") {
			returnString = returnString + success;
		}

		if (StringLength(returnString) == 0) {
			returnString = ""TRUE"";
		}

		return returnString;

	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeleteIterationConfiguration"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_EditAllEntityActive"", ""*""
#include ""AL_ClearConfiguration"", ""*""

string AL_DeleteIterationConfiguration(string server, string ticket, string cube, string cycleUN, string iterationUN)
@Description: ""Clears descriptions, active, and any defined configurations for an iteration."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation iteration configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
{
	LogDebug(""Entering AL_DeleteIterationConfiguration"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_DeleteIterationConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Iteration '"" + iterationUN + ""'"");

	try {
		string languageValueUN = ""[BPDLANGUAGE].[Value].[1]"";
		string parameterActiveUN = ""[BPDPARAMETER].[FEATURE_AL_ACTIVE].[1]"";
		string mainConfigCube = ""ALCCONFIG"";
		string iterationCube = ""ALCCONFIG_ITERATION"";
		string entityAccountCube = ""ALCCONFIG_ENTITY_ACCOUNT"";
		string unassigned = ""N.A."";
		string returnString = """";

		// First clear out the active flags
		string success = AL_EditAllEntityActive(server, ticket, cube, cycleUN, iterationUN, languageValueUN, parameterActiveUN, ""0"");
		if (success != ""TRUE"") {
			returnString = success;
		}

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string cycle = ResolveUniqueName(connection, cycleUN);
		string iteration = ResolveUniqueName(connection, iterationUN);
		OLAPDataArea iterationsData = OLAPCreateDataArea(connection, iterationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 cycle,
		                                                 unassigned,
		                                                 iteration,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells);
		OLAPDeleteDataArea(iterationsData);
		
		// Clear out Entity Account relations
		OLAPDataArea entityAccountData = OLAPCreateDataArea(connection, entityAccountCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                    OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                    cycle,
		                                                    OlapDataAreaBCells,
		                                                    iteration,
		                                                    OlapDataAreaBCells);
		OLAPDeleteDataArea(entityAccountData);

		// Clear out any configuration
		success = AL_ClearConfiguration(server, ticket, mainConfigCube, cycleUN, ""*"", iterationUN, ""*"");
		if (success != ""TRUE"") {
			returnString = returnString + success;
		}

		if (StringLength(returnString) == 0) {
			returnString = ""TRUE"";
		}

		return returnString;

	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeleteIterationConfiguration"");
	return ""FALSE"";
}"	1	CC255042-5E01-47E2-9B30-4B0466C719EB	Clears descriptions, active, and any defined configurations for an iteration.	1	1	1	1512	NULL	0	45708.67501	0	0
02ADB581-2860-4C51-87F4-EC1D3D5E3787	CD491758-D9DF-4002-94C8-8006E1855F86	AL_DeleteManualDriverData	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name containing the driver data"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The pConfiguration set."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The entity"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""accountUN"" parameter-type=""string"" parameter-description=""The driver account"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_DeleteManualDriverData(string server, string ticket, string cube, string cycleUN, string entityUN, string accountUN)
@Description: ""Clears any manually entered data from a driver."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name containing the driver data"";
@Parameter[cycleUN]: ""The pConfiguration set."";
@Parameter[entityUN]: ""The entity"";
@Parameter[accountUN]: ""The driver account"";
{
	LogDebug(""Entering AL_DeleteManualDriverData"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Account: "" + accountUN);

	string functionName = ""AL_DeleteManualDriverData:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Account "" + accountUN + ""'"");

	try {
		string levelElement = ""INPUT_MAIN"";

		// Create the connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = ResolveUniqueName(connection, entityUN);
		string account = ResolveUniqueName(connection, accountUN);

		// Create the data area
		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          OlapDataAreaBCells,
		                                          cycle,
		                                          OlapDataAreaBCells,
		                                          levelElement,
		                                          OlapDataAreaBCells,
		                                          entity,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          account,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells);
		foreach(OLAPCell cell in dataArea)
		{
			double value = cell;
			LogDebug(OLAPCellGetElement(cell, ""BPDTIME"") + "" = "" + value);
		}

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";

	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeleteManualDriverData"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_DeleteManualDriverData(string server, string ticket, string cube, string cycleUN, string entityUN, string accountUN)
@Description: ""Clears any manually entered data from a driver."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name containing the driver data"";
@Parameter[cycleUN]: ""The pConfiguration set."";
@Parameter[entityUN]: ""The entity"";
@Parameter[accountUN]: ""The driver account"";
{
	LogDebug(""Entering AL_DeleteManualDriverData"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Account: "" + accountUN);

	string functionName = ""AL_DeleteManualDriverData:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Account "" + accountUN + ""'"");

	try {
		string levelElement = ""INPUT_MAIN"";

		// Create the connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = ResolveUniqueName(connection, entityUN);
		string account = ResolveUniqueName(connection, accountUN);

		// Create the data area
		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          OlapDataAreaBCells,
		                                          cycle,
		                                          OlapDataAreaBCells,
		                                          levelElement,
		                                          OlapDataAreaBCells,
		                                          entity,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          account,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells,
		                                          OlapDataAreaBCells);
		foreach(OLAPCell cell in dataArea)
		{
			double value = cell;
			LogDebug(OLAPCellGetElement(cell, ""BPDTIME"") + "" = "" + value);
		}

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";

	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeleteManualDriverData"");
	return ""FALSE"";
}"	1	99FF835B-115D-4D95-A28C-E80B458BAF05	Clears any manually entered data from a driver.	1	1	1	1513	NULL	0	45708.67507	0	0
6B278B79-D505-4C2B-8E55-777D68D3EAAA	CD491758-D9DF-4002-94C8-8006E1855F86	AL_DeletetSingleParameterization	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The entity element defining the allocation configuration"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""The iteration element defining the allocation configuration"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""accountUN"" parameter-type=""string"" parameter-description=""The account element defining the allocation configuration or * for all accounts"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""versionUN"" parameter-type=""string"" parameter-description=""The version element defining the allocation configuration or * for all versions"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_DeletetSingleParameterization(string server, string ticket, string cube, string cycleUN, string entityUN, string iterationUN, string accountUN, string versionUN)
@Description: ""This function is used to clear out the configuration for the specified parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[accountUN]: ""The account element defining the allocation configuration or * for all accounts"";
@Parameter[versionUN]: ""The version element defining the allocation configuration or * for all versions"";
{
	LogDebug(""Entering AL_DeletetSingleParameterization"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Account: "" + accountUN);
	LogDebug(""Version: "" + versionUN);

	string functionName = ""AL_DeletetSingleParameterization:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Iteration '"" + iterationUN + ""' accountUN '"" + accountUN + ""'"" + "" versionUN '"" + versionUN + ""'"");

	try {
		// Dimension and element names
		string parameterDimension = ""BPDPARAMETER"";
		string featureParent = ""FEATURE_AL_PARAM"";

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Resolve unique names
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = """";
		if ((StringLength(entityUN) &gt; 0) and (entityUN != ""*""))
		{
			entity = ResolveUniqueName(connection, entityUN);
		}

		string iteration = ResolveUniqueName(connection, iterationUN);
		string account = """";
		if ((StringLength(accountUN) &gt; 0) and (accountUN != ""*""))
		{
			account = ResolveUniqueName(connection, accountUN);
		}
		
		string version = """";
		if ((StringLength(versionUN) &gt; 0) and (versionUN != ""*""))
		{
			version = ResolveUniqueName(connection, versionUN);
		}

		// Get the dimensions to use for creating the data area
		StringListList dimensionsList = CreateStringListList();

		Append(dimensionsList, ConvertToStringList(cycle));
		if (StringLength(entity) &gt; 0)
		{
			Append(dimensionsList, ConvertToStringList(entity));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(iteration));
		if (StringLength(account) &gt; 0)
		{
			Append(dimensionsList, ConvertToStringList(account));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}
		
		if (StringLength(version) &gt; 0)
		{
			StringList versionList = CreateStringList();
			Append(versionList, """");
			Append(versionList, version);
			Append(versionList, ""N.A."");
			Append(dimensionsList, versionList);
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}
		
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // ALDDIMENSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDNO
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDPARAMETER

		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          dimensionsList);

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeletetSingleParameterization"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_DeletetSingleParameterization(string server, string ticket, string cube, string cycleUN, string entityUN, string iterationUN, string accountUN, string versionUN)
@Description: ""This function is used to clear out the configuration for the specified parameters."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[accountUN]: ""The account element defining the allocation configuration or * for all accounts"";
@Parameter[versionUN]: ""The version element defining the allocation configuration or * for all versions"";
{
	LogDebug(""Entering AL_DeletetSingleParameterization"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Account: "" + accountUN);
	LogDebug(""Version: "" + versionUN);

	string functionName = ""AL_DeletetSingleParameterization:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Iteration '"" + iterationUN + ""' accountUN '"" + accountUN + ""'"" + "" versionUN '"" + versionUN + ""'"");

	try {
		// Dimension and element names
		string parameterDimension = ""BPDPARAMETER"";
		string featureParent = ""FEATURE_AL_PARAM"";

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Resolve unique names
		string cycle = ResolveUniqueName(connection, cycleUN);
		string entity = """";
		if ((StringLength(entityUN) > 0) and (entityUN != ""*""))
		{
			entity = ResolveUniqueName(connection, entityUN);
		}

		string iteration = ResolveUniqueName(connection, iterationUN);
		string account = """";
		if ((StringLength(accountUN) > 0) and (accountUN != ""*""))
		{
			account = ResolveUniqueName(connection, accountUN);
		}
		
		string version = """";
		if ((StringLength(versionUN) > 0) and (versionUN != ""*""))
		{
			version = ResolveUniqueName(connection, versionUN);
		}

		// Get the dimensions to use for creating the data area
		StringListList dimensionsList = CreateStringListList();

		Append(dimensionsList, ConvertToStringList(cycle));
		if (StringLength(entity) > 0)
		{
			Append(dimensionsList, ConvertToStringList(entity));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}

		Append(dimensionsList, ConvertToStringList(iteration));
		if (StringLength(account) > 0)
		{
			Append(dimensionsList, ConvertToStringList(account));
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}
		
		if (StringLength(version) > 0)
		{
			StringList versionList = CreateStringList();
			Append(versionList, """");
			Append(versionList, version);
			Append(versionList, ""N.A."");
			Append(dimensionsList, versionList);
		}
		else
		{
			Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells));
		}
		
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // ALDDIMENSION
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDNO
		Append(dimensionsList, ConvertToStringList(OlapDataAreaBCells)); // BPDPARAMETER

		OLAPDataArea dataArea= OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                          OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                          dimensionsList);

		OLAPDeleteDataArea(dataArea); // Clear destination

		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_DeletetSingleParameterization"");
	return ""FALSE"";
}"	1	8CC26E7A-3750-498C-B7FC-F96B27CF10A2	This function is used to clear out the configuration for the specified parameters.	1	1	1	1514	NULL	0	45708.67501	0	0
72500066-E725-4FD5-B221-4FC2D29A95E1	CD491758-D9DF-4002-94C8-8006E1855F86	AL_DimensionBaseElements	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""A string split up by commas of all base elements in the dimension under the parent element."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimensionName"" parameter-type=""string"" parameter-description=""The name of the dimension to get the base elements from."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""topElementName"" parameter-type=""string"" parameter-description=""The name of the parent element to get base elemements from."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_DimensionBaseElements(
	OLAPConnection connection,
	string dimensionName,
	string topElementName)
@Description: ""Copies allocation parameters."";
@Category: ""Allocation Functions"";
@Parameter[connection]: ""Connection to the OLAP database."";
@Parameter[dimensionName]: ""The name of the dimension to get the base elements from."";
@Parameter[topElementName]: ""The name of the parent element to get base elemements from."";
@Returns: ""A string split up by commas of all base elements in the dimension under the parent element."";
{
	LogDebug(""Entering AL_DimensionBaseElements"");
	LogDebug(""Dimension: "" + dimensionName);
	LogDebug(""Top Element: "" + topElementName);

	OLAPElementList baseElements = CreateOLAPElementList();
	OLAPElement parentElement = OLAPGetDimensionElement(connection, dimensionName, topElementName);
	if (OLAPIsBaseElement(connection, parentElement))
	{
		OLAPElementListAddElement(baseElements, parentElement);
	}
	else
	{
		baseElements = OLAPGetChildElementList(connection, dimensionName, topElementName, true);
	}
	
	StringArray returnedList = CreateStringArray();
	
	foreach(OLAPElement baseElement in baseElements)
	{
		Append(returnedList,ToString(baseElement));
	}
	
	LogDebug(""Leaving AL_DimensionBaseElements"");
	return returnedList;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_DimensionBaseElements(
	OLAPConnection connection,
	string dimensionName,
	string topElementName)
@Description: ""Copies allocation parameters."";
@Category: ""Allocation Functions"";
@Parameter[connection]: ""Connection to the OLAP database."";
@Parameter[dimensionName]: ""The name of the dimension to get the base elements from."";
@Parameter[topElementName]: ""The name of the parent element to get base elemements from."";
@Returns: ""A string split up by commas of all base elements in the dimension under the parent element."";
{
	LogDebug(""Entering AL_DimensionBaseElements"");
	LogDebug(""Dimension: "" + dimensionName);
	LogDebug(""Top Element: "" + topElementName);

	OLAPElementList baseElements = CreateOLAPElementList();
	OLAPElement parentElement = OLAPGetDimensionElement(connection, dimensionName, topElementName);
	if (OLAPIsBaseElement(connection, parentElement))
	{
		OLAPElementListAddElement(baseElements, parentElement);
	}
	else
	{
		baseElements = OLAPGetChildElementList(connection, dimensionName, topElementName, true);
	}
	
	StringArray returnedList = CreateStringArray();
	
	foreach(OLAPElement baseElement in baseElements)
	{
		Append(returnedList,ToString(baseElement));
	}
	
	LogDebug(""Leaving AL_DimensionBaseElements"");
	return returnedList;
}"	1	653B6276-46B8-4FF9-A8A0-54907D890940	Copies allocation parameters.	1	1	1	1515	NULL	0	45708.67503	0	0
F1CA0779-40D4-489E-9705-5DBA12A559FC	CD491758-D9DF-4002-94C8-8006E1855F86	AL_EditAllEntityActive	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The cycle element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""The iteration element defining the allocation configuration"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""languageValueUN"" parameter-type=""string"" parameter-description=""The language element to write the active flag back to"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""parameterActiveUN"" parameter-type=""string"" parameter-description=""The BPDPARAMETER active element to use for writeback"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""active"" parameter-type=""string"" parameter-description=""1 if setting to active, 0 if setting to not active"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_EditAllEntityActive(string server, string ticket, string cube, string cycleUN, string iterationUN, string languageValueUN, string parameterActiveUN, string active)
@Description: ""This function is used to either set all entities in ALCCONFIG_ITERATION to active, or set all to inactive for an iteration"";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The cycle element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[languageValueUN]: ""The language element to write the active flag back to"";
@Parameter[parameterActiveUN]: ""The BPDPARAMETER active element to use for writeback"";
@Parameter[active]: ""1 if setting to active, 0 if setting to not active"";
{
	LogDebug(""Entering AL_EditAllEntityActive"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Language Value: "" + languageValueUN);
	LogDebug(""Active Parameter: "" + parameterActiveUN);
	LogDebug(""Active: "" + active);

	/*
	cube = ""ALCCONFIG_ITERATION"";
	cycleUN = ""[BPDCYCLE].[Cycle 1].[1]"";
	iterationUN = ""[ALDITERATION].[Iteration_0002].[1]"";
	active = ""1"";
	string OlapDatabase = ""usalvwpsrep/Public Sector Prototype"";
	OLAPConnection connection = OLAPCreateConnection(OlapDatabase, ""Admin"", ""Infor2014"");
	 */
	

	string functionName = ""AL_EditAllEntityActive"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Server = '"" + server + ""' Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Iteration '"" + iterationUN + ""'Activate '"" + active);

	try {
		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		LogDebug(""Resolving unique names"");
		string cycle = ResolveUniqueName(connection, cycleUN);
		string iteration = ResolveUniqueName(connection, iterationUN);
		string languageValue = ResolveUniqueName(connection, languageValueUN);
		string parameterActive = ResolveUniqueName(connection, parameterActiveUN);
		string entityDimension = ""BPDENTITY"";
		
		// OLAPGetElementList(OlapConnection connection, string dimension, bool onlyBaseElements)
		OLAPElementList entityList = OLAPGetElementList(connection, entityDimension, true);

		LogDebug(""Editing entities:"");
		foreach(OLAPElement entity in entityList)
		{
			LogDebug(""Processing entity "" + entity + "", value "" + ToDouble(active));

			OLAPCellWriteNumber(connection, cube,
			                    ToDouble(active),
			                    cycle,
			                    ToString(entity),
			                    iteration,
			                    languageValue,
			                    parameterActive);
		}

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR"";
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_EditAllEntityActive"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_EditAllEntityActive(string server, string ticket, string cube, string cycleUN, string iterationUN, string languageValueUN, string parameterActiveUN, string active)
@Description: ""This function is used to either set all entities in ALCCONFIG_ITERATION to active, or set all to inactive for an iteration"";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The cycle element defining the allocation configuration"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[languageValueUN]: ""The language element to write the active flag back to"";
@Parameter[parameterActiveUN]: ""The BPDPARAMETER active element to use for writeback"";
@Parameter[active]: ""1 if setting to active, 0 if setting to not active"";
{
	LogDebug(""Entering AL_EditAllEntityActive"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Iteration: "" + iterationUN);
	LogDebug(""Language Value: "" + languageValueUN);
	LogDebug(""Active Parameter: "" + parameterActiveUN);
	LogDebug(""Active: "" + active);

	/*
	cube = ""ALCCONFIG_ITERATION"";
	cycleUN = ""[BPDCYCLE].[Cycle 1].[1]"";
	iterationUN = ""[ALDITERATION].[Iteration_0002].[1]"";
	active = ""1"";
	string OlapDatabase = ""usalvwpsrep/Public Sector Prototype"";
	OLAPConnection connection = OLAPCreateConnection(OlapDatabase, ""Admin"", ""Infor2014"");
	 */
	

	string functionName = ""AL_EditAllEntityActive"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Server = '"" + server + ""' Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Iteration '"" + iterationUN + ""'Activate '"" + active);

	try {
		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		LogDebug(""Resolving unique names"");
		string cycle = ResolveUniqueName(connection, cycleUN);
		string iteration = ResolveUniqueName(connection, iterationUN);
		string languageValue = ResolveUniqueName(connection, languageValueUN);
		string parameterActive = ResolveUniqueName(connection, parameterActiveUN);
		string entityDimension = ""BPDENTITY"";
		
		// OLAPGetElementList(OlapConnection connection, string dimension, bool onlyBaseElements)
		OLAPElementList entityList = OLAPGetElementList(connection, entityDimension, true);

		LogDebug(""Editing entities:"");
		foreach(OLAPElement entity in entityList)
		{
			LogDebug(""Processing entity "" + entity + "", value "" + ToDouble(active));

			OLAPCellWriteNumber(connection, cube,
			                    ToDouble(active),
			                    cycle,
			                    ToString(entity),
			                    iteration,
			                    languageValue,
			                    parameterActive);
		}

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR"";
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_EditAllEntityActive"");
	return ""FALSE"";
}"	1	8F6D44B3-DDF3-46B1-91EF-9EE60BD87BA1	This function is used to either set all entities in ALCCONFIG_ITERATION to active, or set all to inactive for an iteration	1	1	1	1516	NULL	0	45708.67504	0	0
E4ED58E8-8E29-438D-80A4-F73DCD16FABE	CD491758-D9DF-4002-94C8-8006E1855F86	AL_ElementStringSplit	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""A StringArray containing the elements found in the provided stringList"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""connection to be used"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""stringList"" parameter-type=""string"" parameter-description=""A comma-separated list of dimension elements"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_ElementStringSplit(OLAPConnection connection, string stringList)
@Description: ""This function is used to split a list of comma separated dimension elements and create strings from UNs."";
@Category: ""Allocation Functions"";
@Returns: ""A StringArray containing the elements found in the provided stringList"";
@Parameter[connection]: ""connection to be used"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringArray elementArray = CreateStringArray();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos &lt; 0) {

			stringList = ResolveUniqueName(connection, stringList);
			Append(elementArray, stringList);
		} else {

			while (pos &gt;= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				element = ResolveUniqueName(connection, element);

				Append(elementArray, element);
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			stringList = ResolveUniqueName(connection, stringList);
			Append(elementArray, stringList);
		}
	}

	return elementArray;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_ElementStringSplit(OLAPConnection connection, string stringList)
@Description: ""This function is used to split a list of comma separated dimension elements and create strings from UNs."";
@Category: ""Allocation Functions"";
@Returns: ""A StringArray containing the elements found in the provided stringList"";
@Parameter[connection]: ""connection to be used"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringArray elementArray = CreateStringArray();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos < 0) {

			stringList = ResolveUniqueName(connection, stringList);
			Append(elementArray, stringList);
		} else {

			while (pos >= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				element = ResolveUniqueName(connection, element);

				Append(elementArray, element);
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			stringList = ResolveUniqueName(connection, stringList);
			Append(elementArray, stringList);
		}
	}

	return elementArray;
}"	1	51F58720-5CE7-4F63-B21C-66FBB41ECC1C	This function is used to split a list of comma separated dimension elements and create strings from UNs.	1	1	1	1517	NULL	0	45708.67501	0	0
B8C06968-D7D3-4F77-BA7B-2E31107C2E6F	CD491758-D9DF-4002-94C8-8006E1855F86	AL_GetCubeDimensions	Internal Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""An array of the dimensions, in order"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The open Olap connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name whose dimensions are to be returned"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_GetCubeDimensions(OLAPConnection connection, string cube)
@Description: ""Gets a list of dimensions, in order, in the cube"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An array of the dimensions, in order"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[cube]: ""The cube name whose dimensions are to be returned"";
{
	LogDebug(""Entering AL_GetCubeDimensions"");
	LogDebug(""Cube: "" + cube);

	StringArray dimensions = CreateStringArray();

	foreach (OLAPCube olapCube in OLAPGetCubeList(connection))
	{
		string name = OLAPGetCubeName(olapCube);
		if(name == cube)
		{
			OLAPDimensionList cubeDimensions = OLAPGetDimensionList(olapCube);
			foreach (OLAPDimension dimension in cubeDimensions)
			{
				Append(dimensions, dimension);
			}

			return dimensions;
		}
	}

	LogDebug(""Leaving AL_GetCubeDimensions"");
	return dimensions;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_GetCubeDimensions(OLAPConnection connection, string cube)
@Description: ""Gets a list of dimensions, in order, in the cube"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An array of the dimensions, in order"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[cube]: ""The cube name whose dimensions are to be returned"";
{
	LogDebug(""Entering AL_GetCubeDimensions"");
	LogDebug(""Cube: "" + cube);

	StringArray dimensions = CreateStringArray();

	foreach (OLAPCube olapCube in OLAPGetCubeList(connection))
	{
		string name = OLAPGetCubeName(olapCube);
		if(name == cube)
		{
			OLAPDimensionList cubeDimensions = OLAPGetDimensionList(olapCube);
			foreach (OLAPDimension dimension in cubeDimensions)
			{
				Append(dimensions, dimension);
			}

			return dimensions;
		}
	}

	LogDebug(""Leaving AL_GetCubeDimensions"");
	return dimensions;
}"	1	FEA4C5F7-7C18-48B5-8EF8-FAD9A6870BF9	Gets a list of dimensions, in order, in the cube	1	1	1	1518	NULL	0	45708.67508	0	0
398603A3-5A75-4DD7-BECB-33CF8D37C450	CD491758-D9DF-4002-94C8-8006E1855F86	AL_GetDimensionElementList	Internal Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""An OLAPElementList containing the elements"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The open Olap connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""baseOnly"" parameter-type=""bool"" parameter-description=""Indicates whether consolidated or base elements can be included in the list"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimensionName"" parameter-type=""string"" parameter-description=""The name of the dimension we are retrieving main cube elements for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""element"" parameter-type=""string"" parameter-description=""The element to get into the list"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList AL_GetDimensionElementList(OLAPConnection connection, bool baseOnly, string dimensionName, string element)
@Description: ""Obtains an OLAPElementList for the specified allocation configuration"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An OLAPElementList containing the elements"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[baseOnly]: ""Indicates whether consolidated or base elements can be included in the list"";
@Parameter[dimensionName]: ""The name of the dimension we are retrieving main cube elements for"";
@Parameter[element]: ""The element to get into the list"";
{
	LogDebug(""Entering AL_GetDimensionElementList"");
	LogDebug(""Dimension: "" + dimensionName);
	LogDebug(""Element: "" + element);

	string functionName = ""AL_GetDimensionElementList:"";
	string errorMessage = """";
	int errorCode = 0;
	OLAPElementList elementList = CreateOLAPElementList();

	//LogDebug(functionName + ""baseOnly = "" + baseOnly + "", "" + dimensionName + "", "" + element);
	try
	{
		if (baseOnly)
		{
			OLAPElementList dimensionElements = OLAPGetChildElementList(connection, dimensionName, element, true);
			if (Count(dimensionElements) == 0) {
				OLAPElement dimensionElement = OLAPGetDimensionElement(connection, dimensionName, element);
				OLAPElementListAddElement(elementList, dimensionElement);
			}
			else
			{
				foreach(OLAPElement dimensionElement in dimensionElements) {
					OLAPElementListAddElement(elementList, dimensionElement);
				}
			}
		} else {
			OLAPElement dimensionElement = OLAPGetDimensionElement(connection, dimensionName, element);
			OLAPElementListAddElement(elementList, dimensionElement);
		}

		return elementList;

	} catch(errorMessage, errorCode) {
		if(errorCode &lt; 0) {
			errorCode = 0;
		}

		string raiseMessage = functionName + ""dimension/element = '"" + dimensionName + ""'/'"" + element + ""'. "" + errorMessage ;
		RaiseError(functionName + raiseMessage, errorCode);
	}

	LogDebug(""Leaving AL_GetDimensionElementList"");
	// This is only here because AppEngine won't compile unless it is.
	return elementList;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList AL_GetDimensionElementList(OLAPConnection connection, bool baseOnly, string dimensionName, string element)
@Description: ""Obtains an OLAPElementList for the specified allocation configuration"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An OLAPElementList containing the elements"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[baseOnly]: ""Indicates whether consolidated or base elements can be included in the list"";
@Parameter[dimensionName]: ""The name of the dimension we are retrieving main cube elements for"";
@Parameter[element]: ""The element to get into the list"";
{
	LogDebug(""Entering AL_GetDimensionElementList"");
	LogDebug(""Dimension: "" + dimensionName);
	LogDebug(""Element: "" + element);

	string functionName = ""AL_GetDimensionElementList:"";
	string errorMessage = """";
	int errorCode = 0;
	OLAPElementList elementList = CreateOLAPElementList();

	//LogDebug(functionName + ""baseOnly = "" + baseOnly + "", "" + dimensionName + "", "" + element);
	try
	{
		if (baseOnly)
		{
			OLAPElementList dimensionElements = OLAPGetChildElementList(connection, dimensionName, element, true);
			if (Count(dimensionElements) == 0) {
				OLAPElement dimensionElement = OLAPGetDimensionElement(connection, dimensionName, element);
				OLAPElementListAddElement(elementList, dimensionElement);
			}
			else
			{
				foreach(OLAPElement dimensionElement in dimensionElements) {
					OLAPElementListAddElement(elementList, dimensionElement);
				}
			}
		} else {
			OLAPElement dimensionElement = OLAPGetDimensionElement(connection, dimensionName, element);
			OLAPElementListAddElement(elementList, dimensionElement);
		}

		return elementList;

	} catch(errorMessage, errorCode) {
		if(errorCode < 0) {
			errorCode = 0;
		}

		string raiseMessage = functionName + ""dimension/element = '"" + dimensionName + ""'/'"" + element + ""'. "" + errorMessage ;
		RaiseError(functionName + raiseMessage, errorCode);
	}

	LogDebug(""Leaving AL_GetDimensionElementList"");
	// This is only here because AppEngine won't compile unless it is.
	return elementList;
}"	1	1A0A5A82-6D5B-4280-8D55-651B1937588C	Obtains an OLAPElementList for the specified allocation configuration	1	1	1	1519	NULL	0	45708.67504	0	0
81531D61-6D3D-44F2-A8E9-935BA48531B1	CD491758-D9DF-4002-94C8-8006E1855F86	AL_GetIterationsInOrder	Internal Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""An array of iteration element names in process order"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""An open OLAP connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_GetIterationsInOrder(OLAPConnection connection, string cycle)
@Description: ""This function reads the iterations and orders from the iteration configuration cube and returns the iteration elements in process order"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An array of iteration element names in process order"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[cycle]: ""The Configuration set element defining the allocation configuration"";
{
	LogDebug(""Entering AL_GetIterationsInOrder"");
	LogDebug(""Configuration set: "" + cycle);

	string functionName = ""AL_GetIterationsInOrder:"";
	string errorMessage = """";
	int errorCode = 0;
	StringArray iterationsInOrder = CreateStringArray();

	LogInformation(functionName + "" cycle '"" + cycle + ""'"");

	try {
		// Cube names
		string iterationConfigCube = ""ALCCONFIG_ITERATION"";
		
		// Element names
		string entityNAElement = ""N.A."";
		string orderParameter = ""FEATURE_AL_ORDER"";
		string languageValue = ""Value"";

		// Dimensions names
		string iterationDimension = ""ALDITERATION"";
		
		LogDebug(""Reading iteration orders for cycle '"" + cycle + ""', entity '"" + entityNAElement + ""', language '"" + languageValue + ""', parameter '"" + orderParameter + ""'"");
		OLAPDataArea iterationOrders = OLAPCreateDataArea(connection, iterationConfigCube,
		                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone,
		                                                  0.0, OlapDataAreaOperatorNone, 0, cycle, entityNAElement, OlapDataAreaBCells, languageValue, orderParameter);

		
		DoubleArray ordersInOrder = CreateDoubleArray();

		bool done = false;
		double lastOrder = -999999.0;
		int count = 0;
		while (!done)
		{
			double lowestOrder = 999999.0;
			string lowestIteration = """";
			foreach (OLAPCell cell in iterationOrders) {
				string iteration =  OLAPCellGetElement(cell, iterationDimension);
				double cellOrder = cell;

				if ((cellOrder &lt; lowestOrder) and (cellOrder &gt; lastOrder))
				{
					lowestOrder = cellOrder;
					lowestIteration = iteration;
				}
			}

			if (lastOrder != lowestOrder)
			{
				if (StringLength(lowestIteration) &gt; 0)
				{
					LogDebug(""Appending iteration "" + lowestIteration + "" with order "" + lowestOrder);

					Append(iterationsInOrder, lowestIteration);
					Append(ordersInOrder, lowestOrder);
					count = count + 1;
				}

				lastOrder = lowestOrder;
			}
			else
			{
				done = true;
			}
		}

		return iterationsInOrder;
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
	}

	LogDebug(""Leaving AL_GetIterationsInOrder"");
	// This is only here because AppEngine won't compile unless it is.
	return iterationsInOrder;

}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray AL_GetIterationsInOrder(OLAPConnection connection, string cycle)
@Description: ""This function reads the iterations and orders from the iteration configuration cube and returns the iteration elements in process order"";
@Category: ""Internal Allocation Functions"";
@Returns: ""An array of iteration element names in process order"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[cycle]: ""The Configuration set element defining the allocation configuration"";
{
	LogDebug(""Entering AL_GetIterationsInOrder"");
	LogDebug(""Configuration set: "" + cycle);

	string functionName = ""AL_GetIterationsInOrder:"";
	string errorMessage = """";
	int errorCode = 0;
	StringArray iterationsInOrder = CreateStringArray();

	LogInformation(functionName + "" cycle '"" + cycle + ""'"");

	try {
		// Cube names
		string iterationConfigCube = ""ALCCONFIG_ITERATION"";
		
		// Element names
		string entityNAElement = ""N.A."";
		string orderParameter = ""FEATURE_AL_ORDER"";
		string languageValue = ""Value"";

		// Dimensions names
		string iterationDimension = ""ALDITERATION"";
		
		LogDebug(""Reading iteration orders for cycle '"" + cycle + ""', entity '"" + entityNAElement + ""', language '"" + languageValue + ""', parameter '"" + orderParameter + ""'"");
		OLAPDataArea iterationOrders = OLAPCreateDataArea(connection, iterationConfigCube,
		                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone,
		                                                  0.0, OlapDataAreaOperatorNone, 0, cycle, entityNAElement, OlapDataAreaBCells, languageValue, orderParameter);

		
		DoubleArray ordersInOrder = CreateDoubleArray();

		bool done = false;
		double lastOrder = -999999.0;
		int count = 0;
		while (!done)
		{
			double lowestOrder = 999999.0;
			string lowestIteration = """";
			foreach (OLAPCell cell in iterationOrders) {
				string iteration =  OLAPCellGetElement(cell, iterationDimension);
				double cellOrder = cell;

				if ((cellOrder < lowestOrder) and (cellOrder > lastOrder))
				{
					lowestOrder = cellOrder;
					lowestIteration = iteration;
				}
			}

			if (lastOrder != lowestOrder)
			{
				if (StringLength(lowestIteration) > 0)
				{
					LogDebug(""Appending iteration "" + lowestIteration + "" with order "" + lowestOrder);

					Append(iterationsInOrder, lowestIteration);
					Append(ordersInOrder, lowestOrder);
					count = count + 1;
				}

				lastOrder = lowestOrder;
			}
			else
			{
				done = true;
			}
		}

		return iterationsInOrder;
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
	}

	LogDebug(""Leaving AL_GetIterationsInOrder"");
	// This is only here because AppEngine won't compile unless it is.
	return iterationsInOrder;

}"	1	200CDD0C-2F60-4434-8F7B-3D0537729F0F	This function reads the iterations and orders from the iteration configuration cube and returns the iteration elements in process order	1	1	1	1520	NULL	0	45708.67502	0	0
FA30BF33-0DD5-4783-9407-22F3604499E8	CD491758-D9DF-4002-94C8-8006E1855F86	AL_MultipleTargetAllocation	DEPM Generic Allocation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE on success"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceXML"" parameter-type=""string"" parameter-description=""XML containing source elements for allocation."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""targetXML"" parameter-type=""string"" parameter-description=""XML containing multiple sets of target elements for allocation."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""dischargeSource"" parameter-type=""string"" parameter-description=""TRUE to discharge source"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_MultipleTargetAllocation(string server, string ticket, string sourceXML, string targetXML, string dischargeSource)
@Description: ""Runs a multiple target generic allocation from xml configuration"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[sourceXML]: ""XML containing source elements for allocation."";
@Parameter[targetXML]: ""XML containing multiple sets of target elements for allocation."";
@Parameter[dischargeSource]: ""TRUE to discharge source"";
@Returns: ""TRUE on success"";
{
	string functionName = ""AL_MultipleTargetAllocation:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_MultipleTargetAllocation_Internal(connection, sourceXML, targetXML, dischargeSource);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_MultipleTargetAllocation(string server, string ticket, string sourceXML, string targetXML, string dischargeSource)
@Description: ""Runs a multiple target generic allocation from xml configuration"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[sourceXML]: ""XML containing source elements for allocation."";
@Parameter[targetXML]: ""XML containing multiple sets of target elements for allocation."";
@Parameter[dischargeSource]: ""TRUE to discharge source"";
@Returns: ""TRUE on success"";
{
	string functionName = ""AL_MultipleTargetAllocation:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_MultipleTargetAllocation_Internal(connection, sourceXML, targetXML, dischargeSource);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}"	1	E76AC137-A30D-44C6-8595-6FE8EBCCDFDB	Runs a multiple target generic allocation from xml configuration	1	1	1	1521	NULL	0	45708.67504	0	0
E91D9691-92CC-467B-B9E2-3CDD4A419846	CD491758-D9DF-4002-94C8-8006E1855F86	AL_PerformAllocation	Internal Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""An open OLAP connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The entity element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""versionUN"" parameter-type=""string"" parameter-description=""The version for the source data area - also used in the config cube to read the driver/target versions."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""timeUN"" parameter-type=""string"" parameter-description=""The time element being processed"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""The iteration element defining the allocation configuration"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stopOnError"" parameter-type=""bool"" parameter-description=""If true, the allocation of accounts will stop."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_PerformAllocation(OLAPConnection connection, string cube, string cycleUN, string entityUN, string versionUN, string timeUN, string iterationUN, bool stopOnError)
@Description: ""This function is used to perform the allocation specified by the arguments."";
@Category: ""Internal Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[versionUN]: ""The version for the source data area - also used in the config cube to read the driver/target versions."";
@Parameter[timeUN]: ""The time element being processed"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[stopOnError]: ""If true, the allocation of accounts will stop."";
{
	LogDebug(""Entering AL_PerformAllocation"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Version: "" + versionUN);
	LogDebug(""Time: "" + timeUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_PerformAllocation:"";
	string errorMessage = """";
	int errorCode = 0;
	string success = """";

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Version '"" + versionUN + ""' Time '"" + timeUN + ""' Iteration '"" + iterationUN + ""' stopOnError + '"" + stopOnError + ""'"");

	try {
		int returnCode = PerformAllocation(connection, cube, cycleUN, entityUN, versionUN, timeUN, iterationUN, stopOnError);
		return ToString(returnCode);
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_PerformAllocation"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_PerformAllocation(OLAPConnection connection, string cube, string cycleUN, string entityUN, string versionUN, string timeUN, string iterationUN, bool stopOnError)
@Description: ""This function is used to perform the allocation specified by the arguments."";
@Category: ""Internal Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[versionUN]: ""The version for the source data area - also used in the config cube to read the driver/target versions."";
@Parameter[timeUN]: ""The time element being processed"";
@Parameter[iterationUN]: ""The iteration element defining the allocation configuration"";
@Parameter[stopOnError]: ""If true, the allocation of accounts will stop."";
{
	LogDebug(""Entering AL_PerformAllocation"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Version: "" + versionUN);
	LogDebug(""Time: "" + timeUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_PerformAllocation:"";
	string errorMessage = """";
	int errorCode = 0;
	string success = """";

	LogInformation(functionName + "" Cube '"" + cube  + ""' Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Version '"" + versionUN + ""' Time '"" + timeUN + ""' Iteration '"" + iterationUN + ""' stopOnError + '"" + stopOnError + ""'"");

	try {
		int returnCode = PerformAllocation(connection, cube, cycleUN, entityUN, versionUN, timeUN, iterationUN, stopOnError);
		return ToString(returnCode);
	}
	catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_PerformAllocation"");
	return ""FALSE"";
}"	1	8AB6A520-737A-42C1-960B-DD7BD560B7EE	This function is used to perform the allocation specified by the arguments.	1	1	1	1522	NULL	0	45708.67504	0	0
5EB3429A-C9E7-43EC-AF2D-23D02596D1DE	CD491758-D9DF-4002-94C8-8006E1855F86	AL_PerformAllocationTicket	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The entity element defining the allocation configuration"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""versionUN"" parameter-type=""string"" parameter-description=""The version for the source data area - also used in the config cube to read the driver/target versions."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""timeUN"" parameter-type=""string"" parameter-description=""The time element being processed"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""iterationUN"" parameter-type=""string"" parameter-description=""A comma separated list of the iteration elements to perform. '*' for all iterations"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""stopOnError"" parameter-type=""bool"" parameter-description=""If true, the allocation of accounts will stop."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""AL_PerformAllocation"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_PerformAllocation"", ""*""

string AL_PerformAllocationTicket(string server, string ticket, string cube, string cycleUN, string entityUN, string versionUN, string timeUN, string iterationUN, bool stopOnError)
@Description: ""This function is used to perform the allocation specified by the arguments."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[versionUN]: ""The version for the source data area - also used in the config cube to read the driver/target versions."";
@Parameter[timeUN]: ""The time element being processed"";
@Parameter[iterationUN]: ""A comma separated list of the iteration elements to perform. '*' for all iterations"";
@Parameter[stopOnError]: ""If true, the allocation of accounts will stop."";
{
	LogDebug(""Entering AL_PerformAllocationTicket"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Version: "" + versionUN);
	LogDebug(""Time: "" + timeUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_PerformAllocationUser:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" server '"" + server + "" Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Time '"" + timeUN + ""' iterationUN '"" + iterationUN + ""' stopOnError '"" + stopOnError + ""'"");

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformAllocation(connection, cube, cycleUN, entityUN, versionUN, timeUN, iterationUN, stopOnError);
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR - "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_PerformAllocationTicket"");
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_PerformAllocation"", ""*""

string AL_PerformAllocationTicket(string server, string ticket, string cube, string cycleUN, string entityUN, string versionUN, string timeUN, string iterationUN, bool stopOnError)
@Description: ""This function is used to perform the allocation specified by the arguments."";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[entityUN]: ""The entity element defining the allocation configuration"";
@Parameter[versionUN]: ""The version for the source data area - also used in the config cube to read the driver/target versions."";
@Parameter[timeUN]: ""The time element being processed"";
@Parameter[iterationUN]: ""A comma separated list of the iteration elements to perform. '*' for all iterations"";
@Parameter[stopOnError]: ""If true, the allocation of accounts will stop."";
{
	LogDebug(""Entering AL_PerformAllocationTicket"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUN);
	LogDebug(""Entity: "" + entityUN);
	LogDebug(""Version: "" + versionUN);
	LogDebug(""Time: "" + timeUN);
	LogDebug(""Iteration: "" + iterationUN);

	string functionName = ""AL_PerformAllocationUser:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" server '"" + server + "" Configuration set '"" + cycleUN + ""' Entity '"" + entityUN + ""' Time '"" + timeUN + ""' iterationUN '"" + iterationUN + ""' stopOnError '"" + stopOnError + ""'"");

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformAllocation(connection, cube, cycleUN, entityUN, versionUN, timeUN, iterationUN, stopOnError);
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR - "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	LogDebug(""Returning FALSE from "" + functionName + errorMessage);
	LogDebug(""Leaving AL_PerformAllocationTicket"");
	return ""FALSE"";
}"	1	6AC1A422-365F-4037-83BB-C414DFBB7FC0	This function is used to perform the allocation specified by the arguments.	1	1	1	1523	NULL	0	45708.67507	0	0
47448459-191F-4E7A-A2C2-63EFF5944E68	CD491758-D9DF-4002-94C8-8006E1855F86	AL_RunGenericAllocationFromXml	DEPM Generic Allocation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE on success"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The unique cycle element."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""allocationType"" parameter-type=""string"" parameter-description=""The unique version element."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""allocationAmount"" parameter-type=""string"" parameter-description=""The unique entity element."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""elementsXML"" parameter-type=""string"" parameter-description=""The unique organization element."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_RunGenericAllocationFromXml(string server, string ticket, string cube, string allocationType, string allocationAmount, string elementsXML)
@Description: ""Runs a generic allocation from xml configuration"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""The unique cycle element."";
@Parameter[allocationType]: ""The unique version element."";
@Parameter[allocationAmount]: ""The unique entity element."";
@Parameter[elementsXML]: ""The unique organization element."";
@Returns: ""TRUE on success"";
{
	string functionName = ""AL_RunGenericAllocationFromXml:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformOneTimeAllocation_Internal(connection, cube, allocationType, allocationAmount, elementsXML);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_RunGenericAllocationFromXml(string server, string ticket, string cube, string allocationType, string allocationAmount, string elementsXML)
@Description: ""Runs a generic allocation from xml configuration"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""The unique cycle element."";
@Parameter[allocationType]: ""The unique version element."";
@Parameter[allocationAmount]: ""The unique entity element."";
@Parameter[elementsXML]: ""The unique organization element."";
@Returns: ""TRUE on success"";
{
	string functionName = ""AL_RunGenericAllocationFromXml:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformOneTimeAllocation_Internal(connection, cube, allocationType, allocationAmount, elementsXML);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}"	1	73CC64FA-EC5E-4880-A83D-138518D83865	Runs a generic allocation from xml configuration	1	1	1	1524	NULL	0	45708.67505	0	0
BC83487C-AEE6-4356-A280-EDCBCC4F43FC	CD491758-D9DF-4002-94C8-8006E1855F86	AL_RunGenericAllocationStep	DEPM Generic Allocation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE if successful"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The unique cycle element."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""versionUN"" parameter-type=""string"" parameter-description=""The unique version element."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUN"" parameter-type=""string"" parameter-description=""The unique entity element."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""organizationUN"" parameter-type=""string"" parameter-description=""The unique organization element."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""placeholderDimension"" parameter-type=""string"" parameter-description=""The placeholder dimension"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""placeholderHierarchy"" parameter-type=""string"" parameter-description=""The placeholder hierarchy"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""placeholderElement"" parameter-type=""string"" parameter-description=""The placeholder element to use"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""iteration"" parameter-type=""string"" parameter-description=""The allocation iteration / level"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""step"" parameter-type=""string"" parameter-description=""The allocation step"" parameter-order=""10"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_RunGenericAllocationStep(string server, string ticket, string cycleUN, string versionUN, string entityUN, string organizationUN, string placeholderDimension, string placeholderHierarchy, string placeholderElement, string iteration, string step)
@Description: ""Runs a generic allocation step"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cycleUN]: ""The unique cycle element."";
@Parameter[versionUN]: ""The unique version element."";
@Parameter[entityUN]: ""The unique entity element."";
@Parameter[organizationUN]: ""The unique organization element."";
@Parameter[placeholderDimension]: ""The placeholder dimension"";
@Parameter[placeholderHierarchy]: ""The placeholder hierarchy"";
@Parameter[placeholderElement]: ""The placeholder element to use"";
@Parameter[iteration]: ""The allocation iteration / level"";
@Parameter[step]: ""The allocation step"";
@Returns: ""TRUE if successful"";
{
	string functionName = ""AL_RunGenericAllocationStep:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformGenericAllocation_Internal(connection, cycleUN, versionUN, entityUN, organizationUN, placeholderDimension, placeholderHierarchy, placeholderElement, iteration, step);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_RunGenericAllocationStep(string server, string ticket, string cycleUN, string versionUN, string entityUN, string organizationUN, string placeholderDimension, string placeholderHierarchy, string placeholderElement, string iteration, string step)
@Description: ""Runs a generic allocation step"";
@Category: ""DEPM Generic Allocation"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cycleUN]: ""The unique cycle element."";
@Parameter[versionUN]: ""The unique version element."";
@Parameter[entityUN]: ""The unique entity element."";
@Parameter[organizationUN]: ""The unique organization element."";
@Parameter[placeholderDimension]: ""The placeholder dimension"";
@Parameter[placeholderHierarchy]: ""The placeholder hierarchy"";
@Parameter[placeholderElement]: ""The placeholder element to use"";
@Parameter[iteration]: ""The allocation iteration / level"";
@Parameter[step]: ""The allocation step"";
@Returns: ""TRUE if successful"";
{
	string functionName = ""AL_RunGenericAllocationStep:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_PerformGenericAllocation_Internal(connection, cycleUN, versionUN, entityUN, organizationUN, placeholderDimension, placeholderHierarchy, placeholderElement, iteration, step);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	return ""FALSE"";
}"	1	791F8738-46A6-4EAA-82AE-5676D08679CD	Runs a generic allocation step	1	1	1	1525	NULL	0	45708.67509	0	0
4E2A7CB0-3747-404C-8826-B71A496A2AC7	CD491758-D9DF-4002-94C8-8006E1855F86	AL_RunProcessesByLevel	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Array of integers that corrospond to return codes for each iteration that was run."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The name of the cube to execute against"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Configuration set Dimension"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entityUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Entity Dimension"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""versionUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Version Dimension"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""timeUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the Time Dimension"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stopOnError"" parameter-type=""bool"" parameter-description=""Selection for stopping on error"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""iterationLevelUniqueName"" parameter-type=""string"" parameter-description=""Unique name for the level dimension to find the iterations to run"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""followingLevels"" parameter-type=""bool"" parameter-description=""Selection for processing all following level members after the given one."" parameter-order=""9"" />
  <dependencies>
    <process process-name=""AL_ClearDataAreaByLevel"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_ClearDataAreaByLevel"", ""*""

string AL_RunProcessesByLevel(string server, string ticket, string cube, string cycleUniqueName, string entityUniqueName, string versionUniqueName,
                              string timeUniqueName, bool stopOnError, string iterationLevelUniqueName, bool followingLevels)
@Description: ""Describe your process here"";
@Category: ""Allocation Functions"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The name of the cube to execute against"";
@Parameter[cycleUniqueName]: ""Unique name for the Configuration set Dimension"";
@Parameter[entityUniqueName]: ""Unique name for the Entity Dimension"";
@Parameter[versionUniqueName]: ""Unique name for the Version Dimension"";
@Parameter[timeUniqueName]: ""Unique name for the Time Dimension"";
@Parameter[stopOnError]: ""Selection for stopping on error"";
@Parameter[iterationLevelUniqueName]: ""Unique name for the level dimension to find the iterations to run"";
@Parameter[followingLevels]: ""Selection for processing all following level members after the given one."";
@Returns: ""Array of integers that corrospond to return codes for each iteration that was run."";
{
	LogDebug(""Entering AL_RunProcessesByLevel"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUniqueName);
	LogDebug(""Entity: "" + entityUniqueName);
	LogDebug(""Version: "" + versionUniqueName);
	LogDebug(""Time: "" + timeUniqueName);
	LogDebug(""Iteration Level: "" + iterationLevelUniqueName);

	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	string cycle = ResolveUniqueName(connection,cycleUniqueName);
	string entity = ResolveUniqueName(connection,entityUniqueName);
	string startingIterationLevel = ResolveUniqueName(connection,iterationLevelUniqueName);

	StringArray levels = CreateStringArray();
	if(followingLevels){
		int levelNumber = ToInt(StringSubstring(startingIterationLevel, StringFind(startingIterationLevel, ""0"", 0), StringLength(startingIterationLevel)-StringFind(startingIterationLevel, ""0"", 0)));
		bool continueLooping = true;
		while(continueLooping){
			string iterationLevel = ""AFTER_ITERATION_""+ToString(levelNumber,""0000"", """");
			string nextIterationLevelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
			string resolved = ResolveUniqueName(connection, nextIterationLevelUniqueName);
			if (StringLength(resolved)&gt;0){
				Append(levels,iterationLevel);
				levelNumber = levelNumber + 1;
			}
			else{
				continueLooping = false;
			}
		}
	}
	else{
		Append(levels, startingIterationLevel);
	}


	StringArray iterationNames = CreateStringArray();
	OLAPDataArea iterationList = OLAPCreateDataArea(connection, ""ALCCONFIG_ITERATION"", OlapDataAreaIncludeB |
	                                                OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                cycle, ""N.A."", OlapDataAreaAllCells, ""Text Value"", ""FEATURE_AL_LEVEL_ELEMENT"");
	foreach(string iterationLevel in levels){
		foreach(OLAPCell cell in iterationList){
			string value = cell;
			string cellIterationLevel = ResolveUniqueName(connection,value);
			if (cellIterationLevel == iterationLevel){
				string iteration = OLAPCellGetElement(cell, ""ALDITERATION"");
				string iterationUniqueName = ""["" + ""ALDITERATION"" + ""].["" + iteration + ""].[1]"";
				Append(iterationNames, iterationUniqueName);
			}
		}

		string levelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
		AL_ClearDataAreaByLevel(server, ticket, cycleUniqueName, entityUniqueName, versionUniqueName, timeUniqueName, levelUniqueName, false);
	}
	
	string resultXML = ""&lt;Table&gt;"";
	foreach(string iterationName in iterationNames)
	{
		string iteration = ResolveUniqueName(connection, iterationName);

		double isActive = OLAPCellReadNumber(connection, ""ALCCONFIG_ITERATION"", 1.0, cycle, entity, iteration, ""Value"", ""FEATURE_AL_ACTIVE"");
		if(isActive == 1.0)
		{
			int returnCode = PerformAllocation(connection, cube, cycleUniqueName, entityUniqueName, versionUniqueName, timeUniqueName, iterationName, stopOnError);
			
			resultXML = resultXML + ""&lt;Row name='"" + iterationName + ""'&gt;"";
			resultXML = resultXML + ""&lt;Property name='returncode' value='"" + ToString(returnCode) + ""' /&gt;"";
			resultXML = resultXML + ""&lt;/Row&gt;"";
		}
	}
	
	resultXML = resultXML + ""&lt;/Table&gt;"";
	
	LogDebug(""Leaving AL_RunProcessesByLevel"");
	
	return resultXML;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""AL_ClearDataAreaByLevel"", ""*""

string AL_RunProcessesByLevel(string server, string ticket, string cube, string cycleUniqueName, string entityUniqueName, string versionUniqueName,
                              string timeUniqueName, bool stopOnError, string iterationLevelUniqueName, bool followingLevels)
@Description: ""Describe your process here"";
@Category: ""Allocation Functions"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The name of the cube to execute against"";
@Parameter[cycleUniqueName]: ""Unique name for the Configuration set Dimension"";
@Parameter[entityUniqueName]: ""Unique name for the Entity Dimension"";
@Parameter[versionUniqueName]: ""Unique name for the Version Dimension"";
@Parameter[timeUniqueName]: ""Unique name for the Time Dimension"";
@Parameter[stopOnError]: ""Selection for stopping on error"";
@Parameter[iterationLevelUniqueName]: ""Unique name for the level dimension to find the iterations to run"";
@Parameter[followingLevels]: ""Selection for processing all following level members after the given one."";
@Returns: ""Array of integers that corrospond to return codes for each iteration that was run."";
{
	LogDebug(""Entering AL_RunProcessesByLevel"");
	LogDebug(""Cube: "" + cube);
	LogDebug(""Configuration set: "" + cycleUniqueName);
	LogDebug(""Entity: "" + entityUniqueName);
	LogDebug(""Version: "" + versionUniqueName);
	LogDebug(""Time: "" + timeUniqueName);
	LogDebug(""Iteration Level: "" + iterationLevelUniqueName);

	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	string cycle = ResolveUniqueName(connection,cycleUniqueName);
	string entity = ResolveUniqueName(connection,entityUniqueName);
	string startingIterationLevel = ResolveUniqueName(connection,iterationLevelUniqueName);

	StringArray levels = CreateStringArray();
	if(followingLevels){
		int levelNumber = ToInt(StringSubstring(startingIterationLevel, StringFind(startingIterationLevel, ""0"", 0), StringLength(startingIterationLevel)-StringFind(startingIterationLevel, ""0"", 0)));
		bool continueLooping = true;
		while(continueLooping){
			string iterationLevel = ""AFTER_ITERATION_""+ToString(levelNumber,""0000"", """");
			string nextIterationLevelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
			string resolved = ResolveUniqueName(connection, nextIterationLevelUniqueName);
			if (StringLength(resolved)>0){
				Append(levels,iterationLevel);
				levelNumber = levelNumber + 1;
			}
			else{
				continueLooping = false;
			}
		}
	}
	else{
		Append(levels, startingIterationLevel);
	}


	StringArray iterationNames = CreateStringArray();
	OLAPDataArea iterationList = OLAPCreateDataArea(connection, ""ALCCONFIG_ITERATION"", OlapDataAreaIncludeB |
	                                                OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                cycle, ""N.A."", OlapDataAreaAllCells, ""Text Value"", ""FEATURE_AL_LEVEL_ELEMENT"");
	foreach(string iterationLevel in levels){
		foreach(OLAPCell cell in iterationList){
			string value = cell;
			string cellIterationLevel = ResolveUniqueName(connection,value);
			if (cellIterationLevel == iterationLevel){
				string iteration = OLAPCellGetElement(cell, ""ALDITERATION"");
				string iterationUniqueName = ""["" + ""ALDITERATION"" + ""].["" + iteration + ""].[1]"";
				Append(iterationNames, iterationUniqueName);
			}
		}

		string levelUniqueName = ""["" + ""BPDLEVEL"" + ""].["" + iterationLevel + ""].[1]"";
		AL_ClearDataAreaByLevel(server, ticket, cycleUniqueName, entityUniqueName, versionUniqueName, timeUniqueName, levelUniqueName, false);
	}
	
	string resultXML = ""<Table>"";
	foreach(string iterationName in iterationNames)
	{
		string iteration = ResolveUniqueName(connection, iterationName);

		double isActive = OLAPCellReadNumber(connection, ""ALCCONFIG_ITERATION"", 1.0, cycle, entity, iteration, ""Value"", ""FEATURE_AL_ACTIVE"");
		if(isActive == 1.0)
		{
			int returnCode = PerformAllocation(connection, cube, cycleUniqueName, entityUniqueName, versionUniqueName, timeUniqueName, iterationName, stopOnError);
			
			resultXML = resultXML + ""<Row name='"" + iterationName + ""'>"";
			resultXML = resultXML + ""<Property name='returncode' value='"" + ToString(returnCode) + ""' />"";
			resultXML = resultXML + ""</Row>"";
		}
	}
	
	resultXML = resultXML + ""</Table>"";
	
	LogDebug(""Leaving AL_RunProcessesByLevel"");
	
	return resultXML;
}"	1	5A8BE95A-23E2-4CB6-8DF1-4810E6ACB3F0	Describe your process here	1	1	1	1526	NULL	0	45708.67501	0	0
88F3F1B4-EB55-4AB0-BEE9-F9A7EE6EC3A2	CD491758-D9DF-4002-94C8-8006E1855F86	AL_SetEntityActive	Allocation Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server containing the OLAP database to connect to"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name holding the allocation configuration"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element defining the allocation configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""languageValueUN"" parameter-type=""string"" parameter-description=""The value language element where the active value is stored"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""languageCurrentUN"" parameter-type=""string"" parameter-description=""The current language element where the description is stored"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""parameterActiveUN"" parameter-type=""string"" parameter-description=""The BPDPARAMETER active element to used to set/check active"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""parameterDescriptionUN"" parameter-type=""string"" parameter-description=""The BPDPARAMETER description element to get the description"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_SetEntityActive(string server, string ticket, string cube, string cycleUN, string languageValueUN, string languageCurrentUN, string parameterActiveUN, string parameterDescriptionUN)
@Description: ""This function is used check if at least one entity is active in ALCCONFIG_ITERATION"";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[languageValueUN]: ""The value language element where the active value is stored"";
@Parameter[languageCurrentUN]: ""The current language element where the description is stored"";
@Parameter[parameterActiveUN]: ""The BPDPARAMETER active element to used to set/check active"";
@Parameter[parameterDescriptionUN]: ""The BPDPARAMETER description element to get the description"";
{
	string functionName = ""AL_SetEntityActive:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_SetEntityActiveInternal(connection, cube, cycleUN, languageValueUN, languageCurrentUN, parameterActiveUN, parameterDescriptionUN);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AL_SetEntityActive(string server, string ticket, string cube, string cycleUN, string languageValueUN, string languageCurrentUN, string parameterActiveUN, string parameterDescriptionUN)
@Description: ""This function is used check if at least one entity is active in ALCCONFIG_ITERATION"";
@Category: ""Allocation Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server containing the OLAP database to connect to"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The cube name holding the allocation configuration"";
@Parameter[cycleUN]: ""The Configuration set element defining the allocation configuration"";
@Parameter[languageValueUN]: ""The value language element where the active value is stored"";
@Parameter[languageCurrentUN]: ""The current language element where the description is stored"";
@Parameter[parameterActiveUN]: ""The BPDPARAMETER active element to used to set/check active"";
@Parameter[parameterDescriptionUN]: ""The BPDPARAMETER description element to get the description"";
{
	string functionName = ""AL_SetEntityActive:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AL_SetEntityActiveInternal(connection, cube, cycleUN, languageValueUN, languageCurrentUN, parameterActiveUN, parameterDescriptionUN);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		NotifyError(errorMessage);
		
		return ""ERROR:"" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	A7B49FE8-7C2C-422E-A9B3-0A6173C96B1F	This function is used check if at least one entity is active in ALCCONFIG_ITERATION	1	1	1	1527	NULL	0	45708.67506	0	0
62E1BE95-C87B-44D1-8353-5B57DEFD22E0	CD491758-D9DF-4002-94C8-8006E1855F86	AT_AddAttributesToCategory	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the attributes were added to the category; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dynamic attributes dimension."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""category"" parameter-type=""string"" parameter-description=""The category to add attributes to."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""attributes"" parameter-type=""string"" parameter-description=""A string containing a delimited list of attributes"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddAttributesToCategory(string server, string ticket, string dimension, string category, string attributes)
@Description: ""Adds attributes to a category."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dynamic attributes dimension."";
@Parameter[category]: ""The category to add attributes to."";
@Parameter[attributes]: ""A string containing a delimited list of attributes"";
@Returns: ""'TRUE' if the attributes were added to the category; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddAttributesToCategory:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddAttributesToCategory_Internal(connection, dimension, category, attributes);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddAttributesToCategory(string server, string ticket, string dimension, string category, string attributes)
@Description: ""Adds attributes to a category."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dynamic attributes dimension."";
@Parameter[category]: ""The category to add attributes to."";
@Parameter[attributes]: ""A string containing a delimited list of attributes"";
@Returns: ""'TRUE' if the attributes were added to the category; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddAttributesToCategory:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddAttributesToCategory_Internal(connection, dimension, category, attributes);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	AF12C95C-616B-4618-A3F3-D2A03B16EA8A	Adds attributes to a category.	1	1	1	1528	NULL	0	45708.67505	0	0
40A084BF-1082-473C-9D41-135853012915	CD491758-D9DF-4002-94C8-8006E1855F86	AT_AddDynamicAttribute	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the dynamic attribute was added; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the dynamic attribute is being added to."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""The name of the dynamic attribute."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""type"" parameter-type=""string"" parameter-description=""The element type of the dynamic attribute."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""addXML"" parameter-type=""string"" parameter-description=""The XML string containing dimension attributes and values for them to set on the new dynamic attribute: Description, Format_Type, and Context."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddDynamicAttribute(string server, string ticket, string dimension, string name, string type,
                                       string addXML)
@Description: ""Adds a new dynamic attribute element to the provided dimension using the parameters."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the dynamic attribute is being added to."";
@Parameter[name]: ""The name of the dynamic attribute."";
@Parameter[type]: ""The element type of the dynamic attribute."";
@Parameter[addXML]: ""The XML string containing dimension attributes and values for them to set on the new dynamic attribute: Description, Format_Type, and Context."";
@Returns: ""'TRUE' if the dynamic attribute was added; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddDynamicAttribute_Internal(connection, dimension, name, type, addXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddDynamicAttribute(string server, string ticket, string dimension, string name, string type,
                                       string addXML)
@Description: ""Adds a new dynamic attribute element to the provided dimension using the parameters."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the dynamic attribute is being added to."";
@Parameter[name]: ""The name of the dynamic attribute."";
@Parameter[type]: ""The element type of the dynamic attribute."";
@Parameter[addXML]: ""The XML string containing dimension attributes and values for them to set on the new dynamic attribute: Description, Format_Type, and Context."";
@Returns: ""'TRUE' if the dynamic attribute was added; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddDynamicAttribute_Internal(connection, dimension, name, type, addXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	7A7ECAAD-C90C-4D33-B765-1098FAB5E749	Adds a new dynamic attribute element to the provided dimension using the parameters.	1	1	1	1529	NULL	0	45708.67503	0	0
6B7441BA-77AB-4459-A83F-0AD4A858C35E	CD491758-D9DF-4002-94C8-8006E1855F86	AT_AddList	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the list was added; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the list is being added to."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""addXML"" parameter-type=""string"" parameter-description=""XML containing data of additions required for the list, including the list name and items"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddList(string server, string ticket, string dimension, string addXML)
@Description: ""Adds a new list to the provided dimension. Technically, it creates a new hierarchy within the dimension using the name and elements defined in the provided XML."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the list is being added to."";
@Parameter[addXML]: ""XML containing data of additions required for the list, including the list name and items"";
@Returns: ""'TRUE' if the list was added; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddList_Internal(connection, dimension, addXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_AddList(string server, string ticket, string dimension, string addXML)
@Description: ""Adds a new list to the provided dimension. Technically, it creates a new hierarchy within the dimension using the name and elements defined in the provided XML."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the list is being added to."";
@Parameter[addXML]: ""XML containing data of additions required for the list, including the list name and items"";
@Returns: ""'TRUE' if the list was added; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_AddList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_AddList_Internal(connection, dimension, addXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	DFFA43B3-EEFF-44A1-9147-32C459904479	Adds a new list to the provided dimension. Technically, it creates a new hierarchy within the dimension using the name and elements defined in the provided XML.	1	1	1	1530	NULL	0	45708.67501	0	0
EA145553-D01D-426C-B52B-C90BABB88764	CD491758-D9DF-4002-94C8-8006E1855F86	AT_DeleteDynamicAttribute	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the dynamic attribute was deleted; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the dynamic attribute is being deleted from."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""The name of the dynamic attribute to delete."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_DeleteDynamicAttribute(string server, string ticket, string dimension, string name)
@Description: ""Deletes a dynamic attribute element from the provided dimension."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the dynamic attribute is being deleted from."";
@Parameter[name]: ""The name of the dynamic attribute to delete."";
@Returns: ""'TRUE' if the dynamic attribute was deleted; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_DeleteDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_DeleteDynamicAttribute_Internal(connection, dimension, name);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_DeleteDynamicAttribute(string server, string ticket, string dimension, string name)
@Description: ""Deletes a dynamic attribute element from the provided dimension."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the dynamic attribute is being deleted from."";
@Parameter[name]: ""The name of the dynamic attribute to delete."";
@Returns: ""'TRUE' if the dynamic attribute was deleted; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_DeleteDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_DeleteDynamicAttribute_Internal(connection, dimension, name);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	7D504E62-C2EA-4ACD-919F-8679A4B1E81B	Deletes a dynamic attribute element from the provided dimension.	1	1	1	1531	NULL	0	45708.67508	0	0
1D833122-2581-4C25-9E1A-BC8A837BEAA0	CD491758-D9DF-4002-94C8-8006E1855F86	AT_DeleteList	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the list was deleted; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the list is being deleted from."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""listName"" parameter-type=""string"" parameter-description=""The name of the list to delete."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_DeleteList(string server, string ticket, string dimension, string listName)
@Description: ""Deletes an existing list from the provided dimension. Technically, it deletes an existing hierarchy within the dimension using the name defined in the provided XML."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the list is being deleted from."";
@Parameter[listName]: ""The name of the list to delete."";
@Returns: ""'TRUE' if the list was deleted; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_DeleteList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_DeleteList_Internal(connection, dimension, listName);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_DeleteList(string server, string ticket, string dimension, string listName)
@Description: ""Deletes an existing list from the provided dimension. Technically, it deletes an existing hierarchy within the dimension using the name defined in the provided XML."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension the list is being deleted from."";
@Parameter[listName]: ""The name of the list to delete."";
@Returns: ""'TRUE' if the list was deleted; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_DeleteList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_DeleteList_Internal(connection, dimension, listName);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	855FFEB2-863C-417D-A007-113688F08282	Deletes an existing list from the provided dimension. Technically, it deletes an existing hierarchy within the dimension using the name defined in the provided XML.	1	1	1	1532	NULL	0	45708.67502	0	0
CB4B4A6E-D588-4B2B-97FA-5B3C44C1B6A2	CD491758-D9DF-4002-94C8-8006E1855F86	AT_RenameDynamicAttribute	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension containing the dynamic attribute."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""The current name of the dynamic attribute."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""updatedName"" parameter-type=""string"" parameter-description=""The name the dynamic attribute will be updated to, or empty if not."" parameter-order=""3"" />
  <dependencies>
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string AT_RenameDynamicAttribute(string server, string dimension, string name, string updatedName)
@Description: ""Renames an existing dynamic attribute element."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[dimension]: ""The dimension containing the dynamic attribute."";
@Parameter[name]: ""The current name of the dynamic attribute."";
@Parameter[updatedName]: ""The name the dynamic attribute will be updated to, or empty if not."";
@Returns: ""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_RenameDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string resolvedName = BP_GetResolvedUniqueName(connection, name);
		return AT_RenameDynamicAttribute_Internal(connection, dimension, resolvedName, updatedName);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string AT_RenameDynamicAttribute(string server, string dimension, string name, string updatedName)
@Description: ""Renames an existing dynamic attribute element."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[dimension]: ""The dimension containing the dynamic attribute."";
@Parameter[name]: ""The current name of the dynamic attribute."";
@Parameter[updatedName]: ""The name the dynamic attribute will be updated to, or empty if not."";
@Returns: ""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_RenameDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string resolvedName = BP_GetResolvedUniqueName(connection, name);
		return AT_RenameDynamicAttribute_Internal(connection, dimension, resolvedName, updatedName);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	742B5F55-B4A0-4D53-8483-B45D1010C6A6	Renames an existing dynamic attribute element.	1	1	1	1533	NULL	0	45708.67508	0	0
EE4C4817-8CD9-46A5-ABE6-335E41BBA2C2	CD491758-D9DF-4002-94C8-8006E1855F86	AT_UpdateDynamicAttribute	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension containing the dynamic attribute."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""name"" parameter-type=""string"" parameter-description=""The current name of the dynamic attribute."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""updatedName"" parameter-type=""string"" parameter-description=""The name the dynamic attribute will be updated to, or empty if not."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""updatedType"" parameter-type=""string"" parameter-description=""The type the dynamic attribute will be updated to, or empty if not."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""updateXML"" parameter-type=""string"" parameter-description=""XML containing the properties and values to be updated for the dynamic attribute."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string AT_UpdateDynamicAttribute(string server, string ticket, string dimension, string name, string updatedName, string updatedType, string updateXML)
@Description: ""Updates an existing dynamic attribute element."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension containing the dynamic attribute."";
@Parameter[name]: ""The current name of the dynamic attribute."";
@Parameter[updatedName]: ""The name the dynamic attribute will be updated to, or empty if not."";
@Parameter[updatedType]: ""The type the dynamic attribute will be updated to, or empty if not."";
@Parameter[updateXML]: ""XML containing the properties and values to be updated for the dynamic attribute."";
@Returns: ""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_UpdateDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string resolvedName = BP_GetResolvedUniqueName(connection, name);
		return AT_UpdateDynamicAttribute_Internal(connection, dimension, resolvedName, updatedName, updatedType, updateXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string AT_UpdateDynamicAttribute(string server, string ticket, string dimension, string name, string updatedName, string updatedType, string updateXML)
@Description: ""Updates an existing dynamic attribute element."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension containing the dynamic attribute."";
@Parameter[name]: ""The current name of the dynamic attribute."";
@Parameter[updatedName]: ""The name the dynamic attribute will be updated to, or empty if not."";
@Parameter[updatedType]: ""The type the dynamic attribute will be updated to, or empty if not."";
@Parameter[updateXML]: ""XML containing the properties and values to be updated for the dynamic attribute."";
@Returns: ""'TRUE' if the dynamic attribute was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_UpdateDynamicAttribute:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string resolvedName = BP_GetResolvedUniqueName(connection, name);
		return AT_UpdateDynamicAttribute_Internal(connection, dimension, resolvedName, updatedName, updatedType, updateXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	99B75A4B-20E5-4DB6-916B-648542477CB3	Updates an existing dynamic attribute element.	1	1	1	1534	NULL	0	45708.67503	0	0
0A82EA7B-2EA8-4DAE-BD2D-E5C3D171D38F	CD491758-D9DF-4002-94C8-8006E1855F86	AT_UpdateList	Dynamic Attribute Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""'TRUE' if the list was updated; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server the OLAP database is located at."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""A COS ticket for authenticating against the server."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension containing the list being updated."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""listName"" parameter-type=""string"" parameter-description=""The name of the list to apply changes to."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""updateXML"" parameter-type=""string"" parameter-description=""XML containing data of changes required to the list."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_UpdateList(string server, string ticket, string dimension, string listName, string updateXML)
@Description: ""Updates an existing list within the provided dimension."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension containing the list being updated."";
@Parameter[listName]: ""The name of the list to apply changes to."";
@Parameter[updateXML]: ""XML containing data of changes required to the list."";
@Returns: ""'TRUE' if the list was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_UpdateList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_UpdateList_Internal(connection, dimension, listName, updateXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string AT_UpdateList(string server, string ticket, string dimension, string listName, string updateXML)
@Description: ""Updates an existing list within the provided dimension."";
@Category: ""Dynamic Attribute Functions"";
@Parameter[server]: ""The server the OLAP database is located at."";
@Parameter[ticket]: ""A COS ticket for authenticating against the server."";
@Parameter[dimension]: ""The dimension containing the list being updated."";
@Parameter[listName]: ""The name of the list to apply changes to."";
@Parameter[updateXML]: ""XML containing data of changes required to the list."";
@Returns: ""'TRUE' if the list was updated; 'FALSE' or an error message otherwise."";
{
	string functionName = ""AT_UpdateList:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		return AT_UpdateList_Internal(connection, dimension, listName, updateXML);
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	541748E1-EF89-448F-A6CD-B1E8303E311E	Updates an existing list within the provided dimension.	1	1	1	1535	NULL	0	45708.67508	0	0
4D785D07-5E4C-42B5-BECD-E39AE9D74195	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_AddHoc_Assumptions	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""Cube where copying will be done."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""staticElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""ArraysNumber"" parameter-type=""int"" parameter-description=""Show number of arrays in strings"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""Value writen into cell"" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_Assumptions(string server, string ticket, string cube,string staticElement, string sourceElement,int ArraysNumber, double value)
@Description: ""Perform assumtions in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""Show number of arrays in strings"";
@Parameter[value]: ""Value writen into cell"";

@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_Assumptions:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return Assumptions_Internal(connection, cube,staticElement, sourceElement,ArraysNumber, value);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_Assumptions(string server, string ticket, string cube,string staticElement, string sourceElement,int ArraysNumber, double value)
@Description: ""Perform assumtions in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""Show number of arrays in strings"";
@Parameter[value]: ""Value writen into cell"";

@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_Assumptions:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return Assumptions_Internal(connection, cube,staticElement, sourceElement,ArraysNumber, value);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}"	1	43E6ACE0-A2EB-482E-8166-97CDF06BC080	Perform assumtions in add hoc reports.	1	1	1	1536	NULL	0	45708.67504	0	0
06CFED51-2D86-4F8F-92DF-F6D55FF8ABE7	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_AddHoc_CopyValues	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""Cube where copying will be done."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""staticElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetElement"" parameter-type=""string"" parameter-description=""String list of target BPCMAIN cube elements."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""mode"" parameter-type=""string"" parameter-description=""Define what should happened with values(copy, move, delete, Revalue)"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""multiplyFactor"" parameter-type=""double"" parameter-description=""when mode ravalue, this is given factor, which will muliply value."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""ArraysNumber"" parameter-type=""int"" parameter-description=""Show number of arrays in strings"" parameter-order=""8"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_CopyValues(string server, string ticket, string cube,string staticElement, string sourceElement,string targetElement,string mode, double multiplyFactor, int ArraysNumber)
@Description: ""Perform copying in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[targetElement]: ""String list of target BPCMAIN cube elements."";
@Parameter[mode]: ""Define what should happened with values(copy, move, delete, Revalue)"";
@Parameter[multiplyFactor]: ""when mode ravalue, this is given factor, which will muliply value."";
@Parameter[ArraysNumber]: ""Show number of arrays in strings"";

@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_CopyValues:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return CopyValues_Internal(connection, cube,staticElement, sourceElement,targetElement,mode,multiplyFactor,ArraysNumber);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_CopyValues(string server, string ticket, string cube,string staticElement, string sourceElement,string targetElement,string mode, double multiplyFactor, int ArraysNumber)
@Description: ""Perform copying in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[targetElement]: ""String list of target BPCMAIN cube elements."";
@Parameter[mode]: ""Define what should happened with values(copy, move, delete, Revalue)"";
@Parameter[multiplyFactor]: ""when mode ravalue, this is given factor, which will muliply value."";
@Parameter[ArraysNumber]: ""Show number of arrays in strings"";

@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_CopyValues:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return CopyValues_Internal(connection, cube,staticElement, sourceElement,targetElement,mode,multiplyFactor,ArraysNumber);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}"	1	DEC4675E-87CF-488B-BC81-F875D8C73155	Perform copying in add hoc reports.	1	1	1	1537	NULL	0	45708.67503	0	0
4B4E62CF-80F5-463F-893E-CDC30BF4FE06	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_AddHoc_DeleteValues	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""'TRUE' if deleting was executed; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""Cube where copying will be done."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""staticElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""ArraysNumber"" parameter-type=""int"" parameter-description=""Show nubmber of arrays in strings"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_DeleteValues(string server, string ticket, string cube,string staticElement, string sourceElement, int ArraysNumber)
@Description: ""Perform deleting in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""Show nubmber of arrays in strings"";
@Returns: ""'TRUE' if deleting was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_DeleteValues:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return DeleteValues_Internal(connection, cube,staticElement, sourceElement,ArraysNumber);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_DeleteValues(string server, string ticket, string cube,string staticElement, string sourceElement, int ArraysNumber)
@Description: ""Perform deleting in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""Show nubmber of arrays in strings"";
@Returns: ""'TRUE' if deleting was executed; 'FALSE' or an error message otherwise."";
{
	string functionName = ""BAP_AddHoc_DeleteValues:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return DeleteValues_Internal(connection, cube,staticElement, sourceElement,ArraysNumber);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return true;
}"	1	B774E21F-F33A-469C-A64E-5BE569C722E6	Perform deleting in add hoc reports.	1	1	1	1538	NULL	0	45708.67501	0	0
8C483E85-728E-469B-9828-C91796A163BE	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_AddHoc_PhasingValues	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to use to connect."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""Cube where copying will be done."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""staticElement"" parameter-type=""string"" parameter-description=""String list of source BPCMAIN cube elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceElement"" parameter-type=""string"" parameter-description=""String list of target BPCMAIN cube elements"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""ArraysNumber"" parameter-type=""int"" parameter-description=""show nubmber of arrays in strings"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""phasingMethod"" parameter-type=""string"" parameter-description=""Element name to identify the selected phasing method"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""phasingAccount"" parameter-type=""string"" parameter-description=""Account which will be used for phasing, if method is ACCOUNT"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""phasingUser"" parameter-type=""string"" parameter-description=""UN of defined phasing method"" parameter-order=""8"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_PhasingValues(string server, string ticket, string cube,string staticElement,string sourceElement,int ArraysNumber, string phasingMethod,string phasingAccount, string phasingUser)
@Description: ""Perform phasing in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of target BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""show nubmber of arrays in strings"";
@Parameter[phasingMethod]: ""Element name to identify the selected phasing method"";
@Parameter[phasingAccount]: ""Account which will be used for phasing, if method is ACCOUNT"";
@Parameter[phasingUser]: ""UN of defined phasing method"";
@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{

	string functionName = ""BAP_AddHoc_Phasing value:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return PhasingValues_Internal(connection, cube,staticElement, sourceElement,ArraysNumber,phasingMethod,phasingAccount, phasingUser);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}
	// This is only here because AppEngine won't compile unless it is.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAP_AddHoc_PhasingValues(string server, string ticket, string cube,string staticElement,string sourceElement,int ArraysNumber, string phasingMethod,string phasingAccount, string phasingUser)
@Description: ""Perform phasing in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[ticket]: ""The ticket to use to connect."";
@Parameter[cube]: ""Cube where copying will be done."";
@Parameter[staticElement]: ""String list of source BPCMAIN cube elements"";
@Parameter[sourceElement]: ""String list of target BPCMAIN cube elements"";
@Parameter[ArraysNumber]: ""show nubmber of arrays in strings"";
@Parameter[phasingMethod]: ""Element name to identify the selected phasing method"";
@Parameter[phasingAccount]: ""Account which will be used for phasing, if method is ACCOUNT"";
@Parameter[phasingUser]: ""UN of defined phasing method"";
@Returns: ""'TRUE' if copying was executed; 'FALSE' or an error message otherwise."";
{

	string functionName = ""BAP_AddHoc_Phasing value:"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return PhasingValues_Internal(connection, cube,staticElement, sourceElement,ArraysNumber,phasingMethod,phasingAccount, phasingUser);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}
	// This is only here because AppEngine won't compile unless it is.
	return true;
}"	1	2F9C454F-75B2-4756-B876-DC12C3B0C57C	Perform phasing in add hoc reports.	1	1	1	1539	NULL	0	45708.67506	0	0
8A53CC57-A396-441A-BFD8-3AF3111ACC76	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_CopyCycleVersion	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if copying was succesfull"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""SourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""TargetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration Set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The source version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""TargetVersionUN"" parameter-type=""string"" parameter-description=""The target version element to be used."" parameter-order=""5"" />
  <dependencies>
    <process process-name=""BP_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""

bool BAP_CopyCycleVersion(string Database, string Ticket, string SourceCycleUN, string TargetCycleUN,string SourceVersionUN, string TargetVersionUN)

@Description: ""Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The source Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration Set element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Returns: ""true if copying was succesfull"";

{

	LogInformation(""BAP_CopyCycleVersion: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	SourceVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_015].[1]"";
	TargetVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";*/
	

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string TotalTime = ""TOTAL_TIME"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	LogInformation(""Configuration Set: "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-&gt; Configuration Set: "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);


	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, SourceCycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, SourceCycle, NA,""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
	

	OLAPElementList years = OLAPGetLevelElements(connection, TimeDimension, TotalTime, 1, false);
	// Get base periods for the time value specified
	OLAPElementList periods = CreateOLAPElementList();
	OLAPElementList basePeriods = CreateOLAPElementList();
	// Special indicator; need to process all years in the planning cycle
	foreach (OLAPElement year in years) {
		// for all years in the cycle, get base periods
		periods = OLAPGetChildElementList(connection, TimeDimension, year, true);
		foreach (OLAPElement p in periods) {
			OLAPElementListAddElement(basePeriods, p);
		}
		

	}


	
	StringList yearStringList = CreateStringList();
	yearStringList  =ToStringList(years) ;
	OLAPElementList CurrenciesOlapList = OLAPGetChildElementList(connection, ""BPDCURRENCY"", ""CURRENCY_DATAENTRY"", true);
	StringList currenciesStringList = CreateStringList();
	currenciesStringList =ToStringList(CurrenciesOlapList);
	string checkPeriod = """";
	bool check = false;
	
	foreach(string actualPeriod  in yearStringList)
	{
		foreach(string currencyString in currenciesStringList)
		{
			double checkValue = OLAPCellReadNumber(connection,""BPCMAIN"", 1.0, actualPeriod , SourceCycle,  SourceVersion, ""TOTAL_OB"", ""TOTAL_STEP"", ""TOTAL_ENTITY"", ""TOTAL_PARTNER"", ""TOTAL_ORGANIZATION"", ""TOTAL_ACCOUNT"",currencyString, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"" ,""TOTAL_SEGMENT"" ,""TOTAL_ANALYSIS01"", ""TOTAL_ANALYSIS02"", ""TOTAL_ANALYSIS03"", ""TOTAL_ANALYSIS04"", ""TOTAL_ANALYSIS05"", ""TOTAL_ANALYSIS06"", ""TOTAL_ANALYSIS07"", ""TOTAL_ANALYSIS08"", ""TOTAL_ANALYSIS09"", ""TOTAL_ANALYSIS10"", ""TOTAL_ANALYSIS11"", ""TOTAL_ANALYSIS12"");
			
			if (checkValue != 0 and !check)
			{
				checkPeriod = actualPeriod ;
				check = true;
			}
		}
	}


	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	Cube = ""BPCCONFIG_EXCHANGE"";
	OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
	                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                               OlapDataAreaOperatorNone, 0.0,
	                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
	
	OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
	                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                               OlapDataAreaOperatorNone, 0.0,
	                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
	{
		

		string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
		string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");

		
		string value = OLAPCellReadString(connection, Cube, SourceCycle,SourceVersion,pcurrency,pparameter,planguage);
		

		
		OLAPCellWriteBufferWriteString(buffer, Cube, value, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
	}

	OLAPCommitCellWriteBuffer(buffer);


	Cube = ""EXCRATES"";
	OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                     OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetDataEXCRATES);
	
	OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                     OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceDataEXCRATES)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
		string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
		string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
		string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
		string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");


		
		string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,SourceVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency,pexrates);
		

		
		OLAPCellWriteBufferWriteString(buffer, Cube, value, ptime, TargetCycle,TargetVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency, pexrates);
	}

	OLAPCommitCellWriteBuffer(buffer);

	Cube = ""BPCMAIN"";


	OLAPElementList Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_CHANGE"", true);


	OLAPDataArea targetDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    basePeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAIN);

	
	OLAPDataArea sourceDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    basePeriods, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAIN)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);

	Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);
	OLAPElementList times =	 CreateOLAPElementList();
	if(checkPeriod != """")
	{
		times = OLAPGetChildElementList(connection, ""BPDTIME"", checkPeriod, true);
	}
	else
	{
		times = basePeriods;

	}



	OLAPDataArea targetDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      basePeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAINOB);

	
	OLAPDataArea sourceDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      times, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAINOB)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}

	OLAPCommitCellWriteBuffer(buffer);

	Cube = ""CFCCASHFLOW"";


	OLAPDataArea targetDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataCASHFLOW);

	
	OLAPDataArea sourceDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataCASHFLOW)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, currency, primarySegment, secondarySegment, tertiarySegment, account, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);



	LogInformation(""BAP_CopyCycleVersion: Starting process"");


	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""

bool BAP_CopyCycleVersion(string Database, string Ticket, string SourceCycleUN, string TargetCycleUN,string SourceVersionUN, string TargetVersionUN)

@Description: ""Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The source Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration Set element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Returns: ""true if copying was succesfull"";

{

	LogInformation(""BAP_CopyCycleVersion: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	SourceVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_015].[1]"";
	TargetVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";*/
	

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string TotalTime = ""TOTAL_TIME"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	LogInformation(""Configuration Set: "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-> Configuration Set: "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);


	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, SourceCycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, SourceCycle, NA,""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
	

	OLAPElementList years = OLAPGetLevelElements(connection, TimeDimension, TotalTime, 1, false);
	// Get base periods for the time value specified
	OLAPElementList periods = CreateOLAPElementList();
	OLAPElementList basePeriods = CreateOLAPElementList();
	// Special indicator; need to process all years in the planning cycle
	foreach (OLAPElement year in years) {
		// for all years in the cycle, get base periods
		periods = OLAPGetChildElementList(connection, TimeDimension, year, true);
		foreach (OLAPElement p in periods) {
			OLAPElementListAddElement(basePeriods, p);
		}
		

	}


	
	StringList yearStringList = CreateStringList();
	yearStringList  =ToStringList(years) ;
	OLAPElementList CurrenciesOlapList = OLAPGetChildElementList(connection, ""BPDCURRENCY"", ""CURRENCY_DATAENTRY"", true);
	StringList currenciesStringList = CreateStringList();
	currenciesStringList =ToStringList(CurrenciesOlapList);
	string checkPeriod = """";
	bool check = false;
	
	foreach(string actualPeriod  in yearStringList)
	{
		foreach(string currencyString in currenciesStringList)
		{
			double checkValue = OLAPCellReadNumber(connection,""BPCMAIN"", 1.0, actualPeriod , SourceCycle,  SourceVersion, ""TOTAL_OB"", ""TOTAL_STEP"", ""TOTAL_ENTITY"", ""TOTAL_PARTNER"", ""TOTAL_ORGANIZATION"", ""TOTAL_ACCOUNT"",currencyString, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"" ,""TOTAL_SEGMENT"" ,""TOTAL_ANALYSIS01"", ""TOTAL_ANALYSIS02"", ""TOTAL_ANALYSIS03"", ""TOTAL_ANALYSIS04"", ""TOTAL_ANALYSIS05"", ""TOTAL_ANALYSIS06"", ""TOTAL_ANALYSIS07"", ""TOTAL_ANALYSIS08"", ""TOTAL_ANALYSIS09"", ""TOTAL_ANALYSIS10"", ""TOTAL_ANALYSIS11"", ""TOTAL_ANALYSIS12"");
			
			if (checkValue != 0 and !check)
			{
				checkPeriod = actualPeriod ;
				check = true;
			}
		}
	}


	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	Cube = ""BPCCONFIG_EXCHANGE"";
	OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
	                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                               OlapDataAreaOperatorNone, 0.0,
	                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
	
	OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
	                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                               OlapDataAreaOperatorNone, 0.0,
	                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
	{
		

		string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
		string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");

		
		string value = OLAPCellReadString(connection, Cube, SourceCycle,SourceVersion,pcurrency,pparameter,planguage);
		

		
		OLAPCellWriteBufferWriteString(buffer, Cube, value, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
	}

	OLAPCommitCellWriteBuffer(buffer);


	Cube = ""EXCRATES"";
	OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                     OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetDataEXCRATES);
	
	OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                                     OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceDataEXCRATES)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
		string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
		string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
		string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
		string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");


		
		string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,SourceVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency,pexrates);
		

		
		OLAPCellWriteBufferWriteString(buffer, Cube, value, ptime, TargetCycle,TargetVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency, pexrates);
	}

	OLAPCommitCellWriteBuffer(buffer);

	Cube = ""BPCMAIN"";


	OLAPElementList Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_CHANGE"", true);


	OLAPDataArea targetDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    basePeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAIN);

	
	OLAPDataArea sourceDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    basePeriods, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAIN)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);

	Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);
	OLAPElementList times =	 CreateOLAPElementList();
	if(checkPeriod != """")
	{
		times = OLAPGetChildElementList(connection, ""BPDTIME"", checkPeriod, true);
	}
	else
	{
		times = basePeriods;

	}



	OLAPDataArea targetDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      basePeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAINOB);

	
	OLAPDataArea sourceDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      times, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAINOB)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}

	OLAPCommitCellWriteBuffer(buffer);

	Cube = ""CFCCASHFLOW"";


	OLAPDataArea targetDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataCASHFLOW);

	
	OLAPDataArea sourceDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     basePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataCASHFLOW)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, ptime, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, currency, primarySegment, secondarySegment, tertiarySegment, account, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);



	LogInformation(""BAP_CopyCycleVersion: Starting process"");


	return true;
}"	1	E072C997-9ED7-41BA-9929-85D889BE513C	Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets	1	1	1	1540	NULL	0	45708.67506	0	0
AEBB1250-1C78-4EEE-8755-57E15064B8F4	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_Finance_CheckCDForAssignments	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if one hierarchical element was filled, false if not"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""hierarchy"" parameter-type=""string"" parameter-description=""hierarchy string to be used"" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_Finance_CheckCDForAssignments(string database, string ticket, string cycle, string version, string entity, string account,string hierarchy)
@Description: ""Chek if in given hierarchy is some elements filled"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[hierarchy]: ""hierarchy string to be used"";
@Returns: ""True, if one hierarchical element was filled, false if not"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	version = ""[BPDVERSION].[BUDGET_01].[1]"";
	account= ""[BPDACCOUNT].[I120100].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	hierarchy= ""DETAIL_CUSTOM01"";*/
	LogInformation(""BAP_Finance_CheckCDForAssignments: Starting process, checking hierarchy: ""+ hierarchy);

	// constants used in the process
	string detailDynamicCube = ""ATCDATA_DETAIL"";
	string NA = ""N.A."";
	string TimeDimension = ""BPDTIME"";
	string CycleDimension = ""BPDCYCLE"";
	string VersionDimension = ""BPDVERSION"";
	string LevelDimension = ""BPDLEVEL"";
	string StepDimension = ""BPDSTEP"";
	string EntityDimension = ""BPDENTITY"";
	string OrganizationDimension = ""BPDORGANIZATION"";
	string AccountDimension = ""BPDACCOUNT"";
	string DetailDimension = ""BPDDETAIL"";
	string LanguageDimension = ""BPDLANGUAGE"";
	string ATDAttribute_DetailDimension = ""ATDATTRIBUTE_DETAIL"";

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	account = ResolveUniqueName(connection, account);

	string cycleHierarchyElement = CycleDimension+""\t""+cycle;
	string versionHierarchyElement = VersionDimension+""\t""+version;
	string organizationHierarchyElement = OrganizationDimension+""\t""+NA;
	string entityHierarchyElement = EntityDimension+""\t""+entity;
	string levelHierarchyElement = LevelDimension+""\t""+NA;
	string stepHierarchyElement = StepDimension+""\t""+""BASE_STEP"";
	string timeHierarchyElement = TimeDimension+""\t""+NA;
	string accountHierarchyElement = AccountDimension+""\t""+NA;
	string LanguageHierarchyElement = LanguageDimension+""\t""+""Default"";
	string detailHierarchyElement = hierarchy+""\t""+NA;
	string ATDAttribute_DetailHierarchyElement = ATDAttribute_DetailDimension+""\t""+""Account"";

	StringArray arrayOfATDAttribute_Detail= CreateStringArray();

	Append(arrayOfATDAttribute_Detail, cycleHierarchyElement);
	Append(arrayOfATDAttribute_Detail, versionHierarchyElement);
	Append(arrayOfATDAttribute_Detail, organizationHierarchyElement);
	Append(arrayOfATDAttribute_Detail, entityHierarchyElement);
	Append(arrayOfATDAttribute_Detail, levelHierarchyElement);
	Append(arrayOfATDAttribute_Detail, stepHierarchyElement);
	Append(arrayOfATDAttribute_Detail, timeHierarchyElement);
	Append(arrayOfATDAttribute_Detail, accountHierarchyElement);
	Append(arrayOfATDAttribute_Detail, LanguageHierarchyElement);
	Append(arrayOfATDAttribute_Detail, detailHierarchyElement);
	Append(arrayOfATDAttribute_Detail, ATDAttribute_DetailHierarchyElement);

	string totalHierarchicalElement = ""TOTAL_""+ hierarchy;
	OLAPElementList hierarchyList =  OLAPGetElementList(connection, DetailDimension ,hierarchy, true, true, true);
	bool result = false;
	string resultString = """";


	foreach(OLAPElement hierarchicalElement in hierarchyList)
	{

		string hierarchicalElementString = ToString(hierarchicalElement);
		arrayOfATDAttribute_Detail[9]= hierarchy+""\t""+hierarchicalElementString;
		arrayOfATDAttribute_Detail[10]= ATDAttribute_DetailDimension+""\t""+""Account"";
		resultString = OLAPCellReadStringDynamic(connection, detailDynamicCube,arrayOfATDAttribute_Detail);
		resultString = ResolveUniqueName(connection, resultString);
		if(resultString==account)
		{
			result = true;

		}
		arrayOfATDAttribute_Detail[10]= ATDAttribute_DetailDimension+""\t""+""Unassigned"";
		resultString = OLAPCellReadStringDynamic(connection, detailDynamicCube,arrayOfATDAttribute_Detail);
		if(resultString !="""")
		{
			result = true;

		}

	}


	LogInformation(""BAP_Finance_CheckCDForAssignments: Closing process."");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_Finance_CheckCDForAssignments(string database, string ticket, string cycle, string version, string entity, string account,string hierarchy)
@Description: ""Chek if in given hierarchy is some elements filled"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[hierarchy]: ""hierarchy string to be used"";
@Returns: ""True, if one hierarchical element was filled, false if not"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	version = ""[BPDVERSION].[BUDGET_01].[1]"";
	account= ""[BPDACCOUNT].[I120100].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	hierarchy= ""DETAIL_CUSTOM01"";*/
	LogInformation(""BAP_Finance_CheckCDForAssignments: Starting process, checking hierarchy: ""+ hierarchy);

	// constants used in the process
	string detailDynamicCube = ""ATCDATA_DETAIL"";
	string NA = ""N.A."";
	string TimeDimension = ""BPDTIME"";
	string CycleDimension = ""BPDCYCLE"";
	string VersionDimension = ""BPDVERSION"";
	string LevelDimension = ""BPDLEVEL"";
	string StepDimension = ""BPDSTEP"";
	string EntityDimension = ""BPDENTITY"";
	string OrganizationDimension = ""BPDORGANIZATION"";
	string AccountDimension = ""BPDACCOUNT"";
	string DetailDimension = ""BPDDETAIL"";
	string LanguageDimension = ""BPDLANGUAGE"";
	string ATDAttribute_DetailDimension = ""ATDATTRIBUTE_DETAIL"";

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	account = ResolveUniqueName(connection, account);

	string cycleHierarchyElement = CycleDimension+""\t""+cycle;
	string versionHierarchyElement = VersionDimension+""\t""+version;
	string organizationHierarchyElement = OrganizationDimension+""\t""+NA;
	string entityHierarchyElement = EntityDimension+""\t""+entity;
	string levelHierarchyElement = LevelDimension+""\t""+NA;
	string stepHierarchyElement = StepDimension+""\t""+""BASE_STEP"";
	string timeHierarchyElement = TimeDimension+""\t""+NA;
	string accountHierarchyElement = AccountDimension+""\t""+NA;
	string LanguageHierarchyElement = LanguageDimension+""\t""+""Default"";
	string detailHierarchyElement = hierarchy+""\t""+NA;
	string ATDAttribute_DetailHierarchyElement = ATDAttribute_DetailDimension+""\t""+""Account"";

	StringArray arrayOfATDAttribute_Detail= CreateStringArray();

	Append(arrayOfATDAttribute_Detail, cycleHierarchyElement);
	Append(arrayOfATDAttribute_Detail, versionHierarchyElement);
	Append(arrayOfATDAttribute_Detail, organizationHierarchyElement);
	Append(arrayOfATDAttribute_Detail, entityHierarchyElement);
	Append(arrayOfATDAttribute_Detail, levelHierarchyElement);
	Append(arrayOfATDAttribute_Detail, stepHierarchyElement);
	Append(arrayOfATDAttribute_Detail, timeHierarchyElement);
	Append(arrayOfATDAttribute_Detail, accountHierarchyElement);
	Append(arrayOfATDAttribute_Detail, LanguageHierarchyElement);
	Append(arrayOfATDAttribute_Detail, detailHierarchyElement);
	Append(arrayOfATDAttribute_Detail, ATDAttribute_DetailHierarchyElement);

	string totalHierarchicalElement = ""TOTAL_""+ hierarchy;
	OLAPElementList hierarchyList =  OLAPGetElementList(connection, DetailDimension ,hierarchy, true, true, true);
	bool result = false;
	string resultString = """";


	foreach(OLAPElement hierarchicalElement in hierarchyList)
	{

		string hierarchicalElementString = ToString(hierarchicalElement);
		arrayOfATDAttribute_Detail[9]= hierarchy+""\t""+hierarchicalElementString;
		arrayOfATDAttribute_Detail[10]= ATDAttribute_DetailDimension+""\t""+""Account"";
		resultString = OLAPCellReadStringDynamic(connection, detailDynamicCube,arrayOfATDAttribute_Detail);
		resultString = ResolveUniqueName(connection, resultString);
		if(resultString==account)
		{
			result = true;

		}
		arrayOfATDAttribute_Detail[10]= ATDAttribute_DetailDimension+""\t""+""Unassigned"";
		resultString = OLAPCellReadStringDynamic(connection, detailDynamicCube,arrayOfATDAttribute_Detail);
		if(resultString !="""")
		{
			result = true;

		}

	}


	LogInformation(""BAP_Finance_CheckCDForAssignments: Closing process."");

	return result;
}"	1	52C1C342-C4D7-4E07-BF9D-1DBB9B29D70A	Chek if in given hierarchy is some elements filled	1	1	1	1541	NULL	0	45708.67505	0	0
505B5049-D07E-4EB2-8FDC-B75413402570	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_FPS_AddAccount	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True- script run correctly"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to configure."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""pno"" parameter-type=""string"" parameter-description=""Planning step element in use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""Account element in use"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_FPS_AddAccount(string database, string ticket, string cycle, string pno,string account)
@Description: ""If the user adds accounts to a step which already has version/entity combinations assigned to it, the process spreads the change to all the combinations"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[account]: ""Account element in use"";
@Parameter[pno]: ""Planning step element in use"";
@Returns: ""True- script run correctly"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	account= ""[BPDACCOUNT].[A110100].[1]"";
	pno=""[BPDNO].[PNO_001].[1]"";//RU0004*/
	
	
	string NA = ""N.A."";
	string AccountDimension = ""BPDACCOUNT"";
	string VersionDimension = ""BPDVERSION"";
	string EntityDimension = ""BPDENTITY"";
	string topEntityElement = ""TOTAL_ENTITY"";
	string topVersionElement= ""TOTAL_CONFIGURATION"";
	string topOrganizationElement= ""TOTAL_ORGANIZATION"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountConfigurationCube = ""BPCCONFIG_MAIN"";

	
	cycle = ResolveUniqueName(connection, cycle);
	pno = ResolveUniqueName(connection, pno);
	account = ResolveUniqueName(connection, account);

	OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
	bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);

	StringArray accountArray = CreateStringArray();
	if(baseAccountElement)
	{
		
		Append(accountArray, account);

	}
	else
	{
		OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
		StringList accountStringListHelp = ToStringList(accountList);

		foreach(string accountOLAPElement in accountStringListHelp )
		{
			Append(accountArray, accountOLAPElement);

		}
	}


	OLAPElementList versionList = OLAPGetChildElementList(connection,VersionDimension, topVersionElement, true);
	OLAPElementList entityList = OLAPGetChildElementList(connection,EntityDimension, topEntityElement , true);
	OLAPElementList organizationList = OLAPGetChildElementList(connection, organizationDimension, topOrganizationElement, true);

	foreach(OLAPElement version in versionList)
	{
		foreach(OLAPElement entity in entityList)
		{
			string versionString = ToString(version);
			string entityString = ToString(entity);
			double value = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  NA, pno, ""SUBPLAN_FINANCE_COMPLETED"", ""Value"");
			if(value == 1)
			{
				double valueOrg = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  NA, pno, ""SUBPLAN_FINANCE_ACTIVE_ORGANIZATION"", ""Value"");
				if(valueOrg == 0)
				{
					foreach(string accountString in accountArray)
					{
						OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  accountString, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
					}
				}
				else
				{
					foreach (OLAPElement organization in organizationList)
					{
						string organizationString = ToString(organization);
						double valueOrgInForeach = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, organizationString,  NA, NA, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
						if(valueOrgInForeach == 1)
						{
							foreach(string accountString in accountArray)
							{
								OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, versionString,  entityString,organizationString,  accountString, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");


							}

						}

					}
				}
			}
		}
	}
	OLAPCommitCellWriteBuffer(buffer);
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_FPS_AddAccount(string database, string ticket, string cycle, string pno,string account)
@Description: ""If the user adds accounts to a step which already has version/entity combinations assigned to it, the process spreads the change to all the combinations"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[account]: ""Account element in use"";
@Parameter[pno]: ""Planning step element in use"";
@Returns: ""True- script run correctly"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	account= ""[BPDACCOUNT].[A110100].[1]"";
	pno=""[BPDNO].[PNO_001].[1]"";//RU0004*/
	
	
	string NA = ""N.A."";
	string AccountDimension = ""BPDACCOUNT"";
	string VersionDimension = ""BPDVERSION"";
	string EntityDimension = ""BPDENTITY"";
	string topEntityElement = ""TOTAL_ENTITY"";
	string topVersionElement= ""TOTAL_CONFIGURATION"";
	string topOrganizationElement= ""TOTAL_ORGANIZATION"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountConfigurationCube = ""BPCCONFIG_MAIN"";

	
	cycle = ResolveUniqueName(connection, cycle);
	pno = ResolveUniqueName(connection, pno);
	account = ResolveUniqueName(connection, account);

	OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
	bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);

	StringArray accountArray = CreateStringArray();
	if(baseAccountElement)
	{
		
		Append(accountArray, account);

	}
	else
	{
		OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
		StringList accountStringListHelp = ToStringList(accountList);

		foreach(string accountOLAPElement in accountStringListHelp )
		{
			Append(accountArray, accountOLAPElement);

		}
	}


	OLAPElementList versionList = OLAPGetChildElementList(connection,VersionDimension, topVersionElement, true);
	OLAPElementList entityList = OLAPGetChildElementList(connection,EntityDimension, topEntityElement , true);
	OLAPElementList organizationList = OLAPGetChildElementList(connection, organizationDimension, topOrganizationElement, true);

	foreach(OLAPElement version in versionList)
	{
		foreach(OLAPElement entity in entityList)
		{
			string versionString = ToString(version);
			string entityString = ToString(entity);
			double value = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  NA, pno, ""SUBPLAN_FINANCE_COMPLETED"", ""Value"");
			if(value == 1)
			{
				double valueOrg = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  NA, pno, ""SUBPLAN_FINANCE_ACTIVE_ORGANIZATION"", ""Value"");
				if(valueOrg == 0)
				{
					foreach(string accountString in accountArray)
					{
						OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, versionString,  entityString, NA,  accountString, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
					}
				}
				else
				{
					foreach (OLAPElement organization in organizationList)
					{
						string organizationString = ToString(organization);
						double valueOrgInForeach = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, versionString,  entityString, organizationString,  NA, NA, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
						if(valueOrgInForeach == 1)
						{
							foreach(string accountString in accountArray)
							{
								OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, versionString,  entityString,organizationString,  accountString, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");


							}

						}

					}
				}
			}
		}
	}
	OLAPCommitCellWriteBuffer(buffer);
	return true;
}"	1	0A29D94C-EE7B-456E-8383-AF88E37B0240	If the user adds accounts to a step which already has version/entity combinations assigned to it, the process spreads the change to all the combinations	1	1	1	1542	NULL	0	45708.67506	0	0
7D57788A-6F49-43B7-9343-60013188BEC6	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_GetCellNotes	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""return xml with count of notes for accounts/times"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The server to connect to."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""topOrganization"" parameter-type=""string"" parameter-description=""Top ogranization for data area create"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""accoutnElements"" parameter-type=""string"" parameter-description=""Csv list of BPDACOUNT elemetns"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""timeElements"" parameter-type=""string"" parameter-description=""Csv list of BPDTIME elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""tuple"" parameter-type=""string"" parameter-description=""Csv list of other elements for data area create"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


string BAP_GetCellNotes(string server, string topOrganization, string accoutnElements, string timeElements, string tuple)
@Description: ""Perform assumtions in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[topOrganization]: ""Top ogranization for data area create"";
@Parameter[accoutnElements]: ""Csv list of BPDACOUNT elemetns"";
@Parameter[timeElements]: ""Csv list of BPDTIME elements"";
@Parameter[tuple]: ""Csv list of other elements for data area create"";
@Returns: ""return xml with count of notes for accounts/times"";
{
	string functionName = ""BAP_GetCellNotes:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return GetCellNotes_Internal(connection, topOrganization, accoutnElements, timeElements, tuple);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return """";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


string BAP_GetCellNotes(string server, string topOrganization, string accoutnElements, string timeElements, string tuple)
@Description: ""Perform assumtions in add hoc reports."";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""The server to connect to."";
@Parameter[topOrganization]: ""Top ogranization for data area create"";
@Parameter[accoutnElements]: ""Csv list of BPDACOUNT elemetns"";
@Parameter[timeElements]: ""Csv list of BPDTIME elements"";
@Parameter[tuple]: ""Csv list of other elements for data area create"";
@Returns: ""return xml with count of notes for accounts/times"";
{
	string functionName = ""BAP_GetCellNotes:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		
		return GetCellNotes_Internal(connection, topOrganization, accoutnElements, timeElements, tuple);

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	// This is only here because AppEngine won't compile unless it is.
	return """";
}"	1	2BCB8F08-F3D2-4631-8FE2-96D13B6D373C	Perform assumtions in add hoc reports.	1	1	1	1543	NULL	0	45708.67508	0	0
3D0C9BD5-6E35-4144-9179-917400624FC3	CD491758-D9DF-4002-94C8-8006E1855F86	BAP_SubPlanAccountActivation	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if script was successful, otherwise false"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""Configuration Set UN to be used"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""accountUN"" parameter-type=""string"" parameter-description=""Account UN to be used"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""subPlanAccountParameterUN"" parameter-type=""string"" parameter-description=""UN of parameter element, where account should be activated/deactivated"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""activation"" parameter-type=""bool"" parameter-description=""TRUE for activation, FALSE for deactivation"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_SubPlanAccountActivation(string database, string cycleUN, string accountUN, string subPlanAccountParameterUN, bool activation)
@Description: ""Activate of deactivate children of account in given Configuration Set for subplan represented by aporameter element"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to be used."";
@Parameter[cycleUN]: ""Configuration Set UN to be used"";
@Parameter[accountUN]: ""Account UN to be used"";
@Parameter[subPlanAccountParameterUN]: ""UN of parameter element, where account should be activated/deactivated"";
@Parameter[activation]: ""TRUE for activation, FALSE for deactivation"";
@Returns: ""true if script was successful, otherwise false"";
{
	string functionName = ""BAP_SubPlanAccountActivation:"";
	string errorMessage = """";
	int errorCode = 0;

	string cube = ""BPCCONFIG_MAIN"";
	string accountDimension = ""BPDACCOUNT"";
	string parameterDimension = ""BPDPARAMETER"";
	string NA = ""N.A."";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		accountUN=""[BPDACCOUNT].[L110400].[1]"";
		subPlanAccountParameterUN=""[BPDPARAMETER].[SUBPLAN_WFB_ACC_ACTIVE].[1]"";*/

		string cycle = ResolveUniqueName(connection, cycleUN);
		string account = ResolveUniqueName(connection, accountUN);
		string subPlanAccountParameter = ResolveUniqueName(connection, subPlanAccountParameterUN);

		OLAPElement parameterElement = OLAPGetDimensionElement(connection, parameterDimension , subPlanAccountParameter);
		OLAPElementList paramParentList = OLAPGetParentElementList(connection, parameterElement);
		StringList paramParentListStringList = ToStringList(paramParentList);


		OLAPElement accountElement = OLAPGetDimensionElement(connection, accountDimension , account);
		bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);
		StringArray accountArray = CreateStringArray();
		
		if(baseAccountElement)
		{
			Append(accountArray, account);
		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,accountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);
			foreach(string acc in accountStringListHelp)
			{
				Append(accountArray, acc);
			}
		}

		foreach(string acc in accountArray)
		{

			if(activation)
			{
				double checkParent = OLAPCellReadNumber(connection, cube, 1.0, cycle, NA,NA,NA,acc,NA, GetElementByIndex(paramParentListStringList, 0),""Value"");

				if(checkParent == 0)
				{
					OLAPCellWriteBufferWriteNumber(buffer, cube, 1, cycle,NA,NA,NA,acc,NA,subPlanAccountParameter,""Value"" );
				}
			}
			else
			{
				double check = OLAPCellReadNumber(connection, cube, 1.0, cycle, NA,NA,NA,acc,NA, subPlanAccountParameter,""Value"");
				if(check == 1)
				{
					OLAPCellWriteBufferDeleteCell(buffer, cube,cycle,NA,NA,NA,acc,NA,subPlanAccountParameter,""Value"" );
				}
			}

		}

		OLAPCommitCellWriteBuffer(buffer);
		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAP_SubPlanAccountActivation(string database, string cycleUN, string accountUN, string subPlanAccountParameterUN, bool activation)
@Description: ""Activate of deactivate children of account in given Configuration Set for subplan represented by aporameter element"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to be used."";
@Parameter[cycleUN]: ""Configuration Set UN to be used"";
@Parameter[accountUN]: ""Account UN to be used"";
@Parameter[subPlanAccountParameterUN]: ""UN of parameter element, where account should be activated/deactivated"";
@Parameter[activation]: ""TRUE for activation, FALSE for deactivation"";
@Returns: ""true if script was successful, otherwise false"";
{
	string functionName = ""BAP_SubPlanAccountActivation:"";
	string errorMessage = """";
	int errorCode = 0;

	string cube = ""BPCCONFIG_MAIN"";
	string accountDimension = ""BPDACCOUNT"";
	string parameterDimension = ""BPDPARAMETER"";
	string NA = ""N.A."";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycleUN= ""[BPDCYCLE].[CYCLE_001].[1]"";
		accountUN=""[BPDACCOUNT].[L110400].[1]"";
		subPlanAccountParameterUN=""[BPDPARAMETER].[SUBPLAN_WFB_ACC_ACTIVE].[1]"";*/

		string cycle = ResolveUniqueName(connection, cycleUN);
		string account = ResolveUniqueName(connection, accountUN);
		string subPlanAccountParameter = ResolveUniqueName(connection, subPlanAccountParameterUN);

		OLAPElement parameterElement = OLAPGetDimensionElement(connection, parameterDimension , subPlanAccountParameter);
		OLAPElementList paramParentList = OLAPGetParentElementList(connection, parameterElement);
		StringList paramParentListStringList = ToStringList(paramParentList);


		OLAPElement accountElement = OLAPGetDimensionElement(connection, accountDimension , account);
		bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);
		StringArray accountArray = CreateStringArray();
		
		if(baseAccountElement)
		{
			Append(accountArray, account);
		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,accountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);
			foreach(string acc in accountStringListHelp)
			{
				Append(accountArray, acc);
			}
		}

		foreach(string acc in accountArray)
		{

			if(activation)
			{
				double checkParent = OLAPCellReadNumber(connection, cube, 1.0, cycle, NA,NA,NA,acc,NA, GetElementByIndex(paramParentListStringList, 0),""Value"");

				if(checkParent == 0)
				{
					OLAPCellWriteBufferWriteNumber(buffer, cube, 1, cycle,NA,NA,NA,acc,NA,subPlanAccountParameter,""Value"" );
				}
			}
			else
			{
				double check = OLAPCellReadNumber(connection, cube, 1.0, cycle, NA,NA,NA,acc,NA, subPlanAccountParameter,""Value"");
				if(check == 1)
				{
					OLAPCellWriteBufferDeleteCell(buffer, cube,cycle,NA,NA,NA,acc,NA,subPlanAccountParameter,""Value"" );
				}
			}

		}

		OLAPCommitCellWriteBuffer(buffer);
		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	89602021-B5F9-4051-B532-380BDB146BE7	Activate of deactivate children of account in given Configuration Set for subplan represented by aporameter element	1	1	1	1544	NULL	0	45708.67508	0	0
F05985A2-9836-458E-A7E8-BC06533B6BB4	CD491758-D9DF-4002-94C8-8006E1855F86	BAPActivateAccountCostcentre	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""Return 0 process was sucessfull"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""step"" parameter-type=""string"" parameter-description=""The step element to fill."" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPActivateAccountCostcentre(string Database, string Ticket, string cycle, string entity, string  version,string account, string step)
@Description: ""Activate organizations, for base and consolidated account"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[step]: ""The step element to fill."";
@Returns: ""Return 0 process was sucessfull"";
{
	LogInformation(""BAPActivateAccountWithCostcentre: Starting process"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string AcountConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string accountDimension = ""BPDACCOUNT"";
	string organizationDimension= ""BPDORGANIZATION"";
	string parameterElement= ""SUBPLAN_FINANCE_ACC_ACTIVE"";
	string totalOrganizationElement= ""TOTAL_ORGANIZATION"";
	string NA = ""N.A."";

	

	cycle = ResolveUniqueName(connection, cycle);
	entity = ResolveUniqueName(connection, entity);
	account = ResolveUniqueName(connection, account);
	step = ResolveUniqueName(connection, step);
	version = ResolveUniqueName(connection, version);
	

	OLAPElement accountElement = OLAPGetDimensionElement(connection, accountDimension, account);
	bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);



	OLAPDataArea target = OLAPCreateDataArea(connection, AcountConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entity,OlapDataAreaBCells, account,step,parameterElement, ""Value"");

	OLAPDeleteDataArea(target);

	if (baseAccountElement)
	{
		OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
		foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
		{
			double value = OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,organizationfill, NA, NA, parameterElement, ""Value"");
			WriteLine(value);
			OLAPCellWriteNumber(connection, AcountConfigurationCube,value, cycle,version,  entity,organizationfill,account, step, parameterElement, ""Value"");
		}
	}
	else
	{
		foreach (OLAPElement accountfill in OLAPGetChildElementList(connection, accountDimension, accountElement, true))
		{
			if(OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,NA, accountfill, step, parameterElement, ""Value"")== 1.0)
			{
				OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
				{

					double value = OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,organizationfill, NA, NA, parameterElement, ""Value"");
					WriteLine(value);
					OLAPCellWriteNumber(connection, AcountConfigurationCube,value, cycle,version,  entity,organizationfill,accountfill, step, parameterElement, ""Value"");
					

				}
			}
		}
	}

	LogInformation(""BAPActivateAccountWithCostcentre: Process is finished"");
	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPActivateAccountCostcentre(string Database, string Ticket, string cycle, string entity, string  version,string account, string step)
@Description: ""Activate organizations, for base and consolidated account"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[step]: ""The step element to fill."";
@Returns: ""Return 0 process was sucessfull"";
{
	LogInformation(""BAPActivateAccountWithCostcentre: Starting process"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string AcountConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string accountDimension = ""BPDACCOUNT"";
	string organizationDimension= ""BPDORGANIZATION"";
	string parameterElement= ""SUBPLAN_FINANCE_ACC_ACTIVE"";
	string totalOrganizationElement= ""TOTAL_ORGANIZATION"";
	string NA = ""N.A."";

	

	cycle = ResolveUniqueName(connection, cycle);
	entity = ResolveUniqueName(connection, entity);
	account = ResolveUniqueName(connection, account);
	step = ResolveUniqueName(connection, step);
	version = ResolveUniqueName(connection, version);
	

	OLAPElement accountElement = OLAPGetDimensionElement(connection, accountDimension, account);
	bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);



	OLAPDataArea target = OLAPCreateDataArea(connection, AcountConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entity,OlapDataAreaBCells, account,step,parameterElement, ""Value"");

	OLAPDeleteDataArea(target);

	if (baseAccountElement)
	{
		OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
		foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
		{
			double value = OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,organizationfill, NA, NA, parameterElement, ""Value"");
			WriteLine(value);
			OLAPCellWriteNumber(connection, AcountConfigurationCube,value, cycle,version,  entity,organizationfill,account, step, parameterElement, ""Value"");
		}
	}
	else
	{
		foreach (OLAPElement accountfill in OLAPGetChildElementList(connection, accountDimension, accountElement, true))
		{
			if(OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,NA, accountfill, step, parameterElement, ""Value"")== 1.0)
			{
				OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
				{

					double value = OLAPCellReadNumber(connection, AcountConfigurationCube, 1.0, cycle,version,  entity,organizationfill, NA, NA, parameterElement, ""Value"");
					WriteLine(value);
					OLAPCellWriteNumber(connection, AcountConfigurationCube,value, cycle,version,  entity,organizationfill,accountfill, step, parameterElement, ""Value"");
					

				}
			}
		}
	}

	LogInformation(""BAPActivateAccountWithCostcentre: Process is finished"");
	return 0;
}"	1	7B132B79-2107-4D3D-BDB9-BD892E4F77CB	Activate organizations, for base and consolidated account	1	1	1	1545	NULL	0	45708.67504	0	0
21D037BE-3273-4C9A-8FF8-937BCADC7C36	CD491758-D9DF-4002-94C8-8006E1855F86	BAPAdjustEntityConfig	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Place the return value description here"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to adjust entity configuration."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version to adjust entity configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""Empty or activate or deactivate intercompany to adjust entity configuration ."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Empty or activate or deactivate organization to adjust entity configuration ."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""Empty or activate or deactivate primarySegment to adjust entity configuration ."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""Empty or activate or deactivate secondarySegment to adjust entity configuration ."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""Empty or activate or deactivate tertiarySegment to adjust entity configuration ."" parameter-order=""8"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPAdjustEntityConfig(string database, string ticket, string cycle, string version,string intercompany, string organization, string primarySegment , string secondarySegment,
                             string tertiarySegment)
@Description: ""This process adjust entity configuration due to passed parameters"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to adjust entity configuration."";
@Parameter[version]: ""The version to adjust entity configuration"";
@Parameter[intercompany]: ""Empty or activate or deactivate intercompany to adjust entity configuration ."";
@Parameter[organization]: ""Empty or activate or deactivate organization to adjust entity configuration ."";
@Parameter[primarySegment]: ""Empty or activate or deactivate primarySegment to adjust entity configuration ."";
@Parameter[secondarySegment]: ""Empty or activate or deactivate secondarySegment to adjust entity configuration ."";
@Parameter[tertiarySegment]: ""Empty or activate or deactivate tertiarySegment to adjust entity configuration ."";
@Returns: ""Place the return value description here"";
{
	string functionName = ""BAPAdjustEntityConfig: "";
	string NA = ""N.A."";
	string entityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string segmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string cycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string organizationDimension= ""BPDORGANIZATION"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		LogInformation(""BAPAdjustEntityConfigs: Starting process"");

		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		tertiarySegment = ""deactivate"";*/
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);

		// find activated entities
		StringArray entityArray = CreateStringArray();

		OLAPElementList entityElements= OLAPGetChildElementList(connection, ""BPDENTITY"",""TOTAL_ENTITY"", true);
		StringList  entityElementsList = ToStringList(entityElements);

		foreach (string entityString in entityElementsList)
		{
			double active = OLAPCellReadNumber(connection, entityConfigurationCube,1.0, cycle,version, entityString,NA,NA, ""GLOBAL_ENTITY_ACTIVE"");
			if(active == 1)
			{
				Append(entityArray,entityString);
			}
		}

		OLAPElementList segment1Elements= OLAPGetChildElementList(connection, ""BPDPSEGMENT"",""TOTAL_SEGMENT"", true);
		OLAPElementList segment2Elements= OLAPGetChildElementList(connection, ""BPDSSEGMENT"",""TOTAL_SEGMENT"", true);
		OLAPElementList segment3Elements= OLAPGetChildElementList(connection, ""BPDTSEGMENT"",""TOTAL_SEGMENT"", true);
		
		StringList segment2StringsswithoutNA = CreateStringList();
		
		if (secondarySegment == ""deactivate"")
		{
			StringArray segment2ElementswithoutNA = CreateStringArray();
			Append(segment2ElementswithoutNA, """");

			foreach(OLAPElement segment in segment2Elements)
			{
				string segmentString = ToString(segment);
				if(segmentString != ""N.A."")
				{
					Append(segment2ElementswithoutNA, segmentString);
				}
			}
			segment2StringsswithoutNA = ToStringList(segment2ElementswithoutNA);
		}


		StringList segment3StringsswithoutNA = CreateStringList();
		
		if (tertiarySegment == ""deactivate"")
		{
			StringArray segment3ElementswithoutNA = CreateStringArray();
			Append(segment3ElementswithoutNA, """");

			foreach(OLAPElement segment in segment3Elements)
			{
				string segmentString = ToString(segment);
				if(segmentString != ""N.A."")
				{
					Append(segment3ElementswithoutNA, segmentString);
				}
			}
			segment3StringsswithoutNA = ToStringList(segment3ElementswithoutNA);
		}


		// do what is passesd from parameters

		foreach (string entityStringUsedInLoop  in entityArray)
		{
			if (intercompany == ""activate"")
			{
				OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1, cycle,version, NA,entityStringUsedInLoop, NA, ""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
			}

			if (intercompany == ""deactivate"")
			{
				OLAPCellWriteBufferDeleteCell(buffer, entityConfigurationCube,cycle,version, NA,entityStringUsedInLoop, NA, ""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
			}

			if (organization == ""activate"")
			{
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true))
				{
					if(ToString(organizationfill) != ""N.A."")
					{
						OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1.0, cycle, version, entityStringUsedInLoop,  NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
					}
				}
			}

			if (organization == ""deactivate"")
			{
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true))
				{
					OLAPCellWriteBufferDeleteCell(buffer,entityConfigurationCube, cycle, version, entityStringUsedInLoop,  NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				}
			}

			
			if (primarySegment == ""activate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
			}


			if (primarySegment == ""deactivate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					OLAPCellWriteBufferDeleteCell(buffer, segmentConfigurationCube,cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
			}

			if (secondarySegment == ""activate"")
			{

				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, NA, NA, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					foreach (OLAPElement segment2 in segment2Elements)
					{
						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , segment2, NA,""GLOBAL_SEGMENT_ACTIVE"");
					}
				}

			}

			if (secondarySegment == ""deactivate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					double segment1Active =  OLAPCellReadNumber(connection, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"",""GLOBAL_SEGMENT_ACTIVE"");

					if (segment1Active &gt;= 1)
					{
						foreach (OLAPElement segment2 in segment2Elements)
						{
							foreach (OLAPElement segment3 in segment3Elements)
							{
								OLAPCellWriteBufferDeleteCell(buffer, segmentConfigurationCube, cycle, version, entityStringUsedInLoop, segment1 , segment2, segment3,""GLOBAL_SEGMENT_ACTIVE"");
							}

						}

						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");

					}
				}
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3Elements, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
				OLAPCommitCellWriteBuffer(buffer);

				OLAPDataArea SourceDataDelete = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaOperatorNone, 0.0,
				                                                   cycle, version, entityStringUsedInLoop, segment1Elements, segment2StringsswithoutNA, segment3StringsswithoutNA, ""GLOBAL_SEGMENT_ACTIVE"");
				OLAPDeleteDataArea(SourceDataDelete);
			}

			if (tertiarySegment == ""activate"")
			{
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, NA, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string pssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					foreach (OLAPElement segment3 in segment3Elements)
					{
						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , pssegment, segment3,""GLOBAL_SEGMENT_ACTIVE"");
					}
				}

			}
			if (tertiarySegment == ""deactivate"")
			{
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3Elements, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string pssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");

					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , pssegment, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
				OLAPCommitCellWriteBuffer(buffer);

				OLAPDataArea SourceDataDelete = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaOperatorNone, 0.0,
				                                                   cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3StringsswithoutNA, ""GLOBAL_SEGMENT_ACTIVE"");
				OLAPDeleteDataArea(SourceDataDelete);
			}
		}

		DateTime datetime = CreateDateTime();
		string date = GetDateTimeAsString(datetime, ""yyyyMMdd"");
		double dateNumeric = ToDouble(date);

		OLAPCellWriteNumber(connection, cycleConfigurationCube, dateNumeric,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Value"");
		OLAPCellWriteString(connection, cycleConfigurationCube,date,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Text Value"");

		OLAPCommitCellWriteBuffer(buffer);
		LogInformation(""BAPAdjustEntityConfig: Process finished"");

		return ""true"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPAdjustEntityConfig(string database, string ticket, string cycle, string version,string intercompany, string organization, string primarySegment , string secondarySegment,
                             string tertiarySegment)
@Description: ""This process adjust entity configuration due to passed parameters"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to adjust entity configuration."";
@Parameter[version]: ""The version to adjust entity configuration"";
@Parameter[intercompany]: ""Empty or activate or deactivate intercompany to adjust entity configuration ."";
@Parameter[organization]: ""Empty or activate or deactivate organization to adjust entity configuration ."";
@Parameter[primarySegment]: ""Empty or activate or deactivate primarySegment to adjust entity configuration ."";
@Parameter[secondarySegment]: ""Empty or activate or deactivate secondarySegment to adjust entity configuration ."";
@Parameter[tertiarySegment]: ""Empty or activate or deactivate tertiarySegment to adjust entity configuration ."";
@Returns: ""Place the return value description here"";
{
	string functionName = ""BAPAdjustEntityConfig: "";
	string NA = ""N.A."";
	string entityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string segmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string cycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string organizationDimension= ""BPDORGANIZATION"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		LogInformation(""BAPAdjustEntityConfigs: Starting process"");

		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		tertiarySegment = ""deactivate"";*/
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);

		// find activated entities
		StringArray entityArray = CreateStringArray();

		OLAPElementList entityElements= OLAPGetChildElementList(connection, ""BPDENTITY"",""TOTAL_ENTITY"", true);
		StringList  entityElementsList = ToStringList(entityElements);

		foreach (string entityString in entityElementsList)
		{
			double active = OLAPCellReadNumber(connection, entityConfigurationCube,1.0, cycle,version, entityString,NA,NA, ""GLOBAL_ENTITY_ACTIVE"");
			if(active == 1)
			{
				Append(entityArray,entityString);
			}
		}

		OLAPElementList segment1Elements= OLAPGetChildElementList(connection, ""BPDPSEGMENT"",""TOTAL_SEGMENT"", true);
		OLAPElementList segment2Elements= OLAPGetChildElementList(connection, ""BPDSSEGMENT"",""TOTAL_SEGMENT"", true);
		OLAPElementList segment3Elements= OLAPGetChildElementList(connection, ""BPDTSEGMENT"",""TOTAL_SEGMENT"", true);
		
		StringList segment2StringsswithoutNA = CreateStringList();
		
		if (secondarySegment == ""deactivate"")
		{
			StringArray segment2ElementswithoutNA = CreateStringArray();
			Append(segment2ElementswithoutNA, """");

			foreach(OLAPElement segment in segment2Elements)
			{
				string segmentString = ToString(segment);
				if(segmentString != ""N.A."")
				{
					Append(segment2ElementswithoutNA, segmentString);
				}
			}
			segment2StringsswithoutNA = ToStringList(segment2ElementswithoutNA);
		}


		StringList segment3StringsswithoutNA = CreateStringList();
		
		if (tertiarySegment == ""deactivate"")
		{
			StringArray segment3ElementswithoutNA = CreateStringArray();
			Append(segment3ElementswithoutNA, """");

			foreach(OLAPElement segment in segment3Elements)
			{
				string segmentString = ToString(segment);
				if(segmentString != ""N.A."")
				{
					Append(segment3ElementswithoutNA, segmentString);
				}
			}
			segment3StringsswithoutNA = ToStringList(segment3ElementswithoutNA);
		}


		// do what is passesd from parameters

		foreach (string entityStringUsedInLoop  in entityArray)
		{
			if (intercompany == ""activate"")
			{
				OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1, cycle,version, NA,entityStringUsedInLoop, NA, ""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
			}

			if (intercompany == ""deactivate"")
			{
				OLAPCellWriteBufferDeleteCell(buffer, entityConfigurationCube,cycle,version, NA,entityStringUsedInLoop, NA, ""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
			}

			if (organization == ""activate"")
			{
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true))
				{
					if(ToString(organizationfill) != ""N.A."")
					{
						OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1.0, cycle, version, entityStringUsedInLoop,  NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
					}
				}
			}

			if (organization == ""deactivate"")
			{
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true))
				{
					OLAPCellWriteBufferDeleteCell(buffer,entityConfigurationCube, cycle, version, entityStringUsedInLoop,  NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				}
			}

			
			if (primarySegment == ""activate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
			}


			if (primarySegment == ""deactivate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					OLAPCellWriteBufferDeleteCell(buffer, segmentConfigurationCube,cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
			}

			if (secondarySegment == ""activate"")
			{

				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, NA, NA, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					foreach (OLAPElement segment2 in segment2Elements)
					{
						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , segment2, NA,""GLOBAL_SEGMENT_ACTIVE"");
					}
				}

			}

			if (secondarySegment == ""deactivate"")
			{
				foreach (OLAPElement segment1 in segment1Elements)
				{
					double segment1Active =  OLAPCellReadNumber(connection, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"",""GLOBAL_SEGMENT_ACTIVE"");

					if (segment1Active >= 1)
					{
						foreach (OLAPElement segment2 in segment2Elements)
						{
							foreach (OLAPElement segment3 in segment3Elements)
							{
								OLAPCellWriteBufferDeleteCell(buffer, segmentConfigurationCube, cycle, version, entityStringUsedInLoop, segment1 , segment2, segment3,""GLOBAL_SEGMENT_ACTIVE"");
							}

						}

						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, segment1 , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");

					}
				}
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3Elements, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , NA, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
				OLAPCommitCellWriteBuffer(buffer);

				OLAPDataArea SourceDataDelete = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaOperatorNone, 0.0,
				                                                   cycle, version, entityStringUsedInLoop, segment1Elements, segment2StringsswithoutNA, segment3StringsswithoutNA, ""GLOBAL_SEGMENT_ACTIVE"");
				OLAPDeleteDataArea(SourceDataDelete);
			}

			if (tertiarySegment == ""activate"")
			{
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, NA, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string pssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					foreach (OLAPElement segment3 in segment3Elements)
					{
						OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , pssegment, segment3,""GLOBAL_SEGMENT_ACTIVE"");
					}
				}

			}
			if (tertiarySegment == ""deactivate"")
			{
				OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3Elements, ""GLOBAL_SEGMENT_ACTIVE"");
				foreach (OLAPCell cell in SourceData)
				{
					string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string pssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");

					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube,1.0, cycle, version, entityStringUsedInLoop, ppsegment , pssegment, NA,""GLOBAL_SEGMENT_ACTIVE"");
				}
				OLAPCommitCellWriteBuffer(buffer);

				OLAPDataArea SourceDataDelete = OLAPCreateDataArea(connection, segmentConfigurationCube,
				                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaOperatorNone, 0.0,
				                                                   cycle, version, entityStringUsedInLoop, segment1Elements, segment2Elements, segment3StringsswithoutNA, ""GLOBAL_SEGMENT_ACTIVE"");
				OLAPDeleteDataArea(SourceDataDelete);
			}
		}

		DateTime datetime = CreateDateTime();
		string date = GetDateTimeAsString(datetime, ""yyyyMMdd"");
		double dateNumeric = ToDouble(date);

		OLAPCellWriteNumber(connection, cycleConfigurationCube, dateNumeric,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Value"");
		OLAPCellWriteString(connection, cycleConfigurationCube,date,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Text Value"");

		OLAPCommitCellWriteBuffer(buffer);
		LogInformation(""BAPAdjustEntityConfig: Process finished"");

		return ""true"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	848B2062-E965-4666-9F0E-9C0DF9244F74	This process adjust entity configuration due to passed parameters	1	1	1	1546	NULL	0	45708.67501	0	0
87B8C6EC-B48F-423C-B3DA-5EA1CBF0D85E	CD491758-D9DF-4002-94C8-8006E1855F86	BAPAssignAccountsToFPS	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True- script run correctly"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to configure."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The intercompany element in use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The Entity element in use"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""pno"" parameter-type=""string"" parameter-description=""Planning step element in use"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""Account element in use"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Organization element in use"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""BP_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""

bool BAPAssignAccountsToFPS(string database, string ticket, string cycle,string version, string entity, string pno,  string account, string organization)
@Description: ""For each activated account in BPCCONFIG main cube, from parameter account given planning step, assign active organizations"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[version]: ""The intercompany element in use"";
@Parameter[entity]: ""The Entity element in use"";
@Parameter[pno]: ""Planning step element in use"";
@Parameter[account]: ""Account element in use"";
@Parameter[organization]: ""Organization element in use"";
@Returns: ""True- script run correctly"";
{


	string functionName = ""BAPAssignAccountsToFPS:"";
	string NA = ""N.A."";
	string AccountDimension = ""BPDACCOUNT"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountConfigurationCube = ""BPCCONFIG_MAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";

	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version= ""[BPDVERSION].[BUDGET_01].[1]"";
		entity=""[BPDENTITY].[RU0001].[1]"";//RU0004
		pno=""[BPDNO].[PNO_001].[1]"";//BU3001
		account=""[BPDACCOUNT].[A110110].[1]"";//[BPDACCOUNT].[A110100].[1]
		organization=""[BPDORGANIZATION].[N.A.].[1]"";//[BPDORGANIZATION].[C_MA].[1],[BPDORGANIZATION].[C_PR].[1]*/

		
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		pno = ResolveUniqueName(connection, pno);

		StringList accountsFromParameter = BP_ElementStringSplit(connection,account);

		StringArray  accountArray = CreateStringArray();
		StringArray accountArrayDel = CreateStringArray();
		Append(accountArrayDel, """");
		//Append(accountArray, """");
		foreach(string accountFromStringList in accountsFromParameter)
		{
			OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, accountFromStringList);
			bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);

			if(baseAccountElement)
			{
				double valueBAcc = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, NA,  NA, NA,  accountFromStringList, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
				if(valueBAcc == 1)
				{
					Append(accountArray, accountFromStringList);
					Append(accountArrayDel, accountFromStringList);

				}
			}
			else
			{
				OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, accountFromStringList, true);
				StringList accountStringListHelp = ToStringList(accountList);

				foreach(string accountOLAPElement in accountStringListHelp )
				{
					double valueCAcc = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, NA,  NA, NA,  accountOLAPElement, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
					if(valueCAcc == 1)
					{
						Append(accountArray, accountOLAPElement);
						Append(accountArrayDel, accountOLAPElement);
					}

				}
			}
		}
		//StringList accountStringList = ToStringList(accountArray);

		StringArray organizationArray = CreateStringArray();
		Append(organizationArray, """");
		string orgToLoop = """";

		if(organization ==""[BPDORGANIZATION].[N.A.].[1]"")
		{
			orgToLoop = ""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";

		}
		else
		{
			orgToLoop = organization;

		}

		StringList organizationsFromParameter = BP_ElementStringSplit(connection,orgToLoop);
		int orgsCount = Count(organizationsFromParameter);

		foreach(string organizationFromStringList in organizationsFromParameter)
		{
			OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organizationFromStringList);
			bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);
			
			if(baseOrganizationElement)
			{
				Append(organizationArray, organizationFromStringList);
			}
			else
			{
				OLAPElementList organizationList = OLAPGetChildElementList(connection, organizationDimension, organizationFromStringList, true);
				StringList organizationStringListHelp = ToStringList(organizationList);

				foreach(string organizationOLAPElement in organizationStringListHelp )
				{
					Append(organizationArray, organizationOLAPElement );
				}
			}
		}

		StringList organizationStringList = ToStringList(organizationArray);
		StringList accountStringListDel = ToStringList(accountArrayDel);


		//bool isNAInOrgList = Contains(organizationStringList, ""N.A."");
		OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, accountConfigurationCube,
		                                                 OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                 OlapDataAreaOperatorNone, 0.0,
		                                                 cycle, version,  entity,  organizationStringList,accountStringListDel, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(targetDataArea);

		if(organization != ""[BPDORGANIZATION].[N.A.].[1]"" )
		{
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, EntityConfigurationCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             cycle, version,  entity,  NA, organizationStringList, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");

			foreach (OLAPCell cell in SourceData)
			{
				string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				double value = cell;
				if(pcostcenter != ""N.A."" )
				{
					if(value == 1 )
					{
						foreach (string accountInLoop in accountArray)
						{
							if(value ==1)
							{
								OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, version,  entity, pcostcenter,  accountInLoop, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
							}
						}
					}

				}
			}
		}
		else
		{
			foreach (string accountInLoop in accountArray)
			{
				OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, version,  entity, ""N.A."",  accountInLoop, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
			}
		}

		OLAPCommitCellWriteBuffer(buffer);
		return true;

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""

bool BAPAssignAccountsToFPS(string database, string ticket, string cycle,string version, string entity, string pno,  string account, string organization)
@Description: ""For each activated account in BPCCONFIG main cube, from parameter account given planning step, assign active organizations"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[version]: ""The intercompany element in use"";
@Parameter[entity]: ""The Entity element in use"";
@Parameter[pno]: ""Planning step element in use"";
@Parameter[account]: ""Account element in use"";
@Parameter[organization]: ""Organization element in use"";
@Returns: ""True- script run correctly"";
{


	string functionName = ""BAPAssignAccountsToFPS:"";
	string NA = ""N.A."";
	string AccountDimension = ""BPDACCOUNT"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountConfigurationCube = ""BPCCONFIG_MAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";

	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version= ""[BPDVERSION].[BUDGET_01].[1]"";
		entity=""[BPDENTITY].[RU0001].[1]"";//RU0004
		pno=""[BPDNO].[PNO_001].[1]"";//BU3001
		account=""[BPDACCOUNT].[A110110].[1]"";//[BPDACCOUNT].[A110100].[1]
		organization=""[BPDORGANIZATION].[N.A.].[1]"";//[BPDORGANIZATION].[C_MA].[1],[BPDORGANIZATION].[C_PR].[1]*/

		
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		pno = ResolveUniqueName(connection, pno);

		StringList accountsFromParameter = BP_ElementStringSplit(connection,account);

		StringArray  accountArray = CreateStringArray();
		StringArray accountArrayDel = CreateStringArray();
		Append(accountArrayDel, """");
		//Append(accountArray, """");
		foreach(string accountFromStringList in accountsFromParameter)
		{
			OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, accountFromStringList);
			bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);

			if(baseAccountElement)
			{
				double valueBAcc = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, NA,  NA, NA,  accountFromStringList, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
				if(valueBAcc == 1)
				{
					Append(accountArray, accountFromStringList);
					Append(accountArrayDel, accountFromStringList);

				}
			}
			else
			{
				OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, accountFromStringList, true);
				StringList accountStringListHelp = ToStringList(accountList);

				foreach(string accountOLAPElement in accountStringListHelp )
				{
					double valueCAcc = OLAPCellReadNumber(connection, accountConfigurationCube, 1.0, cycle, NA,  NA, NA,  accountOLAPElement, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
					if(valueCAcc == 1)
					{
						Append(accountArray, accountOLAPElement);
						Append(accountArrayDel, accountOLAPElement);
					}

				}
			}
		}
		//StringList accountStringList = ToStringList(accountArray);

		StringArray organizationArray = CreateStringArray();
		Append(organizationArray, """");
		string orgToLoop = """";

		if(organization ==""[BPDORGANIZATION].[N.A.].[1]"")
		{
			orgToLoop = ""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";

		}
		else
		{
			orgToLoop = organization;

		}

		StringList organizationsFromParameter = BP_ElementStringSplit(connection,orgToLoop);
		int orgsCount = Count(organizationsFromParameter);

		foreach(string organizationFromStringList in organizationsFromParameter)
		{
			OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organizationFromStringList);
			bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);
			
			if(baseOrganizationElement)
			{
				Append(organizationArray, organizationFromStringList);
			}
			else
			{
				OLAPElementList organizationList = OLAPGetChildElementList(connection, organizationDimension, organizationFromStringList, true);
				StringList organizationStringListHelp = ToStringList(organizationList);

				foreach(string organizationOLAPElement in organizationStringListHelp )
				{
					Append(organizationArray, organizationOLAPElement );
				}
			}
		}

		StringList organizationStringList = ToStringList(organizationArray);
		StringList accountStringListDel = ToStringList(accountArrayDel);


		//bool isNAInOrgList = Contains(organizationStringList, ""N.A."");
		OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, accountConfigurationCube,
		                                                 OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                 OlapDataAreaOperatorNone, 0.0,
		                                                 cycle, version,  entity,  organizationStringList,accountStringListDel, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(targetDataArea);

		if(organization != ""[BPDORGANIZATION].[N.A.].[1]"" )
		{
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, EntityConfigurationCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             cycle, version,  entity,  NA, organizationStringList, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");

			foreach (OLAPCell cell in SourceData)
			{
				string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				double value = cell;
				if(pcostcenter != ""N.A."" )
				{
					if(value == 1 )
					{
						foreach (string accountInLoop in accountArray)
						{
							if(value ==1)
							{
								OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, version,  entity, pcostcenter,  accountInLoop, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
							}
						}
					}

				}
			}
		}
		else
		{
			foreach (string accountInLoop in accountArray)
			{
				OLAPCellWriteBufferWriteNumber(buffer, accountConfigurationCube, 1.0, cycle, version,  entity, ""N.A."",  accountInLoop, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
			}
		}

		OLAPCommitCellWriteBuffer(buffer);
		return true;

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	4E3F1875-8F45-4BE5-BE25-05C6920E4F15	For each activated account in BPCCONFIG main cube, from parameter account given planning step, assign active organizations	1	1	1	1547	NULL	0	45708.67508	0	0
D3DEC085-B728-4141-BE01-8A84655A3291	CD491758-D9DF-4002-94C8-8006E1855F86	BAPAssignFPSToDuplicates	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure and ERROR:message in the case of unexpected errors"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Server"" parameter-type=""string"" parameter-description=""OLAP server and database to connect to, in the format server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""User credentials, as obtained from the AppStudio function GETTICKET()"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""Element of the CycleDimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""VersionUN"" parameter-type=""string"" parameter-description=""Element of the VersionDimension; multiples can be supplied using a comma-delimited list"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""EntityUN"" parameter-type=""string"" parameter-description=""Element of the EntityDimension"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""StepUN"" parameter-type=""string"" parameter-description=""Element of the NumberDimension; used to represent the planning steps"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ParameterUN"" parameter-type=""string"" parameter-description=""Element of the ParameterDimension, representing the setting to be set"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""Value"" parameter-type=""double"" parameter-description=""Value to be assigned to the specified parameter in the specified slice(s)"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""BP_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""

/*
void Test() {
	string cycleUN = ""CYCLE_001"";
	string versionUN = ""BUDGET_01"";
	string entityUN = ""RU0001"";
	string stepUN = ""PNO_001"";
	string parameterUN = """";

	string result = WB_CopyAllocationLine(""usalvwpsolap/Planning"", """", cycleUN, versionUN, entityUN, stepUN, paramterUN);
	Write(result);
}
 */


string BAPAssignFPSToDuplicates(
	string Server,
	string Ticket,
	string CycleUN,
	string VersionUN,
	string EntityUN,
	string StepUN,
	string ParameterUN,
	double Value
)
@Description: ""Process to set the specified parameter to 1"";
@Category: ""Budgeting and Planning"";
@Parameter[Server]: ""OLAP server and database to connect to, in the format server/database"";
@Parameter[Ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[CycleUN]: ""Element of the CycleDimension"";
@Parameter[VersionUN]: ""Element of the VersionDimension; multiples can be supplied using a comma-delimited list"";
@Parameter[EntityUN]: ""Element of the EntityDimension"";
@Parameter[StepUN]: ""Element of the NumberDimension; used to represent the planning steps"";
@Parameter[ParameterUN]: ""Element of the ParameterDimension, representing the setting to be set"";
@Parameter[Value]: ""Value to be assigned to the specified parameter in the specified slice(s)"";
@Returns: ""TRUE for success, FALSE for failure and ERROR:message in the case of unexpected errors"";
{
	string functionName = ""BAPAssignFPSToDuplicates: "";
	string errorMessage = """";
	int errorCode = 0;
	string result = ""TRUE"";


	try {
		DateTime startTime = CreateDateTime();
		LogDebug(functionName + ""CycleUN="" + CycleUN + "", VersionUN="" + VersionUN + "", EntityUN="" + EntityUN
		         + "", StepUN="" + StepUN + "", ParameterUN="" + ParameterUN);


		// Constants
		string CubeName = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		StringList versionList = CreateStringList();

		OLAPConnection connection = OLAPCreatePooledNamedConnection(Server);

		// Validate parameters
		CycleUN = BP_GetResolvedUniqueName(connection, CycleUN);
		if (CycleUN == """") {
			LogError(functionName + ""CycleUN is required"");
			return ""ERROR:CycleUN is required"";
		}

		if (VersionUN == """") {
			LogError(functionName + ""VersionUN is required"");
			return ""ERROR:VersionUN is required"";
		} else {
			// Handle VersionUN may be a comma-delimited list of unique names
			versionList = BP_ElementStringSplit(connection, VersionUN);
			Prepend(versionList, """"); // Mandatory for passing to OLAPCreateDataArea
		}

		EntityUN = BP_GetResolvedUniqueName(connection, EntityUN);
		if (EntityUN == """") {
			LogError(functionName + ""EntityUN is required"");
			return ""ERROR:EntityUN is required"";
		}

		StepUN = BP_GetResolvedUniqueName(connection, StepUN);
		if (StepUN == """") {
			LogError(functionName + ""StepUN is required"");
			return ""ERROR:StepUN is required"";
		}

		ParameterUN = BP_GetResolvedUniqueName(connection, ParameterUN);
		if (ParameterUN == """") {
			LogError(functionName + ""ParameterUN is required"");
			return ""ERROR:ParameterUN is required"";
		}


		// Define the data slice
		StringListList elements = CreateStringListList();
		Append(elements, ConvertToStringList(CycleUN));
		Append(elements, versionList);
		Append(elements, ConvertToStringList(EntityUN));
		Append(elements, ConvertToStringList(NA)); // BPDORGANIZATION
		Append(elements, ConvertToStringList(NA)); // BPDACCOUNT
		Append(elements, ConvertToStringList(StepUN));
		Append(elements, ConvertToStringList(ParameterUN));
		Append(elements, ConvertToStringList(""VALUE""));

		// Create a data area (not suppressing NULLs) and set each cell to Value
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, CubeName,
		                                           OlapDataAreaIncludeB,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           elements);
		foreach (OLAPCell cell in dataArea) {
			StringArray cellElements = OLAPCellGetElements(cell);
			OLAPCellWriteNumberDynamic(connection, CubeName, Value, cellElements);
		}

		
		// Done processing
		DateTime endTime = CreateDateTime();
		string duration = GetDurationAsString(startTime, endTime);
		LogDebug(functionName + ""Done in "" + duration + "" seconds"");
		
		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + errorMessage + "" ("" + errorCode + "")"";
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""

/*
void Test() {
	string cycleUN = ""CYCLE_001"";
	string versionUN = ""BUDGET_01"";
	string entityUN = ""RU0001"";
	string stepUN = ""PNO_001"";
	string parameterUN = """";

	string result = WB_CopyAllocationLine(""usalvwpsolap/Planning"", """", cycleUN, versionUN, entityUN, stepUN, paramterUN);
	Write(result);
}
 */


string BAPAssignFPSToDuplicates(
	string Server,
	string Ticket,
	string CycleUN,
	string VersionUN,
	string EntityUN,
	string StepUN,
	string ParameterUN,
	double Value
)
@Description: ""Process to set the specified parameter to 1"";
@Category: ""Budgeting and Planning"";
@Parameter[Server]: ""OLAP server and database to connect to, in the format server/database"";
@Parameter[Ticket]: ""User credentials, as obtained from the AppStudio function GETTICKET()"";
@Parameter[CycleUN]: ""Element of the CycleDimension"";
@Parameter[VersionUN]: ""Element of the VersionDimension; multiples can be supplied using a comma-delimited list"";
@Parameter[EntityUN]: ""Element of the EntityDimension"";
@Parameter[StepUN]: ""Element of the NumberDimension; used to represent the planning steps"";
@Parameter[ParameterUN]: ""Element of the ParameterDimension, representing the setting to be set"";
@Parameter[Value]: ""Value to be assigned to the specified parameter in the specified slice(s)"";
@Returns: ""TRUE for success, FALSE for failure and ERROR:message in the case of unexpected errors"";
{
	string functionName = ""BAPAssignFPSToDuplicates: "";
	string errorMessage = """";
	int errorCode = 0;
	string result = ""TRUE"";


	try {
		DateTime startTime = CreateDateTime();
		LogDebug(functionName + ""CycleUN="" + CycleUN + "", VersionUN="" + VersionUN + "", EntityUN="" + EntityUN
		         + "", StepUN="" + StepUN + "", ParameterUN="" + ParameterUN);


		// Constants
		string CubeName = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		StringList versionList = CreateStringList();

		OLAPConnection connection = OLAPCreatePooledNamedConnection(Server);

		// Validate parameters
		CycleUN = BP_GetResolvedUniqueName(connection, CycleUN);
		if (CycleUN == """") {
			LogError(functionName + ""CycleUN is required"");
			return ""ERROR:CycleUN is required"";
		}

		if (VersionUN == """") {
			LogError(functionName + ""VersionUN is required"");
			return ""ERROR:VersionUN is required"";
		} else {
			// Handle VersionUN may be a comma-delimited list of unique names
			versionList = BP_ElementStringSplit(connection, VersionUN);
			Prepend(versionList, """"); // Mandatory for passing to OLAPCreateDataArea
		}

		EntityUN = BP_GetResolvedUniqueName(connection, EntityUN);
		if (EntityUN == """") {
			LogError(functionName + ""EntityUN is required"");
			return ""ERROR:EntityUN is required"";
		}

		StepUN = BP_GetResolvedUniqueName(connection, StepUN);
		if (StepUN == """") {
			LogError(functionName + ""StepUN is required"");
			return ""ERROR:StepUN is required"";
		}

		ParameterUN = BP_GetResolvedUniqueName(connection, ParameterUN);
		if (ParameterUN == """") {
			LogError(functionName + ""ParameterUN is required"");
			return ""ERROR:ParameterUN is required"";
		}


		// Define the data slice
		StringListList elements = CreateStringListList();
		Append(elements, ConvertToStringList(CycleUN));
		Append(elements, versionList);
		Append(elements, ConvertToStringList(EntityUN));
		Append(elements, ConvertToStringList(NA)); // BPDORGANIZATION
		Append(elements, ConvertToStringList(NA)); // BPDACCOUNT
		Append(elements, ConvertToStringList(StepUN));
		Append(elements, ConvertToStringList(ParameterUN));
		Append(elements, ConvertToStringList(""VALUE""));

		// Create a data area (not suppressing NULLs) and set each cell to Value
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, CubeName,
		                                           OlapDataAreaIncludeB,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           elements);
		foreach (OLAPCell cell in dataArea) {
			StringArray cellElements = OLAPCellGetElements(cell);
			OLAPCellWriteNumberDynamic(connection, CubeName, Value, cellElements);
		}

		
		// Done processing
		DateTime endTime = CreateDateTime();
		string duration = GetDurationAsString(startTime, endTime);
		LogDebug(functionName + ""Done in "" + duration + "" seconds"");
		
		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: "" + errorMessage + "" ("" + errorCode + "")"";
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	C03E2908-8080-42CA-A7AA-868D6F7789CB	Process to set the specified parameter to 1	1	1	1	1548	NULL	0	45708.67501	0	0
63E61FDF-5F4D-472C-81C9-ACE6F1126922	CD491758-D9DF-4002-94C8-8006E1855F86	BAPAssumptions_ChangeSourceAccount	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true for ok"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Configuration set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""currentSourceAccount"" parameter-type=""string"" parameter-description=""The current source account to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""newSourceAccount"" parameter-type=""string"" parameter-description=""The current source account where values should be copied"" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPAssumptions_ChangeSourceAccount(string Database, string Ticket, string cycle, string version, string entity, string currentSourceAccount, string newSourceAccount)

@Description: ""Process used in define dependent account report, when user change definition of account, from en tagret account into another."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currentSourceAccount]: ""The current source account to be used."";
@Parameter[newSourceAccount]: ""The current source account where values should be copied"";
@Returns: ""true for ok"";
{

	LogInformation(""BAPAssumptions_ChangeSourceAccount: Started"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	currentSourceAccount = ResolveUniqueName(connection, currentSourceAccount);
	newSourceAccount= ResolveUniqueName(connection, newSourceAccount);

	string AccountDimension = ""BPDACCOUNT"";
	string assumptionsConfigurationCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";


	OLAPDataArea TargetData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle,  version, entity, newSourceAccount, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle, version, entity, currentSourceAccount, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceData)
	{
		string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
		
		string value = OLAPCellReadString(connection, assumptionsConfigurationCube, NA, cycle, version, entity, currentSourceAccount, ppremises);
		
		
		OLAPCellWriteString(connection, assumptionsConfigurationCube, value, NA, cycle, version, entity, newSourceAccount, ppremises);
	}

	OLAPDeleteDataArea(SourceData);

	LogInformation(""BAPAssumptions_ChangeSourceAccount: Finished"");

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPAssumptions_ChangeSourceAccount(string Database, string Ticket, string cycle, string version, string entity, string currentSourceAccount, string newSourceAccount)

@Description: ""Process used in define dependent account report, when user change definition of account, from en tagret account into another."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currentSourceAccount]: ""The current source account to be used."";
@Parameter[newSourceAccount]: ""The current source account where values should be copied"";
@Returns: ""true for ok"";
{

	LogInformation(""BAPAssumptions_ChangeSourceAccount: Started"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	currentSourceAccount = ResolveUniqueName(connection, currentSourceAccount);
	newSourceAccount= ResolveUniqueName(connection, newSourceAccount);

	string AccountDimension = ""BPDACCOUNT"";
	string assumptionsConfigurationCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";


	OLAPDataArea TargetData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle,  version, entity, newSourceAccount, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle, version, entity, currentSourceAccount, OlapDataAreaBCells);


	foreach (OLAPCell cell in SourceData)
	{
		string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
		
		string value = OLAPCellReadString(connection, assumptionsConfigurationCube, NA, cycle, version, entity, currentSourceAccount, ppremises);
		
		
		OLAPCellWriteString(connection, assumptionsConfigurationCube, value, NA, cycle, version, entity, newSourceAccount, ppremises);
	}

	OLAPDeleteDataArea(SourceData);

	LogInformation(""BAPAssumptions_ChangeSourceAccount: Finished"");

	return true;
}"	1	F1F6AB4E-726B-4407-A28A-8F1C9DE9F106	Process used in define dependent account report, when user change definition of account, from en tagret account into another.	1	1	1	1549	NULL	0	45708.67501	0	0
BC8E409E-255E-441F-80EE-07F0C98FA979	CD491758-D9DF-4002-94C8-8006E1855F86	BAPAssumptions_DeleteSourceAccount	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true for ok"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Currently selected Configuration set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""currentSourceAccount"" parameter-type=""string"" parameter-description=""The current source account to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""relatedAccount"" parameter-type=""string"" parameter-description=""All if whole definiton should be deleted, and UN of related account if only defintion below related account should be deleted"" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPAssumptions_DeleteSourceAccount(string Database, string Ticket, string cycle, string version, string entity, string currentSourceAccount, string relatedAccount)

@Description: ""Process used in define dependent account report, when user delete definition of account, from en tagret account into another.."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currentSourceAccount]: ""The current source account to be used."";
@Parameter[relatedAccount]: ""All if whole definiton should be deleted, and UN of related account if only defintion below related account should be deleted"";
@Returns: ""true for ok"";
{

	LogInformation(""BAPAssumptions_DeleteSourceAccount: Started"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	version = ""[BPDVERSION].[BUDGET_01].[1]"";
	entity= ""[BPDENTITY].[RU0002].[1]"";
	currentSourceAccount= ""[BPDACCOUNT].[I000000].[1]"";
	relatedAccount= ""All"";//[BPDPREMISE].[ACCOUNT_2].[1]*/




	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	currentSourceAccount = ResolveUniqueName(connection, currentSourceAccount);

	string AccountDimension = ""BPDACCOUNT"";
	string dimensionName = ""BPDPREMISE"";
	string assumptionsConfigurationCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";

	StringArray elementsArray = CreateStringArray();
	OLAPElementList elementList = CreateOLAPElementList();

	Append(elementsArray, """");
	if(relatedAccount == ""All"")
	{
		elementList = OLAPGetElementList(connection, dimensionName,  false);
	}
	else
	{
		relatedAccount = ResolveUniqueName(connection, relatedAccount);
		elementList = OLAPGetChildElementList(connection, dimensionName, relatedAccount, false);

	}

	StringList elementListHelp = ToStringList(elementList);

	foreach(string elementHelp in elementListHelp )
	{
		Append(elementsArray, elementHelp );
	}

	
	StringList elementStringList = ToStringList(elementsArray);



	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle, version, entity, currentSourceAccount, elementStringList);



	OLAPDeleteDataArea(SourceData);

	LogInformation(""BAPAssumptions_DeleteSourceAccount: Finished"");

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPAssumptions_DeleteSourceAccount(string Database, string Ticket, string cycle, string version, string entity, string currentSourceAccount, string relatedAccount)

@Description: ""Process used in define dependent account report, when user delete definition of account, from en tagret account into another.."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currentSourceAccount]: ""The current source account to be used."";
@Parameter[relatedAccount]: ""All if whole definiton should be deleted, and UN of related account if only defintion below related account should be deleted"";
@Returns: ""true for ok"";
{

	LogInformation(""BAPAssumptions_DeleteSourceAccount: Started"");

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	version = ""[BPDVERSION].[BUDGET_01].[1]"";
	entity= ""[BPDENTITY].[RU0002].[1]"";
	currentSourceAccount= ""[BPDACCOUNT].[I000000].[1]"";
	relatedAccount= ""All"";//[BPDPREMISE].[ACCOUNT_2].[1]*/




	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	currentSourceAccount = ResolveUniqueName(connection, currentSourceAccount);

	string AccountDimension = ""BPDACCOUNT"";
	string dimensionName = ""BPDPREMISE"";
	string assumptionsConfigurationCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";

	StringArray elementsArray = CreateStringArray();
	OLAPElementList elementList = CreateOLAPElementList();

	Append(elementsArray, """");
	if(relatedAccount == ""All"")
	{
		elementList = OLAPGetElementList(connection, dimensionName,  false);
	}
	else
	{
		relatedAccount = ResolveUniqueName(connection, relatedAccount);
		elementList = OLAPGetChildElementList(connection, dimensionName, relatedAccount, false);

	}

	StringList elementListHelp = ToStringList(elementList);

	foreach(string elementHelp in elementListHelp )
	{
		Append(elementsArray, elementHelp );
	}

	
	StringList elementStringList = ToStringList(elementsArray);



	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, assumptionsConfigurationCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             NA, cycle, version, entity, currentSourceAccount, elementStringList);



	OLAPDeleteDataArea(SourceData);

	LogInformation(""BAPAssumptions_DeleteSourceAccount: Finished"");

	return true;
}"	1	C4114545-3CE3-4089-AFAF-237E8B6A4797	Process used in define dependent account report, when user delete definition of account, from en tagret account into another..	1	1	1	1550	NULL	0	45708.67507	0	0
E4A1DE4C-9EC4-4D52-972A-097CE525DED6	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateCostEntry	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Currently selected Configuration set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""accountFactor"" parameter-type=""string"" parameter-description=""The account factor for the account."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""costGroup"" parameter-type=""string"" parameter-description=""The cost group element to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""costPosition"" parameter-type=""string"" parameter-description=""The cost position element to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""isPercent"" parameter-type=""bool"" parameter-description=""If true, the factor is provided as percent, otherwise it is an absolute value."" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""20"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateCostEntry(
	string database, string ticket, string time, string cycle, string version,string entity, string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string accountFactor, string account, string primarySegment, string secondarySegment, string tertiarySegment,
	string costGroup, string costPosition, bool isPercent, double value)
@Description: ""Write back the entered cost factor for the used cost position and calculate the depending cost value and cash movement and opening balance."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[accountFactor]: ""The account factor for the account."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[costPosition]: ""The cost position element to be used."";
@Parameter[isPercent]: ""If true, the factor is provided as percent, otherwise it is an absolute value."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateCostEntry: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	// get native IDs from XMLA names
	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	accountFactor = ResolveUniqueName(connection, accountFactor);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);
	costPosition = ResolveUniqueName(connection, costPosition);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
	string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	double activeProduction = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_MANUF"", ""Value"");
	LogDebug(costAccount);
	LogDebug(liabilitiesAccount);
	LogDebug(cashAccount);

	if (StringLength(costAccount) == 0 or StringLength(liabilitiesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BAPCalculateCostEntry: An error has occured the configuration of the cost accounts is inclomplete."");
		return -1;
	}

	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);

	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	costAccount = ResolveUniqueName(connection, costAccount);
	liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);

	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	WriteLine(baseTimeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		
		// read default value and calculate difference
		double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"",stepRead, entity, intercompany, organization, accountFactor,currencyRead, NA , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValue = value - defaultValue;
		
		OLAPCellWriteNumber(connection, MainCube, differenceValue, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"", stepWrite, entity, intercompany, organization, accountFactor,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double costs = 0;
		if (isPercent)
		{
			double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany,  organization,""REVENUE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costs = (revenue / 100.0) * value * -1;
		}
		else
		{
			double quantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costs = quantity * value * -1;
		}

		OLAPCellWriteNumber(connection, MainCube, costs, currentMonth, cycle, version, ""CHANGE_SALES_VALUES_DEFAULTS"",stepWrite, entity,intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead, entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double oldCosts = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization,costAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = RoundDecimals(daysLiabilities / 30, 0);
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset &gt; 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		LogDebug(""BAPCalculateCostEntry: Month: "" + laggedMonth + "" Element: "" + lagElement);
		LogDebug(""BAPCalculateCostEntry: Previous cost value: "" + oldCosts);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"",stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, costs , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs * -1 , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs , laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		//Calculated COST_PER_UNIT
		double totalQuantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double totalCost = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""COSTS"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double costPerUnit = 0;
		
		if(totalQuantity != 0)
		{
			costPerUnit = totalCost/totalQuantity * -1;
		}
		
		OLAPCellWriteNumber(connection, MainCube, costPerUnit, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""COST_PER_UNIT"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		//Calculation of Production planning
		if (activeProduction == 1)
		{
			double quantityOfSales = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double productionVolume = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""PRODUCTION_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costPerUnit = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""COST_PER_UNIT"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			double changeOfInventoryVolume = productionVolume - quantityOfSales;
			double changeOfInventory = changeOfInventoryVolume * costPerUnit;
			
			OLAPCellWriteNumber(connection, MainCube, changeOfInventoryVolume, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""CHANGE_INVENTORY_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""CHANGE_INVENTORY"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, inventoryAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BAPCalculateCostEntry: Calculating OB for "" + lastYearTotal + "" write to: "" + currentYearFirstMonth);

				double lastYearMovementLiabilitiesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementLiabilitiesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingLiabilitiesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingLiabilitiesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceLiabilitiesIncrease = lastYearMovementLiabilitiesIncrease + lastYearClosingLiabilitiesIncrease;
				double closingBalanceLiabilitiesDecrease = lastYearMovementLiabilitiesDecrease + lastYearClosingLiabilitiesDecrease;
				double closingCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilitiesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilitiesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
				if (activeProduction == 1)
				{
					double lastYearMovementFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, finishedGoodsAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					
					double closingBalanceFinishedGoods = lastYearMovementFinishedGoods + lastYearClosingFinishedGoods;
					
					OLAPCellWriteNumber(connection, MainCube, closingBalanceFinishedGoods, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				}
				
			}
		}
	}
	
	LogInformation(""BAPCalculateCostEntry: Process complete"");

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateCostEntry(
	string database, string ticket, string time, string cycle, string version,string entity, string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string accountFactor, string account, string primarySegment, string secondarySegment, string tertiarySegment,
	string costGroup, string costPosition, bool isPercent, double value)
@Description: ""Write back the entered cost factor for the used cost position and calculate the depending cost value and cash movement and opening balance."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[accountFactor]: ""The account factor for the account."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[costPosition]: ""The cost position element to be used."";
@Parameter[isPercent]: ""If true, the factor is provided as percent, otherwise it is an absolute value."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateCostEntry: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	// get native IDs from XMLA names
	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	accountFactor = ResolveUniqueName(connection, accountFactor);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);
	costPosition = ResolveUniqueName(connection, costPosition);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
	string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	double activeProduction = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_MANUF"", ""Value"");
	LogDebug(costAccount);
	LogDebug(liabilitiesAccount);
	LogDebug(cashAccount);

	if (StringLength(costAccount) == 0 or StringLength(liabilitiesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BAPCalculateCostEntry: An error has occured the configuration of the cost accounts is inclomplete."");
		return -1;
	}

	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);

	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	costAccount = ResolveUniqueName(connection, costAccount);
	liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);

	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	WriteLine(baseTimeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		
		// read default value and calculate difference
		double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"",stepRead, entity, intercompany, organization, accountFactor,currencyRead, NA , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValue = value - defaultValue;
		
		OLAPCellWriteNumber(connection, MainCube, differenceValue, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"", stepWrite, entity, intercompany, organization, accountFactor,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double costs = 0;
		if (isPercent)
		{
			double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany,  organization,""REVENUE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costs = (revenue / 100.0) * value * -1;
		}
		else
		{
			double quantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costs = quantity * value * -1;
		}

		OLAPCellWriteNumber(connection, MainCube, costs, currentMonth, cycle, version, ""CHANGE_SALES_VALUES_DEFAULTS"",stepWrite, entity,intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead, entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double oldCosts = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization,costAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = RoundDecimals(daysLiabilities / 30, 0);
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset > 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		LogDebug(""BAPCalculateCostEntry: Month: "" + laggedMonth + "" Element: "" + lagElement);
		LogDebug(""BAPCalculateCostEntry: Previous cost value: "" + oldCosts);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"",stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, costs , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs * -1 , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs , laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, costs, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		//Calculated COST_PER_UNIT
		double totalQuantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double totalCost = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""COSTS"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double costPerUnit = 0;
		
		if(totalQuantity != 0)
		{
			costPerUnit = totalCost/totalQuantity * -1;
		}
		
		OLAPCellWriteNumber(connection, MainCube, costPerUnit, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""COST_PER_UNIT"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		//Calculation of Production planning
		if (activeProduction == 1)
		{
			double quantityOfSales = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double productionVolume = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""PRODUCTION_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costPerUnit = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""COST_PER_UNIT"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			double changeOfInventoryVolume = productionVolume - quantityOfSales;
			double changeOfInventory = changeOfInventoryVolume * costPerUnit;
			
			OLAPCellWriteNumber(connection, MainCube, changeOfInventoryVolume, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""CHANGE_INVENTORY_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization, ""CHANGE_INVENTORY"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, inventoryAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BAPCalculateCostEntry: Calculating OB for "" + lastYearTotal + "" write to: "" + currentYearFirstMonth);

				double lastYearMovementLiabilitiesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementLiabilitiesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingLiabilitiesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingLiabilitiesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceLiabilitiesIncrease = lastYearMovementLiabilitiesIncrease + lastYearClosingLiabilitiesIncrease;
				double closingBalanceLiabilitiesDecrease = lastYearMovementLiabilitiesDecrease + lastYearClosingLiabilitiesDecrease;
				double closingCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilitiesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilitiesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",  stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
				if (activeProduction == 1)
				{
					double lastYearMovementFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, finishedGoodsAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					
					double closingBalanceFinishedGoods = lastYearMovementFinishedGoods + lastYearClosingFinishedGoods;
					
					OLAPCellWriteNumber(connection, MainCube, closingBalanceFinishedGoods, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				}
				
			}
		}
	}
	
	LogInformation(""BAPCalculateCostEntry: Process complete"");

	return 0;
}"	1	E083BDE8-AB82-4DCB-8DEC-627C77ACA868	Write back the entered cost factor for the used cost position and calculate the depending cost value and cash movement and opening balance.	1	1	1	1551	NULL	0	45708.67506	0	0
E512A08D-FD50-4BF5-AF88-938273368B2A	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateDaysLiabilities	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Currently selected Configuration set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The company element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""costGroup"" parameter-type=""string"" parameter-description=""The cost group element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""17"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateDaysLiabilities(
	string database, string ticket, string time, string cycle, string version,string entity, string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string costGroup, double value)
@Description: ""Calculates the cash and payables account movement based on entered days liabilities."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The company element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok."";
{
	LogInformation(""BPCalculateDaysLiabilities: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";
	
	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	int costNumber = 0;
	
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	double numberOfCosts = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COSTS"", ""SUBPLAN_SALES_ACTIVE"", ""Value"");
	
	if (StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateDaysLiabilities: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{

		double oldDaysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"" ,stepRead, entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		LogDebug(""BPCalculateDaysLiabilities: Previous days liabilities value: "" + oldDaysLiabilities);
		double periodOffset = oldDaysLiabilities / 30.0;
		remainder = periodOffset;
		while (remainder &gt; 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string oldTargetPeriod = currentMonth;
		if (periodOffset &gt; 0)
		{
			oldTargetPeriod = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			oldTargetPeriod = ResolveUniqueName(connection, oldTargetPeriod);
		}
		
		LogDebug(""BPCalculateDaysLiabilities: Adjusting values based on previous days liabilities. Used period: "" + oldTargetPeriod);

		costNumber = 0;
		
		while (costNumber &lt; numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costPosition = ""COST"";
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}
			costPosition = costPosition + costNumberText;
			LogDebug(""BPCalculateDaysLiabilities: Cost Position: "" + costPosition);
			
			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);
			
			double costs = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, costAccount,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

			OLAPCellIncrementNumber(connection, MainCube, costs * -1, oldTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs * -1, oldTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		double defaultDaysLiabilities =  OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version, ""SALES_FACTORS_DEFAULTS"",stepRead, entity, intercompany, organization, account,currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceLiabilities = value - defaultDaysLiabilities;
		
		OLAPCellWriteNumber(connection, MainCube, differenceLiabilities, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"", stepWrite, entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		periodOffset = value / 30.0;
		remainder = periodOffset;
		while (remainder &gt; 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		lagElement = periodOffset + ""_PERIODS_LATER"";
		string newTargetPeriod = currentMonth;
		if (periodOffset &gt; 0)
		{
			newTargetPeriod = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			newTargetPeriod = ResolveUniqueName(connection, newTargetPeriod);
		}

		LogDebug(""BPCalculateDaysLiabilities: Adjusting values based on new days liabilities. Used period: "" + newTargetPeriod);
		
		costNumber = 0;
		
		while (costNumber &lt; numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costPosition = ""COST"";
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}
			costPosition = costPosition + costNumberText;
			LogDebug(""BAPCalculateDaysLiabilities: Cost Position: "" + costPosition);

			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);

			double costs = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization, costAccount,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			LogInformation(""test2"");
			OLAPCellIncrementNumber(connection, MainCube, costs, newTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs, newTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
	}
	
	costNumber = 0;
	while (costNumber &lt; numberOfCosts)
	{
		// get configuration based on cost number
		costNumber = costNumber + 1;

		string costPosition = ""COST"";
		string costNumberText = ToString(costNumber);
		if (StringLength(costNumberText) == 1)
		{
			costNumberText = ""0"" + costNumberText;
		}
		costPosition = costPosition + costNumberText;
		LogDebug(""BPCalculateDaysLiabilities: Cost Position: "" + costPosition);

		string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
		liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);

		foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
		{
			// this is a workaround as we are lacking the function to get only direct children for an element
			if (StringLength(year) == 4)
			{
				// check if the current year in the loop is after the specified month and before the end year of the cycle
				double checkYear = ToDouble(year);
				
				// for all years in the cycle after the entered period calculate the opening balance
				if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
				{
					// TODO get from calendar
					string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
					// TODO get from calendar
					string currentYearFirstMonth = ""01_"" + checkYear;

					double lastYearMovementLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearMovementCashLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingCashLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					
					double closingBalanceLiabilities = lastYearMovementLiabilities + lastYearClosingLiabilities;
					double closingBalanceCashLiabilities = lastYearMovementCashLiabilities + lastYearClosingCashLiabilities;
					
					OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilities, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
					OLAPCellWriteNumber(connection, MainCube, closingBalanceCashLiabilities, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

				}
			}
		}
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingBalanceCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization,cashAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}
	
	LogInformation(""BPCalculateDaysLiabilities: Process complete"");
	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateDaysLiabilities(
	string database, string ticket, string time, string cycle, string version,string entity, string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string costGroup, double value)
@Description: ""Calculates the cash and payables account movement based on entered days liabilities."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The company element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok."";
{
	LogInformation(""BPCalculateDaysLiabilities: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";
	
	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	int costNumber = 0;
	
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	double numberOfCosts = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COSTS"", ""SUBPLAN_SALES_ACTIVE"", ""Value"");
	
	if (StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateDaysLiabilities: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{

		double oldDaysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"" ,stepRead, entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		LogDebug(""BPCalculateDaysLiabilities: Previous days liabilities value: "" + oldDaysLiabilities);
		double periodOffset = oldDaysLiabilities / 30.0;
		remainder = periodOffset;
		while (remainder > 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string oldTargetPeriod = currentMonth;
		if (periodOffset > 0)
		{
			oldTargetPeriod = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			oldTargetPeriod = ResolveUniqueName(connection, oldTargetPeriod);
		}
		
		LogDebug(""BPCalculateDaysLiabilities: Adjusting values based on previous days liabilities. Used period: "" + oldTargetPeriod);

		costNumber = 0;
		
		while (costNumber < numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costPosition = ""COST"";
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}
			costPosition = costPosition + costNumberText;
			LogDebug(""BPCalculateDaysLiabilities: Cost Position: "" + costPosition);
			
			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);
			
			double costs = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, costAccount,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

			OLAPCellIncrementNumber(connection, MainCube, costs * -1, oldTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs * -1, oldTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		double defaultDaysLiabilities =  OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version, ""SALES_FACTORS_DEFAULTS"",stepRead, entity, intercompany, organization, account,currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceLiabilities = value - defaultDaysLiabilities;
		
		OLAPCellWriteNumber(connection, MainCube, differenceLiabilities, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"", stepWrite, entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		periodOffset = value / 30.0;
		remainder = periodOffset;
		while (remainder > 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		lagElement = periodOffset + ""_PERIODS_LATER"";
		string newTargetPeriod = currentMonth;
		if (periodOffset > 0)
		{
			newTargetPeriod = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			newTargetPeriod = ResolveUniqueName(connection, newTargetPeriod);
		}

		LogDebug(""BPCalculateDaysLiabilities: Adjusting values based on new days liabilities. Used period: "" + newTargetPeriod);
		
		costNumber = 0;
		
		while (costNumber < numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costPosition = ""COST"";
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}
			costPosition = costPosition + costNumberText;
			LogDebug(""BAPCalculateDaysLiabilities: Cost Position: "" + costPosition);

			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);

			double costs = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization, costAccount,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			LogInformation(""test2"");
			OLAPCellIncrementNumber(connection, MainCube, costs, newTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs, newTargetPeriod, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
	}
	
	costNumber = 0;
	while (costNumber < numberOfCosts)
	{
		// get configuration based on cost number
		costNumber = costNumber + 1;

		string costPosition = ""COST"";
		string costNumberText = ToString(costNumber);
		if (StringLength(costNumberText) == 1)
		{
			costNumberText = ""0"" + costNumberText;
		}
		costPosition = costPosition + costNumberText;
		LogDebug(""BPCalculateDaysLiabilities: Cost Position: "" + costPosition);

		string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
		liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);

		foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
		{
			// this is a workaround as we are lacking the function to get only direct children for an element
			if (StringLength(year) == 4)
			{
				// check if the current year in the loop is after the specified month and before the end year of the cycle
				double checkYear = ToDouble(year);
				
				// for all years in the cycle after the entered period calculate the opening balance
				if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
				{
					// TODO get from calendar
					string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
					// TODO get from calendar
					string currentYearFirstMonth = ""01_"" + checkYear;

					double lastYearMovementLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization,liabilitiesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearMovementCashLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					double lastYearClosingCashLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, liabilitiesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
					
					double closingBalanceLiabilities = lastYearMovementLiabilities + lastYearClosingLiabilities;
					double closingBalanceCashLiabilities = lastYearMovementCashLiabilities + lastYearClosingCashLiabilities;
					
					OLAPCellWriteNumber(connection, MainCube, closingBalanceLiabilities, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
					OLAPCellWriteNumber(connection, MainCube, closingBalanceCashLiabilities, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

				}
			}
		}
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingBalanceCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization,cashAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}
	
	LogInformation(""BPCalculateDaysLiabilities: Process complete"");
	return 0;
}"	1	D5A6C8C0-23AA-4A38-AAD2-38B4E369CE47	Calculates the cash and payables account movement based on entered days liabilities.	1	1	1	1552	NULL	0	45708.67503	0	0
4D9600B9-797D-4765-B11B-ADB676981042	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateDeductionEntry	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Currently selected Configuration set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""salesGroup"" parameter-type=""string"" parameter-description=""The sales group element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""17"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateDeductionEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, double value)
@Description: ""Write back the sales deduction value entered by the user and recalculate the net revenue and opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPCalculateDeductionEntry: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";
	
	//Elias: It is TOTAL SALES GROUP and not TOTAL_SALES_GROUP
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateDeductionEntry: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double defaultFactorSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"",stepRead,entity, intercompany, organization,account, currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceForSalesDeduction = value - defaultFactorSalesDeduction;
		
		OLAPCellWriteNumber(connection, MainCube, differenceForSalesDeduction, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"",stepWrite, entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double factorSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""FACTOR_SALES_DEDUCTION"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		
		double salesDeduction = factorSalesDeduction * revenue / 100.0 * -1;
		double defaultSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization,""SALES_DEDUCTION"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValueForSalesDeduction = salesDeduction - defaultSalesDeduction;

		OLAPCellWriteNumber(connection, MainCube, differenceValueForSalesDeduction, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""SALES_DEDUCTION"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		OLAPCellWriteNumber(connection, MainCube, netRevenue, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"" ,stepWrite,entity, intercompany, organization, salesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = RoundDecimals(daysReceivables / 30, 0);
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset &gt; 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, netRevenue , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue * -1 , laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
	}

	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;
				
				LogDebug(""BAPCalculateDeductionEntry; Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);
				double closingBalanceReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_UNAPPROVED"",stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingBalanceReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead,entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
			}
		}
	}
	
	LogInformation(""BAPCalculateDeductionEntry: Process complete"");

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateDeductionEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, double value)
@Description: ""Write back the sales deduction value entered by the user and recalculate the net revenue and opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Currently selected Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPCalculateDeductionEntry: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";
	
	//Elias: It is TOTAL SALES GROUP and not TOTAL_SALES_GROUP
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateDeductionEntry: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double defaultFactorSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"",stepRead,entity, intercompany, organization,account, currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceForSalesDeduction = value - defaultFactorSalesDeduction;
		
		OLAPCellWriteNumber(connection, MainCube, differenceForSalesDeduction, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"",stepWrite, entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double factorSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""FACTOR_SALES_DEDUCTION"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		
		double salesDeduction = factorSalesDeduction * revenue / 100.0 * -1;
		double defaultSalesDeduction = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization,""SALES_DEDUCTION"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValueForSalesDeduction = salesDeduction - defaultSalesDeduction;

		OLAPCellWriteNumber(connection, MainCube, differenceValueForSalesDeduction, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""SALES_DEDUCTION"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		OLAPCellWriteNumber(connection, MainCube, netRevenue, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"" ,stepWrite,entity, intercompany, organization, salesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = RoundDecimals(daysReceivables / 30, 0);
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset > 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, netRevenue , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue * -1 , laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
	}

	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;
				
				LogDebug(""BAPCalculateDeductionEntry; Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);
				double closingBalanceReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version, ""CALC_SALES_UNAPPROVED"",stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingBalanceReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead,entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double closingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepRead,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
			}
		}
	}
	
	LogInformation(""BAPCalculateDeductionEntry: Process complete"");

	return 0;
}"	1	58A47289-ED20-4DB2-84D4-F5137FB3EF5B	Write back the sales deduction value entered by the user and recalculate the net revenue and opening balances.	1	1	1	1553	NULL	0	45708.67506	0	0
EB152994-1598-4A3B-9182-EA15A789CA9E	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateOpeningBalanceCycleStart	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True if script run ok"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""month"" parameter-type=""string"" parameter-description=""Currently selected month."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Currently selected Configuration set"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""Source version for calculating the opening balance"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""Target version for writing the opening balance"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""Entity"" parameter-type=""string"" parameter-description=""Currently selected Entity"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""Currency assigned to the Entity"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPCalculateOpeningBalanceCycleStart(string database, string ticket, string month,string cycle, string sourceVersion, string targetVersion, string Entity, string currency)
@Description: ""Generates the opening balance for first cycle month based on a defined version of the year prior to Configuration Set start"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[month]: ""Currently selected month."";
@Parameter[cycle]: ""Currently selected Configuration set "";
@Parameter[Entity]: ""Currently selected Entity"";
@Parameter[currency]: ""Currency assigned to the Entity"";
@Parameter[sourceVersion]: ""Source version for calculating the opening balance"";
@Parameter[targetVersion]: ""Target version for writing the opening balance"";
@Returns: ""True if script run ok"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	/*month  = ""[BPDTIME].[12_2017].[1]"";
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	sourceVersion = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	targetVersion = ""[BPDVERSION].[FC_FISCAL02].[1]"";
	Entity= ""[BPDENTITY].[RU0001].[1]"";
	currency= ""[BPDCURRENCY].[EUR_LC].[1]"";*/
	month = ResolveUniqueName(connection, month);
	cycle = ResolveUniqueName(connection, cycle);
	Entity = ResolveUniqueName(connection, Entity);
	sourceVersion = ResolveUniqueName(connection, sourceVersion);
	targetVersion = ResolveUniqueName(connection, targetVersion);
	currency = ResolveUniqueName(connection, currency);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);


	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string LevelDimension = ""BPDLEVEL"";
	string AccountDimension = ""BPDACCOUNT"";
	string ConfigDimension = ""BPDCONFIGURATION"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string currencyDimension = ""BPDCURRENCY"";
	string firstCycleMonth ="""";
	string lastYearLastPeriod ="""";
	string PeriodForRead = """";

	OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

	StringList  currenList = CreateStringList();
	Append(currenList, """");
	foreach(OLAPElement currencyOE in currencies)
	{
		currency =ToString(currencyOE);
		Append(currenList ,currency);

	}

	if(StringStartsWith(targetVersion, ""BUDGET""))
	{
		string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
		double cycleYearStart = ToDouble(cycleYearStarthelp);
		
		double yearPriorCylceStart = cycleYearStart-1;
		firstCycleMonth = ""01_""+cycleYearStart;
		lastYearLastPeriod = ""12_"" + yearPriorCylceStart;
		PeriodForRead =firstCycleMonth;

	}
	else
	{
		string months = StringSubstring(month, 0, 2);
		string year = StringSubstring(month, 3, 4);
		double monthsNumber =ToDouble(months);
		double yearsNumber =ToDouble(year);

		if(StringStartsWith(month, ""01""))
		{
			yearsNumber = yearsNumber-1;
			year = ToString(yearsNumber);
			lastYearLastPeriod =""12_""+ year;
			PeriodForRead  = month;
		}
		else
		{

			lastYearLastPeriod  = month;
			PeriodForRead = month +""_""+ ""YTD"";
		}
	}

	OLAPElement TimeElement = OLAPGetDimensionElement(connection, TimeDimension, PeriodForRead);
	bool baseTimeElement = OLAPIsBaseElement(connection, TimeElement);

	StringArray timeArray = CreateStringArray();
	Append(timeArray, """");

	if(baseTimeElement)
	{
		
		Append(timeArray , PeriodForRead);

	}
	else
	{
		OLAPElementList timeList = OLAPGetChildElementList(connection, TimeDimension, PeriodForRead, true);
		StringList timeStringListHelp = ToStringList(timeList);

		foreach(string timeOLAPElement in timeStringListHelp )
		{
			Append(timeArray , timeOLAPElement );
		}
	}


	StringList timeListStringList = ToStringList(timeArray );

	OLAPElementList Levels = CreateOLAPElementList();

	if(StringStartsWith(targetVersion, ""BUDGET""))
	{
		
		Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);

	}
	else
	{
		Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_LEVEL"", true);

	}

	StringArray accountsArray = CreateStringArray();
	Append(accountsArray , """");
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension, ""TOTAL_ACCOUNT"", true);
	foreach(OLAPElement account in baseAccounts)
	{
		string accountType = OLAPGetStringAttribute(connection, account, ""ACCTYPE"");
		if (accountType == ""A"" or accountType == ""L"" or accountType == ""Q"")
		{
			string accountString = ToString(account);
			Append(accountsArray , accountString);
		}
	}
	StringList accountsList = ToStringList(accountsArray);

	
	OLAPDataArea targetDataOB = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                               lastYearLastPeriod, cycle, targetVersion,Levels,OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells, accountsList,currencies, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells );

	
	
	OLAPDeleteDataArea(targetDataOB);
	// first dataarea for transfer values Import_OB
	OLAPDataArea sourceDataOB = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                               timeListStringList, cycle, sourceVersion,Levels,OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells, accountsList,currencies, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells );
	
	foreach(OLAPCell cell in sourceDataOB)
	{

		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string period = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string segment1 = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string segment2 = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string segment3 = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string currencyinLoop = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		if(level != ""TOTAL_INPUT_ALLOCATION"")
		{
			if(level != ""TOTAL_INPUT_ALLOCATION_DP"")
			{

				OLAPCellWriteBufferIncrementNumber(buffer,MainCube, cell, lastYearLastPeriod, cycle, targetVersion,level, step, Entity, intercompany, organization, account, currencyinLoop, detail, segment1, segment2, segment3, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}

	OLAPCommitCellWriteBuffer(buffer);
	
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPCalculateOpeningBalanceCycleStart(string database, string ticket, string month,string cycle, string sourceVersion, string targetVersion, string Entity, string currency)
@Description: ""Generates the opening balance for first cycle month based on a defined version of the year prior to Configuration Set start"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[month]: ""Currently selected month."";
@Parameter[cycle]: ""Currently selected Configuration set "";
@Parameter[Entity]: ""Currently selected Entity"";
@Parameter[currency]: ""Currency assigned to the Entity"";
@Parameter[sourceVersion]: ""Source version for calculating the opening balance"";
@Parameter[targetVersion]: ""Target version for writing the opening balance"";
@Returns: ""True if script run ok"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	/*month  = ""[BPDTIME].[12_2017].[1]"";
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	sourceVersion = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	targetVersion = ""[BPDVERSION].[FC_FISCAL02].[1]"";
	Entity= ""[BPDENTITY].[RU0001].[1]"";
	currency= ""[BPDCURRENCY].[EUR_LC].[1]"";*/
	month = ResolveUniqueName(connection, month);
	cycle = ResolveUniqueName(connection, cycle);
	Entity = ResolveUniqueName(connection, Entity);
	sourceVersion = ResolveUniqueName(connection, sourceVersion);
	targetVersion = ResolveUniqueName(connection, targetVersion);
	currency = ResolveUniqueName(connection, currency);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);


	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string LevelDimension = ""BPDLEVEL"";
	string AccountDimension = ""BPDACCOUNT"";
	string ConfigDimension = ""BPDCONFIGURATION"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string currencyDimension = ""BPDCURRENCY"";
	string firstCycleMonth ="""";
	string lastYearLastPeriod ="""";
	string PeriodForRead = """";

	OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

	StringList  currenList = CreateStringList();
	Append(currenList, """");
	foreach(OLAPElement currencyOE in currencies)
	{
		currency =ToString(currencyOE);
		Append(currenList ,currency);

	}

	if(StringStartsWith(targetVersion, ""BUDGET""))
	{
		string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
		double cycleYearStart = ToDouble(cycleYearStarthelp);
		
		double yearPriorCylceStart = cycleYearStart-1;
		firstCycleMonth = ""01_""+cycleYearStart;
		lastYearLastPeriod = ""12_"" + yearPriorCylceStart;
		PeriodForRead =firstCycleMonth;

	}
	else
	{
		string months = StringSubstring(month, 0, 2);
		string year = StringSubstring(month, 3, 4);
		double monthsNumber =ToDouble(months);
		double yearsNumber =ToDouble(year);

		if(StringStartsWith(month, ""01""))
		{
			yearsNumber = yearsNumber-1;
			year = ToString(yearsNumber);
			lastYearLastPeriod =""12_""+ year;
			PeriodForRead  = month;
		}
		else
		{

			lastYearLastPeriod  = month;
			PeriodForRead = month +""_""+ ""YTD"";
		}
	}

	OLAPElement TimeElement = OLAPGetDimensionElement(connection, TimeDimension, PeriodForRead);
	bool baseTimeElement = OLAPIsBaseElement(connection, TimeElement);

	StringArray timeArray = CreateStringArray();
	Append(timeArray, """");

	if(baseTimeElement)
	{
		
		Append(timeArray , PeriodForRead);

	}
	else
	{
		OLAPElementList timeList = OLAPGetChildElementList(connection, TimeDimension, PeriodForRead, true);
		StringList timeStringListHelp = ToStringList(timeList);

		foreach(string timeOLAPElement in timeStringListHelp )
		{
			Append(timeArray , timeOLAPElement );
		}
	}


	StringList timeListStringList = ToStringList(timeArray );

	OLAPElementList Levels = CreateOLAPElementList();

	if(StringStartsWith(targetVersion, ""BUDGET""))
	{
		
		Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);

	}
	else
	{
		Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_LEVEL"", true);

	}

	StringArray accountsArray = CreateStringArray();
	Append(accountsArray , """");
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension, ""TOTAL_ACCOUNT"", true);
	foreach(OLAPElement account in baseAccounts)
	{
		string accountType = OLAPGetStringAttribute(connection, account, ""ACCTYPE"");
		if (accountType == ""A"" or accountType == ""L"" or accountType == ""Q"")
		{
			string accountString = ToString(account);
			Append(accountsArray , accountString);
		}
	}
	StringList accountsList = ToStringList(accountsArray);

	
	OLAPDataArea targetDataOB = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                               lastYearLastPeriod, cycle, targetVersion,Levels,OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells, accountsList,currencies, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells );

	
	
	OLAPDeleteDataArea(targetDataOB);
	// first dataarea for transfer values Import_OB
	OLAPDataArea sourceDataOB = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                               timeListStringList, cycle, sourceVersion,Levels,OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells, accountsList,currencies, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells );
	
	foreach(OLAPCell cell in sourceDataOB)
	{

		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string period = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string segment1 = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string segment2 = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string segment3 = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string currencyinLoop = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		if(level != ""TOTAL_INPUT_ALLOCATION"")
		{
			if(level != ""TOTAL_INPUT_ALLOCATION_DP"")
			{

				OLAPCellWriteBufferIncrementNumber(buffer,MainCube, cell, lastYearLastPeriod, cycle, targetVersion,level, step, Entity, intercompany, organization, account, currencyinLoop, detail, segment1, segment2, segment3, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}

	OLAPCommitCellWriteBuffer(buffer);
	
	return true;
}"	1	A5DEA15F-21E3-48C6-B0DF-A2B9C2630EE6	Generates the opening balance for first cycle month based on a defined version of the year prior to Configuration Set start	1	1	1	1554	NULL	0	45708.67502	0	0
7C860767-B456-449B-B22F-EC7281A4CAE6	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateProductionVolumeEntry	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set  element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""costGroup"" parameter-type=""string"" parameter-description=""The cost group element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""17"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateProductionVolumeEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment,
	string costGroup, double value)
@Description: ""Calculate change of inventory and finished goods during optional production planning in sales planning process."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPCalculateProductionVolumeEntry: Starting process"");
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	WriteLine(finishedGoodsAccount);	if (StringLength(inventoryAccount) == 0 or StringLength(finishedGoodsAccount) == 0)
	{
		LogDebug(""BPCalculateProductionVolumeEntry: An error has occured the configuration of the sales accounts is incomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	WriteLine(timeElement);
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);

	// read default value and calculate difference
	double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account, currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
	double differenceValue = value - defaultValue;

	if (baseTimeElement)
	{
		// if the time element is a base element write the value
		OLAPCellWriteNumber(connection, MainCube, differenceValue, time, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
	}
	else
	{
		// if the time element is a parnet element splash the value either equally or with external reference
		StringArray splashCoordinate = CreateStringArray();
		StringArray referenceCoordinate = CreateStringArray();

		// TODO check splash coordinates


		Append(referenceCoordinate, time);
		Append(referenceCoordinate, cycle);
		Append(referenceCoordinate, version);
		Append(referenceCoordinate, ""SALES_VALUES_DEFAULT"");
		Append(referenceCoordinate, stepRead);
		Append(referenceCoordinate, entity);
		Append(referenceCoordinate, intercompany);
		Append(referenceCoordinate, organization);
		Append(referenceCoordinate, account);
		Append(referenceCoordinate, currencyWrite);
		Append(referenceCoordinate, NA);
		Append(referenceCoordinate, primarySegment);
		Append(referenceCoordinate, secondarySegment);
		Append(referenceCoordinate, tertiarySegment);
		Append(referenceCoordinate, analysis1read);
		Append(referenceCoordinate, analysis2read);
		Append(referenceCoordinate, analysis3read);
		Append(referenceCoordinate, analysis4read);
		Append(referenceCoordinate, analysis5read);
		Append(referenceCoordinate, analysis6read);
		Append(referenceCoordinate, analysis7read);
		Append(referenceCoordinate, analysis8read);
		Append(referenceCoordinate, analysis9read);
		Append(referenceCoordinate, analysis10read);
		Append(referenceCoordinate, analysis11read);
		Append(referenceCoordinate, analysis12read);

		Append(splashCoordinate, time);
		Append(splashCoordinate, cycle);
		Append(splashCoordinate, version);
		Append(splashCoordinate, ""CHANGE_SALES_VALUES_DEFAULTS"");
		Append(splashCoordinate, stepWrite);
		Append(splashCoordinate, entity);
		Append(splashCoordinate, intercompany);
		Append(splashCoordinate, organization);
		Append(splashCoordinate, account);
		Append(splashCoordinate, currencyWrite);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, primarySegment);
		Append(splashCoordinate, secondarySegment);
		Append(splashCoordinate, tertiarySegment);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);

		if (defaultValue == 0)
		{
			OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""Equal"", false, 20, false, splashCoordinate);
		}
		else
		{
			OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""External weighted"", false, 20, false, referenceCoordinate, splashCoordinate);
		}
	}
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double quantityOfSales = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double productionValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""PRODUCTION_VOLUME"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double costPerUnit = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version ,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization, ""COST_PER_UNIT"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		
		double changeOfInventoryVolume = productionValue - quantityOfSales;
		double changeOfInventory = changeOfInventoryVolume * costPerUnit;
		
		OLAPCellWriteNumber(connection, MainCube, changeOfInventoryVolume, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization,""CHANGE_INVENTORY_VOLUME"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version, ""CHANGE_SALES_VALUES_DEFAULTS"",stepWrite, entity, intercompany, organization,""CHANGE_INVENTORY"", currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, inventoryAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BPCalculateProductionVolumeEntry: Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);

				double lastYearMovementFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, finishedGoodsAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment,  analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, finishedGoodsAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment,  analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceFinishedGoods = lastYearMovementFinishedGoods + lastYearClosingFinishedGoods;
				

				OLAPCellWriteNumber(connection, MainCube, closingBalanceFinishedGoods, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepWrite,entity,intercompany, organization,finishedGoodsAccount,currencyWrite,NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
			}
		}
	}
	
	LogInformation(""BAPCalculateProductionVolumeEntry: Process complete"");

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateProductionVolumeEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment,
	string costGroup, double value)
@Description: ""Calculate change of inventory and finished goods during optional production planning in sales planning process."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPCalculateProductionVolumeEntry: Starting process"");
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	costGroup = ResolveUniqueName(connection, costGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	WriteLine(finishedGoodsAccount);	if (StringLength(inventoryAccount) == 0 or StringLength(finishedGoodsAccount) == 0)
	{
		LogDebug(""BPCalculateProductionVolumeEntry: An error has occured the configuration of the sales accounts is incomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	WriteLine(timeElement);
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);

	// read default value and calculate difference
	double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account, currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
	double differenceValue = value - defaultValue;

	if (baseTimeElement)
	{
		// if the time element is a base element write the value
		OLAPCellWriteNumber(connection, MainCube, differenceValue, time, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
	}
	else
	{
		// if the time element is a parnet element splash the value either equally or with external reference
		StringArray splashCoordinate = CreateStringArray();
		StringArray referenceCoordinate = CreateStringArray();

		// TODO check splash coordinates


		Append(referenceCoordinate, time);
		Append(referenceCoordinate, cycle);
		Append(referenceCoordinate, version);
		Append(referenceCoordinate, ""SALES_VALUES_DEFAULT"");
		Append(referenceCoordinate, stepRead);
		Append(referenceCoordinate, entity);
		Append(referenceCoordinate, intercompany);
		Append(referenceCoordinate, organization);
		Append(referenceCoordinate, account);
		Append(referenceCoordinate, currencyWrite);
		Append(referenceCoordinate, NA);
		Append(referenceCoordinate, primarySegment);
		Append(referenceCoordinate, secondarySegment);
		Append(referenceCoordinate, tertiarySegment);
		Append(referenceCoordinate, analysis1read);
		Append(referenceCoordinate, analysis2read);
		Append(referenceCoordinate, analysis3read);
		Append(referenceCoordinate, analysis4read);
		Append(referenceCoordinate, analysis5read);
		Append(referenceCoordinate, analysis6read);
		Append(referenceCoordinate, analysis7read);
		Append(referenceCoordinate, analysis8read);
		Append(referenceCoordinate, analysis9read);
		Append(referenceCoordinate, analysis10read);
		Append(referenceCoordinate, analysis11read);
		Append(referenceCoordinate, analysis12read);

		Append(splashCoordinate, time);
		Append(splashCoordinate, cycle);
		Append(splashCoordinate, version);
		Append(splashCoordinate, ""CHANGE_SALES_VALUES_DEFAULTS"");
		Append(splashCoordinate, stepWrite);
		Append(splashCoordinate, entity);
		Append(splashCoordinate, intercompany);
		Append(splashCoordinate, organization);
		Append(splashCoordinate, account);
		Append(splashCoordinate, currencyWrite);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, primarySegment);
		Append(splashCoordinate, secondarySegment);
		Append(splashCoordinate, tertiarySegment);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);
		Append(splashCoordinate, NA);

		if (defaultValue == 0)
		{
			OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""Equal"", false, 20, false, splashCoordinate);
		}
		else
		{
			OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""External weighted"", false, 20, false, referenceCoordinate, splashCoordinate);
		}
	}
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double quantityOfSales = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double productionValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead, entity, intercompany, organization, ""PRODUCTION_VOLUME"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double costPerUnit = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version ,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization, ""COST_PER_UNIT"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		
		double changeOfInventoryVolume = productionValue - quantityOfSales;
		double changeOfInventory = changeOfInventoryVolume * costPerUnit;
		
		OLAPCellWriteNumber(connection, MainCube, changeOfInventoryVolume, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite, entity, intercompany, organization,""CHANGE_INVENTORY_VOLUME"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version, ""CHANGE_SALES_VALUES_DEFAULTS"",stepWrite, entity, intercompany, organization,""CHANGE_INVENTORY"", currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, inventoryAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite, entity, intercompany, organization, finishedGoodsAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BPCalculateProductionVolumeEntry: Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);

				double lastYearMovementFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead, entity, intercompany, organization, finishedGoodsAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment,  analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingFinishedGoods = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"", stepRead, entity, intercompany, organization, finishedGoodsAccount, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment,  analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceFinishedGoods = lastYearMovementFinishedGoods + lastYearClosingFinishedGoods;
				

				OLAPCellWriteNumber(connection, MainCube, closingBalanceFinishedGoods, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepWrite,entity,intercompany, organization,finishedGoodsAccount,currencyWrite,NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				
			}
		}
	}
	
	LogInformation(""BAPCalculateProductionVolumeEntry: Process complete"");

	return 0;
}"	1	B9458925-801E-4B37-B43F-99DB05B9CDD3	Calculate change of inventory and finished goods during optional production planning in sales planning process.	1	1	1	1555	NULL	0	45708.67508	0	0
8AE1C61A-E019-4081-9F3F-48DD6E59F82C	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateSalesEntry	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set  element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""salesGroup"" parameter-type=""string"" parameter-description=""The sales group element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""costGroup"" parameter-type=""string"" parameter-description=""The cost group element to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""18"" />
  <dependencies>
    <process process-name=""BAPCalculateDeductionEntry"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BAPCalculateDeductionEntry"", ""*""
#include ""BP_GetTopElement"", ""*""

int BAPCalculateSalesEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, string costGroup, double value)
@Description: ""Calculates the quantity, price, or revenue depending on the sales configuration, depending cost position, and change of inventory and opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";

@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateSalesEntry: Starting process"");
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	//help variables for script BAPCalculateDeductionEntry
	string Htime = time;
	string Hcycle = cycle;
	string Hversion = version;
	string Hentity = entity;
	string HstepRead = stepRead;
	string HstepWrite = stepWrite;
	string Hintercompany = intercompany;
	string Horganization = organization;
	string HcurrencyRead = currencyRead;
	string HcurrencyWrite = currencyWrite;
	string Haccount = account;
	string HprimarySegment = primarySegment;
	string HsecondarySegment = secondarySegment;
	string HtertiarySegment = tertiarySegment;
	string HsalesGroup = salesGroup;

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);
	costGroup = ResolveUniqueName(connection, costGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);

	// read the activation settings
	double quantityActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_QUANTITY"", ""Value"");
	double priceActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_PRICE"", ""Value"");
	double revenueActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_REVENUE"", ""Value"");

	// read cost settings
	double numberOfCosts = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COSTS"", ""SUBPLAN_SALES_ACTIVE"", ""Value"");
	string cashAccountCosts = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	double activeProduction = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_MANUF"", ""Value"");

	cashAccountCosts = ResolveUniqueName(connection, cashAccountCosts);
	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);
	LogDebug(""Cash Cost Account: "" + cashAccountCosts);
	LogDebug(""Inventory  Account: "" + inventoryAccount);
	LogDebug(""Finished Goods Account: "" + finishedGoodsAccount);
	
	if(account != ""PRICE"")
	{
		// read default value and calculate difference
		double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account,currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValue = value - defaultValue;
		//ELIAS
		LogDebug(""Difference: "" + differenceValue + "" Value: "" + value + "" Default: "" + defaultValue);
		if (baseTimeElement)
		{
			// if the time element is a base element write the value
			OLAPCellWriteNumber(connection, MainCube, differenceValue, time, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else
		{
			// if the time element is a parnet element splash the value either equally or with external reference
			StringArray splashCoordinate = CreateStringArray();
			StringArray referenceCoordinate = CreateStringArray();
			
			// TODO check splash coordinates

			Append(referenceCoordinate, time);
			Append(referenceCoordinate, cycle);
			Append(referenceCoordinate, version);
			Append(referenceCoordinate, ""SALES_VALUES_DEFAULT"");
			Append(referenceCoordinate, stepRead);
			Append(referenceCoordinate, entity);
			Append(referenceCoordinate, intercompany);
			Append(referenceCoordinate, organization);
			Append(referenceCoordinate, account);
			Append(referenceCoordinate, currencyWrite);
			Append(referenceCoordinate, NA);
			Append(referenceCoordinate, primarySegment);
			Append(referenceCoordinate, secondarySegment);
			Append(referenceCoordinate, tertiarySegment);
			Append(referenceCoordinate, analysis1read);
			Append(referenceCoordinate, analysis2read);
			Append(referenceCoordinate, analysis3read);
			Append(referenceCoordinate, analysis4read);
			Append(referenceCoordinate, analysis5read);
			Append(referenceCoordinate, analysis6read);
			Append(referenceCoordinate, analysis7read);
			Append(referenceCoordinate, analysis8read);
			Append(referenceCoordinate, analysis9read);
			Append(referenceCoordinate, analysis10read);
			Append(referenceCoordinate, analysis11read);
			Append(referenceCoordinate, analysis12read);
			
			

			Append(splashCoordinate, time);
			Append(splashCoordinate, cycle);
			Append(splashCoordinate, version);
			Append(splashCoordinate, ""CHANGE_SALES_VALUES_DEFAULTS"");
			Append(splashCoordinate, stepWrite);
			Append(splashCoordinate, entity);
			Append(splashCoordinate, intercompany);
			Append(splashCoordinate, organization);
			Append(splashCoordinate, account);
			Append(splashCoordinate, currencyWrite);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, primarySegment);
			Append(splashCoordinate, secondarySegment);
			Append(splashCoordinate, tertiarySegment);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			
			
			if (defaultValue == 0)
			{
				OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""Equal"", false, 20, false, splashCoordinate);
			}
			else
			{
				OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""External weighted"", false, 20, false, referenceCoordinate, splashCoordinate);
			}
		}
	}
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		if(account == ""PRICE"")
		{
			double defaultPrice = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double differenceForPrice = value - defaultPrice;
			OLAPCellWriteNumber(connection, MainCube, differenceForPrice, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		// calculate the missing information and write the difference correspondingly
		double quantityValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double priceValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""PRICE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double revenueValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization,""REVENUE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		if (quantityActive == 0.0)
		{
			double defaultQuantityValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			quantityValue = 0;
			if(priceValue != 0)
			{
				quantityValue = revenueValue / priceValue - defaultQuantityValue;
			}
			OLAPCellWriteNumber(connection, MainCube, quantityValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else if (revenueActive == 0.0)
		{
			double defaultRevenueValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			revenueValue = quantityValue * priceValue - defaultRevenueValue;
			OLAPCellWriteNumber(connection, MainCube, revenueValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""REVENUE"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else if (priceActive == 0.0)
		{
			double defaultPriceValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization,""PRICE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			priceValue = 0;
			if(quantityValue != 0)
			{
				priceValue = revenueValue / quantityValue;
			}
			OLAPCellWriteNumber(connection, MainCube, priceValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""PRICE"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		// write net revenue
		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		LogDebug(""Net Revenue = "" + netRevenue);
		OLAPCellWriteNumber(connection, MainCube, netRevenue, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, salesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = daysReceivables / 30.0;
		remainder = periodOffset;
		while (remainder &gt; 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset &gt; 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		LogDebug(""Month: "" + laggedMonth + "" Element: "" + lagElement);
		LogDebug(""Old value: "" + increaseReceivables);
		OLAPCellIncrementNumber(connection, MainCube, Abs(increaseReceivables), laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, netRevenue , currentMonth, cycle, version, ""CALC_SALES_UNAPPROVED"",stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue * -1 , laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization,cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		LogDebug(""Calculating changes in costs"");
		
		int costNumber = 0;
		
		while (costNumber &lt; numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}

			string costPosition = ""COST"" + costNumberText;
			string factorCosts = ""FACTOR_COSTS_"" + costNumberText;
			string costMeasure = ""COSTS_"" + costNumberText;
			LogDebug(""Cost Position: "" + costPosition);
			LogDebug(""Factor Costs: "" + factorCosts);
			LogDebug(""Cost Measure: "" + costMeasure);

			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			double isPercentValue = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_COST_PERCENT"", ""Value"");
			bool isPercent = isPercentValue == 1;
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);

			double costFactor = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, factorCosts,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

			double costs = 0;
			if (isPercent)
			{
				double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				costs = (revenue / 100.0) * costFactor * -1;
			}
			else
			{
				double quantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				costs = quantity * costFactor * -1;
			}

			OLAPCellWriteNumber(connection, MainCube, costs, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, costMeasure,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			
			// get days receivables
			double daysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double oldCosts = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			periodOffset = daysLiabilities / 30.0;
			remainder = periodOffset;
			while (remainder &gt; 1)
			{
				remainder = remainder - 1;
			}
			periodOffset = periodOffset - remainder;
			currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
			lagElement = periodOffset + ""_PERIODS_LATER"";
			laggedMonth = currentMonth;
			if (periodOffset &gt; 0)
			{
				laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
				laggedMonth = ResolveUniqueName(connection, laggedMonth);
			}
			
			LogDebug(""Month: "" + laggedMonth + "" Element: "" + lagElement);
			LogDebug(""Old value: "" + oldCosts);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccountCosts,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			OLAPCellWriteNumber(connection, MainCube, costs , currentMonth, cycle, version, ""CALC_SALES_UNAPPROVED"",stepWrite,entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs * -1 , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs , laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, "	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BAPCalculateDeductionEntry"", ""*""
#include ""BP_GetTopElement"", ""*""

int BAPCalculateSalesEntry(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, string costGroup, double value)
@Description: ""Calculates the quantity, price, or revenue depending on the sales configuration, depending cost position, and change of inventory and opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[costGroup]: ""The cost group element to be used."";
@Parameter[value]: ""The value entered."";

@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateSalesEntry: Starting process"");
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	//help variables for script BAPCalculateDeductionEntry
	string Htime = time;
	string Hcycle = cycle;
	string Hversion = version;
	string Hentity = entity;
	string HstepRead = stepRead;
	string HstepWrite = stepWrite;
	string Hintercompany = intercompany;
	string Horganization = organization;
	string HcurrencyRead = currencyRead;
	string HcurrencyWrite = currencyWrite;
	string Haccount = account;
	string HprimarySegment = primarySegment;
	string HsecondarySegment = secondarySegment;
	string HtertiarySegment = tertiarySegment;
	string HsalesGroup = salesGroup;

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);
	costGroup = ResolveUniqueName(connection, costGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));


	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");
	
	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);

	// read the activation settings
	double quantityActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_QUANTITY"", ""Value"");
	double priceActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_PRICE"", ""Value"");
	double revenueActive = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_REVENUE"", ""Value"");

	// read cost settings
	double numberOfCosts = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COSTS"", ""SUBPLAN_SALES_ACTIVE"", ""Value"");
	string cashAccountCosts = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	string inventoryAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_INVENTORY"", ""Text Value"");
	string finishedGoodsAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACC_FINISHED_GOODS"", ""Text Value"");
	double activeProduction = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", ""COST_GROUP_INFO"", ""SUBPLAN_SALES_ACTIVE_MANUF"", ""Value"");

	cashAccountCosts = ResolveUniqueName(connection, cashAccountCosts);
	inventoryAccount = ResolveUniqueName(connection, inventoryAccount);
	finishedGoodsAccount = ResolveUniqueName(connection, finishedGoodsAccount);
	LogDebug(""Cash Cost Account: "" + cashAccountCosts);
	LogDebug(""Inventory  Account: "" + inventoryAccount);
	LogDebug(""Finished Goods Account: "" + finishedGoodsAccount);
	
	if(account != ""PRICE"")
	{
		// read default value and calculate difference
		double defaultValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account,currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceValue = value - defaultValue;
		//ELIAS
		LogDebug(""Difference: "" + differenceValue + "" Value: "" + value + "" Default: "" + defaultValue);
		if (baseTimeElement)
		{
			// if the time element is a base element write the value
			OLAPCellWriteNumber(connection, MainCube, differenceValue, time, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else
		{
			// if the time element is a parnet element splash the value either equally or with external reference
			StringArray splashCoordinate = CreateStringArray();
			StringArray referenceCoordinate = CreateStringArray();
			
			// TODO check splash coordinates

			Append(referenceCoordinate, time);
			Append(referenceCoordinate, cycle);
			Append(referenceCoordinate, version);
			Append(referenceCoordinate, ""SALES_VALUES_DEFAULT"");
			Append(referenceCoordinate, stepRead);
			Append(referenceCoordinate, entity);
			Append(referenceCoordinate, intercompany);
			Append(referenceCoordinate, organization);
			Append(referenceCoordinate, account);
			Append(referenceCoordinate, currencyWrite);
			Append(referenceCoordinate, NA);
			Append(referenceCoordinate, primarySegment);
			Append(referenceCoordinate, secondarySegment);
			Append(referenceCoordinate, tertiarySegment);
			Append(referenceCoordinate, analysis1read);
			Append(referenceCoordinate, analysis2read);
			Append(referenceCoordinate, analysis3read);
			Append(referenceCoordinate, analysis4read);
			Append(referenceCoordinate, analysis5read);
			Append(referenceCoordinate, analysis6read);
			Append(referenceCoordinate, analysis7read);
			Append(referenceCoordinate, analysis8read);
			Append(referenceCoordinate, analysis9read);
			Append(referenceCoordinate, analysis10read);
			Append(referenceCoordinate, analysis11read);
			Append(referenceCoordinate, analysis12read);
			
			

			Append(splashCoordinate, time);
			Append(splashCoordinate, cycle);
			Append(splashCoordinate, version);
			Append(splashCoordinate, ""CHANGE_SALES_VALUES_DEFAULTS"");
			Append(splashCoordinate, stepWrite);
			Append(splashCoordinate, entity);
			Append(splashCoordinate, intercompany);
			Append(splashCoordinate, organization);
			Append(splashCoordinate, account);
			Append(splashCoordinate, currencyWrite);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, primarySegment);
			Append(splashCoordinate, secondarySegment);
			Append(splashCoordinate, tertiarySegment);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			Append(splashCoordinate, NA);
			
			
			if (defaultValue == 0)
			{
				OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""Equal"", false, 20, false, splashCoordinate);
			}
			else
			{
				OLAPSplashValueDynamic(connection, MainCube, differenceValue, ""External weighted"", false, 20, false, referenceCoordinate, splashCoordinate);
			}
		}
	}
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		if(account == ""PRICE"")
		{
			double defaultPrice = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, account,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double differenceForPrice = value - defaultPrice;
			OLAPCellWriteNumber(connection, MainCube, differenceForPrice, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, account, currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		// calculate the missing information and write the difference correspondingly
		double quantityValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double priceValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""PRICE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double revenueValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization,""REVENUE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		if (quantityActive == 0.0)
		{
			double defaultQuantityValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			quantityValue = 0;
			if(priceValue != 0)
			{
				quantityValue = revenueValue / priceValue - defaultQuantityValue;
			}
			OLAPCellWriteNumber(connection, MainCube, quantityValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization,""QUANTITY_OF_SALES"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else if (revenueActive == 0.0)
		{
			double defaultRevenueValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			revenueValue = quantityValue * priceValue - defaultRevenueValue;
			OLAPCellWriteNumber(connection, MainCube, revenueValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""REVENUE"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		else if (priceActive == 0.0)
		{
			double defaultPriceValue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_VALUES_DEFAULT"", stepRead,entity, intercompany, organization,""PRICE"", currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			priceValue = 0;
			if(quantityValue != 0)
			{
				priceValue = revenueValue / quantityValue;
			}
			OLAPCellWriteNumber(connection, MainCube, priceValue, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""PRICE"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		}
		
		// write net revenue
		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		LogDebug(""Net Revenue = "" + netRevenue);
		OLAPCellWriteNumber(connection, MainCube, netRevenue, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, salesAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = daysReceivables / 30.0;
		remainder = periodOffset;
		while (remainder > 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset > 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}
		
		LogDebug(""Month: "" + laggedMonth + "" Element: "" + lagElement);
		LogDebug(""Old value: "" + increaseReceivables);
		OLAPCellIncrementNumber(connection, MainCube, Abs(increaseReceivables), laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		OLAPCellWriteNumber(connection, MainCube, netRevenue , currentMonth, cycle, version, ""CALC_SALES_UNAPPROVED"",stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue * -1 , laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization,cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		LogDebug(""Calculating changes in costs"");
		
		int costNumber = 0;
		
		while (costNumber < numberOfCosts)
		{
			// get configuration based on cost number
			costNumber = costNumber + 1;
			
			string costNumberText = ToString(costNumber);
			if (StringLength(costNumberText) == 1)
			{
				costNumberText = ""0"" + costNumberText;
			}

			string costPosition = ""COST"" + costNumberText;
			string factorCosts = ""FACTOR_COSTS_"" + costNumberText;
			string costMeasure = ""COSTS_"" + costNumberText;
			LogDebug(""Cost Position: "" + costPosition);
			LogDebug(""Factor Costs: "" + factorCosts);
			LogDebug(""Cost Measure: "" + costMeasure);

			string liabilitiesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_LIABILITIES"", ""Text Value"");
			string costAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_ACC_COSTS"", ""Text Value"");
			double isPercentValue = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, costGroup, ""TOTAL COST GROUP"", costPosition, ""SUBPLAN_SALES_COST_PERCENT"", ""Value"");
			bool isPercent = isPercentValue == 1;
			
			liabilitiesAccount = ResolveUniqueName(connection, liabilitiesAccount);
			costAccount = ResolveUniqueName(connection, costAccount);

			double costFactor = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, factorCosts,currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

			double costs = 0;
			if (isPercent)
			{
				double revenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				costs = (revenue / 100.0) * costFactor * -1;
			}
			else
			{
				double quantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				costs = quantity * costFactor * -1;
			}

			OLAPCellWriteNumber(connection, MainCube, costs, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, costMeasure,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			
			// get days receivables
			double daysLiabilities = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"", stepRead,entity, intercompany, organization, ""DAYS_LIABILITIES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double oldCosts = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			periodOffset = daysLiabilities / 30.0;
			remainder = periodOffset;
			while (remainder > 1)
			{
				remainder = remainder - 1;
			}
			periodOffset = periodOffset - remainder;
			currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
			lagElement = periodOffset + ""_PERIODS_LATER"";
			laggedMonth = currentMonth;
			if (periodOffset > 0)
			{
				laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
				laggedMonth = ResolveUniqueName(connection, laggedMonth);
			}
			
			LogDebug(""Month: "" + laggedMonth + "" Element: "" + lagElement);
			LogDebug(""Old value: "" + oldCosts);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, oldCosts * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccountCosts,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
			OLAPCellWriteNumber(connection, MainCube, costs , currentMonth, cycle, version, ""CALC_SALES_UNAPPROVED"",stepWrite,entity, intercompany, organization, costAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs * -1 , currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs , laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, liabilitiesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellIncrementNumber(connection, MainCube, costs, laggedMonth, cycle, version,""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccountCosts,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			
		} // END of Cost loop
		
		// Calculated COST_PER_UNIT
		double totalQuantity = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double totalCost = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""COSTS"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double costPerUnit = 0;
		
		if(totalQuantity != 0)
		{
			costPerUnit = totalCost/totalQuantity * -1;
		}
		
		OLAPCellWriteNumber(connection, MainCube, costPerUnit, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"",stepWrite,entity, intercompany, organization, ""COST_PER_UNIT"", currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		
		// Calculation of Production planning
		LogDebug(""BAPCalculateSalesEntry: Production active: "" + activeProduction);
		
		if (activeProduction == 1)
		{
			double quantityOfSales = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""QUANTITY_OF_SALES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			double productionVolume = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""PRODUCTION_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			costPerUnit = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"", stepRead,entity, intercompany, organization, ""COST_PER_UNIT"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			double changeOfInventoryVolume = productionVolume - quantityOfSales;
			double changeOfInventory = changeOfInventoryVolume * costPerUnit;
			
			OLAPCellWriteNumber(connection, MainCube, changeOfInventoryVolume, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""CHANGE_INVENTORY_VOLUME"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			OLAPCellWriteNumber(connection, MainCube, changeOfInventory, currentMonth, cycle, version,""CHANGE_SALES_VALUES_DEFAULTS"", stepWrite,entity, intercompany, organization, ""CHANGE_INVENTORY"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA"	1	02BF5BA3-B0FF-4FFC-9336-26422B48B22A	Calculates the quantity, price, or revenue depending on the sales configuration, depending cost position, and change of inventory and opening balances.	1	1	1	1556	NULL	0	45708.67504	0	0
9A51967D-1F5C-4967-8B4F-141EBAA82406	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCalculateSalesReceivables	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set  element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The cost center element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""salesGroup"" parameter-type=""string"" parameter-description=""The sales group element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""The value entered."" parameter-order=""17"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateSalesReceivables(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, double value)
@Description: ""Calculate cash and receivables movement based on entered days receivables."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The cost center element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateSalesReceivables: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));

	
	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	//Elias: It is TOTAL SALES GROUP and not TOTAL_SALES_GROUP
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateSalesReceivables: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");

	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"",stepRead, entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = daysReceivables / 30.0;
		remainder = periodOffset;
		while (remainder &gt; 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset &gt; 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}

		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double defaultDaysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"", stepRead,entity, intercompany, organization,account, currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceDaysReceivables = value - defaultDaysReceivables;
		LogDebug(""Difference: "" + differenceDaysReceivables);
		OLAPCellWriteNumber(connection, MainCube, differenceDaysReceivables, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"",stepWrite, entity, intercompany, organization, account,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		// calculate lag from entered value
		periodOffset = value / 30.0;
		remainder = periodOffset;
		while (remainder &gt; 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		lagElement = periodOffset + ""_PERIODS_LATER"";
		laggedMonth = currentMonth;
		if (periodOffset &gt; 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}

		OLAPCellIncrementNumber(connection, MainCube, netRevenue * - 1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the Configuration set  after the entered period calculate the opening balance
			if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BPCalculateSalesReceivables: Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);
				double lastYearMovementReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceReceivablesIncrease = lastYearMovementReceivablesIncrease + lastYearClosingReceivablesIncrease;
				double closingBalanceReceivablesDecrease = lastYearMovementReceivablesDecrease + lastYearClosingReceivablesDecrease;
				double closingCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}
	
	LogInformation(""BPCalculateSalesReceivables: Process complete"");

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPCalculateSalesReceivables(
	string database, string ticket, string time, string cycle, string version, string entity,string stepRead,string stepWrite, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string primarySegment, string secondarySegment, string tertiarySegment, string salesGroup, double value)
@Description: ""Calculate cash and receivables movement based on entered days receivables."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set  element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The cost center element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[salesGroup]: ""The sales group element to be used."";
@Parameter[value]: ""The value entered."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BAPCalculateSalesReceivables: Starting process"");

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	time = ResolveUniqueName(connection, time);
	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	stepRead= ResolveUniqueName(connection, stepRead);
	stepWrite= ResolveUniqueName(connection, stepWrite);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	account = ResolveUniqueName(connection, account);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	salesGroup = ResolveUniqueName(connection, salesGroup);

	// constants used in the process
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES_GROUP"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));

	
	// needed for truncation as we currently have no truncate operator
	// TODO replace in next version
	double remainder = 0;
	
	//Elias: It is TOTAL SALES GROUP and not TOTAL_SALES_GROUP
	string salesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_SALES"", ""Text Value"");
	string receivablesAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_RECEIVABLES"", ""Text Value"");
	string cashAccount = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, salesGroup, ""TOTAL SALES GROUP"", ""SALES_GROUP_INFO"", ""SUBPLAN_SALES_ACC_CASH"", ""Text Value"");
	
	if (StringLength(salesAccount) == 0 or StringLength(receivablesAccount) == 0 or StringLength(cashAccount) == 0)
	{
		LogDebug(""BPCalculateSalesReceivables: An error has occured the configuration of the sales accounts is inclomplete."");
		return -1;
	}
	
	// read attributes to detect the account type and if the calendar element is a base element
	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
	string currentYear = OLAPGetStringAttribute(connection, timeElement, ""CURRENT_YEAR"");

	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	double cycleYearStart = ToDouble(cycleYearStarthelp);
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	salesAccount = ResolveUniqueName(connection, salesAccount);
	receivablesAccount = ResolveUniqueName(connection, receivablesAccount);
	cashAccount = ResolveUniqueName(connection, cashAccount);
	
	// get the list of months to calculate effectively
	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(connection, TimeDimension, time, true);
	}
	
	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		double netRevenue = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_VALUES"",stepRead, entity, intercompany, organization, ""NET_REVENUE"",currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		// get days receivables
		double daysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""TOTAL_SALES_FACTORS"",stepRead, entity, intercompany, organization, ""DAYS_RECEIVABLES"",currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double increaseReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""CALC_SALES_UNAPPROVED"", stepRead,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double periodOffset = daysReceivables / 30.0;
		remainder = periodOffset;
		while (remainder > 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		OLAPElement currentMonthElement = OLAPGetDimensionElement(connection, TimeDimension, currentMonth);
		string lagElement = periodOffset + ""_PERIODS_LATER"";
		string laggedMonth = currentMonth;
		if (periodOffset > 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}

		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, increaseReceivables * -1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		
		double defaultDaysReceivables = OLAPCellReadNumber(connection, MainCube, 1.0, currentMonth, cycle, version,""SALES_FACTORS_DEFAULTS"", stepRead,entity, intercompany, organization,account, currencyRead,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
		double differenceDaysReceivables = value - defaultDaysReceivables;
		LogDebug(""Difference: "" + differenceDaysReceivables);
		OLAPCellWriteNumber(connection, MainCube, differenceDaysReceivables, currentMonth, cycle, version,""CHANGE_SALES_FACTORS_DEFAULTS"",stepWrite, entity, intercompany, organization, account,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);

		// calculate lag from entered value
		periodOffset = value / 30.0;
		remainder = periodOffset;
		while (remainder > 1)
		{
			remainder = remainder - 1;
		}
		periodOffset = periodOffset - remainder;
		lagElement = periodOffset + ""_PERIODS_LATER"";
		laggedMonth = currentMonth;
		if (periodOffset > 0)
		{
			laggedMonth = OLAPGetStringAttribute(connection, currentMonthElement, lagElement);
			laggedMonth = ResolveUniqueName(connection, laggedMonth);
		}

		OLAPCellIncrementNumber(connection, MainCube, netRevenue * - 1, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
		OLAPCellIncrementNumber(connection, MainCube, netRevenue, laggedMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"", stepWrite,entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
	}
	
	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the Configuration set  after the entered period calculate the opening balance
			if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				// TODO get from calendar
				string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
				// TODO get from calendar
				string currentYearFirstMonth = ""01_"" + checkYear;

				LogDebug(""BPCalculateSalesReceivables: Calculating OB for "" + lastYearTotal + "" Write to: "" + currentYearFirstMonth);
				double lastYearMovementReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED"",stepRead, entity, intercompany, organization,receivablesAccount, currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearMovementCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"",stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingReceivablesIncrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingReceivablesDecrease = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				double lastYearClosingCash = OLAPCellReadNumber(connection, MainCube, 1.0, lastYearTotal, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepRead, entity, intercompany, organization, cashAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				double closingBalanceReceivablesIncrease = lastYearMovementReceivablesIncrease + lastYearClosingReceivablesIncrease;
				double closingBalanceReceivablesDecrease = lastYearMovementReceivablesDecrease + lastYearClosingReceivablesDecrease;
				double closingCash = lastYearMovementCash + lastYearClosingCash;
				
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesIncrease, currentYearFirstMonth, cycle, version,""CALC_SALES_UNAPPROVED_OB"",stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingBalanceReceivablesDecrease, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"", stepWrite, entity, intercompany, organization, receivablesAccount,currencyWrite,  NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
				OLAPCellWriteNumber(connection, MainCube, closingCash, currentYearFirstMonth, cycle, version,""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"",stepWrite, entity, intercompany, organization, cashAccount,currencyWrite, NA, primarySegment, secondarySegment, tertiarySegment, NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA);
			}
		}
	}
	
	LogInformation(""BPCalculateSalesReceivables: Process complete"");

	return 0;
}"	1	F7F00E24-C8E8-431B-AF1E-F81138141789	Calculate cash and receivables movement based on entered days receivables.	1	1	1	1557	NULL	0	45708.67503	0	0
6D48B065-CB9C-436F-8BFF-D30A94158D13	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyAssumptions	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""SourceCycleUN"" parameter-type=""string"" parameter-description=""The Source Configuration set  element UN to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The Source version element UN to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""SourceEntityUN"" parameter-type=""string"" parameter-description=""The Source Entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""TargetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration set  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""TargetVersionUN"" parameter-type=""string"" parameter-description=""The target version element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""TargetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity/entities element to be used."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPCopyAssumptions(string Database, string Ticket, string SourceCycleUN,string SourceVersionUN,string SourceEntityUN, string TargetCycleUN,  string TargetVersionUN , string TargetEntityUN)
@Description: ""Copy premises from source Configuration Set , version, entity to selected target Configuration Set , version, entities."";
@Category: ""Budgeting and Planning"";

@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The Source Configuration set  element UN to be used."";
@Parameter[SourceVersionUN]: ""The Source version element UN to be used."";
@Parameter[SourceEntityUN]: ""The Source Entity element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity/entities element to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPCopyAssumptions: "";
	string Cube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string result ="""";
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		string sourceCycle = ResolveUniqueName(connection, SourceCycleUN);
		string sourceVersion = ResolveUniqueName(connection, SourceVersionUN);
		string sourceEntity = ResolveUniqueName(connection, SourceEntityUN);
		string targetCycle = ResolveUniqueName(connection, TargetCycleUN);
		string targetVersion = ResolveUniqueName(connection, TargetVersionUN);

		//procedure to fill array with entities from string paramater
		StringArray targetEntities = CreateStringArray();
		if(!StringContains(TargetEntityUN, "",""))
		{
			TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
			Append(targetEntities, TargetEntityUN);
		}

		while(StringContains(TargetEntityUN, "",""))
		{
			int numberOfLetters = StringFind(TargetEntityUN,"","",1);

			string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
			targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
			AppendDistinct(targetEntities, targetEntityHelp);

			TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
			numberOfLetters = StringFind(TargetEntityUN,"","",1);
			if(numberOfLetters&lt;0)
			{
				numberOfLetters = StringLength(TargetEntityUN);
			}
			targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
			targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
			AppendDistinct(targetEntities, targetEntityHelp);
		}



		// finding free element in PNO dimension - planning step
		foreach (string TargetEntity in targetEntities)
		{

			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             NA, targetCycle,  targetVersion, TargetEntity, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             NA, sourceCycle, sourceVersion, sourceEntity, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, NA, targetCycle, targetVersion, TargetEntity, paccount, ppremises);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  NA, targetCycle, targetVersion, TargetEntity, paccount, ppremises);
				}

			}

		}
		OLAPCommitCellWriteBuffer(buffer);
		return ""true"";		
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		result = """";
		return result;
	}

}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPCopyAssumptions(string Database, string Ticket, string SourceCycleUN,string SourceVersionUN,string SourceEntityUN, string TargetCycleUN,  string TargetVersionUN , string TargetEntityUN)
@Description: ""Copy premises from source Configuration Set , version, entity to selected target Configuration Set , version, entities."";
@Category: ""Budgeting and Planning"";

@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The Source Configuration set  element UN to be used."";
@Parameter[SourceVersionUN]: ""The Source version element UN to be used."";
@Parameter[SourceEntityUN]: ""The Source Entity element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity/entities element to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPCopyAssumptions: "";
	string Cube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string result ="""";
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		string sourceCycle = ResolveUniqueName(connection, SourceCycleUN);
		string sourceVersion = ResolveUniqueName(connection, SourceVersionUN);
		string sourceEntity = ResolveUniqueName(connection, SourceEntityUN);
		string targetCycle = ResolveUniqueName(connection, TargetCycleUN);
		string targetVersion = ResolveUniqueName(connection, TargetVersionUN);

		//procedure to fill array with entities from string paramater
		StringArray targetEntities = CreateStringArray();
		if(!StringContains(TargetEntityUN, "",""))
		{
			TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
			Append(targetEntities, TargetEntityUN);
		}

		while(StringContains(TargetEntityUN, "",""))
		{
			int numberOfLetters = StringFind(TargetEntityUN,"","",1);

			string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
			targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
			AppendDistinct(targetEntities, targetEntityHelp);

			TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
			numberOfLetters = StringFind(TargetEntityUN,"","",1);
			if(numberOfLetters<0)
			{
				numberOfLetters = StringLength(TargetEntityUN);
			}
			targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
			targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
			AppendDistinct(targetEntities, targetEntityHelp);
		}



		// finding free element in PNO dimension - planning step
		foreach (string TargetEntity in targetEntities)
		{

			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             NA, targetCycle,  targetVersion, TargetEntity, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             NA, sourceCycle, sourceVersion, sourceEntity, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, NA, targetCycle, targetVersion, TargetEntity, paccount, ppremises);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  NA, targetCycle, targetVersion, TargetEntity, paccount, ppremises);
				}

			}

		}
		OLAPCommitCellWriteBuffer(buffer);
		return ""true"";		
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		result = """";
		return result;
	}

}"	1	4ABE85D2-E443-4652-82F0-E608D092B9D1	Copy premises from source Configuration Set , version, entity to selected target Configuration Set , version, entities.	1	1	1	1558	NULL	0	45708.67508	0	0
923C2922-3D52-442A-BF14-FA6CB55F69AA	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyCycle	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Number of copied cubes."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""Cubes"" parameter-type=""string"" parameter-description=""List of cubes to copy + WFCOPY if workflow is copied"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""SourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""TargetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""TargetCycleName"" parameter-type=""string"" parameter-description=""Target Configuration set name"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyCycle(string Database, string Ticket, string Cubes, string SourceCycleUN, string TargetCycleUN, string TargetCycleName)

@Description: ""Copy Configuration Set settings within the listed cubes."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[Cubes]: ""List of cubes to copy + WFCOPY if workflow is copied"";
@Parameter[SourceCycleUN]: ""The source Configuration set  element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetCycleName]: ""Target Configuration set name"";
{
	LogInformation(""BPCopyCycle: Starting process"");
	int CopyOperations = 0;
	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	/*Cubes=""BPCCONFIG_EXCHANGE,CFCCONFIG_CASHFLOW,EXCRATES,BPCCONFIG_CYCLE,BPCCONFIG_ENTITY,BPCCONFIG_ENTITY_SEGMENT,BPCCONFIG_PREMISES,BPCCONFIG_SALES_GROUP,BPCCONFIG_SALES,PWORKFLOW"";

	SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_004].[1]"";
	TargetCycleName= ""MichalTest"";*/

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	NotifyInformation(""Creation of new Configuration set started."");

	// Creating cubes array from the semicolon delimited list
	StringArray CubesArray = CreateStringArray();
	if (StringContains(Cubes, ""BPCCONFIG_EXCHANGE""))
	{
		Cube = ""BPCCONFIG_EXCHANGE"";
		NotifyInformation(""Copying data for Exchange configuration."" );

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion,pcurrency,pparameter,planguage);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}

		}

	}
	else
	{
		// this part is because there is not possibility to activate forecast in UI , so fc configuration for BPCCONFIG_EXCHANGE should be copied everytime
		OLAPElementList fcVersionList = OLAPGetChildElementList(connection, ""BPDVERSION"", ""TOTAL_FORECAST"" , true);
		Cube = ""BPCCONFIG_EXCHANGE"";
		NotifyInformation(""Copying data for Exchange configuration for forecast versions."" );

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle,  fcVersionList,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, fcVersionList,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
		}
	}



	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""CFCCONFIG_CASHFLOW""))
	{
		Cube = ""CFCCONFIG_CASHFLOW"";
		NotifyInformation(""Copying data for Cashflow configuration."");

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pdetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pCashFlow = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
			string pConfigCashFlow = OLAPCellGetElement(cell, ""CFDCONFIG_CASHFLOW"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			
			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, ptime, TargetCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, ptime, TargetCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			}
			
		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""EXCRATES""))
	{
		Cube = ""EXCRATES"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
			string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
			string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
			string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,pversion,exdtype,pentity,pintercompany,paccount,pccurrency,pgcurrency,pexrates);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  ptime, TargetCycle,pversion,exdtype,pentity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  ptime, TargetCycle,pversion,exdtype,pentity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);


	if (StringContains(Cubes, ""BPCCONFIG_CYCLE""))
	{
		Cube = ""BPCCONFIG_CYCLE"";
		NotifyInformation(""Copying data for Configuration set Definition."");

		// Definition of the target data area
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);

		// Clear target data area before copying
		OLAPDeleteDataArea(TargetData);
		
		// Definition of the source data area
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);
		// Copy values
		foreach (OLAPCell cell in SourceData)
		{
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			
			// Skip listed settings to allow new cycle editing
			if ((pattpara!=""GLOBAL_CYCLE_CURRENT"") and (pattpara!=""GLOBAL_CYCLE_PLANNING_STARTED"") and (pattpara!=""GLOBAL_CYCLE_PLANNING_ENDED"") and (pattpara!=""GLOBAL_CYCLE_VERSION_COMPLETED""))
			{
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion, pattpara, planguage);
				
				// Set cycle name from the parameter
				if (pattpara==""GLOBAL_CYCLE_DESCRIPTION"")
				{
					valueStr = TargetCycleName;
				}
				
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  TargetCycle,pversion, pattpara, planguage);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  TargetCycle,pversion, pattpara, planguage);
				}
			}
		}
		bool isActivated = false;
		if (StringContains(Cubes, ""BPCCONFIG_MAIN""))
		{
			StringDictionary created = CreateStringDictionary();
			OLAPDataArea SourceDatat = OLAPCreateDataArea(connection, ""BPCCONFIG_MAIN"",
			                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC| OlapDataAreaSuppressNull , OlapDataAreaOperatorNone, 0.0,
			                                              OlapDataAreaOperatorNone, 0.0,
			                                              SourceCycle, OlapDataAreaBCells, ""TOTAL_ENTITY"", ""N.A."", ""N.A."",""TOTAL"",""SUBPLAN_FINANCE_CREATED"",""Value"");

			foreach (OLAPCell cell in SourceDatat)
			{
				string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
				double value = cell;
				created[pversion]=ToString(value);
			}

			OLAPDataArea SourceDataCompl = OLAPCreateDataArea(connection, Cube,
			                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                  OlapDataAreaOperatorNone, 0.0,
			                                                  SourceCycle, OlapDataAreaBCells,""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");
			foreach (OLAPCell cell in SourceDataCompl)
			{
				string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
				double value =0;
				if(ContainsKey(created,pversion))
				{
					value = ToDouble(created[pversion]);
				}

				if(value !=0)
				{
					OLAPCellWriteBufferWriteNumber(buffer,Cube,1, TargetCycle,pversion, ""GLOBAL_CYCLE_VERSION_COMPLETED"", ""Value"");
					if(!isActivated)
					{
						OLAPCellWriteBufferWriteNumber(buffer,Cube,1, TargetCycle,""N.A."", ""GLOBAL_CYCLE_PLANNING_STARTED"", ""Value"");
					}
					isActivated = true;
				}
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""BPCCONFIG_ENTITY""))
	{
		Cube = ""BPCCONFIG_ENTITY"";
		NotifyInformation(""Copying data for Configuration set configuration/Entity Settings."");
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}


			//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  TargetCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			}

		}

	}
	OLAPCommitCellWriteBuffer(buffer);
	StringList slVersion = ConvertToStringList(OlapDataAreaBCells);
	StringList slEntity = ConvertToStringList(OlapDataAreaBCells);
	StringList slOrganization = ConvertToStringList(OlapDataAreaBCells);
	StringList slIntercompany = ConvertToStringList(OlapDataAreaBCells);
	StringList slAccount = ConvertToStringList(OlapDataAreaBCells);
	StringList slNO = ConvertToStringList(OlapDataAreaBCells);
	StringList slParameter = ConvertToStringList(OlapDataAreaBCells);
	StringList slLanguage = ConvertToStringList(OlapDataAreaBCells);
	StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);
	


	if (StringContains(Cubes, ""BPCCONFIG_ENTITY_SEGMENT""))
	{
		Cube = ""BPCCONFIG_ENTITY_SEGMENT"";
		NotifyInformation(""Copying data for Segment configuration."");
		OLAPDataArea TargetDataBES = OLAPCreateDataArea(connection, Cube,
		                                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataBES);
		
		OLAPDataArea SourceDataBES = OLAPCreateDataArea(connection, Cube,
		                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                SourceCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		StringListList targetElementsBES = CreateStringListList();
		StringList slTCycle = ConvertToStringList(TargetCycle);
		Append(targetElementsBES, slTCycle);
		Append(targetElementsBES, slVersion);
		Append(targetElementsBES, slEntity);
		Append(targetElementsBES, slPSegment);
		Append(targetElementsBES, slSSegment);
		Append(targetElementsBES, slTSegment);
		Append(targetElementsBES, slParameter);

		
		StringListList sourceElementsBES = CreateStringListList();
		StringList slSCycle = ConvertToStringList(SourceCycle);
		Append(sourceElementsBES, slSCycle);
		Append(sourceElementsBES, slVersion);
		Append(sourceElementsBES, slEntity);
		Append(sourceElementsBES, slPSegment);
		Append(sourceElementsBES, slSSegment);
		Append(sourceElementsBES, slTSegment);
		Append(sourceElementsBES, slParameter);

		OLAPCopyDataArea(SourceDataBES, Cube, ""Relative"", 1.0, targetElementsBES, sourceElementsBES, true, true);



	}
	OLAPCommitCellWriteBuffer(buffer);


	if (StringContains(Cubes, ""BPCCONFIG_MAIN""))
	{
		Cube = ""BPCCONFIG_MAIN"";


		NotifyInformation(""Copying data for Financial planning steps. This cube contain significant amount of data, so copying can take long time."");


		
		OLAPDataArea TargetDataBPCCONMAIN = OLAPCreateDataArea(connection, Cube,
		                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                       OlapDataAreaOperatorNone, 0.0,
		                                                       TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells);

		OLAPDeleteDataArea(TargetDataBPCCONMAIN);


		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube ,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells);


		StringListList targetElementsBM = CreateStringListList();
		StringList slVersionBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slEntityBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slOrganizationBM = ConvertToStringList(OlapDataAreaAllCells);

		StringList slAccountBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slNOBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slLanguageBM = ConvertToStringList(OlapDataAreaAllCells);

		StringList slTCycle = ConvertToStringList(TargetCycle);
		Append(targetElementsBM, slTCycle);
		Append(targetElementsBM, slVersion);
		Append(targetElementsBM, slEntity);
		Append(targetElementsBM, slOrganization);
		Append(targetElementsBM, slAccount);
		Append(targetElementsBM, slNO);
		Append(targetElementsBM, slParameter);
		Append(targetElementsBM, slLanguage);

		StringListList sourceElementsBM = CreateStringListList();
		StringList slSCycle = ConvertToStringList(SourceCycle);
		Append(sourceElementsBM, slSCycle);
		Append(sourceElementsBM, slVersion);
		Append(sourceElementsBM, slEntity);
		Append(sourceElementsBM, slOrganization);
		Append(sourceElementsBM, slAccount);
		Append(sourceElementsBM, slNO);
		Append(sourceElementsBM, slParameter);
		Append(sourceElementsBM, slLanguage);


		OLAPCopyDataArea(SourceData, Cube, ""Relative"", 1.0, targetElementsBM, sourceElementsBM, true, true);
		if(!StringContains(Cubes, ""WFCOPY""))
		{
			OLAPDataArea TargetDataBPCCONMAINDELETECOMAPLETED = OLAPCreateDataArea(connection, Cube,
			                                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                                       OlapDataAreaOperatorNone, 0.0,
			                                                                       TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, ""SUBPLAN_FINANCE_COMPLETED"", OlapDataAreaAllCells);

			OLAPDeleteDataArea(TargetDataBPCCONMAINDELETECOMAPLETED);

		}
	}
	else
	{
		Cube = ""BPCCONFIG_MAIN"";

		OLAPDataArea TargetDataBPCCONMAIN = OLAPCreateDataArea(connection, Cube,
		                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                       OlapDataAreaOperatorNone, 0.0,
		                                                       TargetCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(TargetDataBPCCONMAIN);


		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube ,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
		foreach (OLAPCell cell in SourceData)
		{
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			
			OLAPCellWriteBufferWriteNumber(buffer, Cube, cell,  TargetCycle,pversion,pcompany,pcostcenter, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
		}
		OLAPCommitCellWriteBuffer(buffer);
	}

	if (StringContains(Cubes, ""BPCCONFIG_PREMISES""))
	{
		NotifyInformation(""Copying data for Dependent account definition."");
		Cube = ""BPCCONFIG_PREMISES"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string psource = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle, psource, pcompany, paccount, ppremises);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, ptime, TargetCycle, psource, pcompany, paccount, ppremises);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  ptime, TargetCycle, psource, pcompany, paccount, ppremises);
			}

		}

	}

	OLAPCommitCellWriteBuffer(buffer);
	if (StringContains(Cubes, ""BPCCONFIG_SALES_GROUP""))
	{

		Cube = ""BPCCONFIG_SALES_GROUP"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pno = OLAPCellGetElement(cell, ""BPDNO"");
			string pconfigSalesGroupTypes = OLAPCellGetElement(cell, ""BPDCONFIG_SALES_GROUP"");
			string pconfigSalesMeasures = OLAPCellGetElement(cell, ""BPDCONFIG_SALES_MEASURE"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			
			//string value = OLAPCellReadString(connection, Cube, SourceCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  TargetCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,   TargetCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);
	if (StringContains(Cubes, ""BPCCONFIG_SALES""))
	{
		Cube = ""BPCCONFIG_SALES"";


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPD"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyCycle(string Database, string Ticket, string Cubes, string SourceCycleUN, string TargetCycleUN, string TargetCycleName)

@Description: ""Copy Configuration Set settings within the listed cubes."";
@Category: ""Budgeting and Planning"";
@Returns: ""Number of copied cubes."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[Cubes]: ""List of cubes to copy + WFCOPY if workflow is copied"";
@Parameter[SourceCycleUN]: ""The source Configuration set  element to be used."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetCycleName]: ""Target Configuration set name"";
{
	LogInformation(""BPCopyCycle: Starting process"");
	int CopyOperations = 0;
	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	/*Cubes=""BPCCONFIG_EXCHANGE,CFCCONFIG_CASHFLOW,EXCRATES,BPCCONFIG_CYCLE,BPCCONFIG_ENTITY,BPCCONFIG_ENTITY_SEGMENT,BPCCONFIG_PREMISES,BPCCONFIG_SALES_GROUP,BPCCONFIG_SALES,PWORKFLOW"";

	SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_004].[1]"";
	TargetCycleName= ""MichalTest"";*/

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	NotifyInformation(""Creation of new Configuration set started."");

	// Creating cubes array from the semicolon delimited list
	StringArray CubesArray = CreateStringArray();
	if (StringContains(Cubes, ""BPCCONFIG_EXCHANGE""))
	{
		Cube = ""BPCCONFIG_EXCHANGE"";
		NotifyInformation(""Copying data for Exchange configuration."" );

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion,pcurrency,pparameter,planguage);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}

		}

	}
	else
	{
		// this part is because there is not possibility to activate forecast in UI , so fc configuration for BPCCONFIG_EXCHANGE should be copied everytime
		OLAPElementList fcVersionList = OLAPGetChildElementList(connection, ""BPDVERSION"", ""TOTAL_FORECAST"" , true);
		Cube = ""BPCCONFIG_EXCHANGE"";
		NotifyInformation(""Copying data for Exchange configuration for forecast versions."" );

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle,  fcVersionList,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, fcVersionList,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,pversion,pcurrency,pparameter,planguage);
			}
		}
	}



	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""CFCCONFIG_CASHFLOW""))
	{
		Cube = ""CFCCONFIG_CASHFLOW"";
		NotifyInformation(""Copying data for Cashflow configuration."");

		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pdetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pCashFlow = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
			string pConfigCashFlow = OLAPCellGetElement(cell, ""CFDCONFIG_CASHFLOW"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			
			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, ptime, TargetCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, ptime, TargetCycle,pversion,pdetail,paccount,pCashFlow,pConfigCashFlow);
			}
			
		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""EXCRATES""))
	{
		Cube = ""EXCRATES"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
			string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
			string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
			string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,pversion,exdtype,pentity,pintercompany,paccount,pccurrency,pgcurrency,pexrates);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  ptime, TargetCycle,pversion,exdtype,pentity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  ptime, TargetCycle,pversion,exdtype,pentity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);


	if (StringContains(Cubes, ""BPCCONFIG_CYCLE""))
	{
		Cube = ""BPCCONFIG_CYCLE"";
		NotifyInformation(""Copying data for Configuration set Definition."");

		// Definition of the target data area
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);

		// Clear target data area before copying
		OLAPDeleteDataArea(TargetData);
		
		// Definition of the source data area
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells);
		// Copy values
		foreach (OLAPCell cell in SourceData)
		{
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			
			// Skip listed settings to allow new cycle editing
			if ((pattpara!=""GLOBAL_CYCLE_CURRENT"") and (pattpara!=""GLOBAL_CYCLE_PLANNING_STARTED"") and (pattpara!=""GLOBAL_CYCLE_PLANNING_ENDED"") and (pattpara!=""GLOBAL_CYCLE_VERSION_COMPLETED""))
			{
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion, pattpara, planguage);
				
				// Set cycle name from the parameter
				if (pattpara==""GLOBAL_CYCLE_DESCRIPTION"")
				{
					valueStr = TargetCycleName;
				}
				
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  TargetCycle,pversion, pattpara, planguage);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  TargetCycle,pversion, pattpara, planguage);
				}
			}
		}
		bool isActivated = false;
		if (StringContains(Cubes, ""BPCCONFIG_MAIN""))
		{
			StringDictionary created = CreateStringDictionary();
			OLAPDataArea SourceDatat = OLAPCreateDataArea(connection, ""BPCCONFIG_MAIN"",
			                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC| OlapDataAreaSuppressNull , OlapDataAreaOperatorNone, 0.0,
			                                              OlapDataAreaOperatorNone, 0.0,
			                                              SourceCycle, OlapDataAreaBCells, ""TOTAL_ENTITY"", ""N.A."", ""N.A."",""TOTAL"",""SUBPLAN_FINANCE_CREATED"",""Value"");

			foreach (OLAPCell cell in SourceDatat)
			{
				string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
				double value = cell;
				created[pversion]=ToString(value);
			}

			OLAPDataArea SourceDataCompl = OLAPCreateDataArea(connection, Cube,
			                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                  OlapDataAreaOperatorNone, 0.0,
			                                                  SourceCycle, OlapDataAreaBCells,""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");
			foreach (OLAPCell cell in SourceDataCompl)
			{
				string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
				double value =0;
				if(ContainsKey(created,pversion))
				{
					value = ToDouble(created[pversion]);
				}

				if(value !=0)
				{
					OLAPCellWriteBufferWriteNumber(buffer,Cube,1, TargetCycle,pversion, ""GLOBAL_CYCLE_VERSION_COMPLETED"", ""Value"");
					if(!isActivated)
					{
						OLAPCellWriteBufferWriteNumber(buffer,Cube,1, TargetCycle,""N.A."", ""GLOBAL_CYCLE_PLANNING_STARTED"", ""Value"");
					}
					isActivated = true;
				}
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	if (StringContains(Cubes, ""BPCCONFIG_ENTITY""))
	{
		Cube = ""BPCCONFIG_ENTITY"";
		NotifyInformation(""Copying data for Configuration set configuration/Entity Settings."");
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}


			//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  TargetCycle,pversion, pcompany, pintercompany, pcostcenter, pattpara);
			}

		}

	}
	OLAPCommitCellWriteBuffer(buffer);
	StringList slVersion = ConvertToStringList(OlapDataAreaBCells);
	StringList slEntity = ConvertToStringList(OlapDataAreaBCells);
	StringList slOrganization = ConvertToStringList(OlapDataAreaBCells);
	StringList slIntercompany = ConvertToStringList(OlapDataAreaBCells);
	StringList slAccount = ConvertToStringList(OlapDataAreaBCells);
	StringList slNO = ConvertToStringList(OlapDataAreaBCells);
	StringList slParameter = ConvertToStringList(OlapDataAreaBCells);
	StringList slLanguage = ConvertToStringList(OlapDataAreaBCells);
	StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);
	


	if (StringContains(Cubes, ""BPCCONFIG_ENTITY_SEGMENT""))
	{
		Cube = ""BPCCONFIG_ENTITY_SEGMENT"";
		NotifyInformation(""Copying data for Segment configuration."");
		OLAPDataArea TargetDataBES = OLAPCreateDataArea(connection, Cube,
		                                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataBES);
		
		OLAPDataArea SourceDataBES = OLAPCreateDataArea(connection, Cube,
		                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                SourceCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		StringListList targetElementsBES = CreateStringListList();
		StringList slTCycle = ConvertToStringList(TargetCycle);
		Append(targetElementsBES, slTCycle);
		Append(targetElementsBES, slVersion);
		Append(targetElementsBES, slEntity);
		Append(targetElementsBES, slPSegment);
		Append(targetElementsBES, slSSegment);
		Append(targetElementsBES, slTSegment);
		Append(targetElementsBES, slParameter);

		
		StringListList sourceElementsBES = CreateStringListList();
		StringList slSCycle = ConvertToStringList(SourceCycle);
		Append(sourceElementsBES, slSCycle);
		Append(sourceElementsBES, slVersion);
		Append(sourceElementsBES, slEntity);
		Append(sourceElementsBES, slPSegment);
		Append(sourceElementsBES, slSSegment);
		Append(sourceElementsBES, slTSegment);
		Append(sourceElementsBES, slParameter);

		OLAPCopyDataArea(SourceDataBES, Cube, ""Relative"", 1.0, targetElementsBES, sourceElementsBES, true, true);



	}
	OLAPCommitCellWriteBuffer(buffer);


	if (StringContains(Cubes, ""BPCCONFIG_MAIN""))
	{
		Cube = ""BPCCONFIG_MAIN"";


		NotifyInformation(""Copying data for Financial planning steps. This cube contain significant amount of data, so copying can take long time."");


		
		OLAPDataArea TargetDataBPCCONMAIN = OLAPCreateDataArea(connection, Cube,
		                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                       OlapDataAreaOperatorNone, 0.0,
		                                                       TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells);

		OLAPDeleteDataArea(TargetDataBPCCONMAIN);


		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube ,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells);


		StringListList targetElementsBM = CreateStringListList();
		StringList slVersionBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slEntityBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slOrganizationBM = ConvertToStringList(OlapDataAreaAllCells);

		StringList slAccountBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slNOBM = ConvertToStringList(OlapDataAreaAllCells);
		StringList slLanguageBM = ConvertToStringList(OlapDataAreaAllCells);

		StringList slTCycle = ConvertToStringList(TargetCycle);
		Append(targetElementsBM, slTCycle);
		Append(targetElementsBM, slVersion);
		Append(targetElementsBM, slEntity);
		Append(targetElementsBM, slOrganization);
		Append(targetElementsBM, slAccount);
		Append(targetElementsBM, slNO);
		Append(targetElementsBM, slParameter);
		Append(targetElementsBM, slLanguage);

		StringListList sourceElementsBM = CreateStringListList();
		StringList slSCycle = ConvertToStringList(SourceCycle);
		Append(sourceElementsBM, slSCycle);
		Append(sourceElementsBM, slVersion);
		Append(sourceElementsBM, slEntity);
		Append(sourceElementsBM, slOrganization);
		Append(sourceElementsBM, slAccount);
		Append(sourceElementsBM, slNO);
		Append(sourceElementsBM, slParameter);
		Append(sourceElementsBM, slLanguage);


		OLAPCopyDataArea(SourceData, Cube, ""Relative"", 1.0, targetElementsBM, sourceElementsBM, true, true);
		if(!StringContains(Cubes, ""WFCOPY""))
		{
			OLAPDataArea TargetDataBPCCONMAINDELETECOMAPLETED = OLAPCreateDataArea(connection, Cube,
			                                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                                       OlapDataAreaOperatorNone, 0.0,
			                                                                       TargetCycle, OlapDataAreaAllCells,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, ""SUBPLAN_FINANCE_COMPLETED"", OlapDataAreaAllCells);

			OLAPDeleteDataArea(TargetDataBPCCONMAINDELETECOMAPLETED);

		}
	}
	else
	{
		Cube = ""BPCCONFIG_MAIN"";

		OLAPDataArea TargetDataBPCCONMAIN = OLAPCreateDataArea(connection, Cube,
		                                                       OlapDataAreaIncludeB | OlapDataAreaIncludeC |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                       OlapDataAreaOperatorNone, 0.0,
		                                                       TargetCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(TargetDataBPCCONMAIN);


		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube ,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
		foreach (OLAPCell cell in SourceData)
		{
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			
			OLAPCellWriteBufferWriteNumber(buffer, Cube, cell,  TargetCycle,pversion,pcompany,pcostcenter, ""N.A."", ""N.A."", ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");
		}
		OLAPCommitCellWriteBuffer(buffer);
	}

	if (StringContains(Cubes, ""BPCCONFIG_PREMISES""))
	{
		NotifyInformation(""Copying data for Dependent account definition."");
		Cube = ""BPCCONFIG_PREMISES"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, TargetCycle,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, SourceCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string psource = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string ppremises = OLAPCellGetElement(cell, ""BPDPREMISE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			//string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle, psource, pcompany, paccount, ppremises);
			
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, ptime, TargetCycle, psource, pcompany, paccount, ppremises);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  ptime, TargetCycle, psource, pcompany, paccount, ppremises);
			}

		}

	}

	OLAPCommitCellWriteBuffer(buffer);
	if (StringContains(Cubes, ""BPCCONFIG_SALES_GROUP""))
	{

		Cube = ""BPCCONFIG_SALES_GROUP"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pno = OLAPCellGetElement(cell, ""BPDNO"");
			string pconfigSalesGroupTypes = OLAPCellGetElement(cell, ""BPDCONFIG_SALES_GROUP"");
			string pconfigSalesMeasures = OLAPCellGetElement(cell, ""BPDCONFIG_SALES_MEASURE"");
			string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			
			//string value = OLAPCellReadString(connection, Cube, SourceCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  TargetCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,   TargetCycle, paccount, pno, pconfigSalesGroupTypes, pconfigSalesMeasures, pattpara, planguage);
			}
		}

	}
	OLAPCommitCellWriteBuffer(buffer);
	if (StringContains(Cubes, ""BPCCONFIG_SALES""))
	{
		Cube = ""BPCCONFIG_SALES"";


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             TargetCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             SourceCycle, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string pversion = OLAPCellGetElement(cell, ""BPDVERSION"");
			string pcompany = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string pcostcenter = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string ppsegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
			string pssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
			string ptsegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
			string pconfigSales = OLAPCellGetElement(cell, ""BPDCONFIG_SALES"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			//string value = OLAPCellReadString(connection, Cube, SourceCycle,pversion, pcompany, pintercompany, pcostcenter, ppsegment, pssegment, ptsegment, pconfigSales);
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr,  TargetCycle,pversion, pcompany, pintercompany, pcostcenter, ppsegment, pssegment, ptsegment, pconfigSales);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,   TargetCycle,pversion, pcompany, pintercompany, pcostcenter, ppsegment, pssegment, ptsegment, pconfigSales);
			}
			
		}
	}
	OLAP"	1	A4273239-8B54-4AF8-AB84-B2EBD7963114	Copy Configuration Set settings within the listed cubes.	1	1	1	1559	NULL	0	45708.67505	0	0
EEB1E688-C4EC-4290-B97A-F6B3DD453F88	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyCycleVersionActualToBudget	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if copying was succesfull"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""SourceCycleUN"" parameter-type=""string"" parameter-description=""The source cycle element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""TargetCycleUN"" parameter-type=""string"" parameter-description=""The target cycle element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""SourceEntityUN"" parameter-type=""string"" parameter-description=""The source entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""SourceYearUN"" parameter-type=""string"" parameter-description=""The source year element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The source version element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""TargetVersionUN"" parameter-type=""string"" parameter-description=""The target version element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""TargetYearUN"" parameter-type=""string"" parameter-description=""The target year element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""copyExRates"" parameter-type=""bool"" parameter-description=""If true, ex rates will be copied from source to target"" parameter-order=""9"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAPCopyCycleVersionActualToBudget(string Database, string Ticket, string SourceCycleUN, string TargetCycleUN,string SourceEntityUN, string SourceYearUN,
                                       string SourceVersionUN, string TargetVersionUN, string TargetYearUN,bool copyExRates)

@Description: ""Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The source cycle element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[SourceEntityUN]: ""The source entity element to be used."";
@Parameter[SourceYearUN]: ""The source year element to be used."";
@Parameter[TargetCycleUN]: ""The target cycle element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetYearUN]: ""The target year element to be used."";
@Parameter[copyExRates]: ""If true, ex rates will be copied from source to target"";
@Returns: ""true if copying was succesfull"";

{

	LogInformation(""BAPCopyCycleVersionActualToBudget: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	SourceCycleUN = ""[BPDCYCLE].[CYCLE_021].[1]"";
	SourceVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_023].[1]"";
	TargetVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
	SourceEntityUN = ""[BPDENTITY].[RU0005].[1]"";
	SourceYearUN = ""[BPDTIME].[2017].[1]"";
	TargetYearUN = ""[BPDTIME].[2018].[1]"";*/

	

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string SourceYear = ResolveUniqueName(connection, SourceYearUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	string TargetYear = ResolveUniqueName(connection, TargetYearUN);
	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);

	
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string TotalTime = ""TOTAL_TIME"";
	string TotalEntity = ""TOTAL_ENTITY"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";


	LogInformation(""Source Configuration set  "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-&gt; Target Configuration set : "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);


	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, TargetCycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	
	double targetYearDouble = ToDouble(TargetYear);

	double targetYearPriorDouble = targetYearDouble-1;
	string sourceYearfirstMonth = ""01_""+ SourceYear;
	string lastYearLastPeriod = ""12_"" + targetYearPriorDouble;


	OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension,SourceEntity);
	bool baseEnttityElement = OLAPIsBaseElement(connection, entityElement);

	StringArray entityArray = CreateStringArray();
	Append(entityArray, """");
	Append(entityArray, ""N.A."");

	if(baseEnttityElement)
	{
		
		AppendDistinct(entityArray, SourceEntity);

	}
	else
	{
		OLAPElementList entityList = OLAPGetChildElementList(connection, EntityDimension, SourceEntity, true);
		StringList entityStringListHelp = ToStringList(entityList);

		foreach(string entityOLAPElement in entityStringListHelp )
		{
			AppendDistinct(entityArray, entityOLAPElement);
		}
	}


	StringList sourceEntities = ToStringList(entityArray);


	/* craeate string list of entities
	StringList sourceEntities = CreateStringList();

	if(SourceEntityUN == ""All"")
	{
		Append(sourceEntities,"""");
		sourceEntities = OLAPGetChildElementList(connection, EntityDimension, TotalEntity, true);

	}
	else
	{
		Append(sourceEntities,"""");
		sourceEntities = BP_ElementStringSplit(connection,SourceEntityUN);
	}*/


	OLAPElementList totalPeriods = OLAPGetChildElementList(connection, TimeDimension, TotalTime, true);
	OLAPElementList sourcePeriods = OLAPGetChildElementList(connection, TimeDimension, SourceYear, true);
	OLAPElementList targetPeriods = OLAPGetChildElementList(connection, TimeDimension, TargetYear, true);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	if(copyExRates)
	{
		Cube = ""BPCCONFIG_EXCHANGE"";
		OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
		                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                               OlapDataAreaOperatorNone, 0.0,
		                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
		
		OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
		                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                               OlapDataAreaOperatorNone, 0.0,
		                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
		{
			

			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");

			
			string value = OLAPCellReadString(connection, Cube, SourceCycle,SourceVersion,pcurrency,pparameter,planguage);
			
			if(pparameter == ""FEATURE_EX_VERSION_RATESET"")
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, TargetVersion, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, value, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
			}

		}

		Cube = ""EXCRATES"";
		OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     targetPeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,sourceEntities,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataEXCRATES);
		
		OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     sourcePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,sourceEntities,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceDataEXCRATES)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
			string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
			string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
			string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
			string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");

			
			string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,SourceVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency,pexrates);
			
			string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
			string targetMonth = monthNumber + ""_"" + TargetYear;

			
			OLAPCellWriteBufferWriteString(buffer, Cube, value, targetMonth, TargetCycle,TargetVersion,exdtype,pentity,pintercompany,paccount, pDetail, pccurrency,pgcurrency, pexrates);
			
		}
	}

	Cube = ""BPCMAIN"";


	OLAPElementList Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_CHANGE"", true);


	OLAPDataArea targetDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    totalPeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAIN);

	
	OLAPDataArea sourceDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    sourcePeriods, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAIN)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;

		string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
		string targetMonth = monthNumber + ""_"" + TargetYear;

		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, targetMonth, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
		
	}

	Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);

	OLAPDataArea targetDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      totalPeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAINOB);
	
	OLAPDataArea sourceDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB |OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      sourceYearfirstMonth, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAINOB)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, lastYearLastPeriod, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
		
	}

	Cube = ""CFCCASHFLOW"";


	OLAPDataArea targetDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     targetPeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,sourceEntities,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	OLAPDeleteDataArea(targetDataCASHFLOW);


	OLAPDataArea sourceDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     sourcePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,sourceEntities,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataCASHFLOW)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
		string targetMonth = monthNumber + ""_"" + TargetYear;

		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, targetMonth, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, currency, primarySegment, secondarySegment, tertiarySegment, account, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);
	LogInformation(""BAPCopyCycleVersionActualToBudget: Finishing process"");


	return true;

}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool BAPCopyCycleVersionActualToBudget(string Database, string Ticket, string SourceCycleUN, string TargetCycleUN,string SourceEntityUN, string SourceYearUN,
                                       string SourceVersionUN, string TargetVersionUN, string TargetYearUN,bool copyExRates)

@Description: ""Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[SourceCycleUN]: ""The source cycle element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[SourceEntityUN]: ""The source entity element to be used."";
@Parameter[SourceYearUN]: ""The source year element to be used."";
@Parameter[TargetCycleUN]: ""The target cycle element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetYearUN]: ""The target year element to be used."";
@Parameter[copyExRates]: ""If true, ex rates will be copied from source to target"";
@Returns: ""true if copying was succesfull"";

{

	LogInformation(""BAPCopyCycleVersionActualToBudget: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	SourceCycleUN = ""[BPDCYCLE].[CYCLE_021].[1]"";
	SourceVersionUN = ""[BPDVERSION].[ACTUAL_CONS].[1]"";
	TargetCycleUN = ""[BPDCYCLE].[CYCLE_023].[1]"";
	TargetVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
	SourceEntityUN = ""[BPDENTITY].[RU0005].[1]"";
	SourceYearUN = ""[BPDTIME].[2017].[1]"";
	TargetYearUN = ""[BPDTIME].[2018].[1]"";*/

	

	string Cube = """";
	string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string SourceYear = ResolveUniqueName(connection, SourceYearUN);
	string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	string TargetYear = ResolveUniqueName(connection, TargetYearUN);
	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);

	
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string TotalTime = ""TOTAL_TIME"";
	string TotalEntity = ""TOTAL_ENTITY"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";


	LogInformation(""Source Configuration set  "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-> Target Configuration set : "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);


	string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, TargetCycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
	
	double targetYearDouble = ToDouble(TargetYear);

	double targetYearPriorDouble = targetYearDouble-1;
	string sourceYearfirstMonth = ""01_""+ SourceYear;
	string lastYearLastPeriod = ""12_"" + targetYearPriorDouble;


	OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension,SourceEntity);
	bool baseEnttityElement = OLAPIsBaseElement(connection, entityElement);

	StringArray entityArray = CreateStringArray();
	Append(entityArray, """");
	Append(entityArray, ""N.A."");

	if(baseEnttityElement)
	{
		
		AppendDistinct(entityArray, SourceEntity);

	}
	else
	{
		OLAPElementList entityList = OLAPGetChildElementList(connection, EntityDimension, SourceEntity, true);
		StringList entityStringListHelp = ToStringList(entityList);

		foreach(string entityOLAPElement in entityStringListHelp )
		{
			AppendDistinct(entityArray, entityOLAPElement);
		}
	}


	StringList sourceEntities = ToStringList(entityArray);


	/* craeate string list of entities
	StringList sourceEntities = CreateStringList();

	if(SourceEntityUN == ""All"")
	{
		Append(sourceEntities,"""");
		sourceEntities = OLAPGetChildElementList(connection, EntityDimension, TotalEntity, true);

	}
	else
	{
		Append(sourceEntities,"""");
		sourceEntities = BP_ElementStringSplit(connection,SourceEntityUN);
	}*/


	OLAPElementList totalPeriods = OLAPGetChildElementList(connection, TimeDimension, TotalTime, true);
	OLAPElementList sourcePeriods = OLAPGetChildElementList(connection, TimeDimension, SourceYear, true);
	OLAPElementList targetPeriods = OLAPGetChildElementList(connection, TimeDimension, TargetYear, true);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);
	if(copyExRates)
	{
		Cube = ""BPCCONFIG_EXCHANGE"";
		OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
		                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                               OlapDataAreaOperatorNone, 0.0,
		                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
		
		OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
		                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                               OlapDataAreaOperatorNone, 0.0,
		                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
		{
			

			string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
			string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
			string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");

			
			string value = OLAPCellReadString(connection, Cube, SourceCycle,SourceVersion,pcurrency,pparameter,planguage);
			
			if(pparameter == ""FEATURE_EX_VERSION_RATESET"")
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, TargetVersion, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
			}
			else
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, value, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
			}

		}

		Cube = ""EXCRATES"";
		OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     targetPeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,sourceEntities,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataEXCRATES);
		
		OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     sourcePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,sourceEntities,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceDataEXCRATES)
		{
			string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
			string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
			string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
			string pentity = OLAPCellGetElement(cell, ""BPDENTITY"");
			string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
			string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
			string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");

			
			string value = OLAPCellReadString(connection, Cube, ptime, SourceCycle,SourceVersion,exdtype,pentity,pintercompany,paccount,pDetail,pccurrency,pgcurrency,pexrates);
			
			string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
			string targetMonth = monthNumber + ""_"" + TargetYear;

			
			OLAPCellWriteBufferWriteString(buffer, Cube, value, targetMonth, TargetCycle,TargetVersion,exdtype,pentity,pintercompany,paccount, pDetail, pccurrency,pgcurrency, pexrates);
			
		}
	}

	Cube = ""BPCMAIN"";


	OLAPElementList Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_CHANGE"", true);


	OLAPDataArea targetDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    totalPeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAIN);

	
	OLAPDataArea sourceDataBPCMAIN = OLAPCreateDataArea(connection, Cube,
	                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                    sourcePeriods, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAIN)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;

		string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
		string targetMonth = monthNumber + ""_"" + TargetYear;

		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, targetMonth, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
		
	}

	Levels = OLAPGetChildElementList(connection, LevelDimension, ""TOTAL_OB"", true);

	OLAPDataArea targetDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      totalPeriods, TargetCycle,  TargetVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
	
	OLAPDeleteDataArea(targetDataBPCMAINOB);
	
	OLAPDataArea sourceDataBPCMAINOB = OLAPCreateDataArea(connection, Cube,
	                                                      OlapDataAreaIncludeB |OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                      sourceYearfirstMonth, SourceCycle,  SourceVersion,Levels,OlapDataAreaBCells, sourceEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataBPCMAINOB)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, lastYearLastPeriod, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
		
	}

	Cube = ""CFCCASHFLOW"";


	OLAPDataArea targetDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     targetPeriods, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,sourceEntities,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	OLAPDeleteDataArea(targetDataCASHFLOW);


	OLAPDataArea sourceDataCASHFLOW = OLAPCreateDataArea(connection, Cube,
	                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                     sourcePeriods, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,sourceEntities,  OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

	foreach(OLAPCell cell in sourceDataCASHFLOW)
	{
		string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
		string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
		string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
		string entity = OLAPCellGetElement(cell, ""BPDENTITY"");
		string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
		string account = OLAPCellGetElement(cell, ""CFDCASHFLOW"");
		string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
		string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
		string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
		string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
		string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
		string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
		string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
		string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
		string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
		string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
		string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
		string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
		string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
		string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
		string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
		string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
		string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
		string step = OLAPCellGetElement(cell, ""BPDSTEP"");
		double value = cell;


		string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, ptime, ""CURRENT_MONTH_ID"");
		string targetMonth = monthNumber + ""_"" + TargetYear;

		OLAPCellWriteBufferWriteNumber(buffer, Cube, value, targetMonth, TargetCycle,  TargetVersion, level, step, entity, intercompany, organization, currency, primarySegment, secondarySegment, tertiarySegment, account, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
	}
	OLAPCommitCellWriteBuffer(buffer);
	LogInformation(""BAPCopyCycleVersionActualToBudget: Finishing process"");


	return true;

}"	1	06E3A3FA-67EC-4712-89C0-8F09E98C63A0	Copy actual version data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets	1	1	1	1560	NULL	0	45708.67507	0	0
CE0DE8E4-66B3-4DED-90B0-BEE5BDC65E1F	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyCycleVersionData	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if copying was succesfull"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""SourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""TargetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration set  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""SourceEntityUN"" parameter-type=""string"" parameter-description=""The source entity element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""SourcePeriods"" parameter-type=""string"" parameter-description=""Comma separated list of source periods."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The source version element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""TargetVersionUN"" parameter-type=""string"" parameter-description=""The target version element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""TargetEntityUN"" parameter-type=""string"" parameter-description=""The target entity element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""TargetPeriods"" parameter-type=""string"" parameter-description=""Comma separated list of target periods."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""copyExRates"" parameter-type=""bool"" parameter-description=""If true, ex rates will be copied from source to target"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""copyOB"" parameter-type=""bool"" parameter-description=""If true, opening balances will be copied from source to target"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""copyComments"" parameter-type=""bool"" parameter-description=""If true, Commnets copied from source to target"" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""copyAttachments"" parameter-type=""bool"" parameter-description=""If true, Attachments will be copied from source to target"" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""copyLineDetails"" parameter-type=""bool"" parameter-description=""If true, line details will be copied from source to target"" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""overWriteTarget"" parameter-type=""bool"" parameter-description=""If true, target will be overwriten by source data, if false source data will be added to target"" parameter-order=""14"" />
  <dependencies>
    <process process-name=""BP_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""BP_IsNAUsedForTarget"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""
#include ""BP_IsNAUsedForTarget"", ""*""

bool BAPCopyCycleVersionData(string Database, string SourceCycleUN, string TargetCycleUN,string SourceEntityUN, string SourcePeriods,
                             string SourceVersionUN, string TargetVersionUN, string TargetEntityUN, string TargetPeriods,bool copyExRates, bool copyOB, bool copyComments,
                             bool copyAttachments, bool copyLineDetails, bool overWriteTarget)

@Description: ""Copy data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets,versions, plus copy line details, attachments and cell commnets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[SourceCycleUN]: ""The source Configuration set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[SourceEntityUN]: ""The source entity element to be used."";
@Parameter[SourcePeriods]: ""Comma separated list of source periods."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetEntityUN]: ""The target entity element to be used."";
@Parameter[TargetPeriods]: ""Comma separated list of target periods."";
@Parameter[copyExRates]: ""If true, ex rates will be copied from source to target"";
@Parameter[copyOB]: ""If true, opening balances will be copied from source to target"";
@Parameter[copyComments]: ""If true, Commnets copied from source to target"";
@Parameter[copyAttachments]: ""If true, Attachments will be copied from source to target"";
@Parameter[copyLineDetails]: ""If true, line details will be copied from source to target"";
@Parameter[overWriteTarget]: ""If true, target will be overwriten by source data, if false source data will be added to target"";
@Returns: ""true if copying was succesfull"";
{
	string functionName = ""BAPCopyCycleVersionData :"";
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string TotalTime = ""TOTAL_TIME"";
	string TotalEntity = ""TOTAL_ENTITY"";
	string currencyDimension = ""BPDCURRENCY"";
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	string trackingCube = ""WFCTRACKING"";
	string configCube = ""BPCCONFIG_MAIN"";
	string detailDimension =""BPDDETAIL"";
	string dataAccountCube = ""ATCDATA_ACCOUNT"";
	string dataDetailCube = ""ATCDATA_DETAIL"";
	string NA = ""N.A."";
	string errorMessage = """";
	string hierarchy= """";
	int errorCode = 0;
	string result ="""";

	try {
		LogInformation(""BAPCopyCycleVersionData: Starting process"");
		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		SourceVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		TargetCycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";
		TargetVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		SourceEntityUN = ""[BPDENTITY].[RU0001].[1]"";
		TargetEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		SourcePeriods = ""[BPDTIME].[2018].[1]"";
		TargetPeriods = ""[BPDTIME].[2019].[1]"";*/

		string Cube = """";
		string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
		string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
		string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
		string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
		string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
		string TargetEntity = ResolveUniqueName(connection, TargetEntityUN);

		LogInformation(""Source Configuration set : "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-&gt; Target Configuration set : "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);
		StringList sourcePeriodsList = BP_ElementStringSplit(connection, SourcePeriods);
		StringList targetPeriodsList = BP_ElementStringSplit(connection, TargetPeriods);

		StringArray sourceTimeArray = CreateStringArray();
		Append(sourceTimeArray, """");

		foreach(string period in sourcePeriodsList)
		{
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, period);
			bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
			if(baseTimeElement)
			{
				Append(sourceTimeArray, period);
			}
			else
			{
				OLAPElementList timetList = OLAPGetChildElementList(connection,TimeDimension, period, true);
				StringList TimetListHelp = ToStringList(timetList);
				foreach(string timeOLAPElement in TimetListHelp )
				{
					Append(sourceTimeArray, timeOLAPElement);
				}
			}
		}
		StringList sourceTimeStringList = ToStringList(sourceTimeArray);

		StringArray targetTimeArray = CreateStringArray();
		Append(targetTimeArray, """");

		foreach(string period in targetPeriodsList)
		{
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, period);
			bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
			if(baseTimeElement)
			{
				Append(targetTimeArray, period);
			}
			else
			{
				OLAPElementList timetList = OLAPGetChildElementList(connection,TimeDimension, period, true);
				StringList TimetListHelp = ToStringList(timetList);
				foreach(string timeOLAPElement in TimetListHelp )
				{
					Append(targetTimeArray, timeOLAPElement);
				}
			}
		}

		string sourceCVECheck = SourceCycle + SourceVersion + SourceEntity;
		string targetCVECheck = TargetCycle + TargetVersion + TargetEntity;
		bool periodsOverLap = false;
		StringList targetTimeStringList = ToStringList(targetTimeArray);
		foreach(string t in targetTimeArray)
		{
			if(t != """")
			{
				if(Contains(sourceTimeArray,t))
				{
					periodsOverLap = true;
				}
			}
		}

		if(sourceCVECheck == targetCVECheck and SourcePeriods == TargetPeriods)
		{
			NotifyInformation(""Source and target are same, no data transfered."");
			return false;
		}

		if(sourceCVECheck == targetCVECheck and periodsOverLap)
		{
			NotifyInformation(""There are same source and target for configuration set, version, entity and overlaping periods, no data transfered."");
			return false;
		}

		int numberOfPeriods =  Count(sourceTimeStringList) - 1;
		StringDictionary dicSourceTarget = CreateStringDictionary();
		int count = 1;

		while(count&lt;=numberOfPeriods)
		{
			string source = GetElementByIndex(sourceTimeStringList, count);
			dicSourceTarget[source] = GetElementByIndex(targetTimeStringList, count);
			count = count + 1;
		}


		double refVersionNumSource = OLAPCellReadNumber(connection, ConfigCycleCube,1.0, SourceCycle,SourceVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
		string sourceVersionForActivatedCheck = """";

		if(refVersionNumSource == 1)
		{
			sourceVersionForActivatedCheck = OLAPCellReadString(connection, ConfigCycleCube, SourceCycle,SourceVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
			sourceVersionForActivatedCheck = ResolveUniqueName(connection, sourceVersionForActivatedCheck);
		}
		else
		{
			sourceVersionForActivatedCheck = SourceVersion;
		}
		
		double refVersionNumTarget = OLAPCellReadNumber(connection, ConfigCycleCube,1.0, TargetCycle,TargetVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
		string targetVersionForActivatedCheck = """";
		if(refVersionNumTarget == 1)
		{
			targetVersionForActivatedCheck = OLAPCellReadString(connection, ConfigCycleCube, TargetCycle,TargetVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
			targetVersionForActivatedCheck = ResolveUniqueName(connection, targetVersionForActivatedCheck);
		}
		else
		{
			targetVersionForActivatedCheck = TargetVersion;
		}


		bool isAnal1NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS01"");
		bool isAnal2NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS02"");
		bool isAnal3NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS03"");
		bool isAnal4NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS04"");
		bool isAnal5NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS05"");
		bool isAnal6NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS06"");
		bool isAnal7NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS07"");
		bool isAnal8NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS08"");
		bool isAnal9NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS09"");
		bool isAnal10NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS10"");
		bool isAnal11NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS11"");
		bool isAnal12NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS12"");
		bool isDetailNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_DETAIL"");
		bool isPSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_PSEGMENT"");
		bool isSSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_SSEGMENT"");
		bool isTSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_TSEGMENT"");
		bool isICNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_IC"");
		bool isOrgNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ORGANIZATION"");

		//int numberOfPeriods =  Count(sourceTimeStringList) - 1;

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);
		StringList  currenList = ConvertToStringList(currencies);

		if(copyExRates)
		{
			string sourceCycleVersion = SourceCycle + SourceVersion;
			string targetCycleVersion = TargetCycle + TargetVersion;
			if(sourceCycleVersion != targetCycleVersion)
			{
				Cube = ""BPCCONFIG_EXCHANGE"";
				OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
				                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                               OlapDataAreaOperatorNone, 0.0,
				                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
				
				OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
				                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                               OlapDataAreaOperatorNone, 0.0,
				                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


				foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
				{
					

					string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(pparameter == ""FEATURE_EX_VERSION_RATESET"")
					{
						OLAPCellWriteBufferWriteString(buffer, Cube, TargetVersion, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}
					else if(isCellText)
					{
						valueStr  = cell;
						OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}
					else
					{
						valueDou = cell;
						OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}


				}
				OLAPCommitCellWriteBuffer(buffer);
			}
			Cube = ""EXCRATES"";
			int counterexData = 0;
			NotifyInformation(""Transfer of exchange rates started."");

			if(sourceCycleVersion != targetCycleVersion or sourceCVECheck == targetCVECheck)
			{
				OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     targetTimeStringList, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(TargetDataEXCRATES);
				
				OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     sourceTimeStringList, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


				foreach (OLAPCell cell in SourceDataEXCRATES)
				{
					string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
					string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
					string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
					string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
					string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
					string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, Cube, value,  dicSourceTarget[ptime], TargetCycle,TargetVersion,exdtype,TargetEntity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
					counterexData = counterexData +1;
					
				}
			}

			if(sourceCycleVersion == targetCycleVersion and SourceEntity != TargetEntity)
			{
				OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     targetTimeStringList, TargetCycle,  TargetVersion,OlapDataAreaBCells,TargetEntity,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, ""H"");

				OLAPDeleteDataArea(TargetDataEXCRATES);
				
				OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     sourceTimeStringList, SourceCycle,  SourceVersion,OlapDataAreaBCells,SourceEntity,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, ""H"");


				foreach (OLAPCell cell in SourceDataEXCRATES)
				{
					string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
					string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
					string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
					string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
					string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
					string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, Cube, value,  dicSourceTarget[ptime], TargetCycle,TargetVersion,exdtype,TargetEntity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
					counterexData = counterexData +1;
					
				}
			}
			OLAPCommitCellWriteBuffer(buffer);
			NotifyInformation(""Transfer of exchange rates finished."");
			NotifyInformation(""Number of exchange rates transferred: "" + counterexData + ""."");
		}

		StringList pnoElementStringList = CreateStringList();
		if(copyAttachments or copyComments)
		{
			OLAPElementList pnoElementlist = OLAPGetElementList(connection, LevelDimension, ""WORKFLOW"", true, false, false);
			Append(pnoElementStringList, """");
			foreach(OLAPElement o in pnoElementlist)
			{
				string Composite = OLAPCreateCompositeName(""WORKFLOW"", ToString(o));
				Append(pnoElementStringList, Composite);
			}
		}

		if(copyAttachments)
		{
			if(sourceCVECheck == targetCVECheck)
			{
				NotifyInformation(""Source and target are same for configuration set, version, entity, no attachments copied."");
			}
			else
			{
				NotifyInformation(""Transfer of Attachments data started."");
				int counterAttchmentData = 0;
				StringList parametersListAttachmensData= CreateStringList();
				Append(parametersListAttachmensData,"""");
				Append(parametersListAttachmensData,""FEATURE_WF_TRACKING_ATTACHMENT"");
				Append(parametersListAttachmensData,""FEATURE_WF_TRACKING_ATTACHMENT_DATE"");

				//delete all info connected to comments from ATCDATA_ACCOUNT
				OLAPDataArea dataAreaAtcAccountDelete = OLAPCreateDataArea(connection, dataAccountCube,
				                                                           OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                           OlapDataAreaOperatorNone, 0.0,
				                                                           TargetCycle, TargetVersion,  OlapDataAreaAllCells,TargetEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData, OlapDataAreaAllCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(dataAreaAtcAccountDelete);

				OLAPDataArea dataAreaAtcAccountCopy = OLAPCreateDataArea(connection, dataAccountCube,
				                                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                         OlapDataAreaOperatorNone, 0.0,
				                                                         SourceCycle, SourceVersion,  OlapDataAreaAllCells,SourceEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData, OlapDataAreaAllCells, OlapDataAreaBCells);

				
				foreach(OLAPCell cell in dataAreaAtcAccountCopy)
				{
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string user = OLAPCellGetElement(cell, ""#_SysUsr"");
					string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
					string parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string accountAttribute = OLAPCellGetElement(cell, ""ATDATTRIBUTE_ACCOUNT"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(isCellText)
					{
						valueStr  = cell;
					}
					else
					{
						valueDou = cell;
					}
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, dataAccountCube, valueStr, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					else
					{
						OLAPCellWriteBufferIncrementNumber(buffer, dataAccountCube, valueDou, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					counterAttchmentData = counterAttchmentData  + 1;
				}

				OLAPDataArea wfDataDelete = OLAPCreateDataArea(connection, trackingCube,
				                                               OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                               OlapDataAreaOperatorNone, 0.0,
				                                               TargetCycle, TargetVersion, TargetEntity,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,pnoElementStringList,OlapDataAreaBCells, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData);

				OLAPDeleteDataArea(wfDataDelete);


				OLAPDataArea wfDataCopy = OLAPCreateDataArea(connection, trackingCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             SourceCycle, SourceVersion, SourceEntity,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,pnoElementStringList,OlapDataAreaBCells, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData);

				foreach(OLAPCell cell in wfDataCopy)
				{
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string application = OLAPCellGetElement(cell, ""BPDAPPLICATION"");
					string tracking = OLAPCellGetElement(cell, ""WFDTRACKING"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					string user = OLAPCellGetElement(cell, ""#_SysUsr"");
					string role = OLAPCellGetElement(cell, ""#__GRP__"");
					string parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(isCellText)
					{
						valueStr  = cell;
					}
					else
					{
						valueDou = cell;
					}
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, trackingCube, valueStr, TargetCycle,  TargetVersion,TargetEntity, organization,application, tracking,level, step, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, user, role, parameter);
					}
					else
					{
						OLAPCellWriteBufferIncrementNumber(buffer, trackingCube, valueDou, TargetCycle,  TargetVersion,TargetEntity, organization,application, tracking,level, step, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, user, role, parameter);
					}
					counterAttchmentData = counterAttchmentData  + 1;
				}
				OLAPCommitCellWriteBuffer(buffer);
				NotifyInformation(""Transfer of attachment data finished."");
				NotifyInformation(""Number of attachment data transferred: "" + counterAttchmentData + ""."");
			}
		}

		if(copyComments)
		{
			int counterCommentData = 0;
			if(sourceCVECheck == targetCVECheck)
			{
				NotifyInformation(""Source and target are same for configuration set, version, entity, no commnets copied."");
			}
			else
			{
				NotifyInformation(""Transfer of Comments data started."");
				StringList parametersListCommentsData= CreateStringList();
				Append(parametersListCommentsData,"""");
				Append(parametersListCommentsData,""FEATURE_WF_TRACKING_COMMENT"");
				Append(parametersListCommentsData,""FEATURE_WF_TRACKING_COMMENT_CHANGED_ON"");
				Append(parametersListCommentsData,""FEATURE_WF_DEFINITION_MANDATORY_COMMENTS"");

				//delete all info connected to comments from ATCDATA_ACCOUNT
				OLAPDataArea dataAreaAtcAccountDelete = OLAPCreateDataArea(connection, dataAccountCube,
				                                                           OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                           OlapDataAreaOperatorNone, 0.0,
				                                                           TargetCycle, TargetVersion,  OlapDataAreaAllCells,TargetEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListCommentsData, OlapDataAreaAllCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(dataAreaAtcAccountDelete);

				OLAPDataArea dataAreaAtcAccountCopy = OLAPCreateDataArea(connection, dataAccountCube,
				                                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                   "	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_ElementStringSplit"", ""*""
#include ""BP_IsNAUsedForTarget"", ""*""

bool BAPCopyCycleVersionData(string Database, string SourceCycleUN, string TargetCycleUN,string SourceEntityUN, string SourcePeriods,
                             string SourceVersionUN, string TargetVersionUN, string TargetEntityUN, string TargetPeriods,bool copyExRates, bool copyOB, bool copyComments,
                             bool copyAttachments, bool copyLineDetails, bool overWriteTarget)

@Description: ""Copy data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets,versions, plus copy line details, attachments and cell commnets"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[SourceCycleUN]: ""The source Configuration set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[SourceEntityUN]: ""The source entity element to be used."";
@Parameter[SourcePeriods]: ""Comma separated list of source periods."";
@Parameter[TargetCycleUN]: ""The target Configuration set  element to be used."";
@Parameter[TargetVersionUN]: ""The target version element to be used."";
@Parameter[TargetEntityUN]: ""The target entity element to be used."";
@Parameter[TargetPeriods]: ""Comma separated list of target periods."";
@Parameter[copyExRates]: ""If true, ex rates will be copied from source to target"";
@Parameter[copyOB]: ""If true, opening balances will be copied from source to target"";
@Parameter[copyComments]: ""If true, Commnets copied from source to target"";
@Parameter[copyAttachments]: ""If true, Attachments will be copied from source to target"";
@Parameter[copyLineDetails]: ""If true, line details will be copied from source to target"";
@Parameter[overWriteTarget]: ""If true, target will be overwriten by source data, if false source data will be added to target"";
@Returns: ""true if copying was succesfull"";
{
	string functionName = ""BAPCopyCycleVersionData :"";
	string LevelDimension= ""BPDLEVEL"";
	string TimeDimension = ""BPDTIME"";
	string EntityDimension = ""BPDENTITY"";
	string TotalTime = ""TOTAL_TIME"";
	string TotalEntity = ""TOTAL_ENTITY"";
	string currencyDimension = ""BPDCURRENCY"";
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	string trackingCube = ""WFCTRACKING"";
	string configCube = ""BPCCONFIG_MAIN"";
	string detailDimension =""BPDDETAIL"";
	string dataAccountCube = ""ATCDATA_ACCOUNT"";
	string dataDetailCube = ""ATCDATA_DETAIL"";
	string NA = ""N.A."";
	string errorMessage = """";
	string hierarchy= """";
	int errorCode = 0;
	string result ="""";

	try {
		LogInformation(""BAPCopyCycleVersionData: Starting process"");
		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*SourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		SourceVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		TargetCycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";
		TargetVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		SourceEntityUN = ""[BPDENTITY].[RU0001].[1]"";
		TargetEntityUN= ""[BPDENTITY].[RU0001].[1]"";
		SourcePeriods = ""[BPDTIME].[2018].[1]"";
		TargetPeriods = ""[BPDTIME].[2019].[1]"";*/

		string Cube = """";
		string SourceCycle = ResolveUniqueName(connection, SourceCycleUN);
		string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
		string TargetCycle = ResolveUniqueName(connection, TargetCycleUN);
		string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
		string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
		string TargetEntity = ResolveUniqueName(connection, TargetEntityUN);

		LogInformation(""Source Configuration set : "" + SourceCycle + "", SourceVersion:  ""+ SourceVersion + ""-> Target Configuration set : "" + TargetCycle+ "", TargetVersion:  ""+ TargetVersion);
		StringList sourcePeriodsList = BP_ElementStringSplit(connection, SourcePeriods);
		StringList targetPeriodsList = BP_ElementStringSplit(connection, TargetPeriods);

		StringArray sourceTimeArray = CreateStringArray();
		Append(sourceTimeArray, """");

		foreach(string period in sourcePeriodsList)
		{
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, period);
			bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
			if(baseTimeElement)
			{
				Append(sourceTimeArray, period);
			}
			else
			{
				OLAPElementList timetList = OLAPGetChildElementList(connection,TimeDimension, period, true);
				StringList TimetListHelp = ToStringList(timetList);
				foreach(string timeOLAPElement in TimetListHelp )
				{
					Append(sourceTimeArray, timeOLAPElement);
				}
			}
		}
		StringList sourceTimeStringList = ToStringList(sourceTimeArray);

		StringArray targetTimeArray = CreateStringArray();
		Append(targetTimeArray, """");

		foreach(string period in targetPeriodsList)
		{
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, period);
			bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
			if(baseTimeElement)
			{
				Append(targetTimeArray, period);
			}
			else
			{
				OLAPElementList timetList = OLAPGetChildElementList(connection,TimeDimension, period, true);
				StringList TimetListHelp = ToStringList(timetList);
				foreach(string timeOLAPElement in TimetListHelp )
				{
					Append(targetTimeArray, timeOLAPElement);
				}
			}
		}

		string sourceCVECheck = SourceCycle + SourceVersion + SourceEntity;
		string targetCVECheck = TargetCycle + TargetVersion + TargetEntity;
		bool periodsOverLap = false;
		StringList targetTimeStringList = ToStringList(targetTimeArray);
		foreach(string t in targetTimeArray)
		{
			if(t != """")
			{
				if(Contains(sourceTimeArray,t))
				{
					periodsOverLap = true;
				}
			}
		}

		if(sourceCVECheck == targetCVECheck and SourcePeriods == TargetPeriods)
		{
			NotifyInformation(""Source and target are same, no data transfered."");
			return false;
		}

		if(sourceCVECheck == targetCVECheck and periodsOverLap)
		{
			NotifyInformation(""There are same source and target for configuration set, version, entity and overlaping periods, no data transfered."");
			return false;
		}

		int numberOfPeriods =  Count(sourceTimeStringList) - 1;
		StringDictionary dicSourceTarget = CreateStringDictionary();
		int count = 1;

		while(count<=numberOfPeriods)
		{
			string source = GetElementByIndex(sourceTimeStringList, count);
			dicSourceTarget[source] = GetElementByIndex(targetTimeStringList, count);
			count = count + 1;
		}


		double refVersionNumSource = OLAPCellReadNumber(connection, ConfigCycleCube,1.0, SourceCycle,SourceVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
		string sourceVersionForActivatedCheck = """";

		if(refVersionNumSource == 1)
		{
			sourceVersionForActivatedCheck = OLAPCellReadString(connection, ConfigCycleCube, SourceCycle,SourceVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
			sourceVersionForActivatedCheck = ResolveUniqueName(connection, sourceVersionForActivatedCheck);
		}
		else
		{
			sourceVersionForActivatedCheck = SourceVersion;
		}
		
		double refVersionNumTarget = OLAPCellReadNumber(connection, ConfigCycleCube,1.0, TargetCycle,TargetVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
		string targetVersionForActivatedCheck = """";
		if(refVersionNumTarget == 1)
		{
			targetVersionForActivatedCheck = OLAPCellReadString(connection, ConfigCycleCube, TargetCycle,TargetVersion, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
			targetVersionForActivatedCheck = ResolveUniqueName(connection, targetVersionForActivatedCheck);
		}
		else
		{
			targetVersionForActivatedCheck = TargetVersion;
		}


		bool isAnal1NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS01"");
		bool isAnal2NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS02"");
		bool isAnal3NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS03"");
		bool isAnal4NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS04"");
		bool isAnal5NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS05"");
		bool isAnal6NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS06"");
		bool isAnal7NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS07"");
		bool isAnal8NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS08"");
		bool isAnal9NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS09"");
		bool isAnal10NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS10"");
		bool isAnal11NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS11"");
		bool isAnal12NA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ANALYSIS12"");
		bool isDetailNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_DETAIL"");
		bool isPSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_PSEGMENT"");
		bool isSSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_SSEGMENT"");
		bool isTSegmentNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_TSEGMENT"");
		bool isICNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_IC"");
		bool isOrgNA = BP_IsNAUsedForTarget(connection,SourceCycle,sourceVersionForActivatedCheck,TargetCycle,targetVersionForActivatedCheck,""GLOBAL_CYCLE_ACTIVE_ORGANIZATION"");

		//int numberOfPeriods =  Count(sourceTimeStringList) - 1;

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);
		StringList  currenList = ConvertToStringList(currencies);

		if(copyExRates)
		{
			string sourceCycleVersion = SourceCycle + SourceVersion;
			string targetCycleVersion = TargetCycle + TargetVersion;
			if(sourceCycleVersion != targetCycleVersion)
			{
				Cube = ""BPCCONFIG_EXCHANGE"";
				OLAPDataArea TargetDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
				                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                               OlapDataAreaOperatorNone, 0.0,
				                                                               TargetCycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(TargetDataBPCCONFIG_EXCHANGE);
				
				OLAPDataArea SourceDataBPCCONFIG_EXCHANGE = OLAPCreateDataArea(connection, Cube,
				                                                               OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                               OlapDataAreaOperatorNone, 0.0,
				                                                               SourceCycle, SourceVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


				foreach (OLAPCell cell in SourceDataBPCCONFIG_EXCHANGE)
				{
					

					string pcurrency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string pparameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					string planguage = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(pparameter == ""FEATURE_EX_VERSION_RATESET"")
					{
						OLAPCellWriteBufferWriteString(buffer, Cube, TargetVersion, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}
					else if(isCellText)
					{
						valueStr  = cell;
						OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}
					else
					{
						valueDou = cell;
						OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, TargetCycle,TargetVersion,pcurrency,pparameter,planguage);
					}


				}
				OLAPCommitCellWriteBuffer(buffer);
			}
			Cube = ""EXCRATES"";
			int counterexData = 0;
			NotifyInformation(""Transfer of exchange rates started."");

			if(sourceCycleVersion != targetCycleVersion or sourceCVECheck == targetCVECheck)
			{
				OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     targetTimeStringList, TargetCycle,  TargetVersion,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(TargetDataEXCRATES);
				
				OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     sourceTimeStringList, SourceCycle,  SourceVersion,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


				foreach (OLAPCell cell in SourceDataEXCRATES)
				{
					string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
					string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
					string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
					string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
					string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
					string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, Cube, value,  dicSourceTarget[ptime], TargetCycle,TargetVersion,exdtype,TargetEntity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
					counterexData = counterexData +1;
					
				}
			}

			if(sourceCycleVersion == targetCycleVersion and SourceEntity != TargetEntity)
			{
				OLAPDataArea TargetDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     targetTimeStringList, TargetCycle,  TargetVersion,OlapDataAreaBCells,TargetEntity,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, ""H"");

				OLAPDeleteDataArea(TargetDataEXCRATES);
				
				OLAPDataArea SourceDataEXCRATES = OLAPCreateDataArea(connection, Cube,
				                                                     OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                     OlapDataAreaOperatorNone, 0.0,
				                                                     sourceTimeStringList, SourceCycle,  SourceVersion,OlapDataAreaBCells,SourceEntity,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, ""H"");


				foreach (OLAPCell cell in SourceDataEXCRATES)
				{
					string ptime = OLAPCellGetElement(cell, ""BPDTIME"");
					string pgcurrency = OLAPCellGetElement(cell, ""EXDGCURRENCY"");
					string exdtype = OLAPCellGetElement(cell, ""EXDTYPE"");
					string pintercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string paccount = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string pexrates = OLAPCellGetElement(cell, ""EXDRATE"");
					string pccurrency = OLAPCellGetElement(cell, ""EXDCCURRENCY"");
					string pDetail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, Cube, value,  dicSourceTarget[ptime], TargetCycle,TargetVersion,exdtype,TargetEntity,pintercompany,paccount,pDetail, pccurrency,pgcurrency, pexrates);
					counterexData = counterexData +1;
					
				}
			}
			OLAPCommitCellWriteBuffer(buffer);
			NotifyInformation(""Transfer of exchange rates finished."");
			NotifyInformation(""Number of exchange rates transferred: "" + counterexData + ""."");
		}

		StringList pnoElementStringList = CreateStringList();
		if(copyAttachments or copyComments)
		{
			OLAPElementList pnoElementlist = OLAPGetElementList(connection, LevelDimension, ""WORKFLOW"", true, false, false);
			Append(pnoElementStringList, """");
			foreach(OLAPElement o in pnoElementlist)
			{
				string Composite = OLAPCreateCompositeName(""WORKFLOW"", ToString(o));
				Append(pnoElementStringList, Composite);
			}
		}

		if(copyAttachments)
		{
			if(sourceCVECheck == targetCVECheck)
			{
				NotifyInformation(""Source and target are same for configuration set, version, entity, no attachments copied."");
			}
			else
			{
				NotifyInformation(""Transfer of Attachments data started."");
				int counterAttchmentData = 0;
				StringList parametersListAttachmensData= CreateStringList();
				Append(parametersListAttachmensData,"""");
				Append(parametersListAttachmensData,""FEATURE_WF_TRACKING_ATTACHMENT"");
				Append(parametersListAttachmensData,""FEATURE_WF_TRACKING_ATTACHMENT_DATE"");

				//delete all info connected to comments from ATCDATA_ACCOUNT
				OLAPDataArea dataAreaAtcAccountDelete = OLAPCreateDataArea(connection, dataAccountCube,
				                                                           OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                           OlapDataAreaOperatorNone, 0.0,
				                                                           TargetCycle, TargetVersion,  OlapDataAreaAllCells,TargetEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData, OlapDataAreaAllCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(dataAreaAtcAccountDelete);

				OLAPDataArea dataAreaAtcAccountCopy = OLAPCreateDataArea(connection, dataAccountCube,
				                                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                         OlapDataAreaOperatorNone, 0.0,
				                                                         SourceCycle, SourceVersion,  OlapDataAreaAllCells,SourceEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData, OlapDataAreaAllCells, OlapDataAreaBCells);

				
				foreach(OLAPCell cell in dataAreaAtcAccountCopy)
				{
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string user = OLAPCellGetElement(cell, ""#_SysUsr"");
					string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
					string parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string accountAttribute = OLAPCellGetElement(cell, ""ATDATTRIBUTE_ACCOUNT"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(isCellText)
					{
						valueStr  = cell;
					}
					else
					{
						valueDou = cell;
					}
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, dataAccountCube, valueStr, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					else
					{
						OLAPCellWriteBufferIncrementNumber(buffer, dataAccountCube, valueDou, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					counterAttchmentData = counterAttchmentData  + 1;
				}

				OLAPDataArea wfDataDelete = OLAPCreateDataArea(connection, trackingCube,
				                                               OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                               OlapDataAreaOperatorNone, 0.0,
				                                               TargetCycle, TargetVersion, TargetEntity,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,pnoElementStringList,OlapDataAreaBCells, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData);

				OLAPDeleteDataArea(wfDataDelete);


				OLAPDataArea wfDataCopy = OLAPCreateDataArea(connection, trackingCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaOperatorNone, 0.0,
				                                             SourceCycle, SourceVersion, SourceEntity,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,pnoElementStringList,OlapDataAreaBCells, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAttachmensData);

				foreach(OLAPCell cell in wfDataCopy)
				{
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string application = OLAPCellGetElement(cell, ""BPDAPPLICATION"");
					string tracking = OLAPCellGetElement(cell, ""WFDTRACKING"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					string user = OLAPCellGetElement(cell, ""#_SysUsr"");
					string role = OLAPCellGetElement(cell, ""#__GRP__"");
					string parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(isCellText)
					{
						valueStr  = cell;
					}
					else
					{
						valueDou = cell;
					}
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, trackingCube, valueStr, TargetCycle,  TargetVersion,TargetEntity, organization,application, tracking,level, step, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, user, role, parameter);
					}
					else
					{
						OLAPCellWriteBufferIncrementNumber(buffer, trackingCube, valueDou, TargetCycle,  TargetVersion,TargetEntity, organization,application, tracking,level, step, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, user, role, parameter);
					}
					counterAttchmentData = counterAttchmentData  + 1;
				}
				OLAPCommitCellWriteBuffer(buffer);
				NotifyInformation(""Transfer of attachment data finished."");
				NotifyInformation(""Number of attachment data transferred: "" + counterAttchmentData + ""."");
			}
		}

		if(copyComments)
		{
			int counterCommentData = 0;
			if(sourceCVECheck == targetCVECheck)
			{
				NotifyInformation(""Source and target are same for configuration set, version, entity, no commnets copied."");
			}
			else
			{
				NotifyInformation(""Transfer of Comments data started."");
				StringList parametersListCommentsData= CreateStringList();
				Append(parametersListCommentsData,"""");
				Append(parametersListCommentsData,""FEATURE_WF_TRACKING_COMMENT"");
				Append(parametersListCommentsData,""FEATURE_WF_TRACKING_COMMENT_CHANGED_ON"");
				Append(parametersListCommentsData,""FEATURE_WF_DEFINITION_MANDATORY_COMMENTS"");

				//delete all info connected to comments from ATCDATA_ACCOUNT
				OLAPDataArea dataAreaAtcAccountDelete = OLAPCreateDataArea(connection, dataAccountCube,
				                                                           OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                           OlapDataAreaOperatorNone, 0.0,
				                                                           TargetCycle, TargetVersion,  OlapDataAreaAllCells,TargetEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListCommentsData, OlapDataAreaAllCells, OlapDataAreaBCells);

				OLAPDeleteDataArea(dataAreaAtcAccountDelete);

				OLAPDataArea dataAreaAtcAccountCopy = OLAPCreateDataArea(connection, dataAccountCube,
				                                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                                         OlapDataAreaOperatorNone, 0.0,
				                                                         SourceCycle, SourceVersion,  OlapDataAreaAllCells,SourceEntity,OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListCommentsData, OlapDataAreaAllCells, OlapDataAreaBCells);

				
				foreach(OLAPCell cell in dataAreaAtcAccountCopy)
				{
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string user = OLAPCellGetElement(cell, ""#_SysUsr"");
					string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
					string parameter = OLAPCellGetElement(cell, ""BPDPARAMETER"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string accountAttribute = OLAPCellGetElement(cell, ""ATDATTRIBUTE_ACCOUNT"");
					bool isCellText =  OLAPCellIsTextCell(cell);
					string valueStr = """";
					double valueDou = 0;
					if(isCellText)
					{
						valueStr  = cell;
					}
					else
					{
						valueDou = cell;
					}
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, dataAccountCube, valueStr, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					else
					{
						OLAPCellWriteBufferIncrementNumber(buffer, dataAccountCube, valueDou, TargetCycle,  TargetVersion, organization,TargetEntity, level, step, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12, user, language, parameter, account, accountAttribute);
					}
					counterCommentData = counterCommentData  + 1;
				}

				OLAPDataArea wfDataDelete = OLAPCreateDataArea(connection, trackingCube,
				                                               OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
				                                               OlapDataAreaOperatorNone, 0.0,
				                                               TargetCycle, TargetVersion, TargetEntity,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,pnoElementStringList,OlapDataAreaBCells, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaB"	1	B3C4EEE7-9AEC-48F8-BB86-8A57CFE7E1C2	Copy data(BPCCONFIG_EXCHANGE,EXCRATES,BPCMAIN,CFCCASHFLOW) between Configuration Sets,versions, plus copy line details, attachments and cell commnets	1	1	1	1561	NULL	0	45708.67501	0	0
887DE0C9-37B4-4D28-8EC2-B5F91AE76E8E	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyEntitySettings	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""Return 0, if entity is consolidated element, 1, if is base element"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceEntity"" parameter-type=""string"" parameter-description=""The source entity to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetEntity"" parameter-type=""string"" parameter-description=""The target entity element to fill."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to fill."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""NumberOfSegments"" parameter-type=""double"" parameter-description=""Number of used segments"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""bool"" parameter-description=""if true, intercompany will be activated"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""bool"" parameter-description=""if true, intercompany will be activated"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""The currency element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""copySegmentConfiguration"" parameter-type=""bool"" parameter-description=""If copy segment configuration"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""copyOrganizationConfiguration"" parameter-type=""bool"" parameter-description=""If copy copy Organization Configuration"" parameter-order=""11"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPCopyEntitySettings(string Database, string Ticket,string cycle, string sourceEntity, string targetEntity, string version, double NumberOfSegments,bool intercompany,bool organization, string currency,
                          bool copySegmentConfiguration,bool copyOrganizationConfiguration)
@Description: ""Copy entity settings to other entities"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceEntity]: ""The source entity to be used."";
@Parameter[targetEntity]: ""The target entity element to fill."";
@Parameter[version]: ""The version element to fill."";
@Parameter[NumberOfSegments]: ""Number of used segments"";
@Parameter[intercompany]: ""if true, intercompany will be activated"";
@Parameter[organization]: ""if true, intercompany will be activated"";
@Parameter[currency]: ""The currency element to be used."";
@Parameter[copySegmentConfiguration]: ""If copy segment configuration"";
@Parameter[copyOrganizationConfiguration]: ""If copy copy Organization Configuration"";
@Returns: ""Return 0, if entity is consolidated element, 1, if is base element"";
{

	LogInformation(""BAPCopyentitySettings: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string segmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string entityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string cycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string mainConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string organizationDimension= ""BPDORGANIZATION"";
	string parameterElement= ""SUBPLAN_FINANCE_ACC_ACTIVE"";
	string parameterElementSegment= ""GLOBAL_SEGMENT_ACTIVE"";
	string totalOrganizationElement= ""TOTAL_ORGANIZATION"";
	string NA = ""N.A."";

	cycle = ResolveUniqueName(connection, cycle);
	sourceEntity = ResolveUniqueName(connection, sourceEntity);
	version = ResolveUniqueName(connection, version);

	//procedure to fill array with entities from string paramater

	StringArray targetEntities = CreateStringArray();
	if(!StringContains(targetEntity, "",""))
	{
		targetEntity = ResolveUniqueName(connection, targetEntity);
		Append(targetEntities, targetEntity);
	}

	while(StringContains(targetEntity, "",""))
	{
		int numberOfLetters = StringFind(targetEntity,"","",1);

		string targetEntityHelp = StringSubstring(targetEntity, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		targetEntity = StringSubstring(targetEntity, numberOfLetters + 1, StringLength(targetEntity)-(numberOfLetters + 1));
		numberOfLetters = StringFind(targetEntity,"","",1);
		if(numberOfLetters&lt;0)
		{
			numberOfLetters = StringLength(targetEntity);
		}
		
		targetEntityHelp = StringSubstring(targetEntity, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);


	}

	foreach (string entities in targetEntities)
	{
		string currencyRead = OLAPCellReadString(connection, entityConfigurationCube, cycle,NA , entities ,NA, NA,""GLOBAL_ENTITY_CURRENCY"");
		if(currencyRead =="""")
		{
			OLAPCellWriteBufferWriteString(buffer, entityConfigurationCube,currency, cycle,NA, entities ,NA , NA,""GLOBAL_ENTITY_CURRENCY"");
		}
	}
	//check if intercompany is activated in cycle, and set it in company

	if(intercompany)
	{
		foreach (string entities in targetEntities)
		{
			OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1, cycle,version, NA ,entities,  NA,""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
		}

	}


	if(!copyOrganizationConfiguration)
	{
		if(organization)
		{
			foreach (string entities in targetEntities)
			{
				OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
				{
					OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1.0, cycle, version, entities , NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
					OLAPCellWriteBufferWriteNumber(buffer, mainConfigurationCube,1.0, cycle,version,  entities , organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");

				}

			}
		}

	}
	else
	{
		foreach (string entities in targetEntities)
		{

			OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
			foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
			{

				
				double organizationSet = OLAPCellReadNumber(connection, entityConfigurationCube, 1.0, cycle,version, sourceEntity,NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,organizationSet, cycle, version, entities , NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");

				double organizationSetSubplan = OLAPCellReadNumber(connection, mainConfigurationCube, 1.0, cycle,version, sourceEntity, organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");
				OLAPCellWriteBufferWriteNumber(buffer, mainConfigurationCube,1.0, cycle,version,  entities , organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");

			}
			
		}
	}


	if(copySegmentConfiguration)
	{
		foreach (string entities in targetEntities)
		{

			OLAPDataArea target = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle, version,entities,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);

			OLAPDeleteDataArea(target);

			OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, sourceEntity,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);
			foreach (OLAPCell cell in source)
			{
				cycle = OLAPCellGetElement(cell, ""BPDCYCLE"");
				string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string segment3write = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				double value = cell;
				OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, value, cycle, version,entities,segment1write, segment2write, segment3write,parameterElementSegment);

			}

		}

	}
	else
	{
		foreach (string entities in targetEntities)
		{
			if(NumberOfSegments == 0)
			{
				OLAPCellWriteNumber(connection, segmentConfigurationCube, 1.0, cycle, version,entities,NA, NA, NA,parameterElementSegment);
			}
			else if (NumberOfSegments == 1)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,NA, NA,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");

					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, NA, NA,parameterElementSegment);

				}

			}
			else if (NumberOfSegments == 2)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,OlapDataAreaBCells, NA,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, segment2write, NA,parameterElementSegment);

				}

			}
			else if (NumberOfSegments == 3)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string segment3write = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, segment2write, segment3write,parameterElementSegment);

				}

			}

		}
	}

	//activate entities
	foreach (string entities in targetEntities)
	{
		double entitydeactivated = OLAPCellReadNumber(connection, entityConfigurationCube, 1.0, cycle,version, entities,NA, NA,""GLOBAL_ENTITY_ACTIVE"");
		if(entitydeactivated==0)
		{
			OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube, 1, cycle, version,entities,NA, NA,""GLOBAL_ENTITY_ACTIVE"");
		}
	}



	DateTime datetime = CreateDateTime();
	string date = GetDateTimeAsString(datetime, ""yyyyMMdd"");
	double dateNumeric = ToDouble(date);
	
	OLAPCommitCellWriteBuffer(buffer);
	OLAPCellWriteNumber(connection, cycleConfigurationCube, dateNumeric,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Value"");
	OLAPCellWriteString(connection, cycleConfigurationCube,date,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Text Value"");

	LogInformation(""BAPCopyentitySettings: Process finished"");
	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPCopyEntitySettings(string Database, string Ticket,string cycle, string sourceEntity, string targetEntity, string version, double NumberOfSegments,bool intercompany,bool organization, string currency,
                          bool copySegmentConfiguration,bool copyOrganizationConfiguration)
@Description: ""Copy entity settings to other entities"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceEntity]: ""The source entity to be used."";
@Parameter[targetEntity]: ""The target entity element to fill."";
@Parameter[version]: ""The version element to fill."";
@Parameter[NumberOfSegments]: ""Number of used segments"";
@Parameter[intercompany]: ""if true, intercompany will be activated"";
@Parameter[organization]: ""if true, intercompany will be activated"";
@Parameter[currency]: ""The currency element to be used."";
@Parameter[copySegmentConfiguration]: ""If copy segment configuration"";
@Parameter[copyOrganizationConfiguration]: ""If copy copy Organization Configuration"";
@Returns: ""Return 0, if entity is consolidated element, 1, if is base element"";
{

	LogInformation(""BAPCopyentitySettings: Starting process"");
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string segmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string entityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string cycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string mainConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string organizationDimension= ""BPDORGANIZATION"";
	string parameterElement= ""SUBPLAN_FINANCE_ACC_ACTIVE"";
	string parameterElementSegment= ""GLOBAL_SEGMENT_ACTIVE"";
	string totalOrganizationElement= ""TOTAL_ORGANIZATION"";
	string NA = ""N.A."";

	cycle = ResolveUniqueName(connection, cycle);
	sourceEntity = ResolveUniqueName(connection, sourceEntity);
	version = ResolveUniqueName(connection, version);

	//procedure to fill array with entities from string paramater

	StringArray targetEntities = CreateStringArray();
	if(!StringContains(targetEntity, "",""))
	{
		targetEntity = ResolveUniqueName(connection, targetEntity);
		Append(targetEntities, targetEntity);
	}

	while(StringContains(targetEntity, "",""))
	{
		int numberOfLetters = StringFind(targetEntity,"","",1);

		string targetEntityHelp = StringSubstring(targetEntity, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		targetEntity = StringSubstring(targetEntity, numberOfLetters + 1, StringLength(targetEntity)-(numberOfLetters + 1));
		numberOfLetters = StringFind(targetEntity,"","",1);
		if(numberOfLetters<0)
		{
			numberOfLetters = StringLength(targetEntity);
		}
		
		targetEntityHelp = StringSubstring(targetEntity, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);


	}

	foreach (string entities in targetEntities)
	{
		string currencyRead = OLAPCellReadString(connection, entityConfigurationCube, cycle,NA , entities ,NA, NA,""GLOBAL_ENTITY_CURRENCY"");
		if(currencyRead =="""")
		{
			OLAPCellWriteBufferWriteString(buffer, entityConfigurationCube,currency, cycle,NA, entities ,NA , NA,""GLOBAL_ENTITY_CURRENCY"");
		}
	}
	//check if intercompany is activated in cycle, and set it in company

	if(intercompany)
	{
		foreach (string entities in targetEntities)
		{
			OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1, cycle,version, NA ,entities,  NA,""GLOBAL_ENTITY_INTERCOMPANY_ACTIVE"");
		}

	}


	if(!copyOrganizationConfiguration)
	{
		if(organization)
		{
			foreach (string entities in targetEntities)
			{
				OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
				foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
				{
					OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,1.0, cycle, version, entities , NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
					OLAPCellWriteBufferWriteNumber(buffer, mainConfigurationCube,1.0, cycle,version,  entities , organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");

				}

			}
		}

	}
	else
	{
		foreach (string entities in targetEntities)
		{

			OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, totalOrganizationElement);
			foreach (OLAPElement organizationfill in OLAPGetChildElementList(connection, organizationDimension, organizationElement, true))
			{

				
				double organizationSet = OLAPCellReadNumber(connection, entityConfigurationCube, 1.0, cycle,version, sourceEntity,NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube,organizationSet, cycle, version, entities , NA, organizationfill,""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");

				double organizationSetSubplan = OLAPCellReadNumber(connection, mainConfigurationCube, 1.0, cycle,version, sourceEntity, organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");
				OLAPCellWriteBufferWriteNumber(buffer, mainConfigurationCube,1.0, cycle,version,  entities , organizationfill,NA,NA,""SUBPLAN_FINANCE_ACC_ACTIVE"",""Value"");

			}
			
		}
	}


	if(copySegmentConfiguration)
	{
		foreach (string entities in targetEntities)
		{

			OLAPDataArea target = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle, version,entities,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);

			OLAPDeleteDataArea(target);

			OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, sourceEntity,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);
			foreach (OLAPCell cell in source)
			{
				cycle = OLAPCellGetElement(cell, ""BPDCYCLE"");
				string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string segment3write = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				double value = cell;
				OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, value, cycle, version,entities,segment1write, segment2write, segment3write,parameterElementSegment);

			}

		}

	}
	else
	{
		foreach (string entities in targetEntities)
		{
			if(NumberOfSegments == 0)
			{
				OLAPCellWriteNumber(connection, segmentConfigurationCube, 1.0, cycle, version,entities,NA, NA, NA,parameterElementSegment);
			}
			else if (NumberOfSegments == 1)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,NA, NA,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");

					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, NA, NA,parameterElementSegment);

				}

			}
			else if (NumberOfSegments == 2)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,OlapDataAreaBCells, NA,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, segment2write, NA,parameterElementSegment);

				}

			}
			else if (NumberOfSegments == 3)
			{

				OLAPDataArea source = OLAPCreateDataArea(connection, segmentConfigurationCube, OlapDataAreaIncludeB ,
				                                         OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,cycle,version, entities,OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells,parameterElementSegment);
				foreach (OLAPCell cell in source)
				{
					string segment1write = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string segment2write = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string segment3write = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					
					OLAPCellWriteBufferWriteNumber(buffer, segmentConfigurationCube, 1.0, cycle, version,entities,segment1write, segment2write, segment3write,parameterElementSegment);

				}

			}

		}
	}

	//activate entities
	foreach (string entities in targetEntities)
	{
		double entitydeactivated = OLAPCellReadNumber(connection, entityConfigurationCube, 1.0, cycle,version, entities,NA, NA,""GLOBAL_ENTITY_ACTIVE"");
		if(entitydeactivated==0)
		{
			OLAPCellWriteBufferWriteNumber(buffer, entityConfigurationCube, 1, cycle, version,entities,NA, NA,""GLOBAL_ENTITY_ACTIVE"");
		}
	}



	DateTime datetime = CreateDateTime();
	string date = GetDateTimeAsString(datetime, ""yyyyMMdd"");
	double dateNumeric = ToDouble(date);
	
	OLAPCommitCellWriteBuffer(buffer);
	OLAPCellWriteNumber(connection, cycleConfigurationCube, dateNumeric,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Value"");
	OLAPCellWriteString(connection, cycleConfigurationCube,date,cycle,version,""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"",""Text Value"");

	LogInformation(""BAPCopyentitySettings: Process finished"");
	return 0;
}"	1	6BF59799-6446-43FE-96B5-27DE95956250	Copy entity settings to other entities	1	1	1	1562	NULL	0	45708.67504	0	0
6E31FF51-2C24-40AB-B06D-8A12A858A9B4	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyPlanningStep	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""SourceEntityUN"" parameter-type=""string"" parameter-description=""The source Entity element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""TargetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""SourcePlanningStepUN"" parameter-type=""string"" parameter-description=""Planning step to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""CopyAllSteps"" parameter-type=""bool"" parameter-description=""The cycle element to be used."" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPCopyPlanningStep(string Database, string Ticket, string SourceEntityUN, string TargetEntityUN, string SourcePlanningStepUN, string CycleUN, bool CopyAllSteps)
@Description: ""Copy single planning step to selected company."";
@Category: ""Budgeting and Planning"";
@Returns: ""True, if successful."";

@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceEntityUN]: ""The source Entity element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity element to be used."";
@Parameter[SourcePlanningStepUN]: ""Planning step to be used."";
@Parameter[CopyAllSteps]: ""The cycle element to be used."";

{
	
	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string SourcePlanningStep = ResolveUniqueName(connection, SourcePlanningStepUN);
	string Cube = ""BPCCONFIG_MAIN"";

	//procedure to fill array with entities from string paramater
	StringArray targetEntities = CreateStringArray();
	if(!StringContains(TargetEntityUN, "",""))
	{
		TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
		Append(targetEntities, TargetEntityUN);
	}

	while(StringContains(TargetEntityUN, "",""))
	{
		int numberOfLetters = StringFind(TargetEntityUN,"","",1);

		string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
		
		targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);
	}

	CopiedValues = 0;

	// finding free element in PNO dimension - planning step
	foreach (string entities in targetEntities)
	{

		if(!CopyAllSteps)
		{
			LogInformation(""Copying planning step, Cycle: "" + Cycle + ""Entity: "" + SourceEntity + "" -&gt; "" + entities + "", Planning step: "" + SourcePlanningStep);

			CopiedValues = 0;

			// finding free element in PNO dimension - planning step

			string FreePlanningStep = """";
			
			LogInformation(""Finding free PNO element..."");

			OLAPElementList PlanningStepList = OLAPGetElementList(connection, ""BPDNO"", true);

			foreach (OLAPElement PlanningStep in PlanningStepList)
			{
				if (FreePlanningStep=="""")
				{
					//LogInformation(""Step: "" + PlanningStep);
					string value = OLAPCellReadString(connection, Cube, Cycle, entities, ""N.A."", ""N.A."", PlanningStep, ""SUBPLAN_FINANCE_DESCRIPTION"", ""Default"");
					if (value=="""")
					{
						if(PlanningStep != ""N.A."")
						{
							FreePlanningStep = PlanningStep;
						}
					}
				}
			}

			LogInformation(""Done, free element found: "" + FreePlanningStep);

			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, entities, OlapDataAreaBCells, OlapDataAreaBCells, FreePlanningStep, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, SourcePlanningStep, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
				string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
				
				string value = OLAPCellReadString(connection, Cube, Cycle, SourceEntity, organization, account, SourcePlanningStep, pattpara, language);
				
				CopiedValues = CopiedValues + 1;
				
				OLAPCellWriteBufferWriteString(buffer, Cube, value, Cycle, entities, organization, account, FreePlanningStep, pattpara, language);
			}
			LogInformation(""Cube: "" + Cube + "", values: "" + ToString(CopiedValues));

		}

		else
		{
			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, entities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle,SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string pno = OLAPCellGetElement(cell, ""BPDNO"");
				string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
				string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
				
				string value = OLAPCellReadString(connection, Cube, Cycle,SourceEntity, organization, account, pno, pattpara, language);
				
				CopiedValues = CopiedValues + 1;
				
				OLAPCellWriteBufferWriteString(buffer, Cube, value, Cycle, entities, organization, account, pno, pattpara, language);
			}
			

		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	return CopiedValues;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPCopyPlanningStep(string Database, string Ticket, string SourceEntityUN, string TargetEntityUN, string SourcePlanningStepUN, string CycleUN, bool CopyAllSteps)
@Description: ""Copy single planning step to selected company."";
@Category: ""Budgeting and Planning"";
@Returns: ""True, if successful."";

@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceEntityUN]: ""The source Entity element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity element to be used."";
@Parameter[SourcePlanningStepUN]: ""Planning step to be used."";
@Parameter[CopyAllSteps]: ""The cycle element to be used."";

{
	
	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string SourcePlanningStep = ResolveUniqueName(connection, SourcePlanningStepUN);
	string Cube = ""BPCCONFIG_MAIN"";

	//procedure to fill array with entities from string paramater
	StringArray targetEntities = CreateStringArray();
	if(!StringContains(TargetEntityUN, "",""))
	{
		TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
		Append(targetEntities, TargetEntityUN);
	}

	while(StringContains(TargetEntityUN, "",""))
	{
		int numberOfLetters = StringFind(TargetEntityUN,"","",1);

		string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
		
		targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);
	}

	CopiedValues = 0;

	// finding free element in PNO dimension - planning step
	foreach (string entities in targetEntities)
	{

		if(!CopyAllSteps)
		{
			LogInformation(""Copying planning step, Cycle: "" + Cycle + ""Entity: "" + SourceEntity + "" -> "" + entities + "", Planning step: "" + SourcePlanningStep);

			CopiedValues = 0;

			// finding free element in PNO dimension - planning step

			string FreePlanningStep = """";
			
			LogInformation(""Finding free PNO element..."");

			OLAPElementList PlanningStepList = OLAPGetElementList(connection, ""BPDNO"", true);

			foreach (OLAPElement PlanningStep in PlanningStepList)
			{
				if (FreePlanningStep=="""")
				{
					//LogInformation(""Step: "" + PlanningStep);
					string value = OLAPCellReadString(connection, Cube, Cycle, entities, ""N.A."", ""N.A."", PlanningStep, ""SUBPLAN_FINANCE_DESCRIPTION"", ""Default"");
					if (value=="""")
					{
						if(PlanningStep != ""N.A."")
						{
							FreePlanningStep = PlanningStep;
						}
					}
				}
			}

			LogInformation(""Done, free element found: "" + FreePlanningStep);

			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, entities, OlapDataAreaBCells, OlapDataAreaBCells, FreePlanningStep, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, SourcePlanningStep, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
				string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
				
				string value = OLAPCellReadString(connection, Cube, Cycle, SourceEntity, organization, account, SourcePlanningStep, pattpara, language);
				
				CopiedValues = CopiedValues + 1;
				
				OLAPCellWriteBufferWriteString(buffer, Cube, value, Cycle, entities, organization, account, FreePlanningStep, pattpara, language);
			}
			LogInformation(""Cube: "" + Cube + "", values: "" + ToString(CopiedValues));

		}

		else
		{
			OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle, entities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetData);
			
			OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaOperatorNone, 0.0,
			                                             Cycle,SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


			foreach (OLAPCell cell in SourceData)
			{
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string pno = OLAPCellGetElement(cell, ""BPDNO"");
				string pattpara = OLAPCellGetElement(cell, ""BPDPARAMETER"");
				string language = OLAPCellGetElement(cell, ""BPDLANGUAGE"");
				
				string value = OLAPCellReadString(connection, Cube, Cycle,SourceEntity, organization, account, pno, pattpara, language);
				
				CopiedValues = CopiedValues + 1;
				
				OLAPCellWriteBufferWriteString(buffer, Cube, value, Cycle, entities, organization, account, pno, pattpara, language);
			}
			

		}

	}
	OLAPCommitCellWriteBuffer(buffer);

	return CopiedValues;
}"	1	08611F20-BB03-4856-83F9-F3443EB53FEE	Copy single planning step to selected company.	1	1	1	1563	NULL	0	45708.67508	0	0
268B659B-A066-4D63-88E2-95D08901CFE8	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyPremises	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""SourceEntityUN"" parameter-type=""string"" parameter-description=""The source Entity element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""TargetEntityUN"" parameter-type=""string"" parameter-description=""The target Entity/entities element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyPremises(string Database, string Ticket, string SourceEntityUN, string TargetEntityUN, string CycleUN)
@Description: ""Copy premises from source entity to selected target entities."";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceEntityUN]: ""The source Entity element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity/entities element to be used."";
@Returns: ""True, if successful."";

{

	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string Cube = ""BPCCONFIG_PREMISES"";


	//procedure to fill array with entities from string paramater
	StringArray targetEntities = CreateStringArray();
	if(!StringContains(TargetEntityUN, "",""))
	{
		TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
		Append(targetEntities, TargetEntityUN);
	}

	while(StringContains(TargetEntityUN, "",""))
	{
		int numberOfLetters = StringFind(TargetEntityUN,"","",1);

		string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
		numberOfLetters = StringFind(TargetEntityUN,"","",1);
		if(numberOfLetters&lt;0)
		{
			numberOfLetters = StringLength(TargetEntityUN);
		}
		targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);
	}



	// finding free element in PNO dimension - planning step
	foreach (string TargetEntity in targetEntities)
	{


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, Cycle,  OlapDataAreaBCells, TargetEntity, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, Cycle, OlapDataAreaBCells,SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string time = OLAPCellGetElement(cell, ""BPDTIME"");
			string version = OLAPCellGetElement(cell, ""BPDVERSION"");
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string premises = OLAPCellGetElement(cell, ""BPDPREMISE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, time, Cycle, version, TargetEntity, account, premises);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  time, Cycle, version, TargetEntity, account, premises);
			}

			
		}
		LogInformation(""Cube: "" + Cube + "", values: "" + ToString(CopiedValues));
		OLAPCommitCellWriteBuffer(buffer);
	}
	return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyPremises(string Database, string Ticket, string SourceEntityUN, string TargetEntityUN, string CycleUN)
@Description: ""Copy premises from source entity to selected target entities."";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceEntityUN]: ""The source Entity element to be used."";
@Parameter[TargetEntityUN]: ""The target Entity/entities element to be used."";
@Returns: ""True, if successful."";

{

	int CopiedValues = 0;

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	string SourceEntity = ResolveUniqueName(connection, SourceEntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string Cube = ""BPCCONFIG_PREMISES"";


	//procedure to fill array with entities from string paramater
	StringArray targetEntities = CreateStringArray();
	if(!StringContains(TargetEntityUN, "",""))
	{
		TargetEntityUN = ResolveUniqueName(connection, TargetEntityUN);
		Append(targetEntities, TargetEntityUN);
	}

	while(StringContains(TargetEntityUN, "",""))
	{
		int numberOfLetters = StringFind(TargetEntityUN,"","",1);

		string targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);

		TargetEntityUN = StringSubstring(TargetEntityUN, numberOfLetters + 1, StringLength(TargetEntityUN)-(numberOfLetters + 1));
		numberOfLetters = StringFind(TargetEntityUN,"","",1);
		if(numberOfLetters<0)
		{
			numberOfLetters = StringLength(TargetEntityUN);
		}
		targetEntityHelp = StringSubstring(TargetEntityUN, 0, numberOfLetters);
		targetEntityHelp = ResolveUniqueName(connection, targetEntityHelp);
		AppendDistinct(targetEntities, targetEntityHelp);
	}



	// finding free element in PNO dimension - planning step
	foreach (string TargetEntity in targetEntities)
	{


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, Cycle,  OlapDataAreaBCells, TargetEntity, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, Cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, Cycle, OlapDataAreaBCells,SourceEntity, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string time = OLAPCellGetElement(cell, ""BPDTIME"");
			string version = OLAPCellGetElement(cell, ""BPDVERSION"");
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			string premises = OLAPCellGetElement(cell, ""BPDPREMISE"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;
			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			CopiedValues = CopiedValues + 1;
			if(isCellText)
			{
				OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, time, Cycle, version, TargetEntity, account, premises);
			}
			else
			{
				OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou,  time, Cycle, version, TargetEntity, account, premises);
			}

			
		}
		LogInformation(""Cube: "" + Cube + "", values: "" + ToString(CopiedValues));
		OLAPCommitCellWriteBuffer(buffer);
	}
	return true;
}"	1	B46299F8-0E5F-4682-B10C-5DDA8C88A686	Copy premises from source entity to selected target entities.	1	1	1	1564	NULL	0	45708.67506	0	0
1E5D9A17-FBED-4894-A395-A781692CC435	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopySalesConfigurationAsDefault	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Place the return value description here"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to configure."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""Intercompany element in use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected for configuration"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""segmentParameter1"" parameter-type=""string"" parameter-description=""First Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""segmentParameter2"" parameter-type=""string"" parameter-description=""Second Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""segmentParameter3"" parameter-type=""string"" parameter-description=""Third Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopySalesConfigurationAsDefault(string database, string ticket, string cycle, string intercompany, string entity, string segmentParameter1, string segmentParameter2,
                                        string segmentParameter3)
@Description: ""Copy default sales configuration to each active version within Configuration Set"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[segmentParameter1]: ""First Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter2]: ""Second Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter3]: ""Third Segment information. Will be turned to correct dimension reference in the process"";
@Returns: ""Place the return value description here"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");

	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	segmentParameter1=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	segmentParameter2=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	segmentParameter3=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string primarySegment = """";
	string secondarySegment = """";
	string tertiarySegment = """";
	string costGroup = """";
	string salesGroup = """";
	string NA = ""N.A."";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	//determine segment dimension of first segment paramater
	if (StringContains(segmentParameter1, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter1;
	}
	else if (StringContains(segmentParameter1, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter1;
	}
	else
	{
		tertiarySegment = segmentParameter1;
	}
	
	//determine segment dimension of second segment paramater
	if (StringContains(segmentParameter2, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter2;
	}
	else if (StringContains(segmentParameter2, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter2;
	}
	else
	{
		tertiarySegment = segmentParameter2;
	}
	
	//determine segment dimension of third segment paramater
	if (StringContains(segmentParameter3, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter3;
	}
	else if (StringContains(segmentParameter3, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter3;
	}
	else
	{
		tertiarySegment = segmentParameter3;
	}
	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	
	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}

	foreach (string version in budgetArray)
	{

		costGroup = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, entity, intercompany, NA, primarySegment, secondarySegment, tertiarySegment, ""COST GROUP"");
		salesGroup = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, entity, intercompany, NA, primarySegment, secondarySegment, tertiarySegment, ""SALES GROUP"");

		LogDebug(""CostGroup: "" + costGroup + "" SalesGroup: "" + salesGroup);
		

		// select all cells having activ == 1
		OLAPDataArea salesConfiguration = OLAPCreateDataArea(connection, SalesConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                     OlapDataAreaOperatorEqual, 1.0, OlapDataAreaOperatorNone, 0.0,
		                                                     cycle, NA, entity, intercompany, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""ACTIV"");

		foreach (OLAPCell cell in salesConfiguration)
		{
			string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
			string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
			string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);
			string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");

			OLAPCellWriteBufferWriteString(buffer, SalesConfigurationCube, costGroup, cycle, NA, entity, intercompany, NA, psegment, ssegment, tsegment, ""COST GROUP"");
			OLAPCellWriteBufferWriteString(buffer, SalesConfigurationCube, salesGroup, cycle, NA, entity, intercompany, NA, psegment, ssegment, tsegment, ""SALES GROUP"");
			
			OLAPCellWriteBufferWriteNumber(buffer, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""VALID"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS1"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS2"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS3"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""FINAL STATUS"");
		}
	}
	OLAPCommitCellWriteBuffer(buffer);

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopySalesConfigurationAsDefault(string database, string ticket, string cycle, string intercompany, string entity, string segmentParameter1, string segmentParameter2,
                                        string segmentParameter3)
@Description: ""Copy default sales configuration to each active version within Configuration Set"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[segmentParameter1]: ""First Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter2]: ""Second Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter3]: ""Third Segment information. Will be turned to correct dimension reference in the process"";
@Returns: ""Place the return value description here"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");

	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	segmentParameter1=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	segmentParameter2=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	segmentParameter3=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string primarySegment = """";
	string secondarySegment = """";
	string tertiarySegment = """";
	string costGroup = """";
	string salesGroup = """";
	string NA = ""N.A."";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	//determine segment dimension of first segment paramater
	if (StringContains(segmentParameter1, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter1;
	}
	else if (StringContains(segmentParameter1, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter1;
	}
	else
	{
		tertiarySegment = segmentParameter1;
	}
	
	//determine segment dimension of second segment paramater
	if (StringContains(segmentParameter2, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter2;
	}
	else if (StringContains(segmentParameter2, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter2;
	}
	else
	{
		tertiarySegment = segmentParameter2;
	}
	
	//determine segment dimension of third segment paramater
	if (StringContains(segmentParameter3, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter3;
	}
	else if (StringContains(segmentParameter3, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter3;
	}
	else
	{
		tertiarySegment = segmentParameter3;
	}
	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	
	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}

	foreach (string version in budgetArray)
	{

		costGroup = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, entity, intercompany, NA, primarySegment, secondarySegment, tertiarySegment, ""COST GROUP"");
		salesGroup = OLAPCellReadString(connection, SalesConfigurationCube, cycle, NA, entity, intercompany, NA, primarySegment, secondarySegment, tertiarySegment, ""SALES GROUP"");

		LogDebug(""CostGroup: "" + costGroup + "" SalesGroup: "" + salesGroup);
		

		// select all cells having activ == 1
		OLAPDataArea salesConfiguration = OLAPCreateDataArea(connection, SalesConfigurationCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                     OlapDataAreaOperatorEqual, 1.0, OlapDataAreaOperatorNone, 0.0,
		                                                     cycle, NA, entity, intercompany, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""ACTIV"");

		foreach (OLAPCell cell in salesConfiguration)
		{
			string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
			string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
			string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);
			string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");

			OLAPCellWriteBufferWriteString(buffer, SalesConfigurationCube, costGroup, cycle, NA, entity, intercompany, NA, psegment, ssegment, tsegment, ""COST GROUP"");
			OLAPCellWriteBufferWriteString(buffer, SalesConfigurationCube, salesGroup, cycle, NA, entity, intercompany, NA, psegment, ssegment, tsegment, ""SALES GROUP"");
			
			OLAPCellWriteBufferWriteNumber(buffer, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""VALID"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS1"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS2"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""STATUS3"");
			OLAPCellWriteBufferWriteNumber(buffer,  SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, psegment, ssegment, tsegment, ""FINAL STATUS"");
		}
	}
	OLAPCommitCellWriteBuffer(buffer);

	return true;
}"	1	89E4C9E7-497F-4135-BC05-CF6FED765DD1	Copy default sales configuration to each active version within Configuration Set	1	1	1	1565	NULL	0	45708.67504	0	0
6F642A43-2EA9-4E2A-B452-C13E5CFC02EC	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopySegmentConfigurationData	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True if succesfull, otherwise error message."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceCycle"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceEntity"" parameter-type=""string"" parameter-description=""The source entity element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetCycle"" parameter-type=""string"" parameter-description=""The target Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetEntity"" parameter-type=""string"" parameter-description=""The target entity element to be used."" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPCopySegmentConfigurationData(string Database, string sourceCycle, string sourceVersion, string sourceEntity, string targetCycle, string targetVersion, string targetEntity)
@Description: ""Copy segment configuration data from source cycle, version, entity to target."";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[sourceCycle]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetCycle]: ""The target Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version element to be used."";
@Parameter[targetEntity]: ""The target entity element to be used."";
@Returns: ""True if succesfull, otherwise error message."";
{
	// constants used in the process
	string functionName = ""BAPCopySegmentConfigurationData:"";
	string errorMessage = """";
	string segmentConfigCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string NA = ""N.A."";
	int errorCode = 0;
	string result ="""";
	try
	{
		LogInformation(""BAPCopySegmentConfigurationData: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
		sourceEntity = ""[BPDENTITY].[RU0001].[1]"";
		targetCycle = ""[BPDCYCLE].[CYCLE_005].[1]"";
		targetVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
		targetEntity = ""[BPDENTITY].[RU0001].[1]"";*/

		sourceCycle = ResolveUniqueName(connection, sourceCycle);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceEntity = ResolveUniqueName(connection, sourceEntity);
		targetCycle = ResolveUniqueName(connection, targetCycle);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		targetEntity = ResolveUniqueName(connection, targetEntity);

		StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slParameter = ConvertToStringList(OlapDataAreaBCells);

		NotifyInformation(""Copying data for Segment configuration."");
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, segmentConfigCube,
		                                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                targetCycle, targetVersion, targetEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigCube,
		                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                sourceCycle,sourceVersion, sourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		StringListList targetElements = CreateStringListList();
		StringList slTCycle = ConvertToStringList(targetCycle);
		StringList slTVersion = ConvertToStringList(targetVersion);
		StringList slTEntity = ConvertToStringList(targetEntity);
		Append(targetElements, slTCycle);
		Append(targetElements, slTVersion);
		Append(targetElements, slTEntity);
		Append(targetElements, slPSegment);
		Append(targetElements, slSSegment);
		Append(targetElements, slTSegment);
		Append(targetElements, slParameter);

		
		StringListList sourceElements = CreateStringListList();
		StringList slSCycle = ConvertToStringList(sourceCycle);
		StringList slSVersion = ConvertToStringList(sourceVersion);
		StringList slSEntity = ConvertToStringList(sourceEntity);
		Append(sourceElements, slSCycle);
		Append(sourceElements, slSVersion);
		Append(sourceElements, slSEntity);
		Append(sourceElements, slPSegment);
		Append(sourceElements, slSSegment);
		Append(sourceElements, slTSegment);
		Append(sourceElements, slParameter);

		OLAPCopyDataArea(SourceData, segmentConfigCube, ""Relative"", 1.0, targetElements, sourceElements, true, true);



		LogInformation(""BAPCopySegmentConfigurationData: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BAPCopySegmentConfigurationData(string Database, string sourceCycle, string sourceVersion, string sourceEntity, string targetCycle, string targetVersion, string targetEntity)
@Description: ""Copy segment configuration data from source cycle, version, entity to target."";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[sourceCycle]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetCycle]: ""The target Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version element to be used."";
@Parameter[targetEntity]: ""The target entity element to be used."";
@Returns: ""True if succesfull, otherwise error message."";
{
	// constants used in the process
	string functionName = ""BAPCopySegmentConfigurationData:"";
	string errorMessage = """";
	string segmentConfigCube = ""BPCCONFIG_ENTITY_SEGMENT"";
	string NA = ""N.A."";
	int errorCode = 0;
	string result ="""";
	try
	{
		LogInformation(""BAPCopySegmentConfigurationData: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
		sourceEntity = ""[BPDENTITY].[RU0001].[1]"";
		targetCycle = ""[BPDCYCLE].[CYCLE_005].[1]"";
		targetVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
		targetEntity = ""[BPDENTITY].[RU0001].[1]"";*/

		sourceCycle = ResolveUniqueName(connection, sourceCycle);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceEntity = ResolveUniqueName(connection, sourceEntity);
		targetCycle = ResolveUniqueName(connection, targetCycle);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		targetEntity = ResolveUniqueName(connection, targetEntity);

		StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);
		StringList slParameter = ConvertToStringList(OlapDataAreaBCells);

		NotifyInformation(""Copying data for Segment configuration."");
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, segmentConfigCube,
		                                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                targetCycle, targetVersion, targetEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, segmentConfigCube,
		                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                OlapDataAreaOperatorNone, 0.0,
		                                                sourceCycle,sourceVersion, sourceEntity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		StringListList targetElements = CreateStringListList();
		StringList slTCycle = ConvertToStringList(targetCycle);
		StringList slTVersion = ConvertToStringList(targetVersion);
		StringList slTEntity = ConvertToStringList(targetEntity);
		Append(targetElements, slTCycle);
		Append(targetElements, slTVersion);
		Append(targetElements, slTEntity);
		Append(targetElements, slPSegment);
		Append(targetElements, slSSegment);
		Append(targetElements, slTSegment);
		Append(targetElements, slParameter);

		
		StringListList sourceElements = CreateStringListList();
		StringList slSCycle = ConvertToStringList(sourceCycle);
		StringList slSVersion = ConvertToStringList(sourceVersion);
		StringList slSEntity = ConvertToStringList(sourceEntity);
		Append(sourceElements, slSCycle);
		Append(sourceElements, slSVersion);
		Append(sourceElements, slSEntity);
		Append(sourceElements, slPSegment);
		Append(sourceElements, slSSegment);
		Append(sourceElements, slTSegment);
		Append(sourceElements, slParameter);

		OLAPCopyDataArea(SourceData, segmentConfigCube, ""Relative"", 1.0, targetElements, sourceElements, true, true);



		LogInformation(""BAPCopySegmentConfigurationData: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}
}"	1	14D09F3A-9F62-4881-B3A5-653C35230940	Copy segment configuration data from source cycle, version, entity to target.	1	1	1	1566	NULL	0	45708.67506	0	0
AC860E1C-098E-46F5-BF85-B4D7B1D38D48	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopySubPlanAccountMapping	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Place the return value description here"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCycle"" parameter-type=""string"" parameter-description=""Source Configuration Set for copy action"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""targetCycle"" parameter-type=""string"" parameter-description=""Target Configuration Set for copy action"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""subplan"" parameter-type=""string"" parameter-description=""Subplan, used for copy action."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopySubPlanAccountMapping(string database, string ticket, string sourceCycle, string targetCycle, string subplan)
@Description: ""Copies the subplan account mapping configuration from one Configuration Set to the other"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[subplan]: ""Subplan, used for copy action."";
@Parameter[sourceCycle]: ""Source Configuration Set for copy action"";
@Parameter[targetCycle]: ""Target Configuration Set for copy action"";
@Returns: ""Place the return value description here"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	
	subplan = ""[BPDPARAMETER].[SUBPLAN_SALES].[1]"";
	sourceCycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	targetCycle = ""[BPDCYCLE].[CYCLE_007].[1]"";*/

	
	sourceCycle = ResolveUniqueName(connection, sourceCycle);
	targetCycle = ResolveUniqueName(connection, targetCycle);
	subplan = ResolveUniqueName(connection, subplan);

	
	//static strings
	string ParameterDimension = ""BPDPARAMETER"";
	//string SubPlan = ""Subplan Parameter"";
	string AccountDimension = ""BPDACCOUNT"";
	string AccountAssignmentCube = ""BPCCONFIG_MAIN"";
	string NA = ""N.A."";
	// all versions
	
	StringArray accountArray = CreateStringArray();
	Append(accountArray, """");
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension,""TOTAL_ACCOUNT"" , true);
	StringList baseAccountsHelp = ToStringList(baseAccounts);

	foreach(string accountElement in baseAccountsHelp )
	{
		Append(accountArray, accountElement);
	}
	StringList accountStringList = ToStringList(accountArray);

	StringArray parameterArray = CreateStringArray();
	Append(parameterArray, """");

	OLAPElementList parameterlist = OLAPGetChildElementList(connection, ParameterDimension, subplan, false);
	StringList baseparameterHelp = ToStringList(parameterlist);

	foreach(string parameterElement in baseparameterHelp )
	{
		Append(parameterArray, parameterElement);
	}
	StringList parameterStringList = ToStringList(parameterArray);
	

	OLAPDataArea targetArea = OLAPCreateDataArea(connection, AccountAssignmentCube,
	                                             OlapDataAreaIncludeB |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                             targetCycle,NA, NA, NA, baseAccounts, NA, parameterStringList , ""Value"");
	OLAPDeleteDataArea(targetArea);
	OLAPDataArea sourceArea = OLAPCreateDataArea(connection, AccountAssignmentCube,
	                                             OlapDataAreaIncludeB |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                             sourceCycle,NA, NA, NA, baseAccounts, NA, parameterStringList , ""Value"");

	
	foreach (OLAPCell cell in sourceArea)
	{
		string account = OLAPCellGetElement(cell, AccountDimension);
		string subplanElement = OLAPCellGetElement(cell, ParameterDimension);
		
		OLAPCellWriteNumber(connection, AccountAssignmentCube, 1.0, targetCycle, NA, NA, NA, account, NA, subplanElement, ""Value"");
	}




	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopySubPlanAccountMapping(string database, string ticket, string sourceCycle, string targetCycle, string subplan)
@Description: ""Copies the subplan account mapping configuration from one Configuration Set to the other"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[subplan]: ""Subplan, used for copy action."";
@Parameter[sourceCycle]: ""Source Configuration Set for copy action"";
@Parameter[targetCycle]: ""Target Configuration Set for copy action"";
@Returns: ""Place the return value description here"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	
	subplan = ""[BPDPARAMETER].[SUBPLAN_SALES].[1]"";
	sourceCycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	targetCycle = ""[BPDCYCLE].[CYCLE_007].[1]"";*/

	
	sourceCycle = ResolveUniqueName(connection, sourceCycle);
	targetCycle = ResolveUniqueName(connection, targetCycle);
	subplan = ResolveUniqueName(connection, subplan);

	
	//static strings
	string ParameterDimension = ""BPDPARAMETER"";
	//string SubPlan = ""Subplan Parameter"";
	string AccountDimension = ""BPDACCOUNT"";
	string AccountAssignmentCube = ""BPCCONFIG_MAIN"";
	string NA = ""N.A."";
	// all versions
	
	StringArray accountArray = CreateStringArray();
	Append(accountArray, """");
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension,""TOTAL_ACCOUNT"" , true);
	StringList baseAccountsHelp = ToStringList(baseAccounts);

	foreach(string accountElement in baseAccountsHelp )
	{
		Append(accountArray, accountElement);
	}
	StringList accountStringList = ToStringList(accountArray);

	StringArray parameterArray = CreateStringArray();
	Append(parameterArray, """");

	OLAPElementList parameterlist = OLAPGetChildElementList(connection, ParameterDimension, subplan, false);
	StringList baseparameterHelp = ToStringList(parameterlist);

	foreach(string parameterElement in baseparameterHelp )
	{
		Append(parameterArray, parameterElement);
	}
	StringList parameterStringList = ToStringList(parameterArray);
	

	OLAPDataArea targetArea = OLAPCreateDataArea(connection, AccountAssignmentCube,
	                                             OlapDataAreaIncludeB |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                             targetCycle,NA, NA, NA, baseAccounts, NA, parameterStringList , ""Value"");
	OLAPDeleteDataArea(targetArea);
	OLAPDataArea sourceArea = OLAPCreateDataArea(connection, AccountAssignmentCube,
	                                             OlapDataAreaIncludeB |  OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                             sourceCycle,NA, NA, NA, baseAccounts, NA, parameterStringList , ""Value"");

	
	foreach (OLAPCell cell in sourceArea)
	{
		string account = OLAPCellGetElement(cell, AccountDimension);
		string subplanElement = OLAPCellGetElement(cell, ParameterDimension);
		
		OLAPCellWriteNumber(connection, AccountAssignmentCube, 1.0, targetCycle, NA, NA, NA, account, NA, subplanElement, ""Value"");
	}




	return true;
}"	1	3F7A23A1-EB62-4D14-B485-13C7DA185CEE	Copies the subplan account mapping configuration from one Configuration Set to the other	1	1	1	1567	NULL	0	45708.67504	0	0
7A34C96B-8D1C-4673-B082-4353DE77C155	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyTotalVersion	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True if copy successful, false if OverwriteTarget is false and there are existing data in the target"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version from which to copy"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version to copy to"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity that should be copied (can be a base or an aggregated element)"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""OverwriteTarget"" parameter-type=""bool"" parameter-description=""Flag that determines if the user wants to overwrite target"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPCopyTotalVersion(string database, string ticket, string cycle, string sourceVersion, string targetVersion, string entity, bool OverwriteTarget )
@Description: ""This process copies a complete version of a Configuration Set to another version"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceVersion]: ""The source version from which to copy"";
@Parameter[targetVersion]: ""The target version to copy to"";
@Parameter[entity]: ""The entity that should be copied (can be a base or an aggregated element)"";
@Parameter[OverwriteTarget]: ""Flag that determines if the user wants to overwrite target"";
@Returns: ""True if copy successful, false if OverwriteTarget is false and there are existing data in the target"";
{

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	cycle = ResolveUniqueName(connection, cycle);
	sourceVersion = ResolveUniqueName(connection, sourceVersion);
	targetVersion = ResolveUniqueName(connection, targetVersion);
	entity = ResolveUniqueName(connection, entity);

	string primarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDPSEGMENT""));
	string secondarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDSSEGMENT""));
	string tertiarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDTSEGMENT""));
	string detailTotal = ToString(BP_GetTopElement(connection, ""BPDDETAIL""));
	string analysis1Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9Total= ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	string stepTotal = ToString(BP_GetTopElement(connection, ""BPDSTEP""));

	string MainCube = ""BPCMAIN"";
	string EntityDimension = ""BPDENTITY"";
	string NA = ""N.A."";

	OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension, entity);
	bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);
	
	if (OverwriteTarget)
	{
		if (baseEntityElement)
		{
			OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, targetVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			OLAPDeleteDataArea(targetData);

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

			foreach(OLAPCell cell in sourceData)
			{
				string time = OLAPCellGetElement(cell, ""BPDTIME"");
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
				string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string step = OLAPCellGetElement(cell, ""BPDSTEP"");
				double value = cell;

				OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			}
		}
		else
		{
			OLAPElementList baseEntities = OLAPGetChildElementList(connection, EntityDimension, entity, true);

			OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, targetVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			OLAPDeleteDataArea(targetData);

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

			foreach(OLAPCell cell in sourceData)
			{
				string time = OLAPCellGetElement(cell, ""BPDTIME"");
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
				string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string step = OLAPCellGetElement(cell, ""BPDSTEP"");
				double value = cell;

				OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			}
		}
	}
	else
	{

		double checkValues = OLAPCellReadNumber(connection, MainCube, 1.0, ""TOTAL_TIME"", cycle, targetVersion,""TOTAL_LEVEL"", ""TOTAL_STEP"", entity, ""TOTAL_PARTNER"", ""TOTAL_ORGANIZATION"",""TOTAL_ACCOUNT"", ""TOTAL_CURRENCY"", detailTotal, primarySegmentTotal, secondarySegmentTotal, tertiarySegmentTotal, analysis1Total,analysis2Total,analysis3Total,analysis4Total,analysis5Total,analysis6Total,analysis7Total,analysis8Total,analysis9Total,analysis10Total,analysis11Total,analysis12Total);
		if (checkValues != 0)
		{
			return false;
		}
		else
		{

			if (baseEntityElement)
			{


				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach(OLAPCell cell in sourceData)
				{
					string time = OLAPCellGetElement(cell, ""BPDTIME"");
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
			else
			{
				OLAPElementList baseEntities = OLAPGetChildElementList(connection, EntityDimension, entity, true);


				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach(OLAPCell cell in sourceData)
				{
					string time = OLAPCellGetElement(cell, ""BPDTIME"");
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
		}
	}
	OLAPCommitCellWriteBuffer(buffer);
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPCopyTotalVersion(string database, string ticket, string cycle, string sourceVersion, string targetVersion, string entity, bool OverwriteTarget )
@Description: ""This process copies a complete version of a Configuration Set to another version"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceVersion]: ""The source version from which to copy"";
@Parameter[targetVersion]: ""The target version to copy to"";
@Parameter[entity]: ""The entity that should be copied (can be a base or an aggregated element)"";
@Parameter[OverwriteTarget]: ""Flag that determines if the user wants to overwrite target"";
@Returns: ""True if copy successful, false if OverwriteTarget is false and there are existing data in the target"";
{

	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);

	cycle = ResolveUniqueName(connection, cycle);
	sourceVersion = ResolveUniqueName(connection, sourceVersion);
	targetVersion = ResolveUniqueName(connection, targetVersion);
	entity = ResolveUniqueName(connection, entity);

	string primarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDPSEGMENT""));
	string secondarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDSSEGMENT""));
	string tertiarySegmentTotal = ToString(BP_GetTopElement(connection, ""BPDTSEGMENT""));
	string detailTotal = ToString(BP_GetTopElement(connection, ""BPDDETAIL""));
	string analysis1Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9Total= ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12Total = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	string stepTotal = ToString(BP_GetTopElement(connection, ""BPDSTEP""));

	string MainCube = ""BPCMAIN"";
	string EntityDimension = ""BPDENTITY"";
	string NA = ""N.A."";

	OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension, entity);
	bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);
	
	if (OverwriteTarget)
	{
		if (baseEntityElement)
		{
			OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, targetVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			OLAPDeleteDataArea(targetData);

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

			foreach(OLAPCell cell in sourceData)
			{
				string time = OLAPCellGetElement(cell, ""BPDTIME"");
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
				string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string step = OLAPCellGetElement(cell, ""BPDSTEP"");
				double value = cell;

				OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			}
		}
		else
		{
			OLAPElementList baseEntities = OLAPGetChildElementList(connection, EntityDimension, entity, true);

			OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, targetVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			OLAPDeleteDataArea(targetData);

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

			foreach(OLAPCell cell in sourceData)
			{
				string time = OLAPCellGetElement(cell, ""BPDTIME"");
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
				string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string step = OLAPCellGetElement(cell, ""BPDSTEP"");
				double value = cell;

				OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			}
		}
	}
	else
	{

		double checkValues = OLAPCellReadNumber(connection, MainCube, 1.0, ""TOTAL_TIME"", cycle, targetVersion,""TOTAL_LEVEL"", ""TOTAL_STEP"", entity, ""TOTAL_PARTNER"", ""TOTAL_ORGANIZATION"",""TOTAL_ACCOUNT"", ""TOTAL_CURRENCY"", detailTotal, primarySegmentTotal, secondarySegmentTotal, tertiarySegmentTotal, analysis1Total,analysis2Total,analysis3Total,analysis4Total,analysis5Total,analysis6Total,analysis7Total,analysis8Total,analysis9Total,analysis10Total,analysis11Total,analysis12Total);
		if (checkValues != 0)
		{
			return false;
		}
		else
		{

			if (baseEntityElement)
			{


				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach(OLAPCell cell in sourceData)
				{
					string time = OLAPCellGetElement(cell, ""BPDTIME"");
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
			else
			{
				OLAPElementList baseEntities = OLAPGetChildElementList(connection, EntityDimension, entity, true);


				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells, cycle, sourceVersion,OlapDataAreaBCells,OlapDataAreaBCells, baseEntities, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach(OLAPCell cell in sourceData)
				{
					string time = OLAPCellGetElement(cell, ""BPDTIME"");
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					string currency = OLAPCellGetElement(cell, ""BPDCURRENCY"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;

					OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, time, cycle, targetVersion,level, step, entity, intercompany, organization, account,currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
		}
	}
	OLAPCommitCellWriteBuffer(buffer);
	return true;
}"	1	E1B7E2D7-C0E0-42DA-9CD1-9629BA276449	This process copies a complete version of a Configuration Set to another version	1	1	1	1568	NULL	0	45708.67507	0	0
7B563451-D9DC-47A7-9056-3643E8FEAEF1	CD491758-D9DF-4002-94C8-8006E1855F86	BAPCopyVersionConfiguration	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The source Version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""TargetVersionUN"" parameter-type=""string"" parameter-description=""The target Version element to be used."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyVersionConfiguration(string Database, string Ticket, string CycleUN, string SourceVersionUN, string TargetVersionUN)
@Description: ""Copies Entity and Segment configuration from one version to another "";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source Version element to be used."";
@Parameter[TargetVersionUN]: ""The target Version element to be used."";
@Returns: ""True, if successful."";

{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	SourceVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
	TargetVersionUN = ""[BPDVERSION].[BUDGET_05].[1]"";*/


	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);

	string MainConfigurationCube = ""BPCCONFIG_MAIN"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string EntitySegmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";

	StringList slCycle = ConvertToStringList(Cycle);
	StringList sltargetVersion = ConvertToStringList(TargetVersion);
	StringList slEntity = ConvertToStringList(OlapDataAreaBCells);
	StringList slOrganization = ConvertToStringList(OlapDataAreaBCells);
	StringList slIntercompany = ConvertToStringList(OlapDataAreaBCells);
	StringList slAccount = ConvertToStringList(OlapDataAreaBCells);
	StringList slNO = ConvertToStringList(OlapDataAreaBCells);
	StringList slParameter = ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE"");
	StringList slLanguage = ConvertToStringList(OlapDataAreaBCells);
	StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);



	//   copying dataa in Cube = ""BPCCONFIG_MAIN"";

	OLAPDataArea TargetData = OLAPCreateDataArea(connection, MainConfigurationCube ,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             Cycle,TargetVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""SUBPLAN_FINANCE_ACC_ACTIVE"", OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, MainConfigurationCube ,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             Cycle,SourceVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""SUBPLAN_FINANCE_ACC_ACTIVE"", OlapDataAreaBCells);


	StringListList targetElementsBM = CreateStringListList();
	
	Append(targetElementsBM, slCycle);
	Append(targetElementsBM, sltargetVersion);
	Append(targetElementsBM, slEntity);
	Append(targetElementsBM, slOrganization);
	Append(targetElementsBM, slAccount);
	Append(targetElementsBM, slNO);
	Append(targetElementsBM, slParameter);
	Append(targetElementsBM, slLanguage);

	StringListList sourceElementsBM = CreateStringListList();
	StringList slSourceVersion = ConvertToStringList(SourceVersion);
	Append(sourceElementsBM, slCycle);
	Append(sourceElementsBM, slSourceVersion);
	Append(sourceElementsBM, slEntity);
	Append(sourceElementsBM, slOrganization);
	Append(sourceElementsBM, slAccount);
	Append(sourceElementsBM, slNO);
	Append(sourceElementsBM, slParameter);
	Append(sourceElementsBM, slLanguage);


	OLAPCopyDataArea(SourceData, MainConfigurationCube, ""Relative"", 1.0, targetElementsBM, sourceElementsBM, true, true);


	//   copying dataa in Cube = ""BPCCONFIG_ENTITY"";
	slParameter = ConvertToStringList(OlapDataAreaBCells);

	TargetData = OLAPCreateDataArea(connection, EntityConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,TargetVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	SourceData = OLAPCreateDataArea(connection, EntityConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,SourceVersion, OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells);

	StringListList targetElementsBE = CreateStringListList();
	Append(targetElementsBE, slCycle);
	Append(targetElementsBE, sltargetVersion);
	Append(targetElementsBE, slEntity);
	Append(targetElementsBE, slIntercompany);
	Append(targetElementsBE, slOrganization);
	Append(targetElementsBE, slParameter);

	StringListList sourceElementsBE = CreateStringListList();
	Append(sourceElementsBE, slCycle);
	Append(sourceElementsBE, slSourceVersion);
	Append(sourceElementsBE, slEntity);
	Append(sourceElementsBE, slIntercompany);
	Append(sourceElementsBE, slOrganization);
	Append(sourceElementsBE, slParameter);


	OLAPCopyDataArea(SourceData, EntityConfigurationCube, ""Relative"", 1.0, targetElementsBE, sourceElementsBE, true, true);


	//   copying dataa in Cube = ""BPCCONFIG_ENTITY_SEGMENT"";

	TargetData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	SourceData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,SourceVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


	StringListList targetElementsBES = CreateStringListList();
	Append(targetElementsBES, slCycle);
	Append(targetElementsBES, sltargetVersion);
	Append(targetElementsBES, slEntity);
	Append(targetElementsBES, slPSegment);
	Append(targetElementsBES, slSSegment);
	Append(targetElementsBES, slTSegment);
	Append(targetElementsBES, slParameter);

	StringListList sourceElementsBES = CreateStringListList();
	Append(sourceElementsBES, slCycle);
	Append(sourceElementsBES, slSourceVersion);
	Append(sourceElementsBES, slEntity);
	Append(sourceElementsBES, slPSegment);
	Append(sourceElementsBES, slSSegment);
	Append(sourceElementsBES, slTSegment);
	Append(sourceElementsBES, slParameter);

	OLAPCopyDataArea(SourceData, EntitySegmentConfigurationCube, ""Relative"", 1.0, targetElementsBES, sourceElementsBES, true, true);


	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPCopyVersionConfiguration(string Database, string Ticket, string CycleUN, string SourceVersionUN, string TargetVersionUN)
@Description: ""Copies Entity and Segment configuration from one version to another "";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source Version element to be used."";
@Parameter[TargetVersionUN]: ""The target Version element to be used."";
@Returns: ""True, if successful."";

{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
	SourceVersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
	TargetVersionUN = ""[BPDVERSION].[BUDGET_05].[1]"";*/


	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	string TargetVersion = ResolveUniqueName(connection, TargetVersionUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);

	string MainConfigurationCube = ""BPCCONFIG_MAIN"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string EntitySegmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";

	StringList slCycle = ConvertToStringList(Cycle);
	StringList sltargetVersion = ConvertToStringList(TargetVersion);
	StringList slEntity = ConvertToStringList(OlapDataAreaBCells);
	StringList slOrganization = ConvertToStringList(OlapDataAreaBCells);
	StringList slIntercompany = ConvertToStringList(OlapDataAreaBCells);
	StringList slAccount = ConvertToStringList(OlapDataAreaBCells);
	StringList slNO = ConvertToStringList(OlapDataAreaBCells);
	StringList slParameter = ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE"");
	StringList slLanguage = ConvertToStringList(OlapDataAreaBCells);
	StringList slPSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slSSegment = ConvertToStringList(OlapDataAreaBCells);
	StringList slTSegment = ConvertToStringList(OlapDataAreaBCells);



	//   copying dataa in Cube = ""BPCCONFIG_MAIN"";

	OLAPDataArea TargetData = OLAPCreateDataArea(connection, MainConfigurationCube ,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             Cycle,TargetVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""SUBPLAN_FINANCE_ACC_ACTIVE"", OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	OLAPDataArea SourceData = OLAPCreateDataArea(connection, MainConfigurationCube ,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             Cycle,SourceVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""SUBPLAN_FINANCE_ACC_ACTIVE"", OlapDataAreaBCells);


	StringListList targetElementsBM = CreateStringListList();
	
	Append(targetElementsBM, slCycle);
	Append(targetElementsBM, sltargetVersion);
	Append(targetElementsBM, slEntity);
	Append(targetElementsBM, slOrganization);
	Append(targetElementsBM, slAccount);
	Append(targetElementsBM, slNO);
	Append(targetElementsBM, slParameter);
	Append(targetElementsBM, slLanguage);

	StringListList sourceElementsBM = CreateStringListList();
	StringList slSourceVersion = ConvertToStringList(SourceVersion);
	Append(sourceElementsBM, slCycle);
	Append(sourceElementsBM, slSourceVersion);
	Append(sourceElementsBM, slEntity);
	Append(sourceElementsBM, slOrganization);
	Append(sourceElementsBM, slAccount);
	Append(sourceElementsBM, slNO);
	Append(sourceElementsBM, slParameter);
	Append(sourceElementsBM, slLanguage);


	OLAPCopyDataArea(SourceData, MainConfigurationCube, ""Relative"", 1.0, targetElementsBM, sourceElementsBM, true, true);


	//   copying dataa in Cube = ""BPCCONFIG_ENTITY"";
	slParameter = ConvertToStringList(OlapDataAreaBCells);

	TargetData = OLAPCreateDataArea(connection, EntityConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,TargetVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	SourceData = OLAPCreateDataArea(connection, EntityConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,SourceVersion, OlapDataAreaBCells,OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells);

	StringListList targetElementsBE = CreateStringListList();
	Append(targetElementsBE, slCycle);
	Append(targetElementsBE, sltargetVersion);
	Append(targetElementsBE, slEntity);
	Append(targetElementsBE, slIntercompany);
	Append(targetElementsBE, slOrganization);
	Append(targetElementsBE, slParameter);

	StringListList sourceElementsBE = CreateStringListList();
	Append(sourceElementsBE, slCycle);
	Append(sourceElementsBE, slSourceVersion);
	Append(sourceElementsBE, slEntity);
	Append(sourceElementsBE, slIntercompany);
	Append(sourceElementsBE, slOrganization);
	Append(sourceElementsBE, slParameter);


	OLAPCopyDataArea(SourceData, EntityConfigurationCube, ""Relative"", 1.0, targetElementsBE, sourceElementsBE, true, true);


	//   copying dataa in Cube = ""BPCCONFIG_ENTITY_SEGMENT"";

	TargetData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle, TargetVersion,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	
	SourceData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
	                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                OlapDataAreaOperatorNone, 0.0,
	                                Cycle,SourceVersion, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


	StringListList targetElementsBES = CreateStringListList();
	Append(targetElementsBES, slCycle);
	Append(targetElementsBES, sltargetVersion);
	Append(targetElementsBES, slEntity);
	Append(targetElementsBES, slPSegment);
	Append(targetElementsBES, slSSegment);
	Append(targetElementsBES, slTSegment);
	Append(targetElementsBES, slParameter);

	StringListList sourceElementsBES = CreateStringListList();
	Append(sourceElementsBES, slCycle);
	Append(sourceElementsBES, slSourceVersion);
	Append(sourceElementsBES, slEntity);
	Append(sourceElementsBES, slPSegment);
	Append(sourceElementsBES, slSSegment);
	Append(sourceElementsBES, slTSegment);
	Append(sourceElementsBES, slParameter);

	OLAPCopyDataArea(SourceData, EntitySegmentConfigurationCube, ""Relative"", 1.0, targetElementsBES, sourceElementsBES, true, true);


	return true;
}"	1	53AB8A1F-44E3-402D-AB3A-973A28D65404	Copies Entity and Segment configuration from one version to another	1	1	1	1569	NULL	0	45708.67502	0	0
21C51DE9-B28B-4F90-AF4C-8D74FE3ABA89	CD491758-D9DF-4002-94C8-8006E1855F86	BAPDeleteAccountAssigmentToStep	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful, otherwise false"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSetUN"" parameter-type=""string"" parameter-description=""The Configuration Set element UN to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""accountUN"" parameter-type=""string"" parameter-description=""The account element UN to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""pnoUN"" parameter-type=""string"" parameter-description=""The planning step(PNO) element UN to be used."" parameter-order=""3"" />
  <dependencies>
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""

string BAPDeleteAccountAssigmentToStep(string server, string configurationSetUN,string accountUN, string pnoUN)
@Description: ""Process for deletion of account assigments for planning step, except version NA and organization NA combination"";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSetUN]: ""The Configuration Set element UN to be used."";
@Parameter[accountUN]: ""The account element UN to be used."";
@Parameter[pnoUN]: ""The planning step(PNO) element UN to be used."";
@Returns: ""True, if successful, otherwise false"";
{
	string functionName = ""BAPDeleteAccountAssigmentToStep:"";
	string errorMessage = """";
	string hierarchy= """";
	int errorCode = 0;
	string mainConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string accountDimension = ""BPDACCOUNT"";
	string versionDimension = ""BPDVERSION"";
	string NA = ""N.A."";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSetUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		accountUN = ""[BPDACCOUNT].[A110000].[1]"";
		pnoUN = ""[BPDNO].[PNO_001].[1]"";*/

		string configurationSet = ResolveUniqueName(connection, configurationSetUN);
		string account = ResolveUniqueName(connection, accountUN);
		string pno = ResolveUniqueName(connection, pnoUN);


		StringList accountStringList = BP_GetChildStringListOrItself(connection, accountDimension, account,true,true);
		OLAPElementList entityOList = OLAPGetElementList(connection, entityDimension, true);
		StringList  enStringList = CreateStringList();
		Append(enStringList, """");
		foreach(OLAPElement e in entityOList)
		{
			string eString =ToString(e);
			if(eString != NA)
			{
				Append(enStringList ,eString);
			}
		}
		OLAPElementList versionOList = OLAPGetElementList(connection, versionDimension, true);
		StringList  verStringList = CreateStringList();
		Append(verStringList, """");
		foreach(OLAPElement v in versionOList)
		{
			string vString =ToString(v);
			if(vString != NA)
			{
				Append(verStringList ,vString);
			}
		}


		OLAPDataArea bpcMainDataArea = OLAPCreateDataArea(connection, mainConfigurationCube,
		                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                  OlapDataAreaOperatorNone, 0.0,
		                                                  configurationSet, verStringList, enStringList, OlapDataAreaBCells, accountStringList, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(bpcMainDataArea);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""

string BAPDeleteAccountAssigmentToStep(string server, string configurationSetUN,string accountUN, string pnoUN)
@Description: ""Process for deletion of account assigments for planning step, except version NA and organization NA combination"";
@Category: ""Budgeting and Planning"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSetUN]: ""The Configuration Set element UN to be used."";
@Parameter[accountUN]: ""The account element UN to be used."";
@Parameter[pnoUN]: ""The planning step(PNO) element UN to be used."";
@Returns: ""True, if successful, otherwise false"";
{
	string functionName = ""BAPDeleteAccountAssigmentToStep:"";
	string errorMessage = """";
	string hierarchy= """";
	int errorCode = 0;
	string mainConfigurationCube = ""BPCCONFIG_MAIN"";
	string entityDimension = ""BPDENTITY"";
	string accountDimension = ""BPDACCOUNT"";
	string versionDimension = ""BPDVERSION"";
	string NA = ""N.A."";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSetUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		accountUN = ""[BPDACCOUNT].[A110000].[1]"";
		pnoUN = ""[BPDNO].[PNO_001].[1]"";*/

		string configurationSet = ResolveUniqueName(connection, configurationSetUN);
		string account = ResolveUniqueName(connection, accountUN);
		string pno = ResolveUniqueName(connection, pnoUN);


		StringList accountStringList = BP_GetChildStringListOrItself(connection, accountDimension, account,true,true);
		OLAPElementList entityOList = OLAPGetElementList(connection, entityDimension, true);
		StringList  enStringList = CreateStringList();
		Append(enStringList, """");
		foreach(OLAPElement e in entityOList)
		{
			string eString =ToString(e);
			if(eString != NA)
			{
				Append(enStringList ,eString);
			}
		}
		OLAPElementList versionOList = OLAPGetElementList(connection, versionDimension, true);
		StringList  verStringList = CreateStringList();
		Append(verStringList, """");
		foreach(OLAPElement v in versionOList)
		{
			string vString =ToString(v);
			if(vString != NA)
			{
				Append(verStringList ,vString);
			}
		}


		OLAPDataArea bpcMainDataArea = OLAPCreateDataArea(connection, mainConfigurationCube,
		                                                  OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                  OlapDataAreaOperatorNone, 0.0,
		                                                  configurationSet, verStringList, enStringList, OlapDataAreaBCells, accountStringList, pno, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"");

		OLAPDeleteDataArea(bpcMainDataArea);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	0BB28554-B9F5-4061-926B-4425B1227CDC	Process for deletion of account assigments for planning step, except version NA and organization NA combination	1	1	1	1570	NULL	0	45708.67502	0	0
CFBF3A36-D9F8-499C-B1C3-54DFECC834FD	CD491758-D9DF-4002-94C8-8006E1855F86	BAPDeletePlannigStepData	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True if copy successful, false otherwise"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""pno"" parameter-type=""string"" parameter-description=""The pno element to be used"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""level"" parameter-type=""string"" parameter-description=""The level element to be used"" parameter-order=""5"" />
  <dependencies>
    <process process-name=""BAPFinance_AssumptionsAll"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""BAPFinance_AssumptionsAll"", ""*""

string BAPDeletePlannigStepData(string database, string cycle, string version, string entity, string pno, string level )
@Description: ""Process for wipe out data and commnets related to planning step"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used"";
@Parameter[entity]: ""The entity element to be used"";
@Parameter[pno]: ""The pno element to be used"";
@Parameter[level]: ""The level element to be used"";
@Returns: ""True if copy successful, false otherwise"";
{
	string functionName = ""BAPDeletePlannigStepData:"";
	string MainCube = ""BPCMAIN"";
	string trackingCube = ""WFCTRACKING"";
	string configCube = ""BPCCONFIG_MAIN"";
	string dataAccountCube = ""ATCDATA_ACCOUNT"";
	string dataDetailCube = ""ATCDATA_DETAIL"";
	string assetCategoryConfigCube = ""CPCCONFIG_ASSETCATEGORY"";
	string EntityDimension = ""BPDENTITY"";
	string AccountDimension =""BPDACCOUNT"";
	string stepDimension =""BPDSTEP"";
	string detailDimension =""BPDDETAIL"";
	string OrganizationDimension =""BPDORGANIZATION"";
	string NA = ""N.A."";
	string processName = """";
	string result = ""false"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0002].[1]"";
		level = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		pno = ""[BPDNO].[PNO_001].[1]"";*/
		
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		pno = ResolveUniqueName(connection, pno);
		level = ResolveUniqueName(connection, level);
		// define list of organizations due to level
		StringList orgList = CreateStringList();
		string levelFofCellNotes = """";
		Append(orgList,"""");
		if(level == ""INPUT_MAIN"")
		{
			Append(orgList,NA);
			levelFofCellNotes = ""TOTAL_INPUT"";
		}
		else
		{
			levelFofCellNotes = ""TOTAL_INPUT_ORGANIZATION"";
			OLAPElementList orgOList = OLAPGetElementList(connection,OrganizationDimension,true);
			foreach(OLAPElement o in orgOList)
			{
				string oStr = ToString(o);

				if(oStr != NA)
				{
					Append(orgList,oStr);
				}
			}
		}
		// define all step exept BASE_STEP
		StringList stepList = CreateStringList();
		Append(stepList,"""");
		OLAPElementList stepOList = OLAPGetElementList(connection,stepDimension,true);
		foreach(OLAPElement s in stepOList)
		{
			string sStr = ToString(s);
			if(sStr != ""BASE_STEP"")
			{
				Append(stepList,sStr);
			}
		}

		// get account list from definition of planning step
		string topAccount = OLAPCellReadString(connection, configCube, cycle, NA, NA, NA, NA, pno, ""SUBPLAN_FINANCE_TOPELEMENT"",""Text Value"");
		StringArray topAccounts = CF_ElementStringSplit(topAccount);
		StringArray accountsArray = CreateStringArray();
		StringArray accountsArrayForCellNotes = CreateStringArray();
		Append(accountsArray, """");
		foreach(string tA in topAccounts)
		{
			string accInLoop = ResolveUniqueName(connection, tA);
			Append(accountsArray, accInLoop);
			Append(accountsArrayForCellNotes, accInLoop);
			OLAPElement oElement = OLAPGetDimensionElement(connection, AccountDimension, accInLoop);
			bool baseElement = OLAPIsBaseElement(connection, oElement);
			if(baseElement)
			{
				Append(accountsArray, accInLoop);
				Append(accountsArrayForCellNotes, accInLoop);
			}
			else
			{
				OLAPElementList oList = OLAPGetChildElementList(connection, AccountDimension, accInLoop, false);
				StringList stringListHelp = ToStringList(oList);
				foreach(string oHelpElement in stringListHelp )
				{
					Append(accountsArray, oHelpElement);
					Append(accountsArrayForCellNotes, oHelpElement);
				}
			}
		}
		StringList accountsStringList = ToStringList(accountsArray);
		StringList accountsStringListForCellNotes = ToStringList(accountsArrayForCellNotes);
		//get attachement XML from FEATURE_WF_TRACKING_ATTACHMENT parametet and data account cube
		StringArray AttachmentsACData = CreateStringArray();

		OLAPDataArea dataAreaAtcAccountAttachem = OLAPCreateDataArea(connection, dataAccountCube,
		                                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                             OlapDataAreaOperatorNone, 0.0,
		                                                             cycle, version,  orgList,entity,level, stepList, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,""FEATURE_WF_TRACKING_ATTACHMENT"", accountsStringList, OlapDataAreaBCells);
		foreach(OLAPCell cell in dataAreaAtcAccountAttachem)
		{
			string xml = cell;
			Append(AttachmentsACData,xml);
		}
		foreach(string xmlin in AttachmentsACData)
		{
			XMLDocument docIn =  XMLParseDocument(xmlin);
			XMLElement tableIn = XMLGetRootElement(docIn);
			XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
			foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property""))
			{
				string propName = XMLGetAttributeValue(prop,""name"");
				string propValue = XMLGetAttributeValue(prop,""value"");

				if(propName == ""Address"")
				{
					string attachment = propValue;
					RepositoryDeleteFile(rc,attachment);
				}
			}
		}

		StringList parametersListAcData= CreateStringList();
		Append(parametersListAcData,"""");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_COMMENT"");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_ATTACHMENT"");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_COMMENT_CHANGED_ON"");
		Append(parametersListAcData,""FEATURE_WF_DEFINITION_MANDATORY_COMMENTS"");
		//delete all info connected to comments from ATCDATA_ACCOUNT
		OLAPDataArea dataAreaAtcAccount = OLAPCreateDataArea(connection, dataAccountCube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     cycle, version,  orgList,entity,level, stepList, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAcData, accountsStringList, OlapDataAreaBCells);

		OLAPDeleteDataArea(dataAreaAtcAccount);
		//get attachement XML from FEATURE_WF_TRACKING_ATTACHMENT parameter and WFCTRACKING cube
		StringArray AttachmentsWFData = CreateStringArray();
		string pnoComposite = OLAPCreateCompositeName(""WORKFLOW"", pno);
		OLAPDataArea dataAreaWFtAttachem = OLAPCreateDataArea(connection, trackingCube,
		                                                      OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                      OlapDataAreaOperatorNone, 0.0,
		                                                      cycle, version, entity,orgList,OlapDataAreaBCells,OlapDataAreaBCells,pnoComposite,stepList,NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,""FEATURE_WF_TRACKING_ATTACHMENT"");
		foreach(OLAPCell cell in dataAreaWFtAttachem)
		{
			string xml = cell;
			Append(AttachmentsWFData,xml);
		}

		foreach(string xmlin in AttachmentsWFData)
		{
			XMLDocument docIn =  XMLParseDocument(xmlin);
			XMLElement tableIn = XMLGetRootElement(docIn);
			XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
			foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property""))
			{
				string propName = XMLGetAttributeValue(prop,""name"");
				string propValue = XMLGetAttributeValue(prop,""value"");

				if(propName == ""Address"")
				{
					string attachment = propValue;
					RepositoryDeleteFile(rc,attachment);
				}
			}
		}
		//delete all info connected to comments from WFCTRACKING
		OLAPDataArea wfData = OLAPCreateDataArea(connection, trackingCube,
		                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                         OlapDataAreaOperatorNone, 0.0,
		                                         cycle, version, entity,orgList,OlapDataAreaBCells,OlapDataAreaBCells,pnoComposite,stepList, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAcData);

		OLAPDeleteDataArea(wfData);

		//delete all data connected to BPCMAIN and given level
		OLAPDataArea sourceDataMainCube = OLAPCreateDataArea(connection, MainCube,
		                                                     OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaBCells,cycle, version,level, stepList, entity,OlapDataAreaBCells, orgList,  accountsStringList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(sourceDataMainCube);

		StringList detailHierarchies = OLAPGetHierarchies(connection,detailDimension);
		foreach(string hie in detailHierarchies)
		{
			if(StringContains(hie,""TOTAL_DETAIL""))
			{
				OLAPElementList elementlist = OLAPGetElementList(connection, detailDimension, hie, true, false, false);
				StringList detElements = CreateStringList();
				Append(detElements, """");
				foreach(OLAPElement o in elementlist)
				{
					string Composite = OLAPCreateCompositeName(hie, ToString(o));
					Append(detElements, Composite);
				}

				OLAPDataArea sourceDataMainCubeHie = OLAPCreateDataArea(connection, MainCube,
				                                                        OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                        OlapDataAreaBCells,cycle, version,level, stepList, entity,OlapDataAreaBCells, orgList, accountsStringList, OlapDataAreaBCells, detElements, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				OLAPDeleteDataArea(sourceDataMainCubeHie);

				OLAPDataArea sourceDataDetailArea = OLAPCreateDataArea(connection, dataDetailCube,
				                                                       OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                       cycle, version,orgList,entity,NA, ""BASE_STEP"", OlapDataAreaBCells,accountsStringList, ""Value"", detElements, ""Detail_Line_Flag"");

				OLAPDeleteDataArea(sourceDataDetailArea);
			}
		}

		// necessary to add function from addin to deleting cell cooments(check parameters) level
		DeleteCellNotes_Internal(connection, cycle, version, entity, levelFofCellNotes,accountsStringListForCellNotes);
		//necesssary for recalculation assumptions
		BAPFinance_AssumptionsAll(database, ""[BPDCYCLE].[""+cycle+""].[1]"", ""[BPDVERSION].[""+version+""].[1]"",""[BPDENTITY].[""+entity+""].[1]"");
		result = ""true"";
		return result;
	}
	catch (errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";

	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""BAPFinance_AssumptionsAll"", ""*""

string BAPDeletePlannigStepData(string database, string cycle, string version, string entity, string pno, string level )
@Description: ""Process for wipe out data and commnets related to planning step"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used"";
@Parameter[entity]: ""The entity element to be used"";
@Parameter[pno]: ""The pno element to be used"";
@Parameter[level]: ""The level element to be used"";
@Returns: ""True if copy successful, false otherwise"";
{
	string functionName = ""BAPDeletePlannigStepData:"";
	string MainCube = ""BPCMAIN"";
	string trackingCube = ""WFCTRACKING"";
	string configCube = ""BPCCONFIG_MAIN"";
	string dataAccountCube = ""ATCDATA_ACCOUNT"";
	string dataDetailCube = ""ATCDATA_DETAIL"";
	string assetCategoryConfigCube = ""CPCCONFIG_ASSETCATEGORY"";
	string EntityDimension = ""BPDENTITY"";
	string AccountDimension =""BPDACCOUNT"";
	string stepDimension =""BPDSTEP"";
	string detailDimension =""BPDDETAIL"";
	string OrganizationDimension =""BPDORGANIZATION"";
	string NA = ""N.A."";
	string processName = """";
	string result = ""false"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		RepositoryConnection rc = CreateRepositoryConnectionExisting();
		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0002].[1]"";
		level = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		pno = ""[BPDNO].[PNO_001].[1]"";*/
		
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		pno = ResolveUniqueName(connection, pno);
		level = ResolveUniqueName(connection, level);
		// define list of organizations due to level
		StringList orgList = CreateStringList();
		string levelFofCellNotes = """";
		Append(orgList,"""");
		if(level == ""INPUT_MAIN"")
		{
			Append(orgList,NA);
			levelFofCellNotes = ""TOTAL_INPUT"";
		}
		else
		{
			levelFofCellNotes = ""TOTAL_INPUT_ORGANIZATION"";
			OLAPElementList orgOList = OLAPGetElementList(connection,OrganizationDimension,true);
			foreach(OLAPElement o in orgOList)
			{
				string oStr = ToString(o);

				if(oStr != NA)
				{
					Append(orgList,oStr);
				}
			}
		}
		// define all step exept BASE_STEP
		StringList stepList = CreateStringList();
		Append(stepList,"""");
		OLAPElementList stepOList = OLAPGetElementList(connection,stepDimension,true);
		foreach(OLAPElement s in stepOList)
		{
			string sStr = ToString(s);
			if(sStr != ""BASE_STEP"")
			{
				Append(stepList,sStr);
			}
		}

		// get account list from definition of planning step
		string topAccount = OLAPCellReadString(connection, configCube, cycle, NA, NA, NA, NA, pno, ""SUBPLAN_FINANCE_TOPELEMENT"",""Text Value"");
		StringArray topAccounts = CF_ElementStringSplit(topAccount);
		StringArray accountsArray = CreateStringArray();
		StringArray accountsArrayForCellNotes = CreateStringArray();
		Append(accountsArray, """");
		foreach(string tA in topAccounts)
		{
			string accInLoop = ResolveUniqueName(connection, tA);
			Append(accountsArray, accInLoop);
			Append(accountsArrayForCellNotes, accInLoop);
			OLAPElement oElement = OLAPGetDimensionElement(connection, AccountDimension, accInLoop);
			bool baseElement = OLAPIsBaseElement(connection, oElement);
			if(baseElement)
			{
				Append(accountsArray, accInLoop);
				Append(accountsArrayForCellNotes, accInLoop);
			}
			else
			{
				OLAPElementList oList = OLAPGetChildElementList(connection, AccountDimension, accInLoop, false);
				StringList stringListHelp = ToStringList(oList);
				foreach(string oHelpElement in stringListHelp )
				{
					Append(accountsArray, oHelpElement);
					Append(accountsArrayForCellNotes, oHelpElement);
				}
			}
		}
		StringList accountsStringList = ToStringList(accountsArray);
		StringList accountsStringListForCellNotes = ToStringList(accountsArrayForCellNotes);
		//get attachement XML from FEATURE_WF_TRACKING_ATTACHMENT parametet and data account cube
		StringArray AttachmentsACData = CreateStringArray();

		OLAPDataArea dataAreaAtcAccountAttachem = OLAPCreateDataArea(connection, dataAccountCube,
		                                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                             OlapDataAreaOperatorNone, 0.0,
		                                                             cycle, version,  orgList,entity,level, stepList, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,""FEATURE_WF_TRACKING_ATTACHMENT"", accountsStringList, OlapDataAreaBCells);
		foreach(OLAPCell cell in dataAreaAtcAccountAttachem)
		{
			string xml = cell;
			Append(AttachmentsACData,xml);
		}
		foreach(string xmlin in AttachmentsACData)
		{
			XMLDocument docIn =  XMLParseDocument(xmlin);
			XMLElement tableIn = XMLGetRootElement(docIn);
			XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
			foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property""))
			{
				string propName = XMLGetAttributeValue(prop,""name"");
				string propValue = XMLGetAttributeValue(prop,""value"");

				if(propName == ""Address"")
				{
					string attachment = propValue;
					RepositoryDeleteFile(rc,attachment);
				}
			}
		}

		StringList parametersListAcData= CreateStringList();
		Append(parametersListAcData,"""");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_COMMENT"");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_ATTACHMENT"");
		Append(parametersListAcData,""FEATURE_WF_TRACKING_COMMENT_CHANGED_ON"");
		Append(parametersListAcData,""FEATURE_WF_DEFINITION_MANDATORY_COMMENTS"");
		//delete all info connected to comments from ATCDATA_ACCOUNT
		OLAPDataArea dataAreaAtcAccount = OLAPCreateDataArea(connection, dataAccountCube,
		                                                     OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaOperatorNone, 0.0,
		                                                     cycle, version,  orgList,entity,level, stepList, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAcData, accountsStringList, OlapDataAreaBCells);

		OLAPDeleteDataArea(dataAreaAtcAccount);
		//get attachement XML from FEATURE_WF_TRACKING_ATTACHMENT parameter and WFCTRACKING cube
		StringArray AttachmentsWFData = CreateStringArray();
		string pnoComposite = OLAPCreateCompositeName(""WORKFLOW"", pno);
		OLAPDataArea dataAreaWFtAttachem = OLAPCreateDataArea(connection, trackingCube,
		                                                      OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                      OlapDataAreaOperatorNone, 0.0,
		                                                      cycle, version, entity,orgList,OlapDataAreaBCells,OlapDataAreaBCells,pnoComposite,stepList,NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,""FEATURE_WF_TRACKING_ATTACHMENT"");
		foreach(OLAPCell cell in dataAreaWFtAttachem)
		{
			string xml = cell;
			Append(AttachmentsWFData,xml);
		}

		foreach(string xmlin in AttachmentsWFData)
		{
			XMLDocument docIn =  XMLParseDocument(xmlin);
			XMLElement tableIn = XMLGetRootElement(docIn);
			XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
			foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property""))
			{
				string propName = XMLGetAttributeValue(prop,""name"");
				string propValue = XMLGetAttributeValue(prop,""value"");

				if(propName == ""Address"")
				{
					string attachment = propValue;
					RepositoryDeleteFile(rc,attachment);
				}
			}
		}
		//delete all info connected to comments from WFCTRACKING
		OLAPDataArea wfData = OLAPCreateDataArea(connection, trackingCube,
		                                         OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                         OlapDataAreaOperatorNone, 0.0,
		                                         cycle, version, entity,orgList,OlapDataAreaBCells,OlapDataAreaBCells,pnoComposite,stepList, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,OlapDataAreaBCells, OlapDataAreaBCells,parametersListAcData);

		OLAPDeleteDataArea(wfData);

		//delete all data connected to BPCMAIN and given level
		OLAPDataArea sourceDataMainCube = OLAPCreateDataArea(connection, MainCube,
		                                                     OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                     OlapDataAreaBCells,cycle, version,level, stepList, entity,OlapDataAreaBCells, orgList,  accountsStringList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(sourceDataMainCube);

		StringList detailHierarchies = OLAPGetHierarchies(connection,detailDimension);
		foreach(string hie in detailHierarchies)
		{
			if(StringContains(hie,""TOTAL_DETAIL""))
			{
				OLAPElementList elementlist = OLAPGetElementList(connection, detailDimension, hie, true, false, false);
				StringList detElements = CreateStringList();
				Append(detElements, """");
				foreach(OLAPElement o in elementlist)
				{
					string Composite = OLAPCreateCompositeName(hie, ToString(o));
					Append(detElements, Composite);
				}

				OLAPDataArea sourceDataMainCubeHie = OLAPCreateDataArea(connection, MainCube,
				                                                        OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                        OlapDataAreaBCells,cycle, version,level, stepList, entity,OlapDataAreaBCells, orgList, accountsStringList, OlapDataAreaBCells, detElements, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				OLAPDeleteDataArea(sourceDataMainCubeHie);

				OLAPDataArea sourceDataDetailArea = OLAPCreateDataArea(connection, dataDetailCube,
				                                                       OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                       cycle, version,orgList,entity,NA, ""BASE_STEP"", OlapDataAreaBCells,accountsStringList, ""Value"", detElements, ""Detail_Line_Flag"");

				OLAPDeleteDataArea(sourceDataDetailArea);
			}
		}

		// necessary to add function from addin to deleting cell cooments(check parameters) level
		DeleteCellNotes_Internal(connection, cycle, version, entity, levelFofCellNotes,accountsStringListForCellNotes);
		//necesssary for recalculation assumptions
		BAPFinance_AssumptionsAll(database, ""[BPDCYCLE].[""+cycle+""].[1]"", ""[BPDVERSION].[""+version+""].[1]"",""[BPDENTITY].[""+entity+""].[1]"");
		result = ""true"";
		return result;
	}
	catch (errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";

	}
}"	1	D934A878-2AB5-417D-BC68-88C4FE1D1C42	Process for wipe out data and commnets related to planning step	1	1	1	1571	NULL	0	45708.67508	0	0
6DE3B83B-0B7A-4674-A10E-46954BDA072D	CD491758-D9DF-4002-94C8-8006E1855F86	BAPDeletePremises	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""EntityUN"" parameter-type=""string"" parameter-description=""The Entity element to be used."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPDeletePremises(string Database, string Ticket, string CycleUN, string EntityUN)
@Description: ""Delete Configuration Set / company settings from the cube"";
@Category: ""Budgeting and Planning"";
@Returns: ""True, if successful."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[EntityUN]: ""The Entity element to be used."";

{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string Entity = ResolveUniqueName(connection, EntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string Cube = ""BPCCONFIG_PREMISES"";


	OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaBCells, Cycle,  OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPDeletePremises(string Database, string Ticket, string CycleUN, string EntityUN)
@Description: ""Delete Configuration Set / company settings from the cube"";
@Category: ""Budgeting and Planning"";
@Returns: ""True, if successful."";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[EntityUN]: ""The Entity element to be used."";

{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string Entity = ResolveUniqueName(connection, EntityUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string Cube = ""BPCCONFIG_PREMISES"";


	OLAPDataArea TargetData = OLAPCreateDataArea(connection, Cube,
	                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaBCells, Cycle,  OlapDataAreaBCells, Entity, OlapDataAreaBCells, OlapDataAreaBCells);

	OLAPDeleteDataArea(TargetData);
	

	return true;
}"	1	6EAB8B4F-4B41-419E-8D6D-37A0C4D27A78	Delete Configuration Set / company settings from the cube	1	1	1	1572	NULL	0	45708.67507	0	0
7C4FF2C4-FFD0-41C7-AC49-D63D03F739AA	CD491758-D9DF-4002-94C8-8006E1855F86	BAPDeleteVersion	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""VersionUN"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPDeleteVersion(string Database, string Ticket, string CycleUN, string VersionUN)
@Description: ""Delete version setting for Configuration Set"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[VersionUN]: ""The version element to be used."";
@Returns: ""True, if successful."";

{
	string functionName = ""BAPDeleteVersion: "";
	string errorMessage = """";
	int errorCode = 0;

	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string MainConfigurationCube = ""BPCCONFIG_MAIN"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string EntitySegmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";

	string topVersionElement = ""TOTAL_CONFIGURATION"";
	string topWBVersionElement = ""SUBPLAN_WB_TOTAL_SCENARIO"";
	string versionDimension = ""BPDVERSION"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		/*VersionUN= ""[BPDVERSION].[BUDGET_01].[1]"";
		CycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";*/

		string Version = ResolveUniqueName(connection, VersionUN);
		string Cycle = ResolveUniqueName(connection, CycleUN);
		StringList versions = CreateStringList();
		Append(versions,"""");
		Append(versions,Version);

		OLAPDataArea rerVersionCheckDA = OLAPCreateDataArea(connection, CycleConfigurationCube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    Cycle, OlapDataAreaBCells, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
		foreach(OLAPCell cell in rerVersionCheckDA)
		{
			string ver = OLAPCellGetElement(cell, ""BPDVERSION"");
			if(StringContains(cell,Version))
			{
				Append(versions,ver);
			}
		}

		//deleting cube = ""BPCCONFIG_CYCLE"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, CycleConfigurationCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             Cycle, versions, OlapDataAreaBCells, OlapDataAreaBCells);


		OLAPDeleteDataArea(TargetData);

		string user = OLAPCellReadString(connection, CycleConfigurationCube, Cycle, ""N.A."",""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");

		if(user != """")
		{
			OLAPCellDelete(connection, CycleConfigurationCube, Cycle, ""N.A."",""GLOBAL_CYCLE_ACTIVE"",""Parameter"");
		}
		
		//deleting cube = ""BPCCONFIG_MAIN"";
		TargetData = OLAPCreateDataArea(connection, MainConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		//deleting cube = ""BPCCONFIG_ENTITY"";
		TargetData = OLAPCreateDataArea(connection, EntityConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		


		//deleting cube = ""BPCCONFIG_ENTITY_SEGMENT"";
		TargetData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		OLAPDeleteDataArea(TargetData);
		//check if there is any version active for cycle, if not delete cycle

		double ActivatedVersions = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, Cycle, topVersionElement ,""GLOBAL_CYCLE_VERSION"", ""Value"");
		double ActivatedWBVersions = 0;

		bool WBVersionExist = OLAPDimensionElementExists(connection, versionDimension, topWBVersionElement);
		if(WBVersionExist)
		{
			ActivatedWBVersions = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, Cycle, topWBVersionElement ,""GLOBAL_CYCLE_VERSION"", ""Value"");
		}
		double checkVersionNumber =ActivatedVersions + ActivatedWBVersions;
		if (checkVersionNumber ==0)
		{
			OLAPDataArea TargetDataForDeletingCycle = OLAPCreateDataArea(connection, CycleConfigurationCube,
			                                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                             OlapDataAreaOperatorNone, 0.0,
			                                                             Cycle, ""N.A."", OlapDataAreaBCells, OlapDataAreaBCells);


			OLAPDeleteDataArea(TargetDataForDeletingCycle);
		}

		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPDeleteVersion(string Database, string Ticket, string CycleUN, string VersionUN)
@Description: ""Delete version setting for Configuration Set"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[VersionUN]: ""The version element to be used."";
@Returns: ""True, if successful."";

{
	string functionName = ""BAPDeleteVersion: "";
	string errorMessage = """";
	int errorCode = 0;

	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string MainConfigurationCube = ""BPCCONFIG_MAIN"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string EntitySegmentConfigurationCube = ""BPCCONFIG_ENTITY_SEGMENT"";

	string topVersionElement = ""TOTAL_CONFIGURATION"";
	string topWBVersionElement = ""SUBPLAN_WB_TOTAL_SCENARIO"";
	string versionDimension = ""BPDVERSION"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		/*VersionUN= ""[BPDVERSION].[BUDGET_01].[1]"";
		CycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";*/

		string Version = ResolveUniqueName(connection, VersionUN);
		string Cycle = ResolveUniqueName(connection, CycleUN);
		StringList versions = CreateStringList();
		Append(versions,"""");
		Append(versions,Version);

		OLAPDataArea rerVersionCheckDA = OLAPCreateDataArea(connection, CycleConfigurationCube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    Cycle, OlapDataAreaBCells, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
		foreach(OLAPCell cell in rerVersionCheckDA)
		{
			string ver = OLAPCellGetElement(cell, ""BPDVERSION"");
			if(StringContains(cell,Version))
			{
				Append(versions,ver);
			}
		}

		//deleting cube = ""BPCCONFIG_CYCLE"";
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, CycleConfigurationCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             Cycle, versions, OlapDataAreaBCells, OlapDataAreaBCells);


		OLAPDeleteDataArea(TargetData);

		string user = OLAPCellReadString(connection, CycleConfigurationCube, Cycle, ""N.A."",""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");

		if(user != """")
		{
			OLAPCellDelete(connection, CycleConfigurationCube, Cycle, ""N.A."",""GLOBAL_CYCLE_ACTIVE"",""Parameter"");
		}
		
		//deleting cube = ""BPCCONFIG_MAIN"";
		TargetData = OLAPCreateDataArea(connection, MainConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		
		//deleting cube = ""BPCCONFIG_ENTITY"";
		TargetData = OLAPCreateDataArea(connection, EntityConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetData);
		


		//deleting cube = ""BPCCONFIG_ENTITY_SEGMENT"";
		TargetData = OLAPCreateDataArea(connection, EntitySegmentConfigurationCube,
		                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                OlapDataAreaOperatorNone, 0.0,
		                                Cycle, Version, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);


		OLAPDeleteDataArea(TargetData);
		//check if there is any version active for cycle, if not delete cycle

		double ActivatedVersions = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, Cycle, topVersionElement ,""GLOBAL_CYCLE_VERSION"", ""Value"");
		double ActivatedWBVersions = 0;

		bool WBVersionExist = OLAPDimensionElementExists(connection, versionDimension, topWBVersionElement);
		if(WBVersionExist)
		{
			ActivatedWBVersions = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, Cycle, topWBVersionElement ,""GLOBAL_CYCLE_VERSION"", ""Value"");
		}
		double checkVersionNumber =ActivatedVersions + ActivatedWBVersions;
		if (checkVersionNumber ==0)
		{
			OLAPDataArea TargetDataForDeletingCycle = OLAPCreateDataArea(connection, CycleConfigurationCube,
			                                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                             OlapDataAreaOperatorNone, 0.0,
			                                                             Cycle, ""N.A."", OlapDataAreaBCells, OlapDataAreaBCells);


			OLAPDeleteDataArea(TargetDataForDeletingCycle);
		}

		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	C76EA02A-86FE-47D3-8340-A2D3018CD8E1	Delete version setting for Configuration Set	1	1	1	1573	NULL	0	45708.67507	0	0
78804733-CF00-4AF1-BD22-AD87AAE69BFD	CD491758-D9DF-4002-94C8-8006E1855F86	BAPDuplicateVersion	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""1, if successful;"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The Budgeting and Planning OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with the planning database."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""SourceVersionUN"" parameter-type=""string"" parameter-description=""The source version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""ParentUN"" parameter-type=""string"" parameter-description=""Parent element, below elements should be created"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""numberOfVersions"" parameter-type=""int"" parameter-description=""How many duplicate/referenced versions should be created"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""EndPeriodUN"" parameter-type=""string"" parameter-description=""End period(s) of the version(s)"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""ActualsUN"" parameter-type=""string"" parameter-description=""Actuals of the version(s)"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""Description"" parameter-type=""string"" parameter-description=""The description connected to target version"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""CurrentLang"" parameter-type=""string"" parameter-description=""Used language where description will be written"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""Mode"" parameter-type=""string"" parameter-description=""Type of the parent version, can be budget or forecast"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""TranslationMethod"" parameter-type=""string"" parameter-description=""Translation Method Set of the parent"" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""ExRateSet"" parameter-type=""string"" parameter-description=""Exchange Rate Set of the parent"" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""Date"" parameter-type=""string"" parameter-description=""Exchange Rate Set of the parent"" parameter-order=""13"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetNextVersion"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetNextVersion"", ""*""

int BAPDuplicateVersion(string Database, string Ticket,string CycleUN,string SourceVersionUN,string ParentUN,int numberOfVersions, string EndPeriodUN ,string ActualsUN ,string Description,string CurrentLang,
                        string Mode, string TranslationMethod, string ExRateSet, string Date)
@Description: ""Generates a duplicate/referenced version"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The Budgeting and Planning OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with the planning database."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[ParentUN]: ""Parent element, below elements should be created"";
@Parameter[numberOfVersions]: ""How many duplicate/referenced versions should be created"";
@Parameter[EndPeriodUN]: ""End period(s) of the version(s)"";
@Parameter[ActualsUN]: ""Actuals of the version(s)"";
@Parameter[Description]: ""The description connected to target version "";
@Parameter[CurrentLang]: ""Used language where description will be written"";
@Parameter[Mode]: ""Type of the parent version, can be budget or forecast"";
@Parameter[TranslationMethod]: ""Translation Method Set of the parent"";
@Parameter[ExRateSet]: ""Exchange Rate Set of the parent"";
@Parameter[Date]: ""Exchange Rate Set of the parent"";

@Returns: ""1, if successful;"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);


	/*CycleUN = ""[BPDCYCLE].[CYCLE_017].[1]"";
	SourceVersionUN = ""[BPDVERSION].[FC_FISCAL01].[1]"";
	ParentUN = ""[BPDVERSION].[TOTAL_FORECAST_FISCAL].[1]"";
	EndPeriodUN = ""[BPDTIME].[12_2019].[1]"";//""[BPDTIME].[12_2019].[1],[BPDTIME].[12_2019].[1],[BPDTIME].[12_2019].[1]"";
	ActualsUN= ""[BPDPARAMETER].[GLOBAL_NUMBER_02].[1]"";//""[BPDPARAMETER].[GLOBAL_NUMBER_02].[1],[BPDPARAMETER].[GLOBAL_NUMBER_03].[1],[BPDPARAMETER].[GLOBAL_NUMBER_04].[1]"";
	Description=""FC ref 1"";//FC ref 1,FC ref 2,FC ref 3"";
	Mode= ""forecast"";
	TranslationMethod= ""Method2"";
	CurrentLang = ""[BPDLANGUAGE].[English].[1]"";
	ExRateSet= ""FC_FISCAL01"";
	Date=""43566"";//[BPDACCOUNT].[L120310].[1]""*/


	

	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string ExchangeConfigurationCube = ""BPCCONFIG_EXCHANGE"";
	string NA = ""N.A."";

	string UserUN = ""[#_SysUsr].[Admin].[1]"";
	string cycle = ResolveUniqueName(connection, CycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	CurrentLang = ResolveUniqueName(connection, CurrentLang);

	// procedure to fill array with target versions
	string TargetVersionUN ="""";
	int counter = 1;

	while(counter &lt;=numberOfVersions)
	{
		string version = BP_GetNextVersion(Database,CycleUN,ParentUN, UserUN);
		if(counter &lt;numberOfVersions)
		{
			TargetVersionUN = TargetVersionUN + version + "","";
		}
		else
		{
			TargetVersionUN = TargetVersionUN + version;
		}

		counter = counter + 1;

	}

	// procedure to fill array with target versions
	StringArray targetVersions = CreateStringArray();

	while(StringContains(TargetVersionUN, "",""))
	{
		int numberOfLetters = StringFind(TargetVersionUN,"","",1);

		string targetVersionHelp = StringSubstring(TargetVersionUN, 0, numberOfLetters);
		targetVersionHelp = ResolveUniqueName(connection, targetVersionHelp);
		Append(targetVersions, targetVersionHelp);

		TargetVersionUN = StringSubstring(TargetVersionUN, numberOfLetters + 1, StringLength(TargetVersionUN)-(numberOfLetters + 1));
	}

	if(!StringContains(TargetVersionUN, "",""))
	{
		TargetVersionUN = ResolveUniqueName(connection, TargetVersionUN);
		Append(targetVersions, TargetVersionUN);
	}

	// procedure to fill array with description
	StringArray Descriptions = CreateStringArray();

	while(StringContains(Description, "",""))
	{
		int numberOfLetters = StringFind(Description,"","",1);

		string DescriptionHelp = StringSubstring(Description, 0, numberOfLetters);
		Append(Descriptions, DescriptionHelp);

		Description = StringSubstring(Description, numberOfLetters + 1, StringLength(Description)-(numberOfLetters + 1));
		
	}
	if(!StringContains(Description, "",""))
	{
		Append(Descriptions, Description);
	}

	// procedure to fill array with EndPeriods
	StringArray EndPeriods = CreateStringArray();

	while(StringContains(EndPeriodUN, "",""))
	{
		int numberOfLetters = StringFind(EndPeriodUN,"","",1);

		string EndPeriodHelp = StringSubstring(EndPeriodUN, 0, numberOfLetters);

		Append(EndPeriods, EndPeriodHelp);
		EndPeriodUN = StringSubstring(EndPeriodUN, numberOfLetters + 1, StringLength(EndPeriodUN)-(numberOfLetters + 1));
	}
	if(!StringContains(EndPeriodUN, "",""))
	{
		Append(EndPeriods, EndPeriodUN);
	}
	
	// procedure to fill array with Actuals
	StringArray Actuals = CreateStringArray();

	while(StringContains(ActualsUN, "",""))
	{
		int numberOfLetters = StringFind(ActualsUN,"","",1);

		string ActualsHelp = StringSubstring(ActualsUN, 0, numberOfLetters);

		Append(Actuals, ActualsHelp);

		ActualsUN = StringSubstring(ActualsUN, numberOfLetters + 1, StringLength(ActualsUN)-(numberOfLetters + 1));
	}
	if(!StringContains(ActualsUN, "",""))
	{
		Append(Actuals, ActualsUN);
	}
	// count how many elements is in arrays
	int counterVersions = Count(targetVersions);
	int counterDescriptions = Count(Descriptions);

	int index = 0;
	// for each element from array targetVersions do writting
	while (index &lt; counterVersions)
	{
		string targetversionFromArray = GetElementByIndex(targetVersions,index);
		string DescriptionFromArray = GetElementByIndex(Descriptions, index);
		string EndPeriodFromArray = GetElementByIndex(EndPeriods, index);
		string ActualsFromArray = GetElementByIndex(Actuals, index);

		OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,DescriptionFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"" , CurrentLang);
		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,DescriptionFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"" , ""Default"");

		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,Date,cycle,targetversionFromArray, ""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"" , ""Text Value"");
		
		OLAPCellWriteBufferWriteString(buffer,  ExchangeConfigurationCube,TranslationMethod,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_METHOD"" , ""Text Value"");

		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_COMPLETED"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CREATED"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"" , ""Value"");
		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,SourceVersionUN,cycle,targetversionFromArray, "" GLOBAL_CYCLE_VERSION_CONFIGURATION"" , ""Text Value"");
		
		if(Mode == ""budget"")
		{
			OLAPCellWriteBufferWriteString(buffer,  ExchangeConfigurationCube,ExRateSet,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_RATESET"" , ""Text Value"");
		}
		
		if(Mode == ""forecast"")
		{
			OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,EndPeriodFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_FORECAST_LEVEL01_ENDPERIOD"" , ""Parameter"");
			OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,ActualsFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_FORECAST_ACTUAL_NUMBER"" , ""Text Value"");
			OLAPCellWriteBufferWriteString(buffer, ExchangeConfigurationCube,targetversionFromArray,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_RATESET"" , ""Text Value"");
		}

		OLAPCellWriteBufferDeleteCell(buffer, CycleConfigurationCube, cycle, targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");

		// PMMIS-7621: We need to activate the referenced versions in Workflow.
		// WF_ActivateDuplicateVersion_Internal(connection, cycle, SourceVersion, targetversionFromArray);
		// Note: Per Alex's comment on PMMIS-7621, we need to remove this call. Leaving it here commented out in case we need to call it again in the future.

		index = index + 1;
	}

	OLAPCommitCellWriteBuffer(buffer);

	return 1;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetNextVersion"", ""*""

int BAPDuplicateVersion(string Database, string Ticket,string CycleUN,string SourceVersionUN,string ParentUN,int numberOfVersions, string EndPeriodUN ,string ActualsUN ,string Description,string CurrentLang,
                        string Mode, string TranslationMethod, string ExRateSet, string Date)
@Description: ""Generates a duplicate/referenced version"";
@Category: ""Budgeting and Planning"";
@Parameter[Database]: ""The Budgeting and Planning OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with the planning database."";
@Parameter[CycleUN]: ""The Configuration Set element to be used."";
@Parameter[SourceVersionUN]: ""The source version element to be used."";
@Parameter[ParentUN]: ""Parent element, below elements should be created"";
@Parameter[numberOfVersions]: ""How many duplicate/referenced versions should be created"";
@Parameter[EndPeriodUN]: ""End period(s) of the version(s)"";
@Parameter[ActualsUN]: ""Actuals of the version(s)"";
@Parameter[Description]: ""The description connected to target version "";
@Parameter[CurrentLang]: ""Used language where description will be written"";
@Parameter[Mode]: ""Type of the parent version, can be budget or forecast"";
@Parameter[TranslationMethod]: ""Translation Method Set of the parent"";
@Parameter[ExRateSet]: ""Exchange Rate Set of the parent"";
@Parameter[Date]: ""Exchange Rate Set of the parent"";

@Returns: ""1, if successful;"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
	OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
	OLAPSetMaxUncommittedValues(buffer, 500);


	/*CycleUN = ""[BPDCYCLE].[CYCLE_017].[1]"";
	SourceVersionUN = ""[BPDVERSION].[FC_FISCAL01].[1]"";
	ParentUN = ""[BPDVERSION].[TOTAL_FORECAST_FISCAL].[1]"";
	EndPeriodUN = ""[BPDTIME].[12_2019].[1]"";//""[BPDTIME].[12_2019].[1],[BPDTIME].[12_2019].[1],[BPDTIME].[12_2019].[1]"";
	ActualsUN= ""[BPDPARAMETER].[GLOBAL_NUMBER_02].[1]"";//""[BPDPARAMETER].[GLOBAL_NUMBER_02].[1],[BPDPARAMETER].[GLOBAL_NUMBER_03].[1],[BPDPARAMETER].[GLOBAL_NUMBER_04].[1]"";
	Description=""FC ref 1"";//FC ref 1,FC ref 2,FC ref 3"";
	Mode= ""forecast"";
	TranslationMethod= ""Method2"";
	CurrentLang = ""[BPDLANGUAGE].[English].[1]"";
	ExRateSet= ""FC_FISCAL01"";
	Date=""43566"";//[BPDACCOUNT].[L120310].[1]""*/


	

	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string ExchangeConfigurationCube = ""BPCCONFIG_EXCHANGE"";
	string NA = ""N.A."";

	string UserUN = ""[#_SysUsr].[Admin].[1]"";
	string cycle = ResolveUniqueName(connection, CycleUN);
	string SourceVersion = ResolveUniqueName(connection, SourceVersionUN);
	CurrentLang = ResolveUniqueName(connection, CurrentLang);

	// procedure to fill array with target versions
	string TargetVersionUN ="""";
	int counter = 1;

	while(counter <=numberOfVersions)
	{
		string version = BP_GetNextVersion(Database,CycleUN,ParentUN, UserUN);
		if(counter <numberOfVersions)
		{
			TargetVersionUN = TargetVersionUN + version + "","";
		}
		else
		{
			TargetVersionUN = TargetVersionUN + version;
		}

		counter = counter + 1;

	}

	// procedure to fill array with target versions
	StringArray targetVersions = CreateStringArray();

	while(StringContains(TargetVersionUN, "",""))
	{
		int numberOfLetters = StringFind(TargetVersionUN,"","",1);

		string targetVersionHelp = StringSubstring(TargetVersionUN, 0, numberOfLetters);
		targetVersionHelp = ResolveUniqueName(connection, targetVersionHelp);
		Append(targetVersions, targetVersionHelp);

		TargetVersionUN = StringSubstring(TargetVersionUN, numberOfLetters + 1, StringLength(TargetVersionUN)-(numberOfLetters + 1));
	}

	if(!StringContains(TargetVersionUN, "",""))
	{
		TargetVersionUN = ResolveUniqueName(connection, TargetVersionUN);
		Append(targetVersions, TargetVersionUN);
	}

	// procedure to fill array with description
	StringArray Descriptions = CreateStringArray();

	while(StringContains(Description, "",""))
	{
		int numberOfLetters = StringFind(Description,"","",1);

		string DescriptionHelp = StringSubstring(Description, 0, numberOfLetters);
		Append(Descriptions, DescriptionHelp);

		Description = StringSubstring(Description, numberOfLetters + 1, StringLength(Description)-(numberOfLetters + 1));
		
	}
	if(!StringContains(Description, "",""))
	{
		Append(Descriptions, Description);
	}

	// procedure to fill array with EndPeriods
	StringArray EndPeriods = CreateStringArray();

	while(StringContains(EndPeriodUN, "",""))
	{
		int numberOfLetters = StringFind(EndPeriodUN,"","",1);

		string EndPeriodHelp = StringSubstring(EndPeriodUN, 0, numberOfLetters);

		Append(EndPeriods, EndPeriodHelp);
		EndPeriodUN = StringSubstring(EndPeriodUN, numberOfLetters + 1, StringLength(EndPeriodUN)-(numberOfLetters + 1));
	}
	if(!StringContains(EndPeriodUN, "",""))
	{
		Append(EndPeriods, EndPeriodUN);
	}
	
	// procedure to fill array with Actuals
	StringArray Actuals = CreateStringArray();

	while(StringContains(ActualsUN, "",""))
	{
		int numberOfLetters = StringFind(ActualsUN,"","",1);

		string ActualsHelp = StringSubstring(ActualsUN, 0, numberOfLetters);

		Append(Actuals, ActualsHelp);

		ActualsUN = StringSubstring(ActualsUN, numberOfLetters + 1, StringLength(ActualsUN)-(numberOfLetters + 1));
	}
	if(!StringContains(ActualsUN, "",""))
	{
		Append(Actuals, ActualsUN);
	}
	// count how many elements is in arrays
	int counterVersions = Count(targetVersions);
	int counterDescriptions = Count(Descriptions);

	int index = 0;
	// for each element from array targetVersions do writting
	while (index < counterVersions)
	{
		string targetversionFromArray = GetElementByIndex(targetVersions,index);
		string DescriptionFromArray = GetElementByIndex(Descriptions, index);
		string EndPeriodFromArray = GetElementByIndex(EndPeriods, index);
		string ActualsFromArray = GetElementByIndex(Actuals, index);

		OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,DescriptionFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"" , CurrentLang);
		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,DescriptionFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"" , ""Default"");

		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,Date,cycle,targetversionFromArray, ""GLOBAL_CYCLE_CHANGE_CONFIGURATION_DATE"" , ""Text Value"");
		
		OLAPCellWriteBufferWriteString(buffer,  ExchangeConfigurationCube,TranslationMethod,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_METHOD"" , ""Text Value"");

		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_COMPLETED"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CREATED"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION"" , ""Value"");
		OLAPCellWriteBufferWriteNumber(buffer, CycleConfigurationCube,1.0,cycle,targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"" , ""Value"");
		OLAPCellWriteBufferWriteString(buffer,  CycleConfigurationCube,SourceVersionUN,cycle,targetversionFromArray, "" GLOBAL_CYCLE_VERSION_CONFIGURATION"" , ""Text Value"");
		
		if(Mode == ""budget"")
		{
			OLAPCellWriteBufferWriteString(buffer,  ExchangeConfigurationCube,ExRateSet,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_RATESET"" , ""Text Value"");
		}
		
		if(Mode == ""forecast"")
		{
			OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,EndPeriodFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_FORECAST_LEVEL01_ENDPERIOD"" , ""Parameter"");
			OLAPCellWriteBufferWriteString(buffer, CycleConfigurationCube,ActualsFromArray,cycle,targetversionFromArray, ""GLOBAL_CYCLE_FORECAST_ACTUAL_NUMBER"" , ""Text Value"");
			OLAPCellWriteBufferWriteString(buffer, ExchangeConfigurationCube,targetversionFromArray,cycle,targetversionFromArray,NA, ""FEATURE_EX_VERSION_RATESET"" , ""Text Value"");
		}

		OLAPCellWriteBufferDeleteCell(buffer, CycleConfigurationCube, cycle, targetversionFromArray, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");

		// PMMIS-7621: We need to activate the referenced versions in Workflow.
		// WF_ActivateDuplicateVersion_Internal(connection, cycle, SourceVersion, targetversionFromArray);
		// Note: Per Alex's comment on PMMIS-7621, we need to remove this call. Leaving it here commented out in case we need to call it again in the future.

		index = index + 1;
	}

	OLAPCommitCellWriteBuffer(buffer);

	return 1;
}"	1	9257552F-2CA7-48BD-B649-E6C03376CD73	Generates a duplicate/referenced version	1	1	1	1574	NULL	0	45708.67504	0	0
DCB9C3C3-8288-40EF-AA53-1C1B7278281A	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_AddLineDetail	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""levelForDeletingValue"" parameter-type=""string"" parameter-description=""The level element to be used, for deleting value."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""stepForDeletingValue"" parameter-type=""string"" parameter-description=""The step element to be used for deleting value."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""20"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""21"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""22"" />
  <parameter-descriptor parameter-name=""Value"" parameter-type=""double"" parameter-description=""1 for adding line, and 0 for deleting"" parameter-order=""23"" />
  <dependencies>
    <process process-name=""BP_GetNextLineDetail"" process-version=""*"" process-id="""" />
    <process process-name=""FC_GetForecastPeriods"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""BP_GetNextLineDetail"", ""*""
#include ""FC_GetForecastPeriods"", ""*""
string  BAPFinance_AddLineDetail(string database, string ticket, string cycle, string version,string levelForDeletingValue,string stepForDeletingValue,  string entity, string organization,
                                 string currency, string account, string detail, string analysis1, string analysis2, string analysis3,
                                 string analysis4,string analysis5,string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12,double Value)
@Description: ""Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[levelForDeletingValue]: ""The level element to be used, for deleting value."";
@Parameter[stepForDeletingValue]: ""The step element to be used for deleting value."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[detail]: ""The organization element to be used."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Parameter[Value]: ""1 for adding line, and 0 for deleting"";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_AddLineDetail: "";
	string MainCube = ""BPCMAIN"";
	string detailDynamicCube = ""ATCDATA_DETAIL"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	string detailHierarchy=""TOTAL_DETAIL_LINE"";
	string TimeDimension = ""BPDTIME"";
	string CycleDimension = ""BPDCYCLE"";
	string VersionDimension = ""BPDVERSION"";
	string LevelDimension = ""BPDLEVEL"";
	string StepDimension = ""BPDSTEP"";
	string EntityDimension = ""BPDENTITY"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string OrganizationDimension = ""BPDORGANIZATION"";
	string AccountDimension = ""BPDACCOUNT"";
	string DetailDimension = ""BPDDETAIL"";
	string LanguageDimension = ""BPDLANGUAGE"";
	string CurrencyDimension = ""BPDCURRENCY"";
	string ATDAttribute_DetailDimension = ""ATDATTRIBUTE_DETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string primarySegment = NA;
	string secondarySegment= NA;
	string tertiarySegment= NA;
	string intercompany = ""EXTERNAL"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{

		LogInformation(""BAPFinance_AddLineDetail: Starting process"");

		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";//BUDGET_01FC_FISCAL01
		levelForDeletingValue = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		stepForDeletingValue = ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		account=""[BPDACCOUNT].[A110210].[1]"";
		currency=""[BPDCURRENCY].[EUR_LC].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/
		// constants used in the process

		string time = """";
		if(Value == 1)
		{
			detail = BP_GetNextLineDetail(database,cycle,version,organization,entity, account);
		}

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		levelForDeletingValue= ResolveUniqueName(connection, levelForDeletingValue);
		stepForDeletingValue = ResolveUniqueName(connection, stepForDeletingValue);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		account= ResolveUniqueName(connection, account);
		currency = ResolveUniqueName(connection, currency);
		detail = ResolveUniqueName(connection, detail);
		/*detailHierarchy = ResolveUniqueName(connection, detailHierarchy);*/
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string detailComParameter = OLAPCreateCompositeName(detailHierarchy, detail);
		string detailComNA= OLAPCreateCompositeName(detailHierarchy, ""N.A."");

		string stepForDataArea = ""TOTAL_"" + stepForDeletingValue;


		OLAPElement organizationElement = OLAPGetDimensionElement(connection, OrganizationDimension, organization);
		OLAPElement analysis1Element = OLAPGetDimensionElement(connection, analysis1Dimension, analysis1);
		OLAPElement analysis2Element = OLAPGetDimensionElement(connection, analysis2Dimension, analysis2);
		OLAPElement analysis3Element = OLAPGetDimensionElement(connection, analysis3Dimension, analysis3);
		OLAPElement analysis4Element = OLAPGetDimensionElement(connection, analysis4Dimension, analysis4);
		OLAPElement analysis5Element = OLAPGetDimensionElement(connection, analysis5Dimension, analysis5);
		OLAPElement analysis6Element = OLAPGetDimensionElement(connection, analysis6Dimension, analysis6);
		OLAPElement analysis7Element = OLAPGetDimensionElement(connection, analysis7Dimension, analysis7);
		OLAPElement analysis8Element = OLAPGetDimensionElement(connection, analysis8Dimension, analysis8);
		OLAPElement analysis9Element = OLAPGetDimensionElement(connection, analysis9Dimension, analysis9);
		OLAPElement analysis10Element = OLAPGetDimensionElement(connection, analysis10Dimension, analysis10);
		OLAPElement analysis11Element = OLAPGetDimensionElement(connection, analysis11Dimension, analysis11);
		OLAPElement analysis12Element = OLAPGetDimensionElement(connection, analysis12Dimension, analysis12);

		bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);
		bool baseAnalysis1Element = OLAPIsBaseElement(connection, analysis1Element);
		bool baseAnalysis2Element = OLAPIsBaseElement(connection, analysis2Element);
		bool baseAnalysis3Element = OLAPIsBaseElement(connection, analysis3Element);
		bool baseAnalysis4Element = OLAPIsBaseElement(connection, analysis4Element);
		bool baseAnalysis5Element = OLAPIsBaseElement(connection, analysis5Element);
		bool baseAnalysis6Element = OLAPIsBaseElement(connection, analysis6Element);
		bool baseAnalysis7Element = OLAPIsBaseElement(connection, analysis7Element);
		bool baseAnalysis8Element = OLAPIsBaseElement(connection, analysis8Element);
		bool baseAnalysis9Element = OLAPIsBaseElement(connection, analysis9Element);
		bool baseAnalysis10Element = OLAPIsBaseElement(connection, analysis10Element);
		bool baseAnalysis11Element = OLAPIsBaseElement(connection, analysis11Element);
		bool baseAnalysis12Element = OLAPIsBaseElement(connection, analysis12Element);

		StringArray stepArray = CreateStringArray();
		Append(stepArray, """");

		OLAPElementList stepList = OLAPGetChildElementList(connection, StepDimension, stepForDataArea, true);
		StringList stepStringListHelp = ToStringList(stepList);
		foreach(string stepOLAPElement in stepStringListHelp )
		{
			Append(stepArray, stepOLAPElement );
		}

		StringList stepStringList = ToStringList(stepArray);


		StringArray organizationArray = CreateStringArray();


		if(baseOrganizationElement)
		{
			
			Append(organizationArray, organization);

		}
		else
		{
			OLAPElementList organizationList = OLAPGetChildElementList(connection, OrganizationDimension, organization, true);
			StringList organizationStringListHelp = ToStringList(organizationList);

			foreach(string organizationOLAPElement in organizationStringListHelp )
			{
				Append(organizationArray, organizationOLAPElement );
			}
		}
		StringArray organizationArrayDataArea = organizationArray;

		StringList organizationStringList = ToStringList(organizationArrayDataArea);
		Prepend(organizationStringList, """");

		StringArray Analysis1Array = CreateStringArray();
		Append(Analysis1Array, """");

		if(baseAnalysis1Element)
		{
			
			Append(Analysis1Array, analysis1);

		}
		else
		{
			OLAPElementList Analysis1List = OLAPGetChildElementList(connection, analysis1Dimension, analysis1, true);
			StringList Analysis1StringListHelp = ToStringList(Analysis1List);

			foreach(string Analysis1OLAPElement in Analysis1StringListHelp )
			{
				Append(Analysis1Array, Analysis1OLAPElement);
			}
		}


		StringList Analysis1StringList = ToStringList(Analysis1Array);

		// fill elements to analysis 2 array and convert it to string list to use in data area
		StringArray Analysis2Array = CreateStringArray();
		Append(Analysis2Array, """");
		if(baseAnalysis2Element)
		{
			Append(Analysis2Array, analysis2);

		}
		else
		{
			OLAPElementList Analysis2List = OLAPGetChildElementList(connection, analysis2Dimension, analysis2, true);
			foreach(OLAPElement Analysis2OLAPElement in Analysis2List )
			{
				Append(Analysis2Array, Analysis2OLAPElement);
			}

		}
		StringList Analysis2StringList = ToStringList(Analysis2Array);

		// fill elements to analysis 3 array and convert it to string list to use in data area
		StringArray Analysis3Array = CreateStringArray();
		Append(Analysis3Array, """");
		if(baseAnalysis3Element)
		{
			Append(Analysis3Array, analysis3);

		}
		else
		{
			OLAPElementList Analysis3List = OLAPGetChildElementList(connection, analysis3Dimension, analysis3, true);
			foreach(OLAPElement Analysis3OLAPElement in Analysis3List )
			{
				Append(Analysis3Array, Analysis3OLAPElement);
			}

		}
		StringList Analysis3StringList = ToStringList(Analysis3Array);

		// fill elements to analysis 4 array and convert it to string list to use in data area
		StringArray Analysis4Array = CreateStringArray();
		Append(Analysis4Array, """");
		if(baseAnalysis4Element)
		{
			Append(Analysis4Array, analysis4);

		}
		else
		{
			OLAPElementList Analysis4List = OLAPGetChildElementList(connection, analysis4Dimension, analysis4, true);
			foreach(OLAPElement Analysis4OLAPElement in Analysis4List )
			{
				Append(Analysis4Array, Analysis4OLAPElement);
			}

		}
		StringList Analysis4StringList = ToStringList(Analysis4Array);

		// fill elements to analysis 5 array and convert it to string list to use in data area
		StringArray Analysis5Array = CreateStringArray();
		Append(Analysis5Array, """");
		if(baseAnalysis5Element)
		{
			Append(Analysis5Array, analysis5);

		}
		else
		{
			OLAPElementList Analysis5List = OLAPGetChildElementList(connection, analysis5Dimension, analysis5, true);
			foreach(OLAPElement Analysis5OLAPElement in Analysis5List )
			{
				Append(Analysis5Array, Analysis5OLAPElement);
			}

		}
		StringList Analysis5StringList = ToStringList(Analysis5Array);

		// fill elements to analysis 6 array and convert it to string list to use in data area
		StringArray Analysis6Array = CreateStringArray();
		Append(Analysis6Array, """");
		if(baseAnalysis6Element)
		{
			Append(Analysis6Array, analysis6);

		}
		else
		{
			OLAPElementList Analysis6List = OLAPGetChildElementList(connection, analysis6Dimension, analysis6, true);
			foreach(OLAPElement Analysis6OLAPElement in Analysis6List )
			{
				Append(Analysis6Array, Analysis6OLAPElement);
			}

		}
		StringList Analysis6StringList = ToStringList(Analysis6Array);

		// fill elements to analysis 7 array and convert it to string list to use in data area
		StringArray Analysis7Array = CreateStringArray();
		Append(Analysis7Array, """");

		if(baseAnalysis7Element)
		{
			Append(Analysis7Array, analysis7);

		}
		else
		{
			OLAPElementList Analysis7List = OLAPGetChildElementList(connection, analysis7Dimension, analysis7, true);
			foreach(OLAPElement Analysis7OLAPElement in Analysis7List )
			{
				Append(Analysis7Array, Analysis7OLAPElement);
			}

		}
		StringList Analysis7StringList = ToStringList(Analysis7Array);

		// fill elements to analysis 8 array and convert it to string list to use in data area
		StringArray Analysis8Array = CreateStringArray();
		Append(Analysis8Array, """");
		if(baseAnalysis8Element)
		{
			Append(Analysis8Array, analysis8);

		}
		else
		{
			OLAPElementList Analysis8List = OLAPGetChildElementList(connection, analysis8Dimension, analysis8, true);
			foreach(OLAPElement Analysis8OLAPElement in Analysis8List )
			{
				Append(Analysis8Array, Analysis8OLAPElement);
			}

		}
		StringList Analysis8StringList = ToStringList(Analysis8Array);

		// fill elements to analysis 9 array and convert it to string list to use in data area
		StringArray Analysis9Array = CreateStringArray();
		Append(Analysis9Array, """");
		if(baseAnalysis9Element)
		{
			Append(Analysis9Array, analysis9);

		}
		else
		{
			OLAPElementList Analysis9List = OLAPGetChildElementList(connection, analysis9Dimension, analysis9, true);
			foreach(OLAPElement Analysis9OLAPElement in Analysis9List )
			{
				Append(Analysis9Array, Analysis9OLAPElement);
			}

		}
		StringList Analysis9StringList = ToStringList(Analysis9Array);

		// fill elements to analysis 10 array and convert it to string list to use in data area
		StringArray Analysis10Array = CreateStringArray();
		Append(Analysis10Array, """");
		if(baseAnalysis10Element)
		{
			Append(Analysis10Array, analysis10);

		}
		else
		{
			OLAPElementList Analysis10List = OLAPGetChildElementList(connection, analysis10Dimension, analysis10, true);
			foreach(OLAPElement Analysis10OLAPElement in Analysis10List )
			{
				Append(Analysis10Array, Analysis10OLAPElement);
			}

		}
		StringList Analysis10StringList = ToStringList(Analysis10Array);

		// fill elements to analysis 11 array and convert it to string list to use in data area
		StringArray Analysis11Array = CreateStringArray();
		Append(Analysis11Array, """");
		if(baseAnalysis11Element)
		{
			Append(Analysis11Array, analysis11);

		}
		else
		{
			OLAPElementList Analysis11List = OLAPGetChildElementList(connection, analysis11Dimension, analysis11, true);
			foreach(OLAPElement Analysis11OLAPElement in Analysis11List )
			{
				Append(Analysis11Array, Analysis11OLAPElement);
			}

		}
		StringList Analysis11StringList = ToStringList(Analysis11Array);

		// fill elements to analysis 12 array and convert it to string list to use in data area
		StringArray Analysis12Array = CreateStringArray();
		Append(Analysis12Array, """");
		if(baseAnalysis12Element)
		{
			Append(Analysis12Array, analysis12);

		}
		else
		{
			OLAPElementList Analysis12List = OLAPGetChildElementList(connection, analysis12Dimension, analysis12, true);
			foreach(OLAPElement Analysis12OLAPElement in Analysis12List )
			{
				Append(Analysis12Array, Analysis12OLAPElement);
			}

		}
		StringList Analysis12StringList = ToStringList(Analysis12Array);

		string cycleHierarchyElement = CycleDimension+""\t""+cycle;
		string versionHierarchyElement = VersionDimension+""\t""+version;
		string organizationHierarchyElement = OrganizationDimension+""\t""+organization;
		string entityHierarchyElement = EntityDimension+""\t""+entity;
		string levelHierarchyForWorkWithLinesElement = LevelDimension+""\t""+""N.A."";
		string stepHierarchyForWorkWithLinesElement = StepDimension+""\t""+""BASE_STEP"";
		string timeHierarchyElement = TimeDimension+""\t""+time;
		string accountHierarchyElement = AccountDimension+""\t""+account;
		string LanguageHierarchyElement = LanguageDimension+""\t""+""Value"";
		string detailHierarchyElement = detailHierarchy+""\t""+detail;
		string ATDAttribute_DetailHierarchyElement = ATDAttribute_DetailDimension+""\t""+""Detail_Line_Flag"";


		StringArray arrayOfATDAttribute_Detail= CreateStringArray();

		Append(arrayOfATDAttribute_Detail, cycleHierarchyElement);
		Append(arrayOfATDAttribute_Detail, versionHierarchyElement);
		Append(arrayOfATDAttribute_Detail, organizationHierarchyElement);
		Append(arrayOfATDAttribute_Detail, entityHierarchyElement);
		Append(arrayOfATDAttribute_Detail, levelHierarchyForWorkWithLinesElement);
		Append(arrayOfATDAttribute_Detail, stepHierarchyForWorkWithLinesElement);
		Append(arrayOfATDAttribute_Detail, timeHierarchyElement);
		Append(arrayOfATDAttribute_Detail, accountHierarchyElement);
		Append(arrayOfATDAttribute_Detail, LanguageHierarchyElement);
		Append(arrayOfATDAttribute_Detail, detailHierarchyElement);
		Append(arrayOfATDAttribute_Detail, ATDAttribute_DetailHierarchyElement);


		StringList cycleBasePeriodsPeriods = CreateStringList();
		if(StringContains(version, ""BUDGET""))
		{
			string yearUN = OLAPCellReadString(connection, CycleConfigurationCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
			string year = ResolveUniqueName(connection, yearUN);
			int yearint = ToInt(year);
			int numberOfYears = ToInt(OLAPCellReadNumber(connection, CycleConfigurationCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));
			int y = 0;
			

			while(y&lt;numberOfYears)
			{
				int yearintInLoop = yearint + y;
				string yearString = ToString(yearintInLoop);
				OLAPElementList Periods = OLAPGetChildElementList(connection, TimeDimension, yearString, true);
				foreach(OLAPElement period in Periods)
				{
					string periodString = ToString(period);
					Append(cycleBasePeriodsPeriods, periodString);

				}

				y = y + 1;
			}
		}
		else
		{
			StringListList forecastPeriods = FC_GetForecastPeriods(connection, cycle, version);
			// OLAPCreateDataArea requires that the first element be an empty string
			foreach (string period in forecastPeriods[0]) {
				Append(cycleBasePeriodsPeriods, period);
			}
			foreach (string period in forecastPeriods[1]) {
				Append(cycleBasePeriodsPeriods, period);
			}
		}



		foreach (string month in cycleBasePeriodsPeriods)
		{
			string monthInCycle= month;
			timeHierarchyElement = TimeDimension+""\t""+month;
			arrayOfATDAttribute_Detail[6]= timeHierarchyElement;
			foreach(string org in organizationArray)
			{
				string orgHirarchyElement = OrganizationDimension+""\t""+org;
				arrayOfATDAttribute_Detail[2]= orgHirarchyElement;
				OLAPCellWriteBufferWriteNumberDynamic(buffer, detailDynamicCube, Value, arrayOfATDAttribute_Detail);
			}

		}

		StringList cycleBasePeriodsDataArea = cycleBasePeriodsPeriods;
		Prepend(cycleBasePeriodsDataArea, """");
		if(Value ==0)
		{
			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                             cycleBasePeriodsDataArea,cycle, version,levelForDeletingValue, stepStringList, entity, intercompany, organizationStringList, account, currency, detailComParameter, primarySegment, secondarySegment,  tertiarySegment, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceData)
			{
				string timeDA  = OLAPCellGetElement(cell, ""BPDTIME"");
				string organizationDA  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string analysis1DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4DA = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5DA = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string stepDA  = OLAPCellGetElement(cell, ""BPDSTEP"");
				double monthValue = cell;
				double defaultMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				double defaultMonthValueWrite = defaultMonthValue - monthValue ;
				
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				OLAPCellWriteBufferDeleteCell(buffer, MainCube, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, detailComParameter, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);

			}
		}


		LogInformation(""BAPFinance_AddLineDetail: Closing process"");
		OLAPCommitCellWriteBuffer(buffer);

		return ""[""+DetailDimension+""].[""+detailHierarchy+""].[""+detail+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""BP_GetNextLineDetail"", ""*""
#include ""FC_GetForecastPeriods"", ""*""
string  BAPFinance_AddLineDetail(string database, string ticket, string cycle, string version,string levelForDeletingValue,string stepForDeletingValue,  string entity, string organization,
                                 string currency, string account, string detail, string analysis1, string analysis2, string analysis3,
                                 string analysis4,string analysis5,string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12,double Value)
@Description: ""Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[levelForDeletingValue]: ""The level element to be used, for deleting value."";
@Parameter[stepForDeletingValue]: ""The step element to be used for deleting value."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[detail]: ""The organization element to be used."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Parameter[Value]: ""1 for adding line, and 0 for deleting"";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_AddLineDetail: "";
	string MainCube = ""BPCMAIN"";
	string detailDynamicCube = ""ATCDATA_DETAIL"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	string detailHierarchy=""TOTAL_DETAIL_LINE"";
	string TimeDimension = ""BPDTIME"";
	string CycleDimension = ""BPDCYCLE"";
	string VersionDimension = ""BPDVERSION"";
	string LevelDimension = ""BPDLEVEL"";
	string StepDimension = ""BPDSTEP"";
	string EntityDimension = ""BPDENTITY"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string OrganizationDimension = ""BPDORGANIZATION"";
	string AccountDimension = ""BPDACCOUNT"";
	string DetailDimension = ""BPDDETAIL"";
	string LanguageDimension = ""BPDLANGUAGE"";
	string CurrencyDimension = ""BPDCURRENCY"";
	string ATDAttribute_DetailDimension = ""ATDATTRIBUTE_DETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string primarySegment = NA;
	string secondarySegment= NA;
	string tertiarySegment= NA;
	string intercompany = ""EXTERNAL"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{

		LogInformation(""BAPFinance_AddLineDetail: Starting process"");

		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";//BUDGET_01FC_FISCAL01
		levelForDeletingValue = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		stepForDeletingValue = ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		account=""[BPDACCOUNT].[A110210].[1]"";
		currency=""[BPDCURRENCY].[EUR_LC].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/
		// constants used in the process

		string time = """";
		if(Value == 1)
		{
			detail = BP_GetNextLineDetail(database,cycle,version,organization,entity, account);
		}

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		levelForDeletingValue= ResolveUniqueName(connection, levelForDeletingValue);
		stepForDeletingValue = ResolveUniqueName(connection, stepForDeletingValue);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		account= ResolveUniqueName(connection, account);
		currency = ResolveUniqueName(connection, currency);
		detail = ResolveUniqueName(connection, detail);
		/*detailHierarchy = ResolveUniqueName(connection, detailHierarchy);*/
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string detailComParameter = OLAPCreateCompositeName(detailHierarchy, detail);
		string detailComNA= OLAPCreateCompositeName(detailHierarchy, ""N.A."");

		string stepForDataArea = ""TOTAL_"" + stepForDeletingValue;


		OLAPElement organizationElement = OLAPGetDimensionElement(connection, OrganizationDimension, organization);
		OLAPElement analysis1Element = OLAPGetDimensionElement(connection, analysis1Dimension, analysis1);
		OLAPElement analysis2Element = OLAPGetDimensionElement(connection, analysis2Dimension, analysis2);
		OLAPElement analysis3Element = OLAPGetDimensionElement(connection, analysis3Dimension, analysis3);
		OLAPElement analysis4Element = OLAPGetDimensionElement(connection, analysis4Dimension, analysis4);
		OLAPElement analysis5Element = OLAPGetDimensionElement(connection, analysis5Dimension, analysis5);
		OLAPElement analysis6Element = OLAPGetDimensionElement(connection, analysis6Dimension, analysis6);
		OLAPElement analysis7Element = OLAPGetDimensionElement(connection, analysis7Dimension, analysis7);
		OLAPElement analysis8Element = OLAPGetDimensionElement(connection, analysis8Dimension, analysis8);
		OLAPElement analysis9Element = OLAPGetDimensionElement(connection, analysis9Dimension, analysis9);
		OLAPElement analysis10Element = OLAPGetDimensionElement(connection, analysis10Dimension, analysis10);
		OLAPElement analysis11Element = OLAPGetDimensionElement(connection, analysis11Dimension, analysis11);
		OLAPElement analysis12Element = OLAPGetDimensionElement(connection, analysis12Dimension, analysis12);

		bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);
		bool baseAnalysis1Element = OLAPIsBaseElement(connection, analysis1Element);
		bool baseAnalysis2Element = OLAPIsBaseElement(connection, analysis2Element);
		bool baseAnalysis3Element = OLAPIsBaseElement(connection, analysis3Element);
		bool baseAnalysis4Element = OLAPIsBaseElement(connection, analysis4Element);
		bool baseAnalysis5Element = OLAPIsBaseElement(connection, analysis5Element);
		bool baseAnalysis6Element = OLAPIsBaseElement(connection, analysis6Element);
		bool baseAnalysis7Element = OLAPIsBaseElement(connection, analysis7Element);
		bool baseAnalysis8Element = OLAPIsBaseElement(connection, analysis8Element);
		bool baseAnalysis9Element = OLAPIsBaseElement(connection, analysis9Element);
		bool baseAnalysis10Element = OLAPIsBaseElement(connection, analysis10Element);
		bool baseAnalysis11Element = OLAPIsBaseElement(connection, analysis11Element);
		bool baseAnalysis12Element = OLAPIsBaseElement(connection, analysis12Element);

		StringArray stepArray = CreateStringArray();
		Append(stepArray, """");

		OLAPElementList stepList = OLAPGetChildElementList(connection, StepDimension, stepForDataArea, true);
		StringList stepStringListHelp = ToStringList(stepList);
		foreach(string stepOLAPElement in stepStringListHelp )
		{
			Append(stepArray, stepOLAPElement );
		}

		StringList stepStringList = ToStringList(stepArray);


		StringArray organizationArray = CreateStringArray();


		if(baseOrganizationElement)
		{
			
			Append(organizationArray, organization);

		}
		else
		{
			OLAPElementList organizationList = OLAPGetChildElementList(connection, OrganizationDimension, organization, true);
			StringList organizationStringListHelp = ToStringList(organizationList);

			foreach(string organizationOLAPElement in organizationStringListHelp )
			{
				Append(organizationArray, organizationOLAPElement );
			}
		}
		StringArray organizationArrayDataArea = organizationArray;

		StringList organizationStringList = ToStringList(organizationArrayDataArea);
		Prepend(organizationStringList, """");

		StringArray Analysis1Array = CreateStringArray();
		Append(Analysis1Array, """");

		if(baseAnalysis1Element)
		{
			
			Append(Analysis1Array, analysis1);

		}
		else
		{
			OLAPElementList Analysis1List = OLAPGetChildElementList(connection, analysis1Dimension, analysis1, true);
			StringList Analysis1StringListHelp = ToStringList(Analysis1List);

			foreach(string Analysis1OLAPElement in Analysis1StringListHelp )
			{
				Append(Analysis1Array, Analysis1OLAPElement);
			}
		}


		StringList Analysis1StringList = ToStringList(Analysis1Array);

		// fill elements to analysis 2 array and convert it to string list to use in data area
		StringArray Analysis2Array = CreateStringArray();
		Append(Analysis2Array, """");
		if(baseAnalysis2Element)
		{
			Append(Analysis2Array, analysis2);

		}
		else
		{
			OLAPElementList Analysis2List = OLAPGetChildElementList(connection, analysis2Dimension, analysis2, true);
			foreach(OLAPElement Analysis2OLAPElement in Analysis2List )
			{
				Append(Analysis2Array, Analysis2OLAPElement);
			}

		}
		StringList Analysis2StringList = ToStringList(Analysis2Array);

		// fill elements to analysis 3 array and convert it to string list to use in data area
		StringArray Analysis3Array = CreateStringArray();
		Append(Analysis3Array, """");
		if(baseAnalysis3Element)
		{
			Append(Analysis3Array, analysis3);

		}
		else
		{
			OLAPElementList Analysis3List = OLAPGetChildElementList(connection, analysis3Dimension, analysis3, true);
			foreach(OLAPElement Analysis3OLAPElement in Analysis3List )
			{
				Append(Analysis3Array, Analysis3OLAPElement);
			}

		}
		StringList Analysis3StringList = ToStringList(Analysis3Array);

		// fill elements to analysis 4 array and convert it to string list to use in data area
		StringArray Analysis4Array = CreateStringArray();
		Append(Analysis4Array, """");
		if(baseAnalysis4Element)
		{
			Append(Analysis4Array, analysis4);

		}
		else
		{
			OLAPElementList Analysis4List = OLAPGetChildElementList(connection, analysis4Dimension, analysis4, true);
			foreach(OLAPElement Analysis4OLAPElement in Analysis4List )
			{
				Append(Analysis4Array, Analysis4OLAPElement);
			}

		}
		StringList Analysis4StringList = ToStringList(Analysis4Array);

		// fill elements to analysis 5 array and convert it to string list to use in data area
		StringArray Analysis5Array = CreateStringArray();
		Append(Analysis5Array, """");
		if(baseAnalysis5Element)
		{
			Append(Analysis5Array, analysis5);

		}
		else
		{
			OLAPElementList Analysis5List = OLAPGetChildElementList(connection, analysis5Dimension, analysis5, true);
			foreach(OLAPElement Analysis5OLAPElement in Analysis5List )
			{
				Append(Analysis5Array, Analysis5OLAPElement);
			}

		}
		StringList Analysis5StringList = ToStringList(Analysis5Array);

		// fill elements to analysis 6 array and convert it to string list to use in data area
		StringArray Analysis6Array = CreateStringArray();
		Append(Analysis6Array, """");
		if(baseAnalysis6Element)
		{
			Append(Analysis6Array, analysis6);

		}
		else
		{
			OLAPElementList Analysis6List = OLAPGetChildElementList(connection, analysis6Dimension, analysis6, true);
			foreach(OLAPElement Analysis6OLAPElement in Analysis6List )
			{
				Append(Analysis6Array, Analysis6OLAPElement);
			}

		}
		StringList Analysis6StringList = ToStringList(Analysis6Array);

		// fill elements to analysis 7 array and convert it to string list to use in data area
		StringArray Analysis7Array = CreateStringArray();
		Append(Analysis7Array, """");

		if(baseAnalysis7Element)
		{
			Append(Analysis7Array, analysis7);

		}
		else
		{
			OLAPElementList Analysis7List = OLAPGetChildElementList(connection, analysis7Dimension, analysis7, true);
			foreach(OLAPElement Analysis7OLAPElement in Analysis7List )
			{
				Append(Analysis7Array, Analysis7OLAPElement);
			}

		}
		StringList Analysis7StringList = ToStringList(Analysis7Array);

		// fill elements to analysis 8 array and convert it to string list to use in data area
		StringArray Analysis8Array = CreateStringArray();
		Append(Analysis8Array, """");
		if(baseAnalysis8Element)
		{
			Append(Analysis8Array, analysis8);

		}
		else
		{
			OLAPElementList Analysis8List = OLAPGetChildElementList(connection, analysis8Dimension, analysis8, true);
			foreach(OLAPElement Analysis8OLAPElement in Analysis8List )
			{
				Append(Analysis8Array, Analysis8OLAPElement);
			}

		}
		StringList Analysis8StringList = ToStringList(Analysis8Array);

		// fill elements to analysis 9 array and convert it to string list to use in data area
		StringArray Analysis9Array = CreateStringArray();
		Append(Analysis9Array, """");
		if(baseAnalysis9Element)
		{
			Append(Analysis9Array, analysis9);

		}
		else
		{
			OLAPElementList Analysis9List = OLAPGetChildElementList(connection, analysis9Dimension, analysis9, true);
			foreach(OLAPElement Analysis9OLAPElement in Analysis9List )
			{
				Append(Analysis9Array, Analysis9OLAPElement);
			}

		}
		StringList Analysis9StringList = ToStringList(Analysis9Array);

		// fill elements to analysis 10 array and convert it to string list to use in data area
		StringArray Analysis10Array = CreateStringArray();
		Append(Analysis10Array, """");
		if(baseAnalysis10Element)
		{
			Append(Analysis10Array, analysis10);

		}
		else
		{
			OLAPElementList Analysis10List = OLAPGetChildElementList(connection, analysis10Dimension, analysis10, true);
			foreach(OLAPElement Analysis10OLAPElement in Analysis10List )
			{
				Append(Analysis10Array, Analysis10OLAPElement);
			}

		}
		StringList Analysis10StringList = ToStringList(Analysis10Array);

		// fill elements to analysis 11 array and convert it to string list to use in data area
		StringArray Analysis11Array = CreateStringArray();
		Append(Analysis11Array, """");
		if(baseAnalysis11Element)
		{
			Append(Analysis11Array, analysis11);

		}
		else
		{
			OLAPElementList Analysis11List = OLAPGetChildElementList(connection, analysis11Dimension, analysis11, true);
			foreach(OLAPElement Analysis11OLAPElement in Analysis11List )
			{
				Append(Analysis11Array, Analysis11OLAPElement);
			}

		}
		StringList Analysis11StringList = ToStringList(Analysis11Array);

		// fill elements to analysis 12 array and convert it to string list to use in data area
		StringArray Analysis12Array = CreateStringArray();
		Append(Analysis12Array, """");
		if(baseAnalysis12Element)
		{
			Append(Analysis12Array, analysis12);

		}
		else
		{
			OLAPElementList Analysis12List = OLAPGetChildElementList(connection, analysis12Dimension, analysis12, true);
			foreach(OLAPElement Analysis12OLAPElement in Analysis12List )
			{
				Append(Analysis12Array, Analysis12OLAPElement);
			}

		}
		StringList Analysis12StringList = ToStringList(Analysis12Array);

		string cycleHierarchyElement = CycleDimension+""\t""+cycle;
		string versionHierarchyElement = VersionDimension+""\t""+version;
		string organizationHierarchyElement = OrganizationDimension+""\t""+organization;
		string entityHierarchyElement = EntityDimension+""\t""+entity;
		string levelHierarchyForWorkWithLinesElement = LevelDimension+""\t""+""N.A."";
		string stepHierarchyForWorkWithLinesElement = StepDimension+""\t""+""BASE_STEP"";
		string timeHierarchyElement = TimeDimension+""\t""+time;
		string accountHierarchyElement = AccountDimension+""\t""+account;
		string LanguageHierarchyElement = LanguageDimension+""\t""+""Value"";
		string detailHierarchyElement = detailHierarchy+""\t""+detail;
		string ATDAttribute_DetailHierarchyElement = ATDAttribute_DetailDimension+""\t""+""Detail_Line_Flag"";


		StringArray arrayOfATDAttribute_Detail= CreateStringArray();

		Append(arrayOfATDAttribute_Detail, cycleHierarchyElement);
		Append(arrayOfATDAttribute_Detail, versionHierarchyElement);
		Append(arrayOfATDAttribute_Detail, organizationHierarchyElement);
		Append(arrayOfATDAttribute_Detail, entityHierarchyElement);
		Append(arrayOfATDAttribute_Detail, levelHierarchyForWorkWithLinesElement);
		Append(arrayOfATDAttribute_Detail, stepHierarchyForWorkWithLinesElement);
		Append(arrayOfATDAttribute_Detail, timeHierarchyElement);
		Append(arrayOfATDAttribute_Detail, accountHierarchyElement);
		Append(arrayOfATDAttribute_Detail, LanguageHierarchyElement);
		Append(arrayOfATDAttribute_Detail, detailHierarchyElement);
		Append(arrayOfATDAttribute_Detail, ATDAttribute_DetailHierarchyElement);


		StringList cycleBasePeriodsPeriods = CreateStringList();
		if(StringContains(version, ""BUDGET""))
		{
			string yearUN = OLAPCellReadString(connection, CycleConfigurationCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
			string year = ResolveUniqueName(connection, yearUN);
			int yearint = ToInt(year);
			int numberOfYears = ToInt(OLAPCellReadNumber(connection, CycleConfigurationCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));
			int y = 0;
			

			while(y<numberOfYears)
			{
				int yearintInLoop = yearint + y;
				string yearString = ToString(yearintInLoop);
				OLAPElementList Periods = OLAPGetChildElementList(connection, TimeDimension, yearString, true);
				foreach(OLAPElement period in Periods)
				{
					string periodString = ToString(period);
					Append(cycleBasePeriodsPeriods, periodString);

				}

				y = y + 1;
			}
		}
		else
		{
			StringListList forecastPeriods = FC_GetForecastPeriods(connection, cycle, version);
			// OLAPCreateDataArea requires that the first element be an empty string
			foreach (string period in forecastPeriods[0]) {
				Append(cycleBasePeriodsPeriods, period);
			}
			foreach (string period in forecastPeriods[1]) {
				Append(cycleBasePeriodsPeriods, period);
			}
		}



		foreach (string month in cycleBasePeriodsPeriods)
		{
			string monthInCycle= month;
			timeHierarchyElement = TimeDimension+""\t""+month;
			arrayOfATDAttribute_Detail[6]= timeHierarchyElement;
			foreach(string org in organizationArray)
			{
				string orgHirarchyElement = OrganizationDimension+""\t""+org;
				arrayOfATDAttribute_Detail[2]= orgHirarchyElement;
				OLAPCellWriteBufferWriteNumberDynamic(buffer, detailDynamicCube, Value, arrayOfATDAttribute_Detail);
			}

		}

		StringList cycleBasePeriodsDataArea = cycleBasePeriodsPeriods;
		Prepend(cycleBasePeriodsDataArea, """");
		if(Value ==0)
		{
			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                             cycleBasePeriodsDataArea,cycle, version,levelForDeletingValue, stepStringList, entity, intercompany, organizationStringList, account, currency, detailComParameter, primarySegment, secondarySegment,  tertiarySegment, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceData)
			{
				string timeDA  = OLAPCellGetElement(cell, ""BPDTIME"");
				string organizationDA  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				string analysis1DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				string analysis2DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				string analysis3DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				string analysis4DA = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				string analysis5DA = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				string analysis6DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				string analysis7DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				string analysis8DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				string analysis9DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				string analysis10DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				string analysis11DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				string analysis12DA  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				string stepDA  = OLAPCellGetElement(cell, ""BPDSTEP"");
				double monthValue = cell;
				double defaultMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				double defaultMonthValueWrite = defaultMonthValue - monthValue ;
				
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				OLAPCellWriteBufferDeleteCell(buffer, MainCube, timeDA, cycle, version,levelForDeletingValue, stepDA, entity, intercompany, organizationDA,account, currency, detailComParameter, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);

			}
		}


		LogInformation(""BAPFinance_AddLineDetail: Closing process"");
		OLAPCommitCellWriteBuffer(buffer);

		return ""[""+DetailDimension+""].[""+detailHierarchy+""].[""+detail+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	AEC9F78B-05E7-4CA2-A136-0B1FDB16C7D6	Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube	1	1	1	1575	NULL	0	45708.67507	0	0
0A759C83-00EB-4B0E-93B2-4E176E067974	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_Assumptions	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""levelInput"" parameter-type=""string"" parameter-description=""The level element with entered values."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""18"" />
  <dependencies>
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string BAPFinance_Assumptions(
	string database, string cycle, string version,string stepWrite, string entity, string organization, string levelInput,
	string analysis1, string analysis2,string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10,string analysis11, string analysis12)
@Description: ""Calculate dependent accounts based on premises configuration for given account, where user do writeback"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[levelInput]: ""The level element with entered values."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Assumptions:"";
	string errorMessage = """";
	int errorCode = 0;
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string levelDimension = ""BPDLEVEL"";
	string stepDimension = ""BPDSTEP"";
	string currencyDimension = ""BPDCURRENCY"";
	string organizationDimension = ""BPDORGANIZATION"";
	string MainCube = ""BPCMAIN"";
	string PhasingCube = ""BPCCONFIG_PHASING"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string cycleConfigCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string intercompany= ""TOTAL_PARTNER"";
	string primarySegment= ""TOTAL_SEGMENT"";
	string secondarySegment= ""TOTAL_SEGMENT"";
	string tertiarySegment= ""TOTAL_SEGMENT"";
	string detail= ""TOTAL_DETAIL"";
	string account = ""TOTAL_ACCOUNT"";
	string analysis1read = """";
	string analysis2read = """";
	string analysis3read = """";
	string analysis4read = """";
	string analysis5read = """";
	string analysis6read = """";
	string analysis7read = """";
	string analysis8read = """";
	string analysis9read = """";
	string analysis10read = """";
	string analysis11read = """";
	string analysis12read = """";
	string currencyWrite  = """";

	try {
		LogInformation(""BAPFinance_Assumptions: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		organization=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";//N.A.C401
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		StringList organizationList = CreateStringList();
		Append(organizationList, """");
		StringArray organizationArray = CreateStringArray();

		if(StringContains(organization,"",""))
		{
			organizationArray = CF_ElementStringSplit(organization);
		}
		else
		{
			Append(organizationArray, organization);
		}

		foreach(string org in organizationArray)
		{
			string orgInLoop = ResolveUniqueName(connection, org);
			OLAPElement orgElement = OLAPGetDimensionElement(connection, organizationDimension, orgInLoop);
			bool baseOrgElement = OLAPIsBaseElement(connection, orgElement);
			if(baseOrgElement)
			{
				
				Append(organizationList, orgInLoop);

			}
			else
			{
				OLAPElementList orgOList = OLAPGetChildElementList(connection, organizationDimension, orgInLoop, true);
				StringList orgStringListHelp = ToStringList(orgOList);

				foreach(string orgOLAPElement in orgStringListHelp )
				{
					Append(organizationList, orgOLAPElement);
				}
			}

		}

		// get native ids from the XMLA names
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		levelInput = ResolveUniqueName(connection, levelInput);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string premiseLevel = ""CALC_PREMISE"";
		if(StringContains(levelInput,""_DP""))
		{
			premiseLevel = ""CALC_PREMISE_DP"";
		}
		if(StringContains(levelInput,""_DP_UN""))
		{
			premiseLevel = ""CALC_PREMISE_DP_UN"";
		}


		string yearUN = OLAPCellReadString(connection, cycleConfigCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		string year = ResolveUniqueName(connection, yearUN);
		int yearint = ToInt(year);
		int numberOfYears = ToInt(OLAPCellReadNumber(connection, cycleConfigCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));
		int y = 0;
		StringList timeStringList = CreateStringList();
		StringArray timeArrayHelp = CreateStringArray();
		Append(timeStringList, """");

		while(y&lt;numberOfYears)
		{
			int yearintInLoop = yearint + y;
			string yearString = ToString(yearintInLoop);
			OLAPElementList Periods = OLAPGetChildElementList(connection, TimeDimension, yearString, true);
			foreach(OLAPElement period in Periods)
			{
				string periodString = ToString(period);
				Append(timeStringList, periodString);
				Append(timeArrayHelp, periodString);
			}

			y = y + 1;
		}

		StringList stepStringList = BP_GetChildStringListOrItself(connection, stepDimension, stepWrite,true,true);
		StringList currencyStringList = BP_GetChildStringListOrItself(connection, currencyDimension, ""CURRENCY_DATAENTRY"",true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, ""TOTAL_ACCOUNT"",true,true);
		StringList totalTimeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, ""TOTAL_TIME"",true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompany,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detail,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegment,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegment,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegment,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);
		
		StringArray contraElements = CreateStringArray();
		StringArray targetAccountElements = CreateStringArray();
		OLAPElementList elementList = OLAPGetElementList(connection, ""BPDPREMISE"",  false);
		int counter = 1;

		while(counter &lt;=99)
		{
			string counterString =ToString(counter);
			string element =""ACCOUNT_""+counterString;
			bool isElementIn = OLAPElementListContainsElement(elementList, element);
			if(isElementIn)
			{
				Append(targetAccountElements, element);
			}
			else
			{
				break;
			}
			counter = counter + 1;
		}
		counter = 1;
		while(counter &lt;=99)
		{
			string counterString =ToString(counter);
			string element =""CONTRA""+counterString;
			bool isElementIn = OLAPElementListContainsElement(elementList, element);
			if(isElementIn)
			{
				Append(contraElements, element);
			}
			else
			{
				break;
			}
			counter = counter + 1;
		}

		OLAPDataArea premiseLevelDataDelete = OLAPCreateDataArea(connection, MainCube,
		                                                         OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                         totalTimeStringList,cycle, version,premiseLevel, stepStringList, entity, intercompanyStringList, organizationList, accountStringList, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
		
		OLAPDeleteDataArea(premiseLevelDataDelete);

		StringArray accountArray = CreateStringArray();
		OLAPDataArea activeAccountDataArea = OLAPCreateDataArea(connection, PremisesConfigurationCube,
		                                                        OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                        ""N.A."",cycle, version,entity, accountStringList, OlapDataAreaBCells);
		foreach(OLAPCell cell in activeAccountDataArea)
		{
			string acc  = OLAPCellGetElement(cell, AccountDimension);

			AppendDistinct(accountArray, acc);
		}


		foreach(string accountUsedInLoop in accountArray)
		{
			bool proceed = false;
			OLAPDataArea sourceDataCheck = OLAPCreateDataArea(connection, MainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  timeStringList,cycle, version,levelInput, stepStringList, entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceDataCheck)
			{
				proceed = true;
				break;
			}
			if(proceed)
			{
				OLAPElement accountElementUsedInLoop = OLAPGetDimensionElement(connection, AccountDimension, accountUsedInLoop);
				
				string accountType = OLAPGetStringAttribute(connection, accountElementUsedInLoop, ""ACCTYPE"");

				foreach(string contra in contraElements)
				{
					string contraAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, contra);

					if (contraAccount != """")
					{
						contraAccount = ResolveUniqueName(connection, contraAccount);
						OLAPElement contraAccountElement = OLAPGetDimensionElement(connection, AccountDimension, contraAccount);
						string contraAccountType = OLAPGetStringAttribute(connection, contraAccountElement, ""ACCTYPE"");

						string contraFactor = contra+""_FACTOR"";
						double contraFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, contraFactor);

						OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
						                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
						                                             timeStringList,cycle, version,levelInput, stepStringList, entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
						
						foreach(OLAPCell cell in sourceData)
						{
							string TimeInLoop  = OLAPCellGetElement(cell, ""BPDTIME"");
							analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
							analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
							analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
							analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
							analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
							analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
							analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
							analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
							analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
							analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
							analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
							analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
							currencyWrite= OLAPCellGetElement(cell, ""BPDCURRENCY"");
							string stepContra = OLAPCellGetElement(cell, ""BPDSTEP"");
							organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
							string intercompanyContra = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
							string primarySegmentContra = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
							string secondarySegmentContra = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
							string tertiarySegmentContra= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
							string detailContra = OLAPCellGetElement(cell, ""BPDDETAIL"");
							string levelContra = OLAPCellGetElement(cell, ""BPDLEVEL"");
							stepContra = OLAPCellGetElement(cell, ""BPDSTEP"");

							double sourceAccountValue = cell;
							double updatedSourceValue = 0;

							double contraAccountValue = sourceAccountValue*contraFactorValue;
							if (accountType != ""A"" and contraAccountType !=""A"")
							{
								contraAccountValue = contraAccountValue*-1;

							}
							if (accountType == ""A"" and contraAccountType ==""A"")
							{
								contraAccountValue = contraAccountValue*-1;

							}
							OLAPCellWriteBufferIncrementNumber(buffer, MainCube, contraAccountValue, TimeInLoop, cycle, version,premiseLevel,stepContra, entity, intercompanyContra, organization,contraAccount, currencyWrite,  detailContra, primarySegmentContra, secondarySegmentContra, tertiarySegmentContra, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							
						}
						OLAPCommitCellWriteBuffer(buffer);
					}
				}
				
				foreach(string target in targetAccountElements)
				{
					string targetPremisesElement = ""TARGET_""+target;
					if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",targetPremisesElement))
					{
						string targetAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, targetPremisesElement);
						
						if (targetAccount != """")
						{
							targetAccount = ResolveUniqueName(connection, targetAccount);
							OLAPElement targetAccountElement = OLAPGetDimensionElement(connection, AccountDimension, targetAccount);
							string targetAccountType = OLAPGetStringAttribute(connection, targetAccountElement, ""ACCTYPE"");

							string accountPeriodScopeElement = ""PERIOD_SCOPE_"" + target;
							string targetFactorElement = ""FACTOR_"" + target;
							string targetMonth = ""TARGET_MONTH_"" + target;
							
							double targetFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, targetFactorElement);

							string scope = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, accountPeriodScopeElement);
							StringArray contraTargetAccountArray = CreateStringArray();
							StringArray contraTargetAccountTypeArray = CreateStringArray();
							StringArray contraTargetFactorValueArray = CreateStringArray();

							foreach(string contra in contraElements)
							{
								string contraTargetElement = contra + ""_"" + target;
								if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",contraTargetElement))
								{
									string contraTargetAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, contraTargetElement);
									if (contraTargetAccount != """")
									{
										contraTargetAccount = ResolveUniqueName(connection, contraTargetAccount);
										Append(contraTargetAccountArray, contraTargetAccount);

										OLAPElement contraTargetAccountElement = OLAPGetDimensionElement(connection, AccountDimension, contraTargetAccount);
										string contraTargetAccountType = OLAPGetStringAttribute(connection,  contraTargetAccountElement , ""ACCTYPE"");
										Append(contraTargetAccountTypeArray, contraTargetAccountType);

										string contraTargetFactor = contra+""_FACTOR_""+target;
										if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",contraTargetFactor))
										{
											double contraTargetFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, contraTargetFactor);
											Append(contraTargetFactorValueArray, ToString(contraTargetFactorValue));
										}
									}
								}
							}
							StringArray targetPeriodsArray = CreateStringArray();
							string targetPeriodMonth ="""";

							foreach(string timeHelp in timeArrayHelp)
							{
								if (scope == ""YEAR"")
								{
									targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, ""CURRENT_YEAR_LAST_MONTH"");
									targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
								}
								else if (scope == ""QUARTER"")
								{
									targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, ""CURRENT_QUARTER_LAST_MONTH"");
									targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
								}
								else if (scope == ""PERIOD"")
								{
									string lag = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, targetMonth);
									lag = lag + ""_PERIODS_LATER"";

									if(lag == ""0_PERIODS_LATER"")
									{
										targetPeriodMonth = timeHelp;
									}
									else
									{
										targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, lag);
										targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
									}
								}
								Append(targetPeriodsArray, targetPeriodMonth);
							}
							int usedNumber = 0;

							foreach(string timeHelp in timeArrayHelp)
							{

								double updatedValue = 0;
								OLAPDataArea sourceDataTarget = OLAPCreateDataArea(connection, MainCube,
								                                                   OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
								                                                   timeHelp,cycle, version,levelInput, stepStringList,  entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);


								foreach(OLAPCell cell in sourceDataTarget)
								{
									string month  = OLAPCellGetElement(cell, ""BPDTIME"");
									analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
									analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
									analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
									analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
									analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
									analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
									analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
									analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
									analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
									analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
									analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
									analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
									organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
									string stepTarget= OLAPCellGetElement(cell, ""BPDSTEP"");
									currencyWrite= OLAPCellGetElement(cell, ""BPDCURRENCY"");
									string intercompanyTarget = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
									string primarySegmentTarget = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
									string secondarySegmentTarget = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
									string tertiarySegmentTarget= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
									string detailTarget = OLAPCellGetElement(cell, ""BPDDETAIL"");
									string levelTarget = OLAPCellGetElement(cell, ""BPDLEVEL"");
									string targetTime = GetElementByIndex(targetPeriodsArray, usedNumber);
									stepTarget= OLAPCellGetElement(cell, ""BPDSTEP"");
									double sourceAccountValue = cell;

									double targetAccountValue = sourceAccountValue*targetFactorValue;

									if (targetAccountType ==""E"")
									{
										targetAccountValue = targetAccountValue*-1;
									}
									if (accountType == ""E"" and targetAccountType ==""E"")
									{
										targetAccountValue = targetAccountValue*-1;
									}

									updatedValue = targetAccountValue;

									OLAPCellWriteBufferIncrementNumber(buffer, MainCube, targetAccountValue, targetTime, cycle, version,premiseLevel, stepTarget, entity, intercompanyTarget, organization,targetAccount, currencyWrite,  detailTarget, primarySegmentTarget, secondarySegmentTarget, tertiarySegmentTarget, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

								}
								usedNumber = usedNumber +1;
							}

							OLAPCommitCellWriteBuffer(buffer);
							
							StringList targetPeriodsList = ToStringList(targetPeriodsArray);
							Prepend(targetPeriodsList,"""");
							int x = 0;
							while(x &lt;= Count(contraTargetAccountArray)-1)
							{

								string contraTargetAccount = GetElementByIndex(contraTargetAccountArray, x);
								string contraTargetAccountType = GetElementByIndex(contraTargetAccountTypeArray, x);
								double contraTargetFactorValue = ToDouble(GetElementByIndex(contraTargetFactorValueArray, x));
								bool isTargetEmpty = false;

								OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
								                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
								                                             targetPeriodsList,cycle, version,premiseLevel, stepStringList, entity, intercompanyStringList, organizationList, targetAccount, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
								foreach(OLAPCell cell in sourceData)
								{
									string time  = OLAPCellGetElement(cell, ""BPDTIME"");
									analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
									analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
									analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
						"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string BAPFinance_Assumptions(
	string database, string cycle, string version,string stepWrite, string entity, string organization, string levelInput,
	string analysis1, string analysis2,string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10,string analysis11, string analysis12)
@Description: ""Calculate dependent accounts based on premises configuration for given account, where user do writeback"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[levelInput]: ""The level element with entered values."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Assumptions:"";
	string errorMessage = """";
	int errorCode = 0;
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string levelDimension = ""BPDLEVEL"";
	string stepDimension = ""BPDSTEP"";
	string currencyDimension = ""BPDCURRENCY"";
	string organizationDimension = ""BPDORGANIZATION"";
	string MainCube = ""BPCMAIN"";
	string PhasingCube = ""BPCCONFIG_PHASING"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string cycleConfigCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string intercompany= ""TOTAL_PARTNER"";
	string primarySegment= ""TOTAL_SEGMENT"";
	string secondarySegment= ""TOTAL_SEGMENT"";
	string tertiarySegment= ""TOTAL_SEGMENT"";
	string detail= ""TOTAL_DETAIL"";
	string account = ""TOTAL_ACCOUNT"";
	string analysis1read = """";
	string analysis2read = """";
	string analysis3read = """";
	string analysis4read = """";
	string analysis5read = """";
	string analysis6read = """";
	string analysis7read = """";
	string analysis8read = """";
	string analysis9read = """";
	string analysis10read = """";
	string analysis11read = """";
	string analysis12read = """";
	string currencyWrite  = """";

	try {
		LogInformation(""BAPFinance_Assumptions: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		organization=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";//N.A.C401
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		StringList organizationList = CreateStringList();
		Append(organizationList, """");
		StringArray organizationArray = CreateStringArray();

		if(StringContains(organization,"",""))
		{
			organizationArray = CF_ElementStringSplit(organization);
		}
		else
		{
			Append(organizationArray, organization);
		}

		foreach(string org in organizationArray)
		{
			string orgInLoop = ResolveUniqueName(connection, org);
			OLAPElement orgElement = OLAPGetDimensionElement(connection, organizationDimension, orgInLoop);
			bool baseOrgElement = OLAPIsBaseElement(connection, orgElement);
			if(baseOrgElement)
			{
				
				Append(organizationList, orgInLoop);

			}
			else
			{
				OLAPElementList orgOList = OLAPGetChildElementList(connection, organizationDimension, orgInLoop, true);
				StringList orgStringListHelp = ToStringList(orgOList);

				foreach(string orgOLAPElement in orgStringListHelp )
				{
					Append(organizationList, orgOLAPElement);
				}
			}

		}

		// get native ids from the XMLA names
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		levelInput = ResolveUniqueName(connection, levelInput);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string premiseLevel = ""CALC_PREMISE"";
		if(StringContains(levelInput,""_DP""))
		{
			premiseLevel = ""CALC_PREMISE_DP"";
		}
		if(StringContains(levelInput,""_DP_UN""))
		{
			premiseLevel = ""CALC_PREMISE_DP_UN"";
		}


		string yearUN = OLAPCellReadString(connection, cycleConfigCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		string year = ResolveUniqueName(connection, yearUN);
		int yearint = ToInt(year);
		int numberOfYears = ToInt(OLAPCellReadNumber(connection, cycleConfigCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));
		int y = 0;
		StringList timeStringList = CreateStringList();
		StringArray timeArrayHelp = CreateStringArray();
		Append(timeStringList, """");

		while(y<numberOfYears)
		{
			int yearintInLoop = yearint + y;
			string yearString = ToString(yearintInLoop);
			OLAPElementList Periods = OLAPGetChildElementList(connection, TimeDimension, yearString, true);
			foreach(OLAPElement period in Periods)
			{
				string periodString = ToString(period);
				Append(timeStringList, periodString);
				Append(timeArrayHelp, periodString);
			}

			y = y + 1;
		}

		StringList stepStringList = BP_GetChildStringListOrItself(connection, stepDimension, stepWrite,true,true);
		StringList currencyStringList = BP_GetChildStringListOrItself(connection, currencyDimension, ""CURRENCY_DATAENTRY"",true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, ""TOTAL_ACCOUNT"",true,true);
		StringList totalTimeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, ""TOTAL_TIME"",true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompany,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detail,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegment,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegment,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegment,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);
		
		StringArray contraElements = CreateStringArray();
		StringArray targetAccountElements = CreateStringArray();
		OLAPElementList elementList = OLAPGetElementList(connection, ""BPDPREMISE"",  false);
		int counter = 1;

		while(counter <=99)
		{
			string counterString =ToString(counter);
			string element =""ACCOUNT_""+counterString;
			bool isElementIn = OLAPElementListContainsElement(elementList, element);
			if(isElementIn)
			{
				Append(targetAccountElements, element);
			}
			else
			{
				break;
			}
			counter = counter + 1;
		}
		counter = 1;
		while(counter <=99)
		{
			string counterString =ToString(counter);
			string element =""CONTRA""+counterString;
			bool isElementIn = OLAPElementListContainsElement(elementList, element);
			if(isElementIn)
			{
				Append(contraElements, element);
			}
			else
			{
				break;
			}
			counter = counter + 1;
		}

		OLAPDataArea premiseLevelDataDelete = OLAPCreateDataArea(connection, MainCube,
		                                                         OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                         totalTimeStringList,cycle, version,premiseLevel, stepStringList, entity, intercompanyStringList, organizationList, accountStringList, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
		
		OLAPDeleteDataArea(premiseLevelDataDelete);

		StringArray accountArray = CreateStringArray();
		OLAPDataArea activeAccountDataArea = OLAPCreateDataArea(connection, PremisesConfigurationCube,
		                                                        OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                        ""N.A."",cycle, version,entity, accountStringList, OlapDataAreaBCells);
		foreach(OLAPCell cell in activeAccountDataArea)
		{
			string acc  = OLAPCellGetElement(cell, AccountDimension);

			AppendDistinct(accountArray, acc);
		}


		foreach(string accountUsedInLoop in accountArray)
		{
			bool proceed = false;
			OLAPDataArea sourceDataCheck = OLAPCreateDataArea(connection, MainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  timeStringList,cycle, version,levelInput, stepStringList, entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceDataCheck)
			{
				proceed = true;
				break;
			}
			if(proceed)
			{
				OLAPElement accountElementUsedInLoop = OLAPGetDimensionElement(connection, AccountDimension, accountUsedInLoop);
				
				string accountType = OLAPGetStringAttribute(connection, accountElementUsedInLoop, ""ACCTYPE"");

				foreach(string contra in contraElements)
				{
					string contraAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, contra);

					if (contraAccount != """")
					{
						contraAccount = ResolveUniqueName(connection, contraAccount);
						OLAPElement contraAccountElement = OLAPGetDimensionElement(connection, AccountDimension, contraAccount);
						string contraAccountType = OLAPGetStringAttribute(connection, contraAccountElement, ""ACCTYPE"");

						string contraFactor = contra+""_FACTOR"";
						double contraFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, contraFactor);

						OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
						                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
						                                             timeStringList,cycle, version,levelInput, stepStringList, entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
						
						foreach(OLAPCell cell in sourceData)
						{
							string TimeInLoop  = OLAPCellGetElement(cell, ""BPDTIME"");
							analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
							analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
							analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
							analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
							analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
							analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
							analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
							analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
							analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
							analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
							analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
							analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
							currencyWrite= OLAPCellGetElement(cell, ""BPDCURRENCY"");
							string stepContra = OLAPCellGetElement(cell, ""BPDSTEP"");
							organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
							string intercompanyContra = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
							string primarySegmentContra = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
							string secondarySegmentContra = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
							string tertiarySegmentContra= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
							string detailContra = OLAPCellGetElement(cell, ""BPDDETAIL"");
							string levelContra = OLAPCellGetElement(cell, ""BPDLEVEL"");
							stepContra = OLAPCellGetElement(cell, ""BPDSTEP"");

							double sourceAccountValue = cell;
							double updatedSourceValue = 0;

							double contraAccountValue = sourceAccountValue*contraFactorValue;
							if (accountType != ""A"" and contraAccountType !=""A"")
							{
								contraAccountValue = contraAccountValue*-1;

							}
							if (accountType == ""A"" and contraAccountType ==""A"")
							{
								contraAccountValue = contraAccountValue*-1;

							}
							OLAPCellWriteBufferIncrementNumber(buffer, MainCube, contraAccountValue, TimeInLoop, cycle, version,premiseLevel,stepContra, entity, intercompanyContra, organization,contraAccount, currencyWrite,  detailContra, primarySegmentContra, secondarySegmentContra, tertiarySegmentContra, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							
						}
						OLAPCommitCellWriteBuffer(buffer);
					}
				}
				
				foreach(string target in targetAccountElements)
				{
					string targetPremisesElement = ""TARGET_""+target;
					if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",targetPremisesElement))
					{
						string targetAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, targetPremisesElement);
						
						if (targetAccount != """")
						{
							targetAccount = ResolveUniqueName(connection, targetAccount);
							OLAPElement targetAccountElement = OLAPGetDimensionElement(connection, AccountDimension, targetAccount);
							string targetAccountType = OLAPGetStringAttribute(connection, targetAccountElement, ""ACCTYPE"");

							string accountPeriodScopeElement = ""PERIOD_SCOPE_"" + target;
							string targetFactorElement = ""FACTOR_"" + target;
							string targetMonth = ""TARGET_MONTH_"" + target;
							
							double targetFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, targetFactorElement);

							string scope = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, accountPeriodScopeElement);
							StringArray contraTargetAccountArray = CreateStringArray();
							StringArray contraTargetAccountTypeArray = CreateStringArray();
							StringArray contraTargetFactorValueArray = CreateStringArray();

							foreach(string contra in contraElements)
							{
								string contraTargetElement = contra + ""_"" + target;
								if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",contraTargetElement))
								{
									string contraTargetAccount = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, contraTargetElement);
									if (contraTargetAccount != """")
									{
										contraTargetAccount = ResolveUniqueName(connection, contraTargetAccount);
										Append(contraTargetAccountArray, contraTargetAccount);

										OLAPElement contraTargetAccountElement = OLAPGetDimensionElement(connection, AccountDimension, contraTargetAccount);
										string contraTargetAccountType = OLAPGetStringAttribute(connection,  contraTargetAccountElement , ""ACCTYPE"");
										Append(contraTargetAccountTypeArray, contraTargetAccountType);

										string contraTargetFactor = contra+""_FACTOR_""+target;
										if(OLAPDimensionElementExists(connection, ""BPDPREMISE"",contraTargetFactor))
										{
											double contraTargetFactorValue = OLAPCellReadNumber(connection, PremisesConfigurationCube,1.0, ""N.A."", cycle, version, entity, accountUsedInLoop, contraTargetFactor);
											Append(contraTargetFactorValueArray, ToString(contraTargetFactorValue));
										}
									}
								}
							}
							StringArray targetPeriodsArray = CreateStringArray();
							string targetPeriodMonth ="""";

							foreach(string timeHelp in timeArrayHelp)
							{
								if (scope == ""YEAR"")
								{
									targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, ""CURRENT_YEAR_LAST_MONTH"");
									targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
								}
								else if (scope == ""QUARTER"")
								{
									targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, ""CURRENT_QUARTER_LAST_MONTH"");
									targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
								}
								else if (scope == ""PERIOD"")
								{
									string lag = OLAPCellReadString(connection, PremisesConfigurationCube, ""N.A."", cycle, version, entity, accountUsedInLoop, targetMonth);
									lag = lag + ""_PERIODS_LATER"";

									if(lag == ""0_PERIODS_LATER"")
									{
										targetPeriodMonth = timeHelp;
									}
									else
									{
										targetPeriodMonth = OLAPGetStringAttribute(connection,TimeDimension, timeHelp, lag);
										targetPeriodMonth = ResolveUniqueName(connection, targetPeriodMonth);
									}
								}
								Append(targetPeriodsArray, targetPeriodMonth);
							}
							int usedNumber = 0;

							foreach(string timeHelp in timeArrayHelp)
							{

								double updatedValue = 0;
								OLAPDataArea sourceDataTarget = OLAPCreateDataArea(connection, MainCube,
								                                                   OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
								                                                   timeHelp,cycle, version,levelInput, stepStringList,  entity, intercompanyStringList, organizationList, accountUsedInLoop, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);


								foreach(OLAPCell cell in sourceDataTarget)
								{
									string month  = OLAPCellGetElement(cell, ""BPDTIME"");
									analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
									analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
									analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
									analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
									analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
									analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
									analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
									analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
									analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
									analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
									analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
									analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
									organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
									string stepTarget= OLAPCellGetElement(cell, ""BPDSTEP"");
									currencyWrite= OLAPCellGetElement(cell, ""BPDCURRENCY"");
									string intercompanyTarget = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
									string primarySegmentTarget = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
									string secondarySegmentTarget = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
									string tertiarySegmentTarget= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
									string detailTarget = OLAPCellGetElement(cell, ""BPDDETAIL"");
									string levelTarget = OLAPCellGetElement(cell, ""BPDLEVEL"");
									string targetTime = GetElementByIndex(targetPeriodsArray, usedNumber);
									stepTarget= OLAPCellGetElement(cell, ""BPDSTEP"");
									double sourceAccountValue = cell;

									double targetAccountValue = sourceAccountValue*targetFactorValue;

									if (targetAccountType ==""E"")
									{
										targetAccountValue = targetAccountValue*-1;
									}
									if (accountType == ""E"" and targetAccountType ==""E"")
									{
										targetAccountValue = targetAccountValue*-1;
									}

									updatedValue = targetAccountValue;

									OLAPCellWriteBufferIncrementNumber(buffer, MainCube, targetAccountValue, targetTime, cycle, version,premiseLevel, stepTarget, entity, intercompanyTarget, organization,targetAccount, currencyWrite,  detailTarget, primarySegmentTarget, secondarySegmentTarget, tertiarySegmentTarget, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

								}
								usedNumber = usedNumber +1;
							}

							OLAPCommitCellWriteBuffer(buffer);
							
							StringList targetPeriodsList = ToStringList(targetPeriodsArray);
							Prepend(targetPeriodsList,"""");
							int x = 0;
							while(x <= Count(contraTargetAccountArray)-1)
							{

								string contraTargetAccount = GetElementByIndex(contraTargetAccountArray, x);
								string contraTargetAccountType = GetElementByIndex(contraTargetAccountTypeArray, x);
								double contraTargetFactorValue = ToDouble(GetElementByIndex(contraTargetFactorValueArray, x));
								bool isTargetEmpty = false;

								OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
								                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
								                                             targetPeriodsList,cycle, version,premiseLevel, stepStringList, entity, intercompanyStringList, organizationList, targetAccount, currencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
								foreach(OLAPCell cell in sourceData)
								{
									string time  = OLAPCellGetElement(cell, ""BPDTIME"");
									analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
									analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
									analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
									analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
									analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
									analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
									analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
									analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
									analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
									analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
									analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
									analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
									organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
									currencyWrite= OLAPCellGetElement(cell, ""BPDCURRENCY"");
									string intercompanyTarget = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
									string primarySegmentTarget = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
									string secondarySegmentTarget = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
									string tertiarySegmentTarget= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
									string detailTarget = OLAPCellGetElement(cell, ""BPDDETAIL"");
									double targetAccountValue =cell ;
									string targetTime = OLAPCellGetElement(cell, ""BPDTIME"");
									string stepTarget= OLAPCellGetElement(cell, ""BPDSTEP"");
									
									double contraTargetAccountValue = contraTargetFactorValue*targetAccountValue;

									if (targetAccountType  != ""A"" and contraTargetAccountType !=""A"")
									{
										contraTargetAccountValue = contraTargetAccountValue*-1;

									}
									if (targetAccountType == ""A"" and contraTargetAccountType ==""A"")
									{
										contraTargetAccountValue = contraTargetAccountValue*-1;

									}
									OLAPCellWriteBufferIncrementNumber(buffer, MainCube,  contraTargetAccountValue, targetTime, cycle, version,premiseLevel, stepTarget, entity, intercompanyTarget, organization,contraTargetAccount, currencyWrite,  detailTarget, primarySegmentTarget, secondarySegmentTarget, tertiarySegmentTarget, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
								}
								x = x+1;
							}
							OLAPCommitCellWriteBuffer(buffer);
						}
					}
				}
			}
			OLAPCommitCellWriteBuffer(buffer);
		}

		LogInformation(""BAPFinance_Assumptions: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	DBC95C42-4E76-4B68-A822-693FE81CE2CD	Calculate dependent accounts based on premises configuration for given account, where user do writeback	1	1	1	1576	NULL	0	45708.67501	0	0
824F9F42-CE44-4010-AB7A-8BA285550652	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_AssumptionsAll	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""3"" />
  <dependencies>
    <process process-name=""BAPFinance_Assumptions"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BAPFinance_Assumptions"", ""*""

string BAPFinance_AssumptionsAll(string database, string cycle, string version,string entity)
@Description: ""Recaculate all assumptions when some depenedent account definition is changed"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Returns: ""True, if successful."";
{

	string functionName = ""BAPFinance_Assumptions:"";
	string errorMessage = """";
	int errorCode = 0;
	string step = """";
	string stepDimension = ""BPDSTEP"";
	string organizationDimension = ""BPDORGANIZATION"";
	string mainCube =  ""BPCMAIN"";
	string premCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";*/
		string aCycle = cycle;
		string aVersion = version;
		string aEntity = entity;

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);


		StringArray levelArray = CreateStringArray();
		Append(levelArray,""INPUT_MAIN"");
		Append(levelArray,""INPUT_ORGANIZATION"");
		Append(levelArray,""INPUT_MAIN_DP"");
		Append(levelArray,""INPUT_ORGANIZATION_DP"");
		Append(levelArray,""INPUT_MAIN_DP_UN"");
		Append(levelArray,""INPUT_ORGANIZATION_DP_UN"");

		OLAPElementList stepList = OLAPGetElementList(connection,stepDimension,false);
		OLAPElementList stepListCheck = OLAPGetElementList(connection,stepDimension,true);

		//evaluating what org string and list should be used in assumtions process
		StringList orgStringListNA =  CreateStringList();
		Append(orgStringListNA,"""");
		StringList orgStringListWithoutNA =  CreateStringList();
		Append(orgStringListWithoutNA,"""");
		StringArray orgStringArray =  CreateStringArray();

		string orgNAUN = ""[BPDORGANIZATION].[N.A.].[1]"";

		OLAPElementList oList = OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true);
		StringList stringOListHelp = ToStringList(oList);

		foreach(string oHelpElement in stringOListHelp )
		{
			if(oHelpElement == ""N.A."")
			{
				Append(orgStringListNA, oHelpElement);
			}
			else
			{
				Append(orgStringListWithoutNA, oHelpElement);
				Append(orgStringArray, oHelpElement);
			}
		}
		StringArray orgStringArrayUN =  CreateStringArray();
		foreach(string org in orgStringArray)
		{
			string o = ""[BPDORGANIZATION].[""+org+""].[1]"";
			Append(orgStringArrayUN, o);
		}
		string orgAllWithoutUN = StringJoin(orgStringArrayUN, "","");

		//finding last total step
		int counter = 1;
		while(counter &lt;=9999)
		{
			string counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";


			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			
			step =""TOTAL_STEP_""+zerosString+counterString;
			bool isStepIn = OLAPElementListContainsElement(stepList, step);
			if(!isStepIn)
			{
				step =""TOTAL_STEP_""+zerosString+ToString(counter - 1);
				break;

			}
			counter = counter + 1;
		}
		StringList accountList = CreateStringList();
		Append(accountList, """");
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, premCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, cycle, version,entity, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			AppendDistinct(accountList,account);

		}

		StringList orgStringList = CreateStringList();
		string organization = """";

		foreach(string level in levelArray)
		{
			string premiseLevel = ""CALC_PREMISE"";
			if(StringContains(level,""_DP""))
			{
				premiseLevel = ""CALC_PREMISE_DP"";
			}
			if(StringContains(level,""_DP_UN""))
			{
				premiseLevel = ""CALC_PREMISE_DP_UN"";
			}

			if(StringContains(level,""ORGANIZATION""))
			{
				orgStringList = orgStringListWithoutNA;
				organization = orgAllWithoutUN;


			}
			else
			{
				orgStringList = orgStringListNA;
				organization = orgNAUN;
			}

			bool proceedSource = false;
			OLAPDataArea sourceAccountsDataCheck = OLAPCreateDataArea(connection, mainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  OlapDataAreaBCells,cycle, version,level, stepListCheck, entity, OlapDataAreaBCells, orgStringList, accountList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			foreach(OLAPCell cell in sourceAccountsDataCheck)
			{
				proceedSource = true;
				break;
			}

			bool proceed = false;
			OLAPDataArea sourceDataCheck = OLAPCreateDataArea(connection, mainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  OlapDataAreaBCells,cycle, version,premiseLevel, stepListCheck, entity, OlapDataAreaBCells, orgStringList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			foreach(OLAPCell cell in sourceDataCheck)
			{
				proceed = true;
				break;
			}
			if(proceed or proceedSource)
			{
				string result = BAPFinance_Assumptions(database, aCycle, aVersion,""[BPDSTEP].[""+step+""].[1]"", aEntity, organization, ""[BPDLEVEL].[""+level+""].[1]"",
				                                       ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"", ""[BPDANALYSIS_02].[TOTAL_ANALYSIS02].[1]"",""[BPDANALYSIS_03].[TOTAL_ANALYSIS03].[1]"",""[BPDANALYSIS_04].[TOTAL_ANALYSIS04].[1]"",""[BPDANALYSIS_05].[TOTAL_ANALYSIS05].[1]"",
				                                       ""[BPDANALYSIS_06].[TOTAL_ANALYSIS06].[1]"",""[BPDANALYSIS_07].[TOTAL_ANALYSIS07].[1]"",""[BPDANALYSIS_08].[TOTAL_ANALYSIS08].[1]"", ""[BPDANALYSIS_09].[TOTAL_ANALYSIS09].[1]"", ""[BPDANALYSIS_10].[TOTAL_ANALYSIS10].[1]"",""[BPDANALYSIS_11].[TOTAL_ANALYSIS11].[1]"", ""[BPDANALYSIS_12].[TOTAL_ANALYSIS12].[1]"");
			}

		}

		
		DataAreaDimensionFilter filter =  OLAPCreateCompositeDataAreaFilter(""WORKFLOW"", OlapDataAreaAllCells);

		OLAPDataArea sourceDataDeleteMissingCalcFlag = OLAPCreateDataArea(connection, ""WFCTRACKING"",
		                                                                  OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull ,OlapDataAreaOperatorNone, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                                  cycle, version,entity,OlapDataAreaAllCells,OlapDataAreaAllCells,OlapDataAreaAllCells,filter,OlapDataAreaAllCells,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,""Admin"",""Everyone"",""FEATURE_WF_TRACKING_MISSING_CALC"");

		OLAPDeleteDataArea(sourceDataDeleteMissingCalcFlag);
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BAPFinance_Assumptions"", ""*""

string BAPFinance_AssumptionsAll(string database, string cycle, string version,string entity)
@Description: ""Recaculate all assumptions when some depenedent account definition is changed"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Returns: ""True, if successful."";
{

	string functionName = ""BAPFinance_Assumptions:"";
	string errorMessage = """";
	int errorCode = 0;
	string step = """";
	string stepDimension = ""BPDSTEP"";
	string organizationDimension = ""BPDORGANIZATION"";
	string mainCube =  ""BPCMAIN"";
	string premCube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

		/*cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";*/
		string aCycle = cycle;
		string aVersion = version;
		string aEntity = entity;

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);


		StringArray levelArray = CreateStringArray();
		Append(levelArray,""INPUT_MAIN"");
		Append(levelArray,""INPUT_ORGANIZATION"");
		Append(levelArray,""INPUT_MAIN_DP"");
		Append(levelArray,""INPUT_ORGANIZATION_DP"");
		Append(levelArray,""INPUT_MAIN_DP_UN"");
		Append(levelArray,""INPUT_ORGANIZATION_DP_UN"");

		OLAPElementList stepList = OLAPGetElementList(connection,stepDimension,false);
		OLAPElementList stepListCheck = OLAPGetElementList(connection,stepDimension,true);

		//evaluating what org string and list should be used in assumtions process
		StringList orgStringListNA =  CreateStringList();
		Append(orgStringListNA,"""");
		StringList orgStringListWithoutNA =  CreateStringList();
		Append(orgStringListWithoutNA,"""");
		StringArray orgStringArray =  CreateStringArray();

		string orgNAUN = ""[BPDORGANIZATION].[N.A.].[1]"";

		OLAPElementList oList = OLAPGetChildElementList(connection, organizationDimension, ""TOTAL_ORGANIZATION"", true);
		StringList stringOListHelp = ToStringList(oList);

		foreach(string oHelpElement in stringOListHelp )
		{
			if(oHelpElement == ""N.A."")
			{
				Append(orgStringListNA, oHelpElement);
			}
			else
			{
				Append(orgStringListWithoutNA, oHelpElement);
				Append(orgStringArray, oHelpElement);
			}
		}
		StringArray orgStringArrayUN =  CreateStringArray();
		foreach(string org in orgStringArray)
		{
			string o = ""[BPDORGANIZATION].[""+org+""].[1]"";
			Append(orgStringArrayUN, o);
		}
		string orgAllWithoutUN = StringJoin(orgStringArrayUN, "","");

		//finding last total step
		int counter = 1;
		while(counter <=9999)
		{
			string counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";


			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			
			step =""TOTAL_STEP_""+zerosString+counterString;
			bool isStepIn = OLAPElementListContainsElement(stepList, step);
			if(!isStepIn)
			{
				step =""TOTAL_STEP_""+zerosString+ToString(counter - 1);
				break;

			}
			counter = counter + 1;
		}
		StringList accountList = CreateStringList();
		Append(accountList, """");
		OLAPDataArea SourceData = OLAPCreateDataArea(connection, premCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaBCells, cycle, version,entity, OlapDataAreaBCells, OlapDataAreaBCells);


		foreach (OLAPCell cell in SourceData)
		{
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			AppendDistinct(accountList,account);

		}

		StringList orgStringList = CreateStringList();
		string organization = """";

		foreach(string level in levelArray)
		{
			string premiseLevel = ""CALC_PREMISE"";
			if(StringContains(level,""_DP""))
			{
				premiseLevel = ""CALC_PREMISE_DP"";
			}
			if(StringContains(level,""_DP_UN""))
			{
				premiseLevel = ""CALC_PREMISE_DP_UN"";
			}

			if(StringContains(level,""ORGANIZATION""))
			{
				orgStringList = orgStringListWithoutNA;
				organization = orgAllWithoutUN;


			}
			else
			{
				orgStringList = orgStringListNA;
				organization = orgNAUN;
			}

			bool proceedSource = false;
			OLAPDataArea sourceAccountsDataCheck = OLAPCreateDataArea(connection, mainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  OlapDataAreaBCells,cycle, version,level, stepListCheck, entity, OlapDataAreaBCells, orgStringList, accountList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			foreach(OLAPCell cell in sourceAccountsDataCheck)
			{
				proceedSource = true;
				break;
			}

			bool proceed = false;
			OLAPDataArea sourceDataCheck = OLAPCreateDataArea(connection, mainCube,
			                                                  OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                                  OlapDataAreaBCells,cycle, version,premiseLevel, stepListCheck, entity, OlapDataAreaBCells, orgStringList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,  OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
			
			foreach(OLAPCell cell in sourceDataCheck)
			{
				proceed = true;
				break;
			}
			if(proceed or proceedSource)
			{
				string result = BAPFinance_Assumptions(database, aCycle, aVersion,""[BPDSTEP].[""+step+""].[1]"", aEntity, organization, ""[BPDLEVEL].[""+level+""].[1]"",
				                                       ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"", ""[BPDANALYSIS_02].[TOTAL_ANALYSIS02].[1]"",""[BPDANALYSIS_03].[TOTAL_ANALYSIS03].[1]"",""[BPDANALYSIS_04].[TOTAL_ANALYSIS04].[1]"",""[BPDANALYSIS_05].[TOTAL_ANALYSIS05].[1]"",
				                                       ""[BPDANALYSIS_06].[TOTAL_ANALYSIS06].[1]"",""[BPDANALYSIS_07].[TOTAL_ANALYSIS07].[1]"",""[BPDANALYSIS_08].[TOTAL_ANALYSIS08].[1]"", ""[BPDANALYSIS_09].[TOTAL_ANALYSIS09].[1]"", ""[BPDANALYSIS_10].[TOTAL_ANALYSIS10].[1]"",""[BPDANALYSIS_11].[TOTAL_ANALYSIS11].[1]"", ""[BPDANALYSIS_12].[TOTAL_ANALYSIS12].[1]"");
			}

		}

		
		DataAreaDimensionFilter filter =  OLAPCreateCompositeDataAreaFilter(""WORKFLOW"", OlapDataAreaAllCells);

		OLAPDataArea sourceDataDeleteMissingCalcFlag = OLAPCreateDataArea(connection, ""WFCTRACKING"",
		                                                                  OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull ,OlapDataAreaOperatorNone, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                                                  cycle, version,entity,OlapDataAreaAllCells,OlapDataAreaAllCells,OlapDataAreaAllCells,filter,OlapDataAreaAllCells,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,""Admin"",""Everyone"",""FEATURE_WF_TRACKING_MISSING_CALC"");

		OLAPDeleteDataArea(sourceDataDeleteMissingCalcFlag);
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	E82C2D87-9665-413D-8918-868EBF728CFE	Recaculate all assumptions when some depenedent account definition is changed	1	1	1	1577	NULL	0	45708.67508	0	0
353D2BB0-153A-49B7-9B17-1E4D2F33F52D	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_Copy	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""levelDefault"" parameter-type=""string"" parameter-description=""The level element that holds the planning defaults."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""levelInput"" parameter-type=""string"" parameter-description=""The level element to write the differences to."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""string"" parameter-description=""The schedule detail element to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""timeCopy"" parameter-type=""string"" parameter-description=""Reference for copy action to time dimension"" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""versionCopy"" parameter-type=""string"" parameter-description=""Reference for copy action to version dimension"" parameter-order=""20"" />
  <parameter-descriptor parameter-name=""organizationRead"" parameter-type=""string"" parameter-description=""The organization element to be used for reading."" parameter-order=""21"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""22"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""23"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""24"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""25"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""26"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""27"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""28"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""29"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""30"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""31"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""32"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""33"" />
  <parameter-descriptor parameter-name=""pno"" parameter-type=""string"" parameter-description=""Finacial planning step where is this copy process initialized"" parameter-order=""34"" />
  <parameter-descriptor parameter-name=""workbook"" parameter-type=""string"" parameter-description=""Workbook where is this copy process initialized"" parameter-order=""35"" />
  <parameter-descriptor parameter-name=""workbookType"" parameter-type=""string"" parameter-description=""Workbook type of workbook where is this copy process initialized"" parameter-order=""36"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Copy(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite,  string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail, string timeCopy, string versionCopy,  string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12, string pno, string workbook, string workbookType)
@Description: ""Copy values from selected time, and version, and run assumptions if they are defined for concrete account"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[timeCopy]: ""Reference for copy action to time dimension"";
@Parameter[versionCopy]: ""Reference for copy action to version dimension"";
@Parameter[organizationRead]:""The organization element to be used for reading."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Parameter[pno]: ""Finacial planning step where is this copy process initialized"";
@Parameter[workbook]: ""Workbook where is this copy process initialized"";
@Parameter[workbookType]: ""Workbook type of workbook where is this copy process initialized"";
@Returns: ""True, if successful."";
{

	string functionName = ""BAPFinance_Copy:"";
	string errorMessage = """";
	int errorCode = 0;
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	string MainConfigCube = ""BPCCONFIG_MAIN"";
	string StepDimension = ""BPDSTEP"";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string CurrencyDimension = ""BPDCURRENCY"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string widgetDimension = ""WWDWIDGET"";
	string levelDimension = ""BPDLEVEL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string parameterDimension = ""BPDPARAMETER"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string workbookCube = ""WWCWORKBOOK"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	LogInformation(""BAPWriteBack_Copy: Starting process"");
	
	try {
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[TOTAL_PARTNER].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[L110400].[1]"";
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		primarySegment=""[BPDPSEGMENT].[TOTAL_SEGMENT].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[TOTAL_SEGMENT].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[TOTAL_SEGMENT].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL].[1]"";
		timeCopy=""[BPDTIME].[2017].[1]"";
		versionCopy=""[BPDVERSION].[ACTUAL_CONS].[1]"";
		organizationRead=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[TOTAL_ANALYSIS02].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[TOTAL_ANALYSIS03].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[TOTAL_ANALYSIS04].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[TOTAL_ANALYSIS05].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[TOTAL_ANALYSIS06].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[TOTAL_ANALYSIS07].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[TOTAL_ANALYSIS08].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[TOTAL_ANALYSIS09].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[TOTAL_ANALYSIS10].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[TOTAL_ANALYSIS11].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[TOTAL_ANALYSIS12].[1]"";
		pno = ""[BPDNO].[PNO_002].[1]"";
		workbook = ""[WWDWORKBOOK].[WORKBOOK_001].[1]"";
		workbookType = ""[WWDTYPE].[FINANCE].[1]"";*/

		// get native ids from the XMLA names
		time = ResolveUniqueName(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		stepRead = ResolveUniqueName(connection, stepRead);
		stepWrite = ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);
		timeCopy = ResolveUniqueName(connection, timeCopy);
		versionCopy = ResolveUniqueName(connection, versionCopy);
		pno = ResolveUniqueName(connection, pno);
		workbook = ResolveUniqueName(connection, workbook);
		workbookType = ResolveUniqueName(connection, workbookType);


		//necessary for checking wich analzsis dims arre activated
		StringArray dimensionArray= CreateStringArray();

		OLAPElementList widgetList = OLAPGetChildElementList(connection,widgetDimension , ""WB_CONFIG_ANALYSIS_DIMENSIONS"", true);
		StringList widgetListHelp = ToStringList(widgetList);

		foreach(string widgetElement in widgetListHelp)
		{
			string widgetValue = OLAPCellReadString(connection, workbookCube, NA, NA, workbook,widgetElement, NA,workbookType,""FEATURE_WW_WIDGET_OBJECTS_GLOBAL_ANALYSIS_DIMENSION"",""Text Value"");
			int lenghString = StringLength(widgetValue);
			if(lenghString &gt; 0)
			{
				int whereBPCMAIN = StringFind(widgetValue, ""BPCMAIN"",0);
				string dimension = StringSubstring(widgetValue, whereBPCMAIN + 10, lenghString - (whereBPCMAIN + 11));
				Append(dimensionArray, dimension);
			}
		}

		OLAPElement timeElementCopy = OLAPGetDimensionElement(connection, TimeDimension, timeCopy);
		bool baseTimeElementCopy = OLAPIsBaseElement(connection, timeElementCopy);
		OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
		bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;


		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}

		OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
		OLAPElement analysis1Element = OLAPGetDimensionElement(connection, analysis1Dimension, analysis1);
		OLAPElement analysis2Element = OLAPGetDimensionElement(connection, analysis2Dimension, analysis2);
		OLAPElement analysis3Element = OLAPGetDimensionElement(connection, analysis3Dimension, analysis3);
		OLAPElement analysis4Element = OLAPGetDimensionElement(connection, analysis4Dimension, analysis4);
		OLAPElement analysis5Element = OLAPGetDimensionElement(connection, analysis5Dimension, analysis5);
		OLAPElement analysis6Element = OLAPGetDimensionElement(connection, analysis6Dimension, analysis6);
		OLAPElement analysis7Element = OLAPGetDimensionElement(connection, analysis7Dimension, analysis7);
		OLAPElement analysis8Element = OLAPGetDimensionElement(connection, analysis8Dimension, analysis8);
		OLAPElement analysis9Element = OLAPGetDimensionElement(connection, analysis9Dimension, analysis9);
		OLAPElement analysis10Element = OLAPGetDimensionElement(connection, analysis10Dimension, analysis10);
		OLAPElement analysis11Element = OLAPGetDimensionElement(connection, analysis11Dimension, analysis11);
		OLAPElement analysis12Element = OLAPGetDimensionElement(connection, analysis12Dimension, analysis12);
		OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organizationRead);

		bool baseaccountElement = OLAPIsBaseElement(connection, accountElement);
		bool baseAnalysis1Element = OLAPIsBaseElement(connection, analysis1Element);
		bool baseAnalysis2Element = OLAPIsBaseElement(connection, analysis2Element);
		bool baseAnalysis3Element = OLAPIsBaseElement(connection, analysis3Element);
		bool baseAnalysis4Element = OLAPIsBaseElement(connection, analysis4Element);
		bool baseAnalysis5Element = OLAPIsBaseElement(connection, analysis5Element);
		bool baseAnalysis6Element = OLAPIsBaseElement(connection, analysis6Element);
		bool baseAnalysis7Element = OLAPIsBaseElement(connection, analysis7Element);
		bool baseAnalysis8Element = OLAPIsBaseElement(connection, analysis8Element);
		bool baseAnalysis9Element = OLAPIsBaseElement(connection, analysis9Element);
		bool baseAnalysis10Element = OLAPIsBaseElement(connection, analysis10Element);
		bool baseAnalysis11Element = OLAPIsBaseElement(connection, analysis11Element);
		bool baseAnalysis12Element = OLAPIsBaseElement(connection, analysis12Element);
		bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);

		StringArray accountArrayHelp = CreateStringArray();

		if(baseaccountElement)
		{
			
			Append(accountArrayHelp, account);

		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);

			foreach(string accountOLAPElement in accountStringListHelp )
			{
				double originalSourceValueCAccount = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompany, organization,accountOLAPElement, currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(originalSourceValueCAccount!=0)
				{
					Append(accountArrayHelp, accountOLAPElement);
				}

			}
		}
		double isOrgActivated =  OLAPCellReadNumber(connection, MainConfigCube, 1.0,cycle, version,entity,NA,NA, pno,""SUBPLAN_FINANCE_ACTIVE_ORGANIZATION"", ""Value"");

		StringList stepStringList = BP_GetChildStringListOrItself(connection, StepDimension, stepRead,true,true);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organizationRead,true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, account,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelDefault,true,true);
		StringList intercompanyStringList =  BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegmentRead,true,true);
		StringList timeStringListCopy = BP_GetChildStringListOrItself(connection, TimeDimension, timeCopy,true,true);
		StringList timeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, time,true,true);


		double isAnal1Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS01"",""Value"");
		double isAnal1ActivatedinLoop = 0;
		if (isAnal1Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_01"")
				{
					isAnal1ActivatedinLoop = 1;

				}
			}
		}

		// fill elements to analysis 1 dimension
		StringArray Analysis1Array = CreateStringArray();
		Append(Analysis1Array, """");

		if(baseAnalysis1Element)
		{
			
			Append(Analysis1Array, analysis1);

		}
		else
		{
			OLAPElementList Analysis1List = OLAPGetChildElementList(connection, analysis1Dimension, analysis1, true);
			StringList Analysis1StringListHelp = ToStringList(Analysis1List);

			foreach(string Analysis1OLAPElement in Analysis1StringListHelp )
			{
				Append(Analysis1Array, Analysis1OLAPElement);
			}
		}


		StringList Analysis1StringList = ToStringList(Analysis1Array);
		double isAnal2Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS02"",""Value"");
		double isAnal2ActivatedinLoop = 0;
		if (isAnal2Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_02"")
				{
					isAnal2ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 2 array and convert it to string list to use in data area
		StringArray Analysis2Array = CreateStringArray();
		Append(Analysis2Array, """");
		if(baseAnalysis2Element)
		{
			Append(Analysis2Array, analysis2);

		}
		else
		{
			OLAPElementList Analysis2List = OLAPGetChildElementList(connection, analysis2Dimension, analysis2, true);
			foreach(OLAPElement Analysis2OLAPElement in Analysis2List )
			{
				Append(Analysis2Array, Analysis2OLAPElement);
			}

		}
		StringList Analysis2StringList = ToStringList(Analysis2Array);
		double isAnal3Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS03"",""Value"");
		double isAnal3ActivatedinLoop = 0;
		if (isAnal3Activated == 1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_03"")
				{
					isAnal3ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 3 array and convert it to string list to use in data area
		StringArray Analysis3Array = CreateStringArray();
		Append(Analysis3Array, """");
		if(baseAnalysis3Element)
		{
			Append(Analysis3Array, analysis3);

		}
		else
		{
			OLAPElementList Analysis3List = OLAPGetChildElementList(connection, analysis3Dimension, analysis3, true);
			foreach(OLAPElement Analysis3OLAPElement in Analysis3List )
			{
				Append(Analysis3Array, Analysis3OLAPElement);
			}

		}
		StringList Analysis3StringList = ToStringList(Analysis3Array);
		
		double isAnal4Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS04"",""Value"");
		double isAnal4ActivatedinLoop = 0;
		if (isAnal4Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_04"")
				{
					isAnal4ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 4 array and convert it to string list to use in data area
		StringArray Analysis4Array = CreateStringArray();
		Append(Analysis4Array, """");
		if(baseAnalysis4Element)
		{
			Append(Analysis4Array, analysis4);

		}
		else
		{
			OLAPElementList Analysis4List = OLAPGetChildElementList(connection, analysis4Dimension, analysis4, true);
			foreach(OLAPElement Analysis4OLAPElement in Analysis4List )
			{
				Append(Analysis4Array, Analysis4OLAPElement);
			}

		}
		StringList Analysis4StringList = ToStringList(Analysis4Array);

		double isAnal5Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS05"",""Value"");
		double isAnal5ActivatedinLoop = 0;
		if (isAnal5Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_05"")
				{
					isAnal5ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 5 array and convert it to string list to use in data area
		StringArray Analysis5Array = CreateStringArray();
		Append(Analysis5Array, """");
		if(baseAnalysis5Element)
		{
			Append(Analysis5Array, analysis5);

		}
		else
		{
			OLAPElementList Analysis5List = OLAPGetChildElementList(connection, analysis5Dimension, analysis5, true);
			foreach(OLAPElement Analysis5OLAPElement in Analysis5List )
			{
				Append(Analysis5Array, Analysis5OLAPElement);
			}

		}
		
		StringList Analysis5StringList = ToStringList(Analysis5Array);

		double isAnal6Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS06"",""Value"");
		double isAnal6ActivatedinLoop = 0;
		if (isAnal6Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_06"")
				{
					isAnal6ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 6 array and convert it to string list to use in data area
		StringArray Analysis6Array = CreateStringArray();
		Append(Analysis6Array, """");
		if(baseAnalysis6Element)
		{
			Append(Analysis6Array, analysis6);

		}
		else
		{
			OLAPElementList Analysis6List = OLAPGetChildElementList(connection, analysis6Dimension, analysis6, true);
			foreach(OLAPElement Analysis6OLAPElement in Analysis6List )
			{
				Append(Analysis6Array, Analysis6OLAPElement);
			}

		}
		StringList Analysis6StringList = ToStringList(Analysis6Array);

		double isAnal7Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS07"",""Value"");
		double isAnal7ActivatedinLoop = 0;
		if (isAnal7Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_07"")
				{
					isAnal7ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 7 array and convert it to string list to use in data area
		StringArray Analysis7Array = CreateStringArray();
		Append(Analysis7Array, """");

		if(baseAnalysis7Element)
		{
			Append(Analysis7Array, analysis7);

		}
		else
		{
			OLAPElementList Analysis7List = OLAPGetChildElementList(connection, analysis7Dimension, analysis7, true);
			foreach(OLAPElement Analysis7OLAPElement in Analysis7List )
			{
				Append(Analysis7Array, Analysis7OLAPElement);
			}

		}
		StringList Analysis7StringList = ToStringList(Analysis7Array);

		double isAnal8Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS08"",""Value"");
		double isAnal8ActivatedinLoop = 0;
		if (isAnal8Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_08"")
				{
					isAnal8ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 8 array and convert it to string list to use in data area
		StringArray Analysis8Array = CreateStringArray();
		Append(Analysis8Array, """");
		if(baseAnalysis8Element)
		{
			Append(Analysis8Array, analysis8);

		}
		else
		{
			OLAPElementList Analysis8List = OLAPGetChildElementList(connection, analysis8Dimension, analysis8, true);
			foreach(OLAPElement Analysis8OLAPElement in Analysis8List )
			{
				Append(Analysis8Array, Analysis8OLAPElement);
			}

		}
		StringList Analysis8StringList = ToStringList(Analysis8Array);

		double isAnal9Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS09"",""Value"");
		double isAnal9ActivatedinLoop = 0;
		if (isAnal9Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_09"")
				{
					isAnal9ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 9 array and convert it to string list to use in data area
		StringArray Analysis9Array = CreateStringArray();
		Append(Analysis9Array, """");
		if(baseAnalysis9Element)
		{
			Append(Analysis9Array, analysis9);

		}
		else
		{
			OLAPElementList Analysis9List = OLAPGetChildElementList(connection, analysis9Dimension, analysis9, true);
			foreach(OLAPElement Analysis9OLAPElement in Analysis9List )
			{
				Append(Analysis9Array, Analysis9OLAPElement);"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Copy(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite,  string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail, string timeCopy, string versionCopy,  string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12, string pno, string workbook, string workbookType)
@Description: ""Copy values from selected time, and version, and run assumptions if they are defined for concrete account"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[timeCopy]: ""Reference for copy action to time dimension"";
@Parameter[versionCopy]: ""Reference for copy action to version dimension"";
@Parameter[organizationRead]:""The organization element to be used for reading."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Parameter[pno]: ""Finacial planning step where is this copy process initialized"";
@Parameter[workbook]: ""Workbook where is this copy process initialized"";
@Parameter[workbookType]: ""Workbook type of workbook where is this copy process initialized"";
@Returns: ""True, if successful."";
{

	string functionName = ""BAPFinance_Copy:"";
	string errorMessage = """";
	int errorCode = 0;
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	string MainConfigCube = ""BPCCONFIG_MAIN"";
	string StepDimension = ""BPDSTEP"";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string CurrencyDimension = ""BPDCURRENCY"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string widgetDimension = ""WWDWIDGET"";
	string levelDimension = ""BPDLEVEL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string parameterDimension = ""BPDPARAMETER"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string workbookCube = ""WWCWORKBOOK"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	LogInformation(""BAPWriteBack_Copy: Starting process"");
	
	try {
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[TOTAL_PARTNER].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[L110400].[1]"";
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		primarySegment=""[BPDPSEGMENT].[TOTAL_SEGMENT].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[TOTAL_SEGMENT].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[TOTAL_SEGMENT].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL].[1]"";
		timeCopy=""[BPDTIME].[2017].[1]"";
		versionCopy=""[BPDVERSION].[ACTUAL_CONS].[1]"";
		organizationRead=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[TOTAL_ANALYSIS01].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[TOTAL_ANALYSIS02].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[TOTAL_ANALYSIS03].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[TOTAL_ANALYSIS04].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[TOTAL_ANALYSIS05].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[TOTAL_ANALYSIS06].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[TOTAL_ANALYSIS07].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[TOTAL_ANALYSIS08].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[TOTAL_ANALYSIS09].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[TOTAL_ANALYSIS10].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[TOTAL_ANALYSIS11].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[TOTAL_ANALYSIS12].[1]"";
		pno = ""[BPDNO].[PNO_002].[1]"";
		workbook = ""[WWDWORKBOOK].[WORKBOOK_001].[1]"";
		workbookType = ""[WWDTYPE].[FINANCE].[1]"";*/

		// get native ids from the XMLA names
		time = ResolveUniqueName(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		stepRead = ResolveUniqueName(connection, stepRead);
		stepWrite = ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);
		timeCopy = ResolveUniqueName(connection, timeCopy);
		versionCopy = ResolveUniqueName(connection, versionCopy);
		pno = ResolveUniqueName(connection, pno);
		workbook = ResolveUniqueName(connection, workbook);
		workbookType = ResolveUniqueName(connection, workbookType);


		//necessary for checking wich analzsis dims arre activated
		StringArray dimensionArray= CreateStringArray();

		OLAPElementList widgetList = OLAPGetChildElementList(connection,widgetDimension , ""WB_CONFIG_ANALYSIS_DIMENSIONS"", true);
		StringList widgetListHelp = ToStringList(widgetList);

		foreach(string widgetElement in widgetListHelp)
		{
			string widgetValue = OLAPCellReadString(connection, workbookCube, NA, NA, workbook,widgetElement, NA,workbookType,""FEATURE_WW_WIDGET_OBJECTS_GLOBAL_ANALYSIS_DIMENSION"",""Text Value"");
			int lenghString = StringLength(widgetValue);
			if(lenghString > 0)
			{
				int whereBPCMAIN = StringFind(widgetValue, ""BPCMAIN"",0);
				string dimension = StringSubstring(widgetValue, whereBPCMAIN + 10, lenghString - (whereBPCMAIN + 11));
				Append(dimensionArray, dimension);
			}
		}

		OLAPElement timeElementCopy = OLAPGetDimensionElement(connection, TimeDimension, timeCopy);
		bool baseTimeElementCopy = OLAPIsBaseElement(connection, timeElementCopy);
		OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
		bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;


		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}

		OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
		OLAPElement analysis1Element = OLAPGetDimensionElement(connection, analysis1Dimension, analysis1);
		OLAPElement analysis2Element = OLAPGetDimensionElement(connection, analysis2Dimension, analysis2);
		OLAPElement analysis3Element = OLAPGetDimensionElement(connection, analysis3Dimension, analysis3);
		OLAPElement analysis4Element = OLAPGetDimensionElement(connection, analysis4Dimension, analysis4);
		OLAPElement analysis5Element = OLAPGetDimensionElement(connection, analysis5Dimension, analysis5);
		OLAPElement analysis6Element = OLAPGetDimensionElement(connection, analysis6Dimension, analysis6);
		OLAPElement analysis7Element = OLAPGetDimensionElement(connection, analysis7Dimension, analysis7);
		OLAPElement analysis8Element = OLAPGetDimensionElement(connection, analysis8Dimension, analysis8);
		OLAPElement analysis9Element = OLAPGetDimensionElement(connection, analysis9Dimension, analysis9);
		OLAPElement analysis10Element = OLAPGetDimensionElement(connection, analysis10Dimension, analysis10);
		OLAPElement analysis11Element = OLAPGetDimensionElement(connection, analysis11Dimension, analysis11);
		OLAPElement analysis12Element = OLAPGetDimensionElement(connection, analysis12Dimension, analysis12);
		OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organizationRead);

		bool baseaccountElement = OLAPIsBaseElement(connection, accountElement);
		bool baseAnalysis1Element = OLAPIsBaseElement(connection, analysis1Element);
		bool baseAnalysis2Element = OLAPIsBaseElement(connection, analysis2Element);
		bool baseAnalysis3Element = OLAPIsBaseElement(connection, analysis3Element);
		bool baseAnalysis4Element = OLAPIsBaseElement(connection, analysis4Element);
		bool baseAnalysis5Element = OLAPIsBaseElement(connection, analysis5Element);
		bool baseAnalysis6Element = OLAPIsBaseElement(connection, analysis6Element);
		bool baseAnalysis7Element = OLAPIsBaseElement(connection, analysis7Element);
		bool baseAnalysis8Element = OLAPIsBaseElement(connection, analysis8Element);
		bool baseAnalysis9Element = OLAPIsBaseElement(connection, analysis9Element);
		bool baseAnalysis10Element = OLAPIsBaseElement(connection, analysis10Element);
		bool baseAnalysis11Element = OLAPIsBaseElement(connection, analysis11Element);
		bool baseAnalysis12Element = OLAPIsBaseElement(connection, analysis12Element);
		bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);

		StringArray accountArrayHelp = CreateStringArray();

		if(baseaccountElement)
		{
			
			Append(accountArrayHelp, account);

		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);

			foreach(string accountOLAPElement in accountStringListHelp )
			{
				double originalSourceValueCAccount = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompany, organization,accountOLAPElement, currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(originalSourceValueCAccount!=0)
				{
					Append(accountArrayHelp, accountOLAPElement);
				}

			}
		}
		double isOrgActivated =  OLAPCellReadNumber(connection, MainConfigCube, 1.0,cycle, version,entity,NA,NA, pno,""SUBPLAN_FINANCE_ACTIVE_ORGANIZATION"", ""Value"");

		StringList stepStringList = BP_GetChildStringListOrItself(connection, StepDimension, stepRead,true,true);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organizationRead,true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, account,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelDefault,true,true);
		StringList intercompanyStringList =  BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegmentRead,true,true);
		StringList timeStringListCopy = BP_GetChildStringListOrItself(connection, TimeDimension, timeCopy,true,true);
		StringList timeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, time,true,true);


		double isAnal1Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS01"",""Value"");
		double isAnal1ActivatedinLoop = 0;
		if (isAnal1Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_01"")
				{
					isAnal1ActivatedinLoop = 1;

				}
			}
		}

		// fill elements to analysis 1 dimension
		StringArray Analysis1Array = CreateStringArray();
		Append(Analysis1Array, """");

		if(baseAnalysis1Element)
		{
			
			Append(Analysis1Array, analysis1);

		}
		else
		{
			OLAPElementList Analysis1List = OLAPGetChildElementList(connection, analysis1Dimension, analysis1, true);
			StringList Analysis1StringListHelp = ToStringList(Analysis1List);

			foreach(string Analysis1OLAPElement in Analysis1StringListHelp )
			{
				Append(Analysis1Array, Analysis1OLAPElement);
			}
		}


		StringList Analysis1StringList = ToStringList(Analysis1Array);
		double isAnal2Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS02"",""Value"");
		double isAnal2ActivatedinLoop = 0;
		if (isAnal2Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_02"")
				{
					isAnal2ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 2 array and convert it to string list to use in data area
		StringArray Analysis2Array = CreateStringArray();
		Append(Analysis2Array, """");
		if(baseAnalysis2Element)
		{
			Append(Analysis2Array, analysis2);

		}
		else
		{
			OLAPElementList Analysis2List = OLAPGetChildElementList(connection, analysis2Dimension, analysis2, true);
			foreach(OLAPElement Analysis2OLAPElement in Analysis2List )
			{
				Append(Analysis2Array, Analysis2OLAPElement);
			}

		}
		StringList Analysis2StringList = ToStringList(Analysis2Array);
		double isAnal3Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS03"",""Value"");
		double isAnal3ActivatedinLoop = 0;
		if (isAnal3Activated == 1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_03"")
				{
					isAnal3ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 3 array and convert it to string list to use in data area
		StringArray Analysis3Array = CreateStringArray();
		Append(Analysis3Array, """");
		if(baseAnalysis3Element)
		{
			Append(Analysis3Array, analysis3);

		}
		else
		{
			OLAPElementList Analysis3List = OLAPGetChildElementList(connection, analysis3Dimension, analysis3, true);
			foreach(OLAPElement Analysis3OLAPElement in Analysis3List )
			{
				Append(Analysis3Array, Analysis3OLAPElement);
			}

		}
		StringList Analysis3StringList = ToStringList(Analysis3Array);
		
		double isAnal4Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS04"",""Value"");
		double isAnal4ActivatedinLoop = 0;
		if (isAnal4Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_04"")
				{
					isAnal4ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 4 array and convert it to string list to use in data area
		StringArray Analysis4Array = CreateStringArray();
		Append(Analysis4Array, """");
		if(baseAnalysis4Element)
		{
			Append(Analysis4Array, analysis4);

		}
		else
		{
			OLAPElementList Analysis4List = OLAPGetChildElementList(connection, analysis4Dimension, analysis4, true);
			foreach(OLAPElement Analysis4OLAPElement in Analysis4List )
			{
				Append(Analysis4Array, Analysis4OLAPElement);
			}

		}
		StringList Analysis4StringList = ToStringList(Analysis4Array);

		double isAnal5Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS05"",""Value"");
		double isAnal5ActivatedinLoop = 0;
		if (isAnal5Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_05"")
				{
					isAnal5ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 5 array and convert it to string list to use in data area
		StringArray Analysis5Array = CreateStringArray();
		Append(Analysis5Array, """");
		if(baseAnalysis5Element)
		{
			Append(Analysis5Array, analysis5);

		}
		else
		{
			OLAPElementList Analysis5List = OLAPGetChildElementList(connection, analysis5Dimension, analysis5, true);
			foreach(OLAPElement Analysis5OLAPElement in Analysis5List )
			{
				Append(Analysis5Array, Analysis5OLAPElement);
			}

		}
		
		StringList Analysis5StringList = ToStringList(Analysis5Array);

		double isAnal6Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS06"",""Value"");
		double isAnal6ActivatedinLoop = 0;
		if (isAnal6Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_06"")
				{
					isAnal6ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 6 array and convert it to string list to use in data area
		StringArray Analysis6Array = CreateStringArray();
		Append(Analysis6Array, """");
		if(baseAnalysis6Element)
		{
			Append(Analysis6Array, analysis6);

		}
		else
		{
			OLAPElementList Analysis6List = OLAPGetChildElementList(connection, analysis6Dimension, analysis6, true);
			foreach(OLAPElement Analysis6OLAPElement in Analysis6List )
			{
				Append(Analysis6Array, Analysis6OLAPElement);
			}

		}
		StringList Analysis6StringList = ToStringList(Analysis6Array);

		double isAnal7Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS07"",""Value"");
		double isAnal7ActivatedinLoop = 0;
		if (isAnal7Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_07"")
				{
					isAnal7ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 7 array and convert it to string list to use in data area
		StringArray Analysis7Array = CreateStringArray();
		Append(Analysis7Array, """");

		if(baseAnalysis7Element)
		{
			Append(Analysis7Array, analysis7);

		}
		else
		{
			OLAPElementList Analysis7List = OLAPGetChildElementList(connection, analysis7Dimension, analysis7, true);
			foreach(OLAPElement Analysis7OLAPElement in Analysis7List )
			{
				Append(Analysis7Array, Analysis7OLAPElement);
			}

		}
		StringList Analysis7StringList = ToStringList(Analysis7Array);

		double isAnal8Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS08"",""Value"");
		double isAnal8ActivatedinLoop = 0;
		if (isAnal8Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_08"")
				{
					isAnal8ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 8 array and convert it to string list to use in data area
		StringArray Analysis8Array = CreateStringArray();
		Append(Analysis8Array, """");
		if(baseAnalysis8Element)
		{
			Append(Analysis8Array, analysis8);

		}
		else
		{
			OLAPElementList Analysis8List = OLAPGetChildElementList(connection, analysis8Dimension, analysis8, true);
			foreach(OLAPElement Analysis8OLAPElement in Analysis8List )
			{
				Append(Analysis8Array, Analysis8OLAPElement);
			}

		}
		StringList Analysis8StringList = ToStringList(Analysis8Array);

		double isAnal9Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS09"",""Value"");
		double isAnal9ActivatedinLoop = 0;
		if (isAnal9Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_09"")
				{
					isAnal9ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 9 array and convert it to string list to use in data area
		StringArray Analysis9Array = CreateStringArray();
		Append(Analysis9Array, """");
		if(baseAnalysis9Element)
		{
			Append(Analysis9Array, analysis9);

		}
		else
		{
			OLAPElementList Analysis9List = OLAPGetChildElementList(connection, analysis9Dimension, analysis9, true);
			foreach(OLAPElement Analysis9OLAPElement in Analysis9List )
			{
				Append(Analysis9Array, Analysis9OLAPElement);
			}

		}
		StringList Analysis9StringList = ToStringList(Analysis9Array);

		double isAnal10Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS10"",""Value"");
		double isAnal10ActivatedinLoop = 0;
		if (isAnal10Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_10"")
				{
					isAnal10ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 10 array and convert it to string list to use in data area
		StringArray Analysis10Array = CreateStringArray();
		Append(Analysis10Array, """");
		if(baseAnalysis10Element)
		{
			Append(Analysis10Array, analysis10);

		}
		else
		{
			OLAPElementList Analysis10List = OLAPGetChildElementList(connection, analysis10Dimension, analysis10, true);
			foreach(OLAPElement Analysis10OLAPElement in Analysis10List )
			{
				Append(Analysis10Array, Analysis10OLAPElement);
			}

		}
		StringList Analysis10StringList = ToStringList(Analysis10Array);

		double isAnal11Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS11"",""Value"");
		double isAnal11ActivatedinLoop = 0;
		if (isAnal11Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_11"")
				{
					isAnal11ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 11 array and convert it to string list to use in data area
		StringArray Analysis11Array = CreateStringArray();
		Append(Analysis11Array, """");
		if(baseAnalysis11Element)
		{
			Append(Analysis11Array, analysis11);

		}
		else
		{
			OLAPElementList Analysis11List = OLAPGetChildElementList(connection, analysis11Dimension, analysis11, true);
			foreach(OLAPElement Analysis11OLAPElement in Analysis11List )
			{
				Append(Analysis11Array, Analysis11OLAPElement);
			}

		}
		StringList Analysis11StringList = ToStringList(Analysis11Array);

		double isAnal12Activated =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,cycle, version,""GLOBAL_CYCLE_ACTIVE_ANALYSIS12"",""Value"");
		double isAnal12ActivatedinLoop = 0;
		if (isAnal12Activated ==1)
		{
			foreach(string dimInArray in dimensionArray)
			{
				if(dimInArray ==""BPDANALYSIS_12"")
				{
					isAnal12ActivatedinLoop = 1;

				}
			}
		}
		// fill elements to analysis 12 array and convert it to string list to use in data area
		StringArray Analysis12Array = CreateStringArray();
		Append(Analysis12Array, """");
		if(baseAnalysis12Element)
		{
			Append(Analysis12Array, analysis12);

		}
		else
		{
			OLAPElementList Analysis12List = OLAPGetChildElementList(connection, analysis12Dimension, analysis12, true);
			foreach(OLAPElement Analysis12OLAPElement in Analysis12List )
			{
				Append(Analysis12Array, Analysis12OLAPElement);
			}

		}
		StringList Analysis12StringList = ToStringList(Analysis12Array);


		StringArray currencyArray = CreateStringArray();
		Append(currencyArray, """");
		OLAPElementList CurrencyList = OLAPGetChildElementList(connection, CurrencyDimension, ""CURRENCY_DATAENTRY"", true);
		
		foreach(OLAPElement CurrencyOLAPElement in CurrencyList )
		{
			Append(currencyArray, CurrencyOLAPElement);
		}
		StringList CurrencyStringList = ToStringList(currencyArray);

		OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull|OlapDataAreaIncludeC , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             timeStringList,cycle, version,levelStringList, stepStringList, entity,intercompanyStringList, organizationStringList , accountStringList, CurrencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

		OLAPDeleteDataArea(targetData);

		OLAPElementList monthsCopy = OLAPGetChildElementList(connection, TimeDimension, timeCopy, true);

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull|OlapDataAreaIncludeC, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             timeStringListCopy,cycle, versionCopy,levelStringList, stepStringList, entity,intercompanyStringList, organizationStringList, accountStringList, CurrencyStringList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
		

		foreach(OLAPCell cell in sourceData)
		{
			string month  = OLAPCellGetElement(cell, ""BPDTIME"");
			account  = OLAPCellGetElement(cell, ""BPDACCOUNT"");
			analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
			analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
			analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
			analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
			analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
			analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
			analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
			analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
			analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
			analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
			analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
			analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
			intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
			secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
			tertiarySegment= OLAPCellGetElement(cell, ""BPDTSEGMENT"");
			detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			string step= OLAPCellGetElement(cell, ""BPDSTEP"");
			levelDefault  = OLAPCellGetElement(cell, ""BPDLEVEL"");
			organization  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string currency  = OLAPCellGetElement(cell, ""BPDCURRENCY"");


			string monthNumber = OLAPGetStringAttribute(connection,TimeDimension, month, ""CURRENT_MONTH_ID"");
			string targetMonth = monthNumber + ""_"" + time;

			double monthSourceValue =  OLAPCellReadNumber(connection, MainCube, 1.0, month , cycle, versionCopy,levelDefault, stepRead, entity, intercompany, organization, account,currency,  detail, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10"	1	0B192518-ACC8-4C42-ADC3-8E82784C0722	Copy values from selected time, and version, and run assumptions if they are defined for concrete account	1	1	1	1578	NULL	0	45708.67503	0	0
DDC8E9EC-AED1-4D59-A8F0-FC7F01E246E4	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_Delete	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""levelDefault"" parameter-type=""string"" parameter-description=""The level element that holds the planning defaults."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""levelInput"" parameter-type=""string"" parameter-description=""The level element to write the differences to."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""string"" parameter-description=""The schedule detail element to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""organizationRead"" parameter-type=""string"" parameter-description=""The organization element to be used for reading."" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""20"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""21"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""22"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""23"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""24"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""25"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""26"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""27"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""28"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""29"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""30"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""31"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string BAPFinance_Delete(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite, string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail, string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Run delete manual adjustments dialog in data entry reports, delete ony given input level"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[organizationRead]:""The organization element to be used for reading."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Delete:"";
	string errorMessage = """";
	int errorCode = 0;
	string currencyDimension = ""BPDCURRENCY"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountDimension = ""BPDACCOUNT"";
	string timeDimension = ""BPDTIME"";
	string intercompanyDimension = ""BPDINTERCOMPANY"";
	string versionDimension = ""BPDVERSION"";
	string detailDimension = ""BPDDETAIL"";
	string segment1Dimension = ""BPDPSEGMENT"";
	string segment2Dimension = ""BPDSSEGMENT"";
	string segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";

	try {
		LogInformation(""BAPWriteBack_Delete: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		
		/*time = ""[BPDTIME].[02_2018].[1],[BPDTIME].[03_2018].[1],[BPDTIME].[Q2_2018].[1],[BPDTIME].[Q3_2018].[1],[BPDTIME].[Q4_2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[FC_FISCAL02].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[TOTAL_PARTNER].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[A110220].[1]"";
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		primarySegment=""[BPDPSEGMENT].[TOTAL_SEGMENT].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[TOTAL_SEGMENT].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[TOTAL_SEGMENT].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL].[1]"";
		organizationRead=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		// get native ids from the XMLA names
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		stepRead= ResolveUniqueName(connection, stepRead);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;
		/*string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));*/
		string step = NA;

		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}

		OLAPElementList forecastVersionList = OLAPGetChildElementList(connection,versionDimension, ""TOTAL_FORECAST"", true);
		StringList timeStringList =CreateStringList();
		if(OLAPElementListContainsElement(forecastVersionList,version))
		{
			Append(timeStringList, """");
			StringArray actualPeriodsArray = CF_ElementStringSplit(time);
			foreach(string el in actualPeriodsArray)
			{
				string element = ResolveUniqueName(connection, el);
				OLAPElement timeElement = OLAPGetDimensionElement(connection, timeDimension, element);
				bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
				if(basetimeElement )
				{
					Append(timeStringList, element);
				}
				else
				{
					OLAPElementList timeList = OLAPGetChildElementList(connection,timeDimension, element, true);
					StringList timeListHelp = ToStringList(timeList);
					foreach(string timeHelp in timeListHelp )
					{
						Append(timeStringList, timeHelp);
					}
				}
			}
		}
		else
		{
			time = ResolveUniqueName(connection, time);
			timeStringList = BP_GetChildStringListOrItself(connection, timeDimension, time,true,true);
		}

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList accountStringList = BP_GetChildStringListOrItself(connection, accountDimension, account,true,true);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, intercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, detailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, segment3Dimension, tertiarySegmentRead,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList =  BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             timeStringList,cycle, version,levelInput, stepWrite, entity, intercompanyStringList, organizationStringList, accountStringList, currenList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

		OLAPDeleteDataArea(sourceData);

		LogInformation(""BAPWriteBack_Delete: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string BAPFinance_Delete(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite, string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail, string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Run delete manual adjustments dialog in data entry reports, delete ony given input level"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[organizationRead]:""The organization element to be used for reading."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Delete:"";
	string errorMessage = """";
	int errorCode = 0;
	string currencyDimension = ""BPDCURRENCY"";
	string organizationDimension = ""BPDORGANIZATION"";
	string accountDimension = ""BPDACCOUNT"";
	string timeDimension = ""BPDTIME"";
	string intercompanyDimension = ""BPDINTERCOMPANY"";
	string versionDimension = ""BPDVERSION"";
	string detailDimension = ""BPDDETAIL"";
	string segment1Dimension = ""BPDPSEGMENT"";
	string segment2Dimension = ""BPDSSEGMENT"";
	string segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";

	try {
		LogInformation(""BAPWriteBack_Delete: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		
		/*time = ""[BPDTIME].[02_2018].[1],[BPDTIME].[03_2018].[1],[BPDTIME].[Q2_2018].[1],[BPDTIME].[Q3_2018].[1],[BPDTIME].[Q4_2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[FC_FISCAL02].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[TOTAL_PARTNER].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[A110220].[1]"";
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		primarySegment=""[BPDPSEGMENT].[TOTAL_SEGMENT].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[TOTAL_SEGMENT].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[TOTAL_SEGMENT].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL].[1]"";
		organizationRead=""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		// get native ids from the XMLA names
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		stepRead= ResolveUniqueName(connection, stepRead);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;
		/*string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));*/
		string step = NA;

		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}

		OLAPElementList forecastVersionList = OLAPGetChildElementList(connection,versionDimension, ""TOTAL_FORECAST"", true);
		StringList timeStringList =CreateStringList();
		if(OLAPElementListContainsElement(forecastVersionList,version))
		{
			Append(timeStringList, """");
			StringArray actualPeriodsArray = CF_ElementStringSplit(time);
			foreach(string el in actualPeriodsArray)
			{
				string element = ResolveUniqueName(connection, el);
				OLAPElement timeElement = OLAPGetDimensionElement(connection, timeDimension, element);
				bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
				if(basetimeElement )
				{
					Append(timeStringList, element);
				}
				else
				{
					OLAPElementList timeList = OLAPGetChildElementList(connection,timeDimension, element, true);
					StringList timeListHelp = ToStringList(timeList);
					foreach(string timeHelp in timeListHelp )
					{
						Append(timeStringList, timeHelp);
					}
				}
			}
		}
		else
		{
			time = ResolveUniqueName(connection, time);
			timeStringList = BP_GetChildStringListOrItself(connection, timeDimension, time,true,true);
		}

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList accountStringList = BP_GetChildStringListOrItself(connection, accountDimension, account,true,true);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, intercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, detailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, segment3Dimension, tertiarySegmentRead,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList =  BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             timeStringList,cycle, version,levelInput, stepWrite, entity, intercompanyStringList, organizationStringList, accountStringList, currenList, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

		OLAPDeleteDataArea(sourceData);

		LogInformation(""BAPWriteBack_Delete: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	11B9BD78-4828-46FF-9FE3-18C7F1056F18	Run delete manual adjustments dialog in data entry reports, delete ony given input level	1	1	1	1579	NULL	0	45708.67506	0	0
68DDCB40-AA59-4046-908E-E522C5B06EBE	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_LineDetailDelete	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""level"" parameter-type=""string"" parameter-description=""The level element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""step"" parameter-type=""string"" parameter-description=""The step element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""string"" parameter-description=""The N.A. for deleting value from not assigned or concrete line detail to be deleted."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""20"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""21"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""22"" />
  <dependencies>
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string  BAPFinance_LineDetailDelete(string database, string time, string cycle, string version,string level,string step,  string entity, string organization,
                                    string currency, string account, string detail, string analysis1, string analysis2, string analysis3,
                                    string analysis4,string analysis5,string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[level]: ""The level element to be used."";
@Parameter[step]: ""The step element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[detail]: ""The N.A. for deleting value from not assigned or concrete line detail to be deleted."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_LineDetailDelete: "";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	string timeDimension = ""BPDTIME"";
	string versionDimension = ""BPDVERSION"";
	string detailDimension = ""BPDDETAIL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string primarySegment = NA;
	string secondarySegment= NA;
	string tertiarySegment= NA;
	string intercompany = ""EXTERNAL"";
	string errorMessage = """";
	int errorCode = 0;

	try
	{
		LogInformation(""BAPFinance_LineDetailDelete: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		
		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[FC_FISCAL02].[1]"";//BUDGET_01FC_FISCAL01
		level = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		step= ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		account=""[BPDACCOUNT].[A110220].[1]"";
		currency=""[BPDCURRENCY].[EUR_LC].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";//""[BPDDETAIL].[N.A.].[1][BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]""
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		string detHierarchy = ResolveHierarchyName(connection, detail);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		level= ResolveUniqueName(connection, level);
		step = ResolveUniqueName(connection, step);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		account= ResolveUniqueName(connection, account);
		currency = ResolveUniqueName(connection, currency);
		detail = ResolveUniqueName(connection, detail);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string detailComParameter = OLAPCreateCompositeName(detHierarchy, detail);
		string totLineDetCom= OLAPCreateCompositeName(""TOTAL_DETAIL_LINE"", ""TOTAL_DETAIL_LINE"");

		OLAPElementList forecastVersionList = OLAPGetChildElementList(connection,versionDimension, ""TOTAL_FORECAST"", true);
		StringList timeStringList =CreateStringList();
		if(OLAPElementListContainsElement(forecastVersionList,version))
		{
			Append(timeStringList, """");
			StringArray actualPeriodsArray = CF_ElementStringSplit(time);
			foreach(string el in actualPeriodsArray)
			{
				string element = ResolveUniqueName(connection, el);
				OLAPElement timeElement = OLAPGetDimensionElement(connection, timeDimension, element);
				bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
				if(basetimeElement )
				{
					Append(timeStringList, element);
				}
				else
				{
					OLAPElementList timeList = OLAPGetChildElementList(connection,timeDimension, element, true);
					StringList timeListHelp = ToStringList(timeList);
					foreach(string timeHelp in timeListHelp )
					{
						Append(timeStringList, timeHelp);
					}
				}
			}
		}
		else
		{
			time = ResolveUniqueName(connection, time);
			timeStringList = BP_GetChildStringListOrItself(connection, timeDimension, time,true,true);
		}


		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList =  BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);
		string detailToLoop = """";

		if(detail == NA)
		{
			detailToLoop = totLineDetCom;
		}
		else
		{
			detailToLoop = NA;
		}

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                             timeStringList,cycle, version,level, step, entity, intercompany, organizationStringList, account, currency, detailComParameter, primarySegment, secondarySegment,  tertiarySegment, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

		foreach(OLAPCell cell in sourceData)
		{
			string timeDA  = OLAPCellGetElement(cell, timeDimension);
			string organizationDA  = OLAPCellGetElement(cell, organizationDimension);
			string analysis1DA = OLAPCellGetElement(cell, analysis1Dimension);
			string analysis2DA = OLAPCellGetElement(cell, analysis2Dimension);
			string analysis3DA = OLAPCellGetElement(cell, analysis3Dimension);
			string analysis4DA = OLAPCellGetElement(cell, analysis4Dimension);
			string analysis5DA = OLAPCellGetElement(cell, analysis5Dimension);
			string analysis6DA = OLAPCellGetElement(cell, analysis6Dimension);
			string analysis7DA = OLAPCellGetElement(cell, analysis7Dimension);
			string analysis8DA = OLAPCellGetElement(cell, analysis8Dimension);
			string analysis9DA = OLAPCellGetElement(cell, analysis9Dimension);
			string analysis10DA = OLAPCellGetElement(cell, analysis10Dimension);
			string analysis11DA = OLAPCellGetElement(cell, analysis11Dimension);
			string analysis12DA = OLAPCellGetElement(cell, analysis12Dimension);
			double monthValue = cell;
			double defaultMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, detailToLoop, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);

			double defaultMonthValueWrite = 0;

			if(detail != NA)
			{
				defaultMonthValueWrite = defaultMonthValue - monthValue;
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				OLAPCellWriteBufferDeleteCell(buffer, MainCube, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, detailComParameter, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				if(defaultMonthValueWrite == 0)
				{
					OLAPCellWriteBufferDeleteCell(buffer, MainCube,  timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				}
			}
			else
			{
				defaultMonthValueWrite = monthValue - (monthValue - defaultMonthValue);
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				if(defaultMonthValueWrite == 0)
				{
					OLAPCellWriteBufferDeleteCell(buffer, MainCube,  timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				}
			}
		}
		LogInformation(""BAPFinance_LineDetailDelete: Closing process"");
		OLAPCommitCellWriteBuffer(buffer);
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetChildStringListOrItself"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string  BAPFinance_LineDetailDelete(string database, string time, string cycle, string version,string level,string step,  string entity, string organization,
                                    string currency, string account, string detail, string analysis1, string analysis2, string analysis3,
                                    string analysis4,string analysis5,string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[level]: ""The level element to be used."";
@Parameter[step]: ""The step element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[account]: ""The account element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[detail]: ""The N.A. for deleting value from not assigned or concrete line detail to be deleted."";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_LineDetailDelete: "";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	string timeDimension = ""BPDTIME"";
	string versionDimension = ""BPDVERSION"";
	string detailDimension = ""BPDDETAIL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string primarySegment = NA;
	string secondarySegment= NA;
	string tertiarySegment= NA;
	string intercompany = ""EXTERNAL"";
	string errorMessage = """";
	int errorCode = 0;

	try
	{
		LogInformation(""BAPFinance_LineDetailDelete: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		
		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[FC_FISCAL02].[1]"";//BUDGET_01FC_FISCAL01
		level = ""[BPDLEVEL].[INPUT_MAIN].[1]"";
		step= ""[BPDSTEP].[STEP_0001].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		account=""[BPDACCOUNT].[A110220].[1]"";
		currency=""[BPDCURRENCY].[EUR_LC].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";//""[BPDDETAIL].[N.A.].[1][BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]""
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";*/

		string detHierarchy = ResolveHierarchyName(connection, detail);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		level= ResolveUniqueName(connection, level);
		step = ResolveUniqueName(connection, step);
		entity = ResolveUniqueName(connection, entity);
		organization = ResolveUniqueName(connection, organization);
		account= ResolveUniqueName(connection, account);
		currency = ResolveUniqueName(connection, currency);
		detail = ResolveUniqueName(connection, detail);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		string detailComParameter = OLAPCreateCompositeName(detHierarchy, detail);
		string totLineDetCom= OLAPCreateCompositeName(""TOTAL_DETAIL_LINE"", ""TOTAL_DETAIL_LINE"");

		OLAPElementList forecastVersionList = OLAPGetChildElementList(connection,versionDimension, ""TOTAL_FORECAST"", true);
		StringList timeStringList =CreateStringList();
		if(OLAPElementListContainsElement(forecastVersionList,version))
		{
			Append(timeStringList, """");
			StringArray actualPeriodsArray = CF_ElementStringSplit(time);
			foreach(string el in actualPeriodsArray)
			{
				string element = ResolveUniqueName(connection, el);
				OLAPElement timeElement = OLAPGetDimensionElement(connection, timeDimension, element);
				bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
				if(basetimeElement )
				{
					Append(timeStringList, element);
				}
				else
				{
					OLAPElementList timeList = OLAPGetChildElementList(connection,timeDimension, element, true);
					StringList timeListHelp = ToStringList(timeList);
					foreach(string timeHelp in timeListHelp )
					{
						Append(timeStringList, timeHelp);
					}
				}
			}
		}
		else
		{
			time = ResolveUniqueName(connection, time);
			timeStringList = BP_GetChildStringListOrItself(connection, timeDimension, time,true,true);
		}


		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList =  BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);
		string detailToLoop = """";

		if(detail == NA)
		{
			detailToLoop = totLineDetCom;
		}
		else
		{
			detailToLoop = NA;
		}

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
		                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
		                                             timeStringList,cycle, version,level, step, entity, intercompany, organizationStringList, account, currency, detailComParameter, primarySegment, secondarySegment,  tertiarySegment, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

		foreach(OLAPCell cell in sourceData)
		{
			string timeDA  = OLAPCellGetElement(cell, timeDimension);
			string organizationDA  = OLAPCellGetElement(cell, organizationDimension);
			string analysis1DA = OLAPCellGetElement(cell, analysis1Dimension);
			string analysis2DA = OLAPCellGetElement(cell, analysis2Dimension);
			string analysis3DA = OLAPCellGetElement(cell, analysis3Dimension);
			string analysis4DA = OLAPCellGetElement(cell, analysis4Dimension);
			string analysis5DA = OLAPCellGetElement(cell, analysis5Dimension);
			string analysis6DA = OLAPCellGetElement(cell, analysis6Dimension);
			string analysis7DA = OLAPCellGetElement(cell, analysis7Dimension);
			string analysis8DA = OLAPCellGetElement(cell, analysis8Dimension);
			string analysis9DA = OLAPCellGetElement(cell, analysis9Dimension);
			string analysis10DA = OLAPCellGetElement(cell, analysis10Dimension);
			string analysis11DA = OLAPCellGetElement(cell, analysis11Dimension);
			string analysis12DA = OLAPCellGetElement(cell, analysis12Dimension);
			double monthValue = cell;
			double defaultMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, detailToLoop, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);

			double defaultMonthValueWrite = 0;

			if(detail != NA)
			{
				defaultMonthValueWrite = defaultMonthValue - monthValue;
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				OLAPCellWriteBufferDeleteCell(buffer, MainCube, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, detailComParameter, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				if(defaultMonthValueWrite == 0)
				{
					OLAPCellWriteBufferDeleteCell(buffer, MainCube,  timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				}
			}
			else
			{
				defaultMonthValueWrite = monthValue - (monthValue - defaultMonthValue);
				OLAPCellWriteBufferWriteNumber(buffer, MainCube, defaultMonthValueWrite, timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				if(defaultMonthValueWrite == 0)
				{
					OLAPCellWriteBufferDeleteCell(buffer, MainCube,  timeDA, cycle, version,level, step, entity, intercompany, organizationDA,account, currency, NA, primarySegment, secondarySegment, tertiarySegment, analysis1DA,analysis2DA,analysis3DA,analysis4DA,analysis5DA,analysis6DA,analysis7DA,analysis8DA,analysis9DA,analysis10DA,analysis11DA,analysis12DA);
				}
			}
		}
		LogInformation(""BAPFinance_LineDetailDelete: Closing process"");
		OLAPCommitCellWriteBuffer(buffer);
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}"	1	895B28B4-C169-4DB3-BE04-C59C7FCBC299	Write 1 when user adding line detail, to make it visible, and 0 to hide line detail, and delete monthly values in default detail hierarchy from BPCMAIN cube	1	1	1	1580	NULL	0	45708.67507	0	0
F9E14AAE-C35B-48B0-A404-9036393E5502	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_Phasing	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""stepRead"" parameter-type=""string"" parameter-description=""The step element to be used for reading."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""stepWrite"" parameter-type=""string"" parameter-description=""The step element to be used for writing."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account for which the value was entered."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""levelDefault"" parameter-type=""string"" parameter-description=""The level element that holds the planning defaults."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""levelInput"" parameter-type=""string"" parameter-description=""The level element to write the differences to."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""levelPremise"" parameter-type=""string"" parameter-description=""The level to calculate the premises planning."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""16"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""17"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""18"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""string"" parameter-description=""The schedule detail element to be used."" parameter-order=""19"" />
  <parameter-descriptor parameter-name=""phasingMethod"" parameter-type=""string"" parameter-description=""Element name to identify the selected phasing method"" parameter-order=""20"" />
  <parameter-descriptor parameter-name=""phasingUser"" parameter-type=""string"" parameter-description=""Determines if the phasing method is a predefined or user defined method"" parameter-order=""21"" />
  <parameter-descriptor parameter-name=""phasingAccount"" parameter-type=""string"" parameter-description=""Account by which should be phased in case of phasing by account method"" parameter-order=""22"" />
  <parameter-descriptor parameter-name=""phaseByTotalValue"" parameter-type=""bool"" parameter-description=""if true, value is phased bz total value, if false value is phased by concrete detail value"" parameter-order=""23"" />
  <parameter-descriptor parameter-name=""organizationRead"" parameter-type=""string"" parameter-description=""Organization element to read from for difference calculation"" parameter-order=""24"" />
  <parameter-descriptor parameter-name=""analysis1"" parameter-type=""string"" parameter-description=""The analysis1 to be used."" parameter-order=""25"" />
  <parameter-descriptor parameter-name=""analysis2"" parameter-type=""string"" parameter-description=""The analysis2 to be used."" parameter-order=""26"" />
  <parameter-descriptor parameter-name=""analysis3"" parameter-type=""string"" parameter-description=""The analysis3 to be used."" parameter-order=""27"" />
  <parameter-descriptor parameter-name=""analysis4"" parameter-type=""string"" parameter-description=""The analysis4 to be used."" parameter-order=""28"" />
  <parameter-descriptor parameter-name=""analysis5"" parameter-type=""string"" parameter-description=""The analysis5 to be used."" parameter-order=""29"" />
  <parameter-descriptor parameter-name=""analysis6"" parameter-type=""string"" parameter-description=""The analysis6 to be used."" parameter-order=""30"" />
  <parameter-descriptor parameter-name=""analysis7"" parameter-type=""string"" parameter-description=""The analysis7 to be used."" parameter-order=""31"" />
  <parameter-descriptor parameter-name=""analysis8"" parameter-type=""string"" parameter-description=""The analysis8 to be used."" parameter-order=""32"" />
  <parameter-descriptor parameter-name=""analysis9"" parameter-type=""string"" parameter-description=""The analysis9 to be used."" parameter-order=""33"" />
  <parameter-descriptor parameter-name=""analysis10"" parameter-type=""string"" parameter-description=""The analysis10 to be used."" parameter-order=""34"" />
  <parameter-descriptor parameter-name=""analysis11"" parameter-type=""string"" parameter-description=""The analysis11&#x9;to be used."" parameter-order=""35"" />
  <parameter-descriptor parameter-name=""analysis12"" parameter-type=""string"" parameter-description=""The analysis12 to be used."" parameter-order=""36"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Phasing(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite, string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput, string levelPremise,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail,
	string phasingMethod, string phasingUser, string phasingAccount, bool phaseByTotalValue, string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Does phasing by defined method of selected account, do phasing if are defined dependent accounts based on assumptions configuration"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[levelPremise]: ""The level to calculate the premises planning."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[phasingMethod]: ""Element name to identify the selected phasing method"";
@Parameter[phasingUser]: ""Determines if the phasing method is a predefined or user defined method"";
@Parameter[phasingAccount]: ""Account by which should be phased in case of phasing by account method"";
@Parameter[phaseByTotalValue]: ""if true, value is phased bz total value, if false value is phased by concrete detail value"";
@Parameter[organizationRead]: ""Organization element to read from for difference calculation"";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Phasing:"";
	string errorMessage = """";
	int errorCode = 0;
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string levelDimension = ""BPDLEVEL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string MainCube = ""BPCMAIN"";
	string PhasingCube = ""BPCCONFIG_PHASING"";
	string NA = ""N.A."";
	string currencyDimension = ""BPDCURRENCY"";

	try {
		LogInformation(""BAPWriteback_Phasing: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[External].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[A110310].[1]"";//[BPDACCOUNT].[L120100].[1]
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		levelPremise=""[BPDLEVEL].[TOTAL_INPUT_ORGANIZATION].[1]"";//[BPDLEVEL].[TOTAL_INPUT_ORGANIZATION].[1]
		primarySegment=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[N.A.].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[N.A.].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";//""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]
		phasingMethod=""[BPDCONFIG_PHASING].[ALLOCATION 1].[1]"";//ACCOUNT[BPDCONFIG_PHASING].[ALLOCATION 1].[1] ACCOUNT [BPDCONFIG_PHASING].[ALLOCATION 1].[1]
		phasingUser=""Admin"";
		phasingAccount =""[BPDACCOUNT].[A110210].[1]"";
		organizationRead=""[BPDORGANIZATION].[N.A.].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";//[BPDANALYSIS_05].[Materialgrouptasks].[1]""
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";//""[BPDANALYSIS_06].[TOTAL_DP].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";//[BPDANALYSIS_12].[Ondra].[1]*/

		string detHierarchy = ResolveHierarchyName(connection, detail);
		// get native ids from the XMLA names
		time = ResolveUniqueName(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity );
		stepRead = ResolveUniqueName(connection, stepRead);
		stepWrite = ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		levelPremise = ResolveUniqueName(connection, levelPremise); // level read premise
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);
		string detailNA = """";
		if(detHierarchy != ""BPDDETAIL"")
		{
			detail = OLAPCreateCompositeName(detHierarchy, detail);
			detailNA = ""N.A."";
		}

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList  currenListForLoop = CreateStringList();

		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenListForLoop ,currency);

		}


		OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
		bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;


		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}


		// read attributes to detect the account type and if the calendar element is a base element

		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, account,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelDefault,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegmentRead,true,true);
		StringList timeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, time,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);


		OLAPElementList months = OLAPGetChildElementList(connection, TimeDimension, time, true);
		string intercompanyReadHelp="""";
		string primarySegmentReadHelp ="""";
		string secondarySegmentReadHelp = """";
		string tertiarySegmentReadHelp = """";
		string detailReadHelp ="""";

		if(phaseByTotalValue)
		{
			intercompanyReadHelp=ToString(BP_GetTopElement(connection, IntercompanyDimension));
			primarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment1Dimension));
			secondarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment2Dimension));
			tertiarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment3Dimension));
			detailReadHelp = ToString(BP_GetTopElement(connection, DetailDimension));
		}
		else
		{
			intercompanyReadHelp=intercompany;
			primarySegmentReadHelp = primarySegment;
			secondarySegmentReadHelp = secondarySegment ;
			tertiarySegmentReadHelp = tertiarySegment;
			detailReadHelp = detail;
		}
		string analysis1readHelp  = analysis1read;
		string analysis2readHelp  = analysis2read;
		string analysis3readHelp  = analysis3read;
		string analysis4readHelp  = analysis4read;
		string analysis5readHelp  = analysis5read;
		string analysis6readHelp  = analysis6read;
		string analysis7readHelp  = analysis7read;
		string analysis8readHelp  = analysis8read;
		string analysis9readHelp  = analysis9read;
		string analysis10readHelp  = analysis10read;
		string analysis11readHelp  = analysis11read;
		string analysis12readHelp  = analysis12read;

		if (phasingMethod == ""ACCOUNT"")
		{

			phasingAccount = ResolveUniqueName(connection, phasingAccount);
			foreach(string curr in currenListForLoop)
			{
				
				double totalPhasingValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompanyReadHelp, organizationRead,phasingAccount, curr, detailReadHelp, primarySegmentReadHelp, secondarySegmentReadHelp, tertiarySegmentReadHelp, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             time, cycle, version, levelDefault, stepRead, entity, intercompanyStringList, organizationStringList, accountStringList, curr, detailStringList, Segment1StringList, Segment2StringList ,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
				
				//timeStringList
				foreach(OLAPCell cell in sourceData)
				{
					organization  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					account  = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					intercompanyRead = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					primarySegmentRead = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					secondarySegmentRead = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					tertiarySegmentRead = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					detailRead = OLAPCellGetElement(cell, ""BPDDETAIL"");
					analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string currency= OLAPCellGetElement(cell, ""BPDCURRENCY"");
					
					double totalYearValue = cell;
					double phasingRatio = totalYearValue/totalPhasingValue;

					foreach (OLAPElement month in months)
					{
						double currentMonthPhasingValue = OLAPCellReadNumber(connection, MainCube, 1.0, month, cycle, version, levelDefault,stepRead, entity, intercompanyReadHelp, organizationRead, phasingAccount,curr, detailReadHelp, primarySegmentReadHelp, secondarySegmentReadHelp, tertiarySegmentReadHelp, analysis1readHelp,analysis2readHelp,analysis3readHelp,analysis4readHelp,analysis5readHelp,analysis6readHelp,analysis7readHelp,analysis8readHelp,analysis9readHelp,analysis10readHelp,analysis11readHelp,analysis12readHelp);
						
						double phasingTargetValue = currentMonthPhasingValue * phasingRatio;
						double total = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double det = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double otherValuesThanDet = total -det ;
						double valueToWrite = phasingTargetValue - otherValuesThanDet;
						if(detHierarchy != ""BPDDETAIL"")
						{
							double NAValue = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							double valueToWriteNA = NAValue - det + valueToWrite;
							OLAPCellWriteBufferWriteNumber( buffer,MainCube, valueToWriteNA, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							if (valueToWriteNA==0)
							{
								OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							}
						}

						OLAPCellWriteBufferWriteNumber( buffer, MainCube, valueToWrite, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						if (valueToWrite==0)
						{
							OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						}
					}
				}
			}

		}
		else
		{

			phasingMethod = ResolveUniqueName(connection, phasingMethod);
			StringArray phasingValues = CreateStringArray();

			foreach (OLAPElement month in months)
			{
				string currentMonthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
				
				currentMonthNumber = ""GLOBAL_NUMBER_""+currentMonthNumber;
				
				double currentMonthPhasingValue = OLAPCellReadNumber(connection, PhasingCube, 1.0, phasingUser, currentMonthNumber, phasingMethod, ""Value"");
				string result =ToString(currentMonthPhasingValue);
				Append(phasingValues,result);
			}


			double totalPhasingValue = OLAPCellReadNumber(connection, PhasingCube, 1.0, phasingUser, ""TOTAL_NUMBERS"",phasingMethod, ""Value"");
			if (totalPhasingValue &gt; 0)
			{
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             time,cycle, version,levelDefault, stepRead, entity, intercompanyStringList, organizationStringList, accountStringList, currenList, detailStringList, Segment1StringList, Segment2StringList ,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

				foreach(OLAPCell cell in sourceData)
				{
					organization  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					account  = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					intercompanyRead = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					primarySegmentRead = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					secondarySegmentRead = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					tertiarySegmentRead = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					detailRead = OLAPCellGetElement(cell, ""BPDDETAIL"");
					analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					analysis8read  = OLAPCellGetElement(cell, ""BPDA"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Phasing(
	string database, string ticket, string time, string cycle, string version,string stepRead,string stepWrite, string entity, string intercompany, string organization,
	string currencyRead, string currencyWrite, string account, string levelDefault, string levelInput, string levelPremise,
	string primarySegment, string secondarySegment, string tertiarySegment, string detail,
	string phasingMethod, string phasingUser, string phasingAccount, bool phaseByTotalValue, string organizationRead, string analysis1, string analysis2, string analysis3,string analysis4,string analysis5,
	string analysis6,string analysis7,string analysis8, string analysis9, string analysis10, string analysis11, string analysis12)
@Description: ""Does phasing by defined method of selected account, do phasing if are defined dependent accounts based on assumptions configuration"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[time]: ""The time element to be used."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[stepRead]: ""The step element to be used for reading."";
@Parameter[stepWrite]: ""The step element to be used for writing."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[account]: ""The account for which the value was entered."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[levelPremise]: ""The level to calculate the premises planning."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Parameter[detail]: ""The schedule detail element to be used."";
@Parameter[phasingMethod]: ""Element name to identify the selected phasing method"";
@Parameter[phasingUser]: ""Determines if the phasing method is a predefined or user defined method"";
@Parameter[phasingAccount]: ""Account by which should be phased in case of phasing by account method"";
@Parameter[phaseByTotalValue]: ""if true, value is phased bz total value, if false value is phased by concrete detail value"";
@Parameter[organizationRead]: ""Organization element to read from for difference calculation"";
@Parameter[analysis1]: ""The analysis1 to be used."";
@Parameter[analysis2]: ""The analysis2 to be used."";
@Parameter[analysis3]: ""The analysis3 to be used."";
@Parameter[analysis4]: ""The analysis4 to be used."";
@Parameter[analysis5]: ""The analysis5 to be used."";
@Parameter[analysis6]: ""The analysis6 to be used."";
@Parameter[analysis7]: ""The analysis7 to be used."";
@Parameter[analysis8]: ""The analysis8 to be used."";
@Parameter[analysis9]: ""The analysis9 to be used."";
@Parameter[analysis10]: ""The analysis10 to be used."";
@Parameter[analysis11]: ""The analysis11	to be used."";
@Parameter[analysis12]: ""The analysis12 to be used."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPFinance_Phasing:"";
	string errorMessage = """";
	int errorCode = 0;
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string levelDimension = ""BPDLEVEL"";
	string organizationDimension = ""BPDORGANIZATION"";
	string PremisesConfigurationCube = ""BPCCONFIG_PREMISES"";
	string MainCube = ""BPCMAIN"";
	string PhasingCube = ""BPCCONFIG_PHASING"";
	string NA = ""N.A."";
	string currencyDimension = ""BPDCURRENCY"";

	try {
		LogInformation(""BAPWriteback_Phasing: Starting process"");
		
		// create connection
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*time = ""[BPDTIME].[2018].[1]"";
		cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
		version = ""[BPDVERSION].[BUDGET_01].[1]"";
		entity= ""[BPDENTITY].[RU0001].[1]"";
		stepRead= ""[BPDSTEP].[TOTAL_STEP_0001].[1]"";
		stepWrite= ""[BPDSTEP].[STEP_0001].[1]"";
		intercompany=""[BPDINTERCOMPANY].[External].[1]"";//RU0004
		organization=""[BPDORGANIZATION].[N.A.].[1]"";
		currencyWrite= ""[BPDCURRENCY].[EUR_LC].[1]"";
		currencyRead= ""[BPDCURRENCY].[EUR].[1]"";
		account=""[BPDACCOUNT].[A110310].[1]"";//[BPDACCOUNT].[L120100].[1]
		levelDefault=""[BPDLEVEL].[TOTAL_INPUT].[1]"";
		levelInput=""[BPDLEVEL].[INPUT_MAIN].[1]"";
		levelPremise=""[BPDLEVEL].[TOTAL_INPUT_ORGANIZATION].[1]"";//[BPDLEVEL].[TOTAL_INPUT_ORGANIZATION].[1]
		primarySegment=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
		secondarySegment=""[BPDSSEGMENT].[N.A.].[1]"";//CH
		tertiarySegment=""[BPDTSEGMENT].[N.A.].[1]"";
		detail=""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]"";//""[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]
		phasingMethod=""[BPDCONFIG_PHASING].[ALLOCATION 1].[1]"";//ACCOUNT[BPDCONFIG_PHASING].[ALLOCATION 1].[1] ACCOUNT [BPDCONFIG_PHASING].[ALLOCATION 1].[1]
		phasingUser=""Admin"";
		phasingAccount =""[BPDACCOUNT].[A110210].[1]"";
		organizationRead=""[BPDORGANIZATION].[N.A.].[1]"";
		analysis1 = ""[BPDANALYSIS_01].[N.A.].[1]"";
		analysis2 = ""[BPDANALYSIS_02].[N.A.].[1]"";
		analysis3 = ""[BPDANALYSIS_03].[N.A.].[1]"";
		analysis4 = ""[BPDANALYSIS_04].[N.A.].[1]"";
		analysis5 = ""[BPDANALYSIS_05].[N.A.].[1]"";//[BPDANALYSIS_05].[Materialgrouptasks].[1]""
		analysis6 = ""[BPDANALYSIS_06].[N.A.].[1]"";//""[BPDANALYSIS_06].[TOTAL_DP].[1]"";
		analysis7 = ""[BPDANALYSIS_07].[N.A.].[1]"";
		analysis8 = ""[BPDANALYSIS_08].[N.A.].[1]"";
		analysis9 = ""[BPDANALYSIS_09].[N.A.].[1]"";
		analysis10 = ""[BPDANALYSIS_10].[N.A.].[1]"";
		analysis11 = ""[BPDANALYSIS_11].[N.A.].[1]"";
		analysis12 = ""[BPDANALYSIS_12].[N.A.].[1]"";//[BPDANALYSIS_12].[Ondra].[1]*/

		string detHierarchy = ResolveHierarchyName(connection, detail);
		// get native ids from the XMLA names
		time = ResolveUniqueName(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity );
		stepRead = ResolveUniqueName(connection, stepRead);
		stepWrite = ResolveUniqueName(connection, stepWrite);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		currencyWrite = ResolveUniqueName(connection, currencyWrite);
		account = ResolveUniqueName(connection, account);
		levelDefault = ResolveUniqueName(connection, levelDefault); // level read
		levelInput = ResolveUniqueName(connection, levelInput); // level write
		levelPremise = ResolveUniqueName(connection, levelPremise); // level read premise
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		organizationRead = ResolveUniqueName(connection, organizationRead);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);
		string detailNA = """";
		if(detHierarchy != ""BPDDETAIL"")
		{
			detail = OLAPCreateCompositeName(detHierarchy, detail);
			detailNA = ""N.A."";
		}

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList  currenListForLoop = CreateStringList();

		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenListForLoop ,currency);

		}


		OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, time);
		bool baseTimeElement = OLAPIsBaseElement(connection, timeElement);
		string intercompanyRead = ""EXTERNAL"";

		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;


		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_""))
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}


		// read attributes to detect the account type and if the calendar element is a base element

		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList accountStringList = BP_GetChildStringListOrItself(connection, AccountDimension, account,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelDefault,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompanyRead,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detailRead,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegmentRead,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegmentRead,true,true);
		StringList Segment3StringList = BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegmentRead,true,true);
		StringList timeStringList = BP_GetChildStringListOrItself(connection, TimeDimension, time,true,true);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);


		OLAPElementList months = OLAPGetChildElementList(connection, TimeDimension, time, true);
		string intercompanyReadHelp="""";
		string primarySegmentReadHelp ="""";
		string secondarySegmentReadHelp = """";
		string tertiarySegmentReadHelp = """";
		string detailReadHelp ="""";

		if(phaseByTotalValue)
		{
			intercompanyReadHelp=ToString(BP_GetTopElement(connection, IntercompanyDimension));
			primarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment1Dimension));
			secondarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment2Dimension));
			tertiarySegmentReadHelp = ToString(BP_GetTopElement(connection, Segment3Dimension));
			detailReadHelp = ToString(BP_GetTopElement(connection, DetailDimension));
		}
		else
		{
			intercompanyReadHelp=intercompany;
			primarySegmentReadHelp = primarySegment;
			secondarySegmentReadHelp = secondarySegment ;
			tertiarySegmentReadHelp = tertiarySegment;
			detailReadHelp = detail;
		}
		string analysis1readHelp  = analysis1read;
		string analysis2readHelp  = analysis2read;
		string analysis3readHelp  = analysis3read;
		string analysis4readHelp  = analysis4read;
		string analysis5readHelp  = analysis5read;
		string analysis6readHelp  = analysis6read;
		string analysis7readHelp  = analysis7read;
		string analysis8readHelp  = analysis8read;
		string analysis9readHelp  = analysis9read;
		string analysis10readHelp  = analysis10read;
		string analysis11readHelp  = analysis11read;
		string analysis12readHelp  = analysis12read;

		if (phasingMethod == ""ACCOUNT"")
		{

			phasingAccount = ResolveUniqueName(connection, phasingAccount);
			foreach(string curr in currenListForLoop)
			{
				
				double totalPhasingValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompanyReadHelp, organizationRead,phasingAccount, curr, detailReadHelp, primarySegmentReadHelp, secondarySegmentReadHelp, tertiarySegmentReadHelp, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             time, cycle, version, levelDefault, stepRead, entity, intercompanyStringList, organizationStringList, accountStringList, curr, detailStringList, Segment1StringList, Segment2StringList ,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
				
				//timeStringList
				foreach(OLAPCell cell in sourceData)
				{
					organization  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					account  = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					intercompanyRead = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					primarySegmentRead = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					secondarySegmentRead = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					tertiarySegmentRead = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					detailRead = OLAPCellGetElement(cell, ""BPDDETAIL"");
					analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string currency= OLAPCellGetElement(cell, ""BPDCURRENCY"");
					
					double totalYearValue = cell;
					double phasingRatio = totalYearValue/totalPhasingValue;

					foreach (OLAPElement month in months)
					{
						double currentMonthPhasingValue = OLAPCellReadNumber(connection, MainCube, 1.0, month, cycle, version, levelDefault,stepRead, entity, intercompanyReadHelp, organizationRead, phasingAccount,curr, detailReadHelp, primarySegmentReadHelp, secondarySegmentReadHelp, tertiarySegmentReadHelp, analysis1readHelp,analysis2readHelp,analysis3readHelp,analysis4readHelp,analysis5readHelp,analysis6readHelp,analysis7readHelp,analysis8readHelp,analysis9readHelp,analysis10readHelp,analysis11readHelp,analysis12readHelp);
						
						double phasingTargetValue = currentMonthPhasingValue * phasingRatio;
						double total = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double det = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double otherValuesThanDet = total -det ;
						double valueToWrite = phasingTargetValue - otherValuesThanDet;
						if(detHierarchy != ""BPDDETAIL"")
						{
							double NAValue = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							double valueToWriteNA = NAValue - det + valueToWrite;
							OLAPCellWriteBufferWriteNumber( buffer,MainCube, valueToWriteNA, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							if (valueToWriteNA==0)
							{
								OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							}
						}

						OLAPCellWriteBufferWriteNumber( buffer, MainCube, valueToWrite, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						if (valueToWrite==0)
						{
							OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,curr, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						}
					}
				}
			}

		}
		else
		{

			phasingMethod = ResolveUniqueName(connection, phasingMethod);
			StringArray phasingValues = CreateStringArray();

			foreach (OLAPElement month in months)
			{
				string currentMonthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
				
				currentMonthNumber = ""GLOBAL_NUMBER_""+currentMonthNumber;
				
				double currentMonthPhasingValue = OLAPCellReadNumber(connection, PhasingCube, 1.0, phasingUser, currentMonthNumber, phasingMethod, ""Value"");
				string result =ToString(currentMonthPhasingValue);
				Append(phasingValues,result);
			}


			double totalPhasingValue = OLAPCellReadNumber(connection, PhasingCube, 1.0, phasingUser, ""TOTAL_NUMBERS"",phasingMethod, ""Value"");
			if (totalPhasingValue > 0)
			{
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
				                                             OlapDataAreaIncludeB|OlapDataAreaIncludeC|OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             time,cycle, version,levelDefault, stepRead, entity, intercompanyStringList, organizationStringList, accountStringList, currenList, detailStringList, Segment1StringList, Segment2StringList ,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);

				foreach(OLAPCell cell in sourceData)
				{
					organization  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
					account  = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					intercompanyRead = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					primarySegmentRead = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					secondarySegmentRead = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					tertiarySegmentRead = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					detailRead = OLAPCellGetElement(cell, ""BPDDETAIL"");
					analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					analysis4read  = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					analysis5read  = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					string currency= OLAPCellGetElement(cell, ""BPDCURRENCY"");

					double totalYearValue = cell;
					double phasingRatio = totalYearValue/totalPhasingValue;
					
					foreach (OLAPElement month in months)
					{

						string monthString = ToString(month);
						string monthNumberString = StringSubstring(monthString, 0, 2);
						int montNumberInt = ToInt(monthNumberString);

						double currentMonthPhasingValue = ToDouble(GetElementByIndex(phasingValues, montNumberInt-1));
						double phasingTargetValue = currentMonthPhasingValue * phasingRatio;
						double total = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization, account,currency, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double det = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						double otherValuesThanDet = total -det ;
						double valueToWrite = phasingTargetValue - otherValuesThanDet;

						if(detHierarchy != ""BPDDETAIL"")
						{
							double NAValue = OLAPCellReadNumber( connection, MainCube, 1.0, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							double valueToWriteNA = NAValue - det + valueToWrite;
							OLAPCellWriteBufferWriteNumber( buffer,MainCube, valueToWriteNA, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							if (valueToWriteNA==0)
							{
								OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailNA, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
							}
						}
						OLAPCellWriteBufferWriteNumber( buffer,MainCube, valueToWrite, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						if (valueToWrite==0)
						{
							OLAPCellWriteBufferDeleteCell(buffer, MainCube, month, cycle, version,levelInput, stepWrite, entity, intercompanyRead, organization, account,currency, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
						}
					}
				}
			}
			else
			{
				LogDebug(""Phasing method does not contain allocation numbers. No action required due to unchanged data after process"");
				return """";
			}
			LogDebug(""Phasing End"");

		}
		OLAPCommitCellWriteBuffer(buffer);
		LogInformation(""BAPWriteback_Phasing: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	97924CB0-E8D3-48C6-9C68-B6EA01863482	Does phasing by defined method of selected account, do phasing if are defined dependent accounts based on assumptions configuration	1	1	1	1581	NULL	0	45708.67506	0	0
4279951F-5463-42DE-9427-AC74C1B37388	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinance_Splasher	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""parameters"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""actualPeriods"" parameter-type=""string"" parameter-description=""Comma separated string with actual periods"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""budgetPeriods"" parameter-type=""string"" parameter-description=""Comma separated string with budget periods"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""double"" parameter-description=""Value what user entered."" parameter-order=""4"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetChildStringListOrItself"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Splasher(string database, string parameters,string actualPeriods,string budgetPeriods, double value)
@Description: ""Do writeback on total column in forecast data entry, run assumptions stript if necessary"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[actualPeriods]: ""Comma separated string with actual periods"";
@Parameter[budgetPeriods]:  ""Comma separated string with budget periods"";
@Parameter[parameters]: ""The ticket to connect with."";
@Parameter[value]: ""Value what user entered."";
@Returns: ""True, if successful."";
{
	// constants used in the process
	string functionName = ""BAPFinance_Splasher:"";
	string errorMessage = """";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string currencyDimension = ""BPDCURRENCY"";
	string levelDimension = ""BPDLEVEL"";
	string stepDimension = ""BPDSTEP"";
	string organizationDimension = ""BPDORGANIZATION"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	string hierarchy= """";
	int errorCode = 0;
	string result ="""";

	try
	{
		LogInformation(""BAPFinance_Splasher: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*actualPeriods =   ""[BPDTIME].[01_2018].[1]"";
		budgetPeriods =   ""[BPDTIME].[02_2018].[1],[BPDTIME].[03_2018].[1],[BPDTIME].[04_2018].[1],[BPDTIME].[05_2018].[1],[BPDTIME].[06_2018].[1],[BPDTIME].[07_2018].[1],[BPDTIME].[08_2018].[1],[BPDTIME].[09_2018].[1],[BPDTIME].[10_2018].[1],[BPDTIME].[11_2018].[1],[BPDTIME].[12_2018].[1]"";
		parameters = ""[BPDCYCLE].[CYCLE_001].[1],[BPDVERSION].[FC_FISCAL02].[1],[BPDENTITY].[RU0001].[1],[BPDSTEP].[STEP_0001].[1],[BPDINTERCOMPANY].[TOTAL_PARTNER].[1],[BPDORGANIZATION].[N.A.].[1],[BPDCURRENCY].[EUR].[1],[BPDACCOUNT].[A110100].[1],[BPDLEVEL].[INPUT_MAIN].[1],[BPDPSEGMENT].[TOTAL_SEGMENT].[1],[BPDSSEGMENT].[TOTAL_SEGMENT].[1],[BPDTSEGMENT].[TOTAL_SEGMENT].[1],[BPDDETAIL].[TOTAL_DETAIL].[1],[BPDANALYSIS_01].[N.A.].[1],[BPDANALYSIS_02].[N.A.].[1],[BPDANALYSIS_03].[N.A.].[1],[BPDANALYSIS_04].[N.A.].[1],[BPDANALYSIS_05].[N.A.].[1],[BPDANALYSIS_06].[N.A.].[1],[BPDANALYSIS_07].[N.A.].[1],[BPDANALYSIS_08].[N.A.].[1],[BPDANALYSIS_09].[N.A.].[1],[BPDANALYSIS_10].[N.A.].[1],[BPDANALYSIS_11].[N.A.].[1],[BPDANALYSIS_12].[N.A.].[1]"";*/
		//[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]
		StringArray actualArray= CF_ElementStringSplit(actualPeriods);
		StringArray budgetArray = CF_ElementStringSplit(budgetPeriods);
		StringArray paramArray = CF_ElementStringSplit(parameters);

		string cycle = GetElementByIndex(paramArray, 0);
		string version = GetElementByIndex(paramArray, 1);
		string entity = GetElementByIndex(paramArray, 2);
		string stepWrite  = GetElementByIndex(paramArray, 3);
		string intercompany = GetElementByIndex(paramArray, 4);
		string organization = GetElementByIndex(paramArray, 5);
		string currencyRead = GetElementByIndex(paramArray, 6);
		string account = GetElementByIndex(paramArray, 7);
		string levelInput= GetElementByIndex(paramArray, 8);
		string primarySegment = GetElementByIndex(paramArray, 9);
		string secondarySegment = GetElementByIndex(paramArray, 10);
		string tertiarySegment = GetElementByIndex(paramArray, 11);
		string detail = GetElementByIndex(paramArray, 12);
		string analysis1 = GetElementByIndex(paramArray, 13);
		string analysis2 = GetElementByIndex(paramArray, 14);
		string analysis3 = GetElementByIndex(paramArray, 15);
		string analysis4 = GetElementByIndex(paramArray, 16);
		string analysis5 = GetElementByIndex(paramArray, 17);
		string analysis6 = GetElementByIndex(paramArray, 18);
		string analysis7 = GetElementByIndex(paramArray, 19);
		string analysis8 = GetElementByIndex(paramArray, 20);
		string analysis9 = GetElementByIndex(paramArray, 21);
		string analysis10 = GetElementByIndex(paramArray, 22);
		string analysis11 = GetElementByIndex(paramArray, 23);
		string analysis12 = GetElementByIndex(paramArray, 24);

		string Hcycle = cycle;
		string Hversion = version;
		string Hentity = entity;
		
		StringArray TotalPeriodsArray = CreateStringArray();
		StringArray actualPeriodsArray = CreateStringArray();
		foreach(string el in actualArray)
		{
			string element = ResolveUniqueName(connection, el);
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, element);
			bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
			if(basetimeElement )
			{
				Append(TotalPeriodsArray,element);
				Append(actualPeriodsArray, element);
			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection,TimeDimension, element, true);
				StringList timeListHelp = ToStringList(timeList);
				foreach(string timeHelp in timeListHelp )
				{
					Append(TotalPeriodsArray,timeHelp);
					Append(actualPeriodsArray, timeHelp);
				}
			}
		}
		
		StringArray budgetPeriodsArray = CreateStringArray();
		foreach(string el in budgetArray)
		{
			string element =  ResolveUniqueName(connection, el);
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, element);
			bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
			if(basetimeElement )
			{
				Append(TotalPeriodsArray,element);
				Append(budgetPeriodsArray, element);

			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection,TimeDimension, element, true);
				StringList timeListHelp = ToStringList(timeList);

				foreach(string timeHelp in timeListHelp )
				{
					Append(TotalPeriodsArray,timeHelp);
					Append(budgetPeriodsArray, timeHelp);

				}
			}
		}

		string detHierarchy = ResolveHierarchyName(connection, detail);

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		account = ResolveUniqueName(connection, account);
		levelInput = ResolveUniqueName(connection, levelInput);
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		if(detHierarchy != ""BPDDETAIL"")
		{
			detail = OLAPCreateCompositeName(detHierarchy, detail);
		}
		string stepRead= ""TOTAL_"" + stepWrite;
		string currencyWrite = currencyRead + ""_LC"";
		OLAPElement levelElementIn = OLAPGetDimensionElement(connection, levelDimension, levelInput);
		string levelDefault = OLAPGetStringAttribute(connection, levelElementIn, ""LEVELID_READ"");
		levelDefault = ResolveUniqueName(connection, levelDefault);

		string organizationRead = """";
		if(organization == ""N.A."")
		{
			organizationRead = ""TOTAL_ORGANIZATION"";
		}
		else
		{
			organizationRead = organization;
		}

		string intercompanyRead = ""EXTERNAL"";
		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;

		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
			
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_"") and detHierarchy == ""BPDDETAIL"")
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}


		OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
		bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);
		StringArray accountArray = CreateStringArray();

		if(baseAccountElement)
		{
			
			Append(accountArray, account);

		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);

			foreach(string accountOLAPElement in accountStringListHelp )
			{

				Append(accountArray, accountOLAPElement);
			}
		}
		StringList organizationArrayCheck  = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,false);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompany,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detail,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegment,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegment,true,true);
		StringList Segment3StringList =  BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegment,true,true);
		StringList stepStringList = BP_GetChildStringListOrItself(connection, stepDimension, stepRead,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelInput,true,true);
		StringList Analysis1ArrayCheck = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,false);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2ArrayCheck = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,false);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3ArrayCheck = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,false);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);

		double targetAccountValuehelp =0;
		double totalValueAll = 0;
		double calcFaktorAll = 0;
		foreach(string period in TotalPeriodsArray)
		{
			double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,account, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
			totalValueAll = totalValueAll + calcValue;
		}
		calcFaktorAll= value/totalValueAll;
		DoubleDictionary dicValues = CreateDoubleDictionary();
		foreach(string accountUsedInLoop in accountArray)
		{
			if(totalValueAll == 0)
			{
				dicValues[accountUsedInLoop] = value/Count(accountArray);
			}
			else
			{
				double totalValueAllAccounts = 0;
				calcFaktorAll= value/totalValueAll;
				foreach(string period in TotalPeriodsArray)
				{
					double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					totalValueAllAccounts = totalValueAllAccounts + calcValue;
				}
				dicValues[accountUsedInLoop] = totalValueAllAccounts*calcFaktorAll;
			}
		}

		foreach(string accountUsedInLoop in accountArray)
		{
			int index = 0;
			double originalSourceValue =0;
			bool zeroCheck = false;
			bool zerobaseCheck = false;

			foreach(string period in budgetPeriodsArray)
			{
				double calcValueZero = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(calcValueZero != 0)
				{
					zeroCheck = true;
				}
				double calcValueBaseZero = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(calcValueBaseZero != 0)
				{
					zerobaseCheck = true;
				}
			}

			bool isOriginalSourceValueZero = false;
			if(!zeroCheck or !zerobaseCheck)
			{
				foreach(string time in budgetPeriodsArray)
				{
					//originalSourceValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					originalSourceValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					if (originalSourceValue == 0)
					{
						if(detHierarchy == ""BPDDETAIL"")
						{
							OLAPSplashValue(connection, MainCube, 1, ""Equal"", false, 0, true, time, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
						}
						else
						{
							foreach(string org in organizationArrayCheck)
							{
								double checkorg =Count(organizationArrayCheck);
								double writeorg = 1/checkorg;
								foreach(string ana1 in Analysis1ArrayCheck)
								{
									double checkAna1 =Count(Analysis1ArrayCheck);
									double writeAna1 = writeorg/checkAna1;
									foreach(string ana2 in Analysis2ArrayCheck)
									{
										double checkAna2 =Count(Analysis2ArrayCheck);
										double writeAna2 = writeAna1/checkAna2;
										foreach(string ana3 in Analysis3ArrayCheck)
										{
											double checkAna3 =Count(Analysis3ArrayCheck);
											double writeAna3 = writeAna2/checkAna3;

											OLAPCellWriteNumber(connection, MainCube, writeAna3 , time, cycle, version,levelInput, stepWrite, entity, intercompany, org,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, ana1,ana2,ana3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
										}
									}
								}
							}
						}
						isOriginalSourceValueZero = true;
					}
				}
			}

			double totalValue = 0;
			double actualValue = 0;
			double budgetValue = 0;
			double budgetValueBase = 0;

			foreach(string period in TotalPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				totalValue = totalValue + calcValue;
			}
			foreach(string period in actualPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				actualValue = actualValue + calcValue;
			}
			foreach(string period in budgetPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				double calcValuebase  = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite,detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				budgetValue = budgetValue + calcValue;
				budgetValueBase = budgetValueBase + calcValuebase;
			}
			double calcFaktor = 0;

			value = dicValues[accountUsedInLoop] - actualValue ;			
			value = value - (budgetValue - budgetValueBase);
			calcFaktor = value /budgetValueBase;

			StringList periods = ToStringList(budgetPeriodsArray);
			Prepend(periods, """");

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                             periods,cycle, version,levelStringList, stepWrite, entity, intercompanyStringList, organizationStringList, accountUsedInLoop, currencyWrite, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceData)
			{
				string TimeInLoop  = OLAPCellGetElement(cell, ""BPDTIME"");
				string orgDataArea  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				analysis4read = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				analysis5read = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				double sourceAccountValue = cell;
				double updatedSourceValue = 0;
				double assValue = 0;

				if(!isOriginalSourceValueZero)
				{
					updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;

					assValue = updatedSourceValue + sourceAccountValue;
				}
				else
				{
					updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;
					assValue = updatedSourceValue + sourceAccountValue;
					if(index &gt;  0 and detHierarchy == ""BPDDETAIL"")
					{
						assValue = updatedSourceValue + sourceAccountValue + sourceAccountValue;
					}
				}
				OLAPCellWriteBufferIncrementNumber(buffer, MainCube, updatedSourceValue, TimeInLoop, cycle, version,levelInput,stepWrite, entity, intercompany, orgDataArea,accountUsedInLoop, currencyWrite,  detail, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				if(detHierarchy != ""BPDDETAIL"")
				{
					string detComposite = OLAPCreateCompositeName(""BPDDETAIL"", ""N.A."");
					if(!isOriginalSourceValueZero)
					{
						updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;

					}
					else
					{
						updatedSourceValue =(sourceAccountValue* calcFaktor);
					}
					OLAPCellWriteBufferIncrementNumber(buffer, MainCube, updatedSourceValue, TimeInLoop, cycle, version,levelInput,stepWrite, entity, intercompany, orgDataArea,accountUsedInLoop, currencyWrite,  detComposite, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				}
			}			
			OLAPCommitCellWriteBuffer(buffer);
		}
		LogInformation(""BAPFinance_Splasher: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetChildStringListOrItself"", ""*""

string BAPFinance_Splasher(string database, string parameters,string actualPeriods,string budgetPeriods, double value)
@Description: ""Do writeback on total column in forecast data entry, run assumptions stript if necessary"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[actualPeriods]: ""Comma separated string with actual periods"";
@Parameter[budgetPeriods]:  ""Comma separated string with budget periods"";
@Parameter[parameters]: ""The ticket to connect with."";
@Parameter[value]: ""Value what user entered."";
@Returns: ""True, if successful."";
{
	// constants used in the process
	string functionName = ""BAPFinance_Splasher:"";
	string errorMessage = """";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string IntercompanyDimension = ""BPDINTERCOMPANY"";
	string DetailDimension = ""BPDDETAIL"";
	string Segment1Dimension = ""BPDPSEGMENT"";
	string Segment2Dimension = ""BPDSSEGMENT"";
	string Segment3Dimension = ""BPDTSEGMENT"";
	string analysis1Dimension = ""BPDANALYSIS_01"";
	string analysis2Dimension = ""BPDANALYSIS_02"";
	string analysis3Dimension = ""BPDANALYSIS_03"";
	string analysis4Dimension = ""BPDANALYSIS_04"";
	string analysis5Dimension = ""BPDANALYSIS_05"";
	string analysis6Dimension = ""BPDANALYSIS_06"";
	string analysis7Dimension = ""BPDANALYSIS_07"";
	string analysis8Dimension = ""BPDANALYSIS_08"";
	string analysis9Dimension = ""BPDANALYSIS_09"";
	string analysis10Dimension = ""BPDANALYSIS_10"";
	string analysis11Dimension = ""BPDANALYSIS_11"";
	string analysis12Dimension = ""BPDANALYSIS_12"";
	string currencyDimension = ""BPDCURRENCY"";
	string levelDimension = ""BPDLEVEL"";
	string stepDimension = ""BPDSTEP"";
	string organizationDimension = ""BPDORGANIZATION"";
	string MainCube = ""BPCMAIN"";
	string NA = ""N.A."";
	string hierarchy= """";
	int errorCode = 0;
	string result ="""";

	try
	{
		LogInformation(""BAPFinance_Splasher: Starting process"");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*actualPeriods =   ""[BPDTIME].[01_2018].[1]"";
		budgetPeriods =   ""[BPDTIME].[02_2018].[1],[BPDTIME].[03_2018].[1],[BPDTIME].[04_2018].[1],[BPDTIME].[05_2018].[1],[BPDTIME].[06_2018].[1],[BPDTIME].[07_2018].[1],[BPDTIME].[08_2018].[1],[BPDTIME].[09_2018].[1],[BPDTIME].[10_2018].[1],[BPDTIME].[11_2018].[1],[BPDTIME].[12_2018].[1]"";
		parameters = ""[BPDCYCLE].[CYCLE_001].[1],[BPDVERSION].[FC_FISCAL02].[1],[BPDENTITY].[RU0001].[1],[BPDSTEP].[STEP_0001].[1],[BPDINTERCOMPANY].[TOTAL_PARTNER].[1],[BPDORGANIZATION].[N.A.].[1],[BPDCURRENCY].[EUR].[1],[BPDACCOUNT].[A110100].[1],[BPDLEVEL].[INPUT_MAIN].[1],[BPDPSEGMENT].[TOTAL_SEGMENT].[1],[BPDSSEGMENT].[TOTAL_SEGMENT].[1],[BPDTSEGMENT].[TOTAL_SEGMENT].[1],[BPDDETAIL].[TOTAL_DETAIL].[1],[BPDANALYSIS_01].[N.A.].[1],[BPDANALYSIS_02].[N.A.].[1],[BPDANALYSIS_03].[N.A.].[1],[BPDANALYSIS_04].[N.A.].[1],[BPDANALYSIS_05].[N.A.].[1],[BPDANALYSIS_06].[N.A.].[1],[BPDANALYSIS_07].[N.A.].[1],[BPDANALYSIS_08].[N.A.].[1],[BPDANALYSIS_09].[N.A.].[1],[BPDANALYSIS_10].[N.A.].[1],[BPDANALYSIS_11].[N.A.].[1],[BPDANALYSIS_12].[N.A.].[1]"";*/
		//[BPDDETAIL].[TOTAL_DETAIL_LINE].[DETAIL_LINE_0001].[1]
		StringArray actualArray= CF_ElementStringSplit(actualPeriods);
		StringArray budgetArray = CF_ElementStringSplit(budgetPeriods);
		StringArray paramArray = CF_ElementStringSplit(parameters);

		string cycle = GetElementByIndex(paramArray, 0);
		string version = GetElementByIndex(paramArray, 1);
		string entity = GetElementByIndex(paramArray, 2);
		string stepWrite  = GetElementByIndex(paramArray, 3);
		string intercompany = GetElementByIndex(paramArray, 4);
		string organization = GetElementByIndex(paramArray, 5);
		string currencyRead = GetElementByIndex(paramArray, 6);
		string account = GetElementByIndex(paramArray, 7);
		string levelInput= GetElementByIndex(paramArray, 8);
		string primarySegment = GetElementByIndex(paramArray, 9);
		string secondarySegment = GetElementByIndex(paramArray, 10);
		string tertiarySegment = GetElementByIndex(paramArray, 11);
		string detail = GetElementByIndex(paramArray, 12);
		string analysis1 = GetElementByIndex(paramArray, 13);
		string analysis2 = GetElementByIndex(paramArray, 14);
		string analysis3 = GetElementByIndex(paramArray, 15);
		string analysis4 = GetElementByIndex(paramArray, 16);
		string analysis5 = GetElementByIndex(paramArray, 17);
		string analysis6 = GetElementByIndex(paramArray, 18);
		string analysis7 = GetElementByIndex(paramArray, 19);
		string analysis8 = GetElementByIndex(paramArray, 20);
		string analysis9 = GetElementByIndex(paramArray, 21);
		string analysis10 = GetElementByIndex(paramArray, 22);
		string analysis11 = GetElementByIndex(paramArray, 23);
		string analysis12 = GetElementByIndex(paramArray, 24);

		string Hcycle = cycle;
		string Hversion = version;
		string Hentity = entity;
		
		StringArray TotalPeriodsArray = CreateStringArray();
		StringArray actualPeriodsArray = CreateStringArray();
		foreach(string el in actualArray)
		{
			string element = ResolveUniqueName(connection, el);
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, element);
			bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
			if(basetimeElement )
			{
				Append(TotalPeriodsArray,element);
				Append(actualPeriodsArray, element);
			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection,TimeDimension, element, true);
				StringList timeListHelp = ToStringList(timeList);
				foreach(string timeHelp in timeListHelp )
				{
					Append(TotalPeriodsArray,timeHelp);
					Append(actualPeriodsArray, timeHelp);
				}
			}
		}
		
		StringArray budgetPeriodsArray = CreateStringArray();
		foreach(string el in budgetArray)
		{
			string element =  ResolveUniqueName(connection, el);
			OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, element);
			bool basetimeElement = OLAPIsBaseElement(connection, timeElement);
			if(basetimeElement )
			{
				Append(TotalPeriodsArray,element);
				Append(budgetPeriodsArray, element);

			}
			else
			{
				OLAPElementList timeList = OLAPGetChildElementList(connection,TimeDimension, element, true);
				StringList timeListHelp = ToStringList(timeList);

				foreach(string timeHelp in timeListHelp )
				{
					Append(TotalPeriodsArray,timeHelp);
					Append(budgetPeriodsArray, timeHelp);

				}
			}
		}

		string detHierarchy = ResolveHierarchyName(connection, detail);

		cycle = ResolveUniqueName(connection, cycle);
		version = ResolveUniqueName(connection, version);
		entity = ResolveUniqueName(connection, entity);
		intercompany = ResolveUniqueName(connection, intercompany);
		organization = ResolveUniqueName(connection, organization);
		stepWrite= ResolveUniqueName(connection, stepWrite);
		currencyRead = ResolveUniqueName(connection, currencyRead);
		account = ResolveUniqueName(connection, account);
		levelInput = ResolveUniqueName(connection, levelInput);
		primarySegment = ResolveUniqueName(connection, primarySegment);
		secondarySegment = ResolveUniqueName(connection, secondarySegment);
		tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
		detail = ResolveUniqueName(connection, detail);
		analysis1 = ResolveUniqueName(connection, analysis1);
		analysis2 = ResolveUniqueName(connection, analysis2);
		analysis3 = ResolveUniqueName(connection, analysis3);
		analysis4 = ResolveUniqueName(connection, analysis4);
		analysis5 = ResolveUniqueName(connection, analysis5);
		analysis6 = ResolveUniqueName(connection, analysis6);
		analysis7 = ResolveUniqueName(connection, analysis7);
		analysis8 = ResolveUniqueName(connection, analysis8);
		analysis9 = ResolveUniqueName(connection, analysis9);
		analysis10 = ResolveUniqueName(connection, analysis10);
		analysis11 = ResolveUniqueName(connection, analysis11);
		analysis12 = ResolveUniqueName(connection, analysis12);

		if(detHierarchy != ""BPDDETAIL"")
		{
			detail = OLAPCreateCompositeName(detHierarchy, detail);
		}
		string stepRead= ""TOTAL_"" + stepWrite;
		string currencyWrite = currencyRead + ""_LC"";
		OLAPElement levelElementIn = OLAPGetDimensionElement(connection, levelDimension, levelInput);
		string levelDefault = OLAPGetStringAttribute(connection, levelElementIn, ""LEVELID_READ"");
		levelDefault = ResolveUniqueName(connection, levelDefault);

		string organizationRead = """";
		if(organization == ""N.A."")
		{
			organizationRead = ""TOTAL_ORGANIZATION"";
		}
		else
		{
			organizationRead = organization;
		}

		string intercompanyRead = ""EXTERNAL"";
		if (!StringContains(intercompany, ""EXTERNAL""))
		{
			intercompanyRead = intercompany;
		}

		string primarySegmentRead = NA;
		string secondarySegmentRead = NA;
		string tertiarySegmentRead = NA;
		string detailRead = NA;
		string analysis1read = analysis1;
		string analysis2read = analysis2;
		string analysis3read = analysis3;
		string analysis4read = analysis4;
		string analysis5read = analysis5;
		string analysis6read = analysis6;
		string analysis7read = analysis7;
		string analysis8read = analysis8;
		string analysis9read = analysis9;
		string analysis10read = analysis10;
		string analysis11read = analysis11;
		string analysis12read = analysis12;

		if (StringContains(intercompany, ""TOTAL_""))
		{
			intercompany = ""EXTERNAL"";
			
		}

		if (StringContains(primarySegment, ""TOTAL_""))
		{
			primarySegmentRead = primarySegment;
			primarySegment = NA;
		}
		else
		{
			primarySegmentRead = primarySegment;
		}

		if (StringContains(secondarySegment, ""TOTAL_""))
		{
			secondarySegmentRead = secondarySegment;
			secondarySegment = NA;
		}
		else
		{
			secondarySegmentRead = secondarySegment;
		}

		if (StringContains(tertiarySegment, ""TOTAL_""))
		{
			tertiarySegmentRead = tertiarySegment;
			tertiarySegment = NA;
		}
		else
		{
			tertiarySegmentRead = tertiarySegment;
		}

		if (StringContains(detail, ""TOTAL_"") and detHierarchy == ""BPDDETAIL"")
		{
			detailRead = detail;
			detail = NA;
		}
		else
		{
			detailRead = detail;
		}


		OLAPElement accountElement = OLAPGetDimensionElement(connection, AccountDimension, account);
		bool baseAccountElement = OLAPIsBaseElement(connection, accountElement);
		StringArray accountArray = CreateStringArray();

		if(baseAccountElement)
		{
			
			Append(accountArray, account);

		}
		else
		{
			OLAPElementList accountList = OLAPGetChildElementList(connection,AccountDimension, account, true);
			StringList accountStringListHelp = ToStringList(accountList);

			foreach(string accountOLAPElement in accountStringListHelp )
			{

				Append(accountArray, accountOLAPElement);
			}
		}
		StringList organizationArrayCheck  = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,false);
		StringList organizationStringList = BP_GetChildStringListOrItself(connection, organizationDimension, organization,true,true);
		StringList intercompanyStringList = BP_GetChildStringListOrItself(connection, IntercompanyDimension, intercompany,true,true);
		StringList detailStringList = BP_GetChildStringListOrItself(connection, DetailDimension, detail,true,true);
		StringList Segment1StringList = BP_GetChildStringListOrItself(connection, Segment1Dimension, primarySegment,true,true);
		StringList Segment2StringList = BP_GetChildStringListOrItself(connection, Segment2Dimension, secondarySegment,true,true);
		StringList Segment3StringList =  BP_GetChildStringListOrItself(connection, Segment3Dimension, tertiarySegment,true,true);
		StringList stepStringList = BP_GetChildStringListOrItself(connection, stepDimension, stepRead,true,true);
		StringList levelStringList = BP_GetChildStringListOrItself(connection, levelDimension, levelInput,true,true);
		StringList Analysis1ArrayCheck = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,false);
		StringList Analysis1StringList = BP_GetChildStringListOrItself(connection, analysis1Dimension, analysis1,true,true);
		StringList Analysis2ArrayCheck = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,false);
		StringList Analysis2StringList = BP_GetChildStringListOrItself(connection, analysis2Dimension, analysis2,true,true);
		StringList Analysis3ArrayCheck = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,false);
		StringList Analysis3StringList = BP_GetChildStringListOrItself(connection, analysis3Dimension, analysis3,true,true);
		StringList Analysis4StringList = BP_GetChildStringListOrItself(connection, analysis4Dimension, analysis4,true,true);
		StringList Analysis5StringList = BP_GetChildStringListOrItself(connection, analysis5Dimension, analysis5,true,true);
		StringList Analysis6StringList = BP_GetChildStringListOrItself(connection, analysis6Dimension, analysis6,true,true);
		StringList Analysis7StringList = BP_GetChildStringListOrItself(connection, analysis7Dimension, analysis7,true,true);
		StringList Analysis8StringList = BP_GetChildStringListOrItself(connection, analysis8Dimension, analysis8,true,true);
		StringList Analysis9StringList = BP_GetChildStringListOrItself(connection, analysis9Dimension, analysis9,true,true);
		StringList Analysis10StringList = BP_GetChildStringListOrItself(connection, analysis10Dimension, analysis10,true,true);
		StringList Analysis11StringList = BP_GetChildStringListOrItself(connection, analysis11Dimension, analysis11,true,true);
		StringList Analysis12StringList = BP_GetChildStringListOrItself(connection, analysis12Dimension, analysis12,true,true);

		double targetAccountValuehelp =0;
		double totalValueAll = 0;
		double calcFaktorAll = 0;
		foreach(string period in TotalPeriodsArray)
		{
			double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,account, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
			totalValueAll = totalValueAll + calcValue;
		}
		calcFaktorAll= value/totalValueAll;
		DoubleDictionary dicValues = CreateDoubleDictionary();
		foreach(string accountUsedInLoop in accountArray)
		{
			if(totalValueAll == 0)
			{
				dicValues[accountUsedInLoop] = value/Count(accountArray);
			}
			else
			{
				double totalValueAllAccounts = 0;
				calcFaktorAll= value/totalValueAll;
				foreach(string period in TotalPeriodsArray)
				{
					double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					totalValueAllAccounts = totalValueAllAccounts + calcValue;
				}
				dicValues[accountUsedInLoop] = totalValueAllAccounts*calcFaktorAll;
			}
		}

		foreach(string accountUsedInLoop in accountArray)
		{
			int index = 0;
			double originalSourceValue =0;
			bool zeroCheck = false;
			bool zerobaseCheck = false;

			foreach(string period in budgetPeriodsArray)
			{
				double calcValueZero = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(calcValueZero != 0)
				{
					zeroCheck = true;
				}
				double calcValueBaseZero = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				if(calcValueBaseZero != 0)
				{
					zerobaseCheck = true;
				}
			}

			bool isOriginalSourceValueZero = false;
			if(!zeroCheck or !zerobaseCheck)
			{
				foreach(string time in budgetPeriodsArray)
				{
					//originalSourceValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					originalSourceValue = OLAPCellReadNumber(connection, MainCube, 1.0, time, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
					if (originalSourceValue == 0)
					{
						if(detHierarchy == ""BPDDETAIL"")
						{
							OLAPSplashValue(connection, MainCube, 1, ""Equal"", false, 0, true, time, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
						}
						else
						{
							foreach(string org in organizationArrayCheck)
							{
								double checkorg =Count(organizationArrayCheck);
								double writeorg = 1/checkorg;
								foreach(string ana1 in Analysis1ArrayCheck)
								{
									double checkAna1 =Count(Analysis1ArrayCheck);
									double writeAna1 = writeorg/checkAna1;
									foreach(string ana2 in Analysis2ArrayCheck)
									{
										double checkAna2 =Count(Analysis2ArrayCheck);
										double writeAna2 = writeAna1/checkAna2;
										foreach(string ana3 in Analysis3ArrayCheck)
										{
											double checkAna3 =Count(Analysis3ArrayCheck);
											double writeAna3 = writeAna2/checkAna3;

											OLAPCellWriteNumber(connection, MainCube, writeAna3 , time, cycle, version,levelInput, stepWrite, entity, intercompany, org,accountUsedInLoop, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, ana1,ana2,ana3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
										}
									}
								}
							}
						}
						isOriginalSourceValueZero = true;
					}
				}
			}

			double totalValue = 0;
			double actualValue = 0;
			double budgetValue = 0;
			double budgetValueBase = 0;

			foreach(string period in TotalPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				totalValue = totalValue + calcValue;
			}
			foreach(string period in actualPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				actualValue = actualValue + calcValue;
			}
			foreach(string period in budgetPeriodsArray)
			{
				double calcValue = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelDefault, stepRead, entity, intercompanyRead, organization,accountUsedInLoop, currencyWrite, detailRead, primarySegmentRead, secondarySegmentRead, tertiarySegmentRead, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				double calcValuebase  = OLAPCellReadNumber(connection, MainCube, 1.0, period, cycle, version,levelInput, stepWrite, entity, intercompany, organization,accountUsedInLoop, currencyWrite,detail, primarySegment, secondarySegment, tertiarySegment, analysis1,analysis2,analysis3,analysis4,analysis5,analysis6,analysis7,analysis8,analysis9,analysis10,analysis11,analysis12);
				budgetValue = budgetValue + calcValue;
				budgetValueBase = budgetValueBase + calcValuebase;
			}
			double calcFaktor = 0;

			value = dicValues[accountUsedInLoop] - actualValue ;			
			value = value - (budgetValue - budgetValueBase);
			calcFaktor = value /budgetValueBase;

			StringList periods = ToStringList(budgetPeriodsArray);
			Prepend(periods, """");

			OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube,
			                                             OlapDataAreaIncludeB|OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.00, OlapDataAreaOperatorNone, 0.00,
			                                             periods,cycle, version,levelStringList, stepWrite, entity, intercompanyStringList, organizationStringList, accountUsedInLoop, currencyWrite, detailStringList, Segment1StringList, Segment2StringList,  Segment3StringList, Analysis1StringList,Analysis2StringList,Analysis3StringList,Analysis4StringList,Analysis5StringList,Analysis6StringList,Analysis7StringList,Analysis8StringList,Analysis9StringList,Analysis10StringList,Analysis11StringList,Analysis12StringList);
			
			foreach(OLAPCell cell in sourceData)
			{
				string TimeInLoop  = OLAPCellGetElement(cell, ""BPDTIME"");
				string orgDataArea  = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
				analysis1read  = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
				analysis2read  = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
				analysis3read  = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
				analysis4read = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
				analysis5read = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
				analysis6read  = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
				analysis7read  = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
				analysis8read  = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
				analysis9read  = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
				analysis10read  = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
				analysis11read  = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
				analysis12read  = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
				double sourceAccountValue = cell;
				double updatedSourceValue = 0;
				double assValue = 0;

				if(!isOriginalSourceValueZero)
				{
					updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;

					assValue = updatedSourceValue + sourceAccountValue;
				}
				else
				{
					updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;
					assValue = updatedSourceValue + sourceAccountValue;
					if(index >  0 and detHierarchy == ""BPDDETAIL"")
					{
						assValue = updatedSourceValue + sourceAccountValue + sourceAccountValue;
					}
				}
				OLAPCellWriteBufferIncrementNumber(buffer, MainCube, updatedSourceValue, TimeInLoop, cycle, version,levelInput,stepWrite, entity, intercompany, orgDataArea,accountUsedInLoop, currencyWrite,  detail, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				if(detHierarchy != ""BPDDETAIL"")
				{
					string detComposite = OLAPCreateCompositeName(""BPDDETAIL"", ""N.A."");
					if(!isOriginalSourceValueZero)
					{
						updatedSourceValue =(sourceAccountValue* calcFaktor)-sourceAccountValue;

					}
					else
					{
						updatedSourceValue =(sourceAccountValue* calcFaktor);
					}
					OLAPCellWriteBufferIncrementNumber(buffer, MainCube, updatedSourceValue, TimeInLoop, cycle, version,levelInput,stepWrite, entity, intercompany, orgDataArea,accountUsedInLoop, currencyWrite,  detComposite, primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				}
			}			
			OLAPCommitCellWriteBuffer(buffer);
		}
		LogInformation(""BAPFinance_Splasher: Process complete"");
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}
}"	1	762AC725-38E7-4F0C-91A2-951B2790EC88	Do writeback on total column in forecast data entry, run assumptions stript if necessary	1	1	1	1582	NULL	0	45708.67504	0	0
2BB99237-4220-4319-95B5-B93E39680D43	CD491758-D9DF-4002-94C8-8006E1855F86	BAPFinanceCopyVersionDataForStep	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""step"" parameter-type=""string"" parameter-description=""The currently displayed financial planning step"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""timeSource"" parameter-type=""string"" parameter-description=""The source year of the copy action"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""timeTarget"" parameter-type=""string"" parameter-description=""The target year of the copy action"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""versionSource"" parameter-type=""string"" parameter-description=""The source version of the copy action (BPDVERSION element)"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""versionTarget"" parameter-type=""string"" parameter-description=""The target version of the copy action (BPDVERSION element)"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element used"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element used (NA if no cost centers used)"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""currencyRead"" parameter-type=""string"" parameter-description=""The currency element to read from."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""currencyWrite"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""levelDefault"" parameter-type=""string"" parameter-description=""The level element that holds the planning defaults."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""levelInput"" parameter-type=""string"" parameter-description=""The level element to write the differences to."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""levelOpeningBalance"" parameter-type=""string"" parameter-description=""The level to calculate the opening balance."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""levelPremise"" parameter-type=""string"" parameter-description=""The level to calculate the premises planning."" parameter-order=""15"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPFinanceCopyVersionDataForStep(string database, string ticket, string cycle, string step, string timeSource, string timeTarget, string versionSource, string versionTarget,
                                      string entity, string organization, string currencyRead, string currencyWrite, string levelDefault, string levelInput, string levelOpeningBalance, string levelPremise)
@Description: ""Copies all data of activated accounts for a step between selected versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[step]: ""The currently displayed financial planning step"";
@Parameter[timeSource]: ""The source year of the copy action"";
@Parameter[timeTarget]: ""The target year of the copy action"";
@Parameter[versionSource]: ""The source version of the copy action (BPDVERSION element)"";
@Parameter[versionTarget]: ""The target version of the copy action (BPDVERSION element)"";
@Parameter[entity]: ""The entity element used"";
@Parameter[organization]: ""The organization element used (NA if no cost centers used)"";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[levelOpeningBalance]: ""The level to calculate the opening balance."";
@Parameter[levelPremise]: ""The level to calculate the premises planning."";
@Returns: ""True, if successful."";
{
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	
	// constants used in the process
	string AccountAssignmentCube = ""BPCCONFIG_MAIN"";
	string NA = ""N.A."";
	string MainCube = ""BPCMAIN"";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string organizationRead = ""TOTAL_ORGANIZATION"";

	// get native ids from the XMLA names
	cycle = ResolveUniqueName(connection, cycle);
	step = ResolveUniqueName(connection, step);
	timeSource = ResolveUniqueName(connection, timeSource);
	timeTarget = ResolveUniqueName(connection, timeTarget);
	versionSource = ResolveUniqueName(connection, versionSource);
	versionTarget = ResolveUniqueName(connection, versionTarget);
	entity = ResolveUniqueName(connection, entity);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	levelDefault = ResolveUniqueName(connection, levelDefault);
	levelInput = ResolveUniqueName(connection, levelInput);
	levelOpeningBalance = ResolveUniqueName(connection, levelOpeningBalance);
	levelPremise = ResolveUniqueName(connection, levelPremise);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	/*string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));*/

	if(organization == ""N.A."")
	{
		organizationRead = ""TOTAL_ORGANIZATION"";
	}
	else
	{
		organizationRead = organization;
	}


	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, timeTarget);
	
	string currentYear = OLAPGetStringAttribute(connection,timeElement ,""CURRENT_YEAR"");
	
	double cycleYearStart = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
	
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension, ""TOTAL_ACCOUNT"", true);
	OLAPElementList basePeriods = OLAPGetChildElementList(connection, TimeDimension, timeSource, true);
	
	foreach (OLAPElement account in baseAccounts where OLAPCellReadNumber(connection, AccountAssignmentCube, 1.0, cycle, entity, organization, account, step, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"") == 1)
	{
		LogDebug(""Account "" + account + "" is activated in step"");
		string accountType = OLAPGetStringAttribute(connection, account, ""ACCTYPE"");
		
		foreach(OLAPElement month in basePeriods)
		{
			
			double checkSourceArea = OLAPCellReadNumber(connection, MainCube, 1.0, month, cycle, versionSource,levelPremise,step, entity,
			                                            ""TOTAL_PARTNER"", organizationRead, account,  currencyRead,  ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			if (checkSourceArea == 0)
			{
				//Loop over all cells of the target area and adjust total value to 0 based on difference calculation
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             month, cycle, versionTarget,levelPremise,OlapDataAreaBCells, entity, OlapDataAreaBCells, organizationRead, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
				
				foreach (OLAPCell cell in sourceData)
				{
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					
					string monthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
					string targetMonth = monthNumber + ""_"" + timeTarget;
					
					double currentMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, targetMonth, cycle, versionTarget,levelDefault,step, entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment,analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					
					double newValueToWrite = 0.0 - currentMonthValue;
					
					OLAPCellWriteNumber(connection, MainCube, newValueToWrite, targetMonth, cycle, versionTarget,levelInput,step, entity, intercompany, organization,account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
				
			}
			else
			{
				//Loop over all cells of the source area and derive the new target value and calculate the difference in the target area
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             month, cycle, versionSource,levelPremise,step, entity, OlapDataAreaBCells, organizationRead, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
				
				foreach (OLAPCell cell in sourceData)
				{
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS1"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS2"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS3"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS4"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS5"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS6"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS7"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS8"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS9"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;
					
					string monthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
					string targetMonth = monthNumber + ""_"" + timeTarget;
					
					double currentMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, targetMonth, cycle, versionTarget, levelDefault,step,entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					
					double copyValueToWrite = value - currentMonthValue;
					
					OLAPCellWriteNumber(connection, MainCube, copyValueToWrite, targetMonth, cycle, versionTarget,levelInput,step ,entity, intercompany, organization,account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
		}
		
		//Calculate opening balance for the accounts in the target version
		if (accountType == ""A"" or accountType == ""L"")
		{
			
			//First delete all existing opening balance values for the input level of the target version
			foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
			{
				
				if (StringLength(year) == 4)
				{
					// check if the current year in the loop is after the specified month and before the end year of the cycle
					double checkYear = ToDouble(year);
					
					// for all years in the cycle after the entered period calculate the opening balance
					if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
					{
						string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
						string currentYearFirstMonth = ""01_"" + checkYear;

						
						OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, currentYearFirstMonth, cycle, versionTarget,levelOpeningBalance,NA, entity, ""TOTAL_PARTNER"", organization, account, currencyWrite, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read, analysis2read, analysis3read, analysis4read, analysis5read, analysis6read, analysis7read, analysis8read, analysis9read, analysis10read, analysis11read, analysis12read);
						
					}
				}
			}
			
			//Loop over all existing data cells of the target area for all years of the cycle to calculate the opening balance
			foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
			{
				
				//Loop over all years
				if (StringLength(year) == 4)
				{
					// check if the current year in the loop is after the specified month and before the end year of the cycle
					double checkYear = ToDouble(year);
					
					// for all years in the cycle after the entered period calculate the opening balance
					if (checkYear &gt; cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
					{
						string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
						
						//Create a data area to determine cells with data in the target version
						//empty cells will be skipped
						OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
						                                             lastYearTotal, cycle, versionTarget,levelInput,OlapDataAreaBCells, entity, OlapDataAreaBCells, organization, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
						
						foreach (OLAPCell cell in sourceData)
						{
							string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
							string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
							string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
							string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
							string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
							string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS1"");
							string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS2"");
							string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS3"");
							string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS4"");
							string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS5"");
							string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS6"");
							string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS7"");
							string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS8"");
							string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS9"");
							string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS10"");
							string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS11"");
							string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS12"");
							step = OLAPCellGetElement(cell, ""BPDSTEP"");
							
							//from the perspective of a cell with data the opening balance values for all remaining years of the cycle will be calculated
							foreach (OLAPElement innerYear in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
							{
								if (StringLength(innerYear) == 4)
								{
									double innerCheckYear = ToDouble(innerYear);
									
									if (innerCheckYear &gt; cycleYearStart and innerCheckYear &gt;= checkYear and (innerCheckYear - cycleYearStart) &lt; cycleYears)
									{
										string innerLastYearTotal = ""12_"" + (innerCheckYear-1) + ""_YTD"";
										string currentYearFirstMonth = ""01_"" + innerCheckYear;
										
										double lastYearMovement = OLAPCellReadNumber(connection, MainCube, 1.0, innerLastYearTotal, cycle, versionTarget,levelInput,step, entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
										double lastYearOpeningBalance = OLAPCellReadNumber(connection, MainCube, 1.0, innerLastYearTotal, cycle, versionTarget,levelOpeningBalance,step, entity, intercompany, organization,account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
										
										double openingBalance = lastYearMovement + lastYearOpeningBalance;

										OLAPCellWriteNumber(connection, MainCube, openingBalance, currentYearFirstMonth, cycle, versionTarget,levelOpeningBalance,step, entity, intercompany, organization, account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
									}
								}
							}
							
						}
						
					}
				}
			}
		}
		
	}

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

bool BAPFinanceCopyVersionDataForStep(string database, string ticket, string cycle, string step, string timeSource, string timeTarget, string versionSource, string versionTarget,
                                      string entity, string organization, string currencyRead, string currencyWrite, string levelDefault, string levelInput, string levelOpeningBalance, string levelPremise)
@Description: ""Copies all data of activated accounts for a step between selected versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[step]: ""The currently displayed financial planning step"";
@Parameter[timeSource]: ""The source year of the copy action"";
@Parameter[timeTarget]: ""The target year of the copy action"";
@Parameter[versionSource]: ""The source version of the copy action (BPDVERSION element)"";
@Parameter[versionTarget]: ""The target version of the copy action (BPDVERSION element)"";
@Parameter[entity]: ""The entity element used"";
@Parameter[organization]: ""The organization element used (NA if no cost centers used)"";
@Parameter[currencyRead]: ""The currency element to read from."";
@Parameter[currencyWrite]: ""The currency element to write from."";
@Parameter[levelDefault]: ""The level element that holds the planning defaults."";
@Parameter[levelInput]: ""The level element to write the differences to."";
@Parameter[levelOpeningBalance]: ""The level to calculate the opening balance."";
@Parameter[levelPremise]: ""The level to calculate the premises planning."";
@Returns: ""True, if successful."";
{
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	
	// constants used in the process
	string AccountAssignmentCube = ""BPCCONFIG_MAIN"";
	string NA = ""N.A."";
	string MainCube = ""BPCMAIN"";
	string AccountDimension = ""BPDACCOUNT"";
	string TimeDimension = ""BPDTIME"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string organizationRead = ""TOTAL_ORGANIZATION"";

	// get native ids from the XMLA names
	cycle = ResolveUniqueName(connection, cycle);
	step = ResolveUniqueName(connection, step);
	timeSource = ResolveUniqueName(connection, timeSource);
	timeTarget = ResolveUniqueName(connection, timeTarget);
	versionSource = ResolveUniqueName(connection, versionSource);
	versionTarget = ResolveUniqueName(connection, versionTarget);
	entity = ResolveUniqueName(connection, entity);
	organization = ResolveUniqueName(connection, organization);
	currencyRead = ResolveUniqueName(connection, currencyRead);
	currencyWrite = ResolveUniqueName(connection, currencyWrite);
	levelDefault = ResolveUniqueName(connection, levelDefault);
	levelInput = ResolveUniqueName(connection, levelInput);
	levelOpeningBalance = ResolveUniqueName(connection, levelOpeningBalance);
	levelPremise = ResolveUniqueName(connection, levelPremise);

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	/*string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));*/

	if(organization == ""N.A."")
	{
		organizationRead = ""TOTAL_ORGANIZATION"";
	}
	else
	{
		organizationRead = organization;
	}


	OLAPElement timeElement = OLAPGetDimensionElement(connection, TimeDimension, timeTarget);
	
	string currentYear = OLAPGetStringAttribute(connection,timeElement ,""CURRENT_YEAR"");
	
	double cycleYearStart = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
	
	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension, ""TOTAL_ACCOUNT"", true);
	OLAPElementList basePeriods = OLAPGetChildElementList(connection, TimeDimension, timeSource, true);
	
	foreach (OLAPElement account in baseAccounts where OLAPCellReadNumber(connection, AccountAssignmentCube, 1.0, cycle, entity, organization, account, step, ""SUBPLAN_FINANCE_ACC_ACTIVE"", ""Value"") == 1)
	{
		LogDebug(""Account "" + account + "" is activated in step"");
		string accountType = OLAPGetStringAttribute(connection, account, ""ACCTYPE"");
		
		foreach(OLAPElement month in basePeriods)
		{
			
			double checkSourceArea = OLAPCellReadNumber(connection, MainCube, 1.0, month, cycle, versionSource,levelPremise,step, entity,
			                                            ""TOTAL_PARTNER"", organizationRead, account,  currencyRead,  ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			if (checkSourceArea == 0)
			{
				//Loop over all cells of the target area and adjust total value to 0 based on difference calculation
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             month, cycle, versionTarget,levelPremise,OlapDataAreaBCells, entity, OlapDataAreaBCells, organizationRead, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
				
				foreach (OLAPCell cell in sourceData)
				{
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					
					string monthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
					string targetMonth = monthNumber + ""_"" + timeTarget;
					
					double currentMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, targetMonth, cycle, versionTarget,levelDefault,step, entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment,analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					
					double newValueToWrite = 0.0 - currentMonthValue;
					
					OLAPCellWriteNumber(connection, MainCube, newValueToWrite, targetMonth, cycle, versionTarget,levelInput,step, entity, intercompany, organization,account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
				
			}
			else
			{
				//Loop over all cells of the source area and derive the new target value and calculate the difference in the target area
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             month, cycle, versionSource,levelPremise,step, entity, OlapDataAreaBCells, organizationRead, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
				
				foreach (OLAPCell cell in sourceData)
				{
					string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
					string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
					string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
					string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS1"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS2"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS3"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS4"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS5"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS6"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS7"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS8"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS9"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;
					
					string monthNumber = OLAPGetStringAttribute(connection, month, ""CURRENT_MONTH_ID"");
					string targetMonth = monthNumber + ""_"" + timeTarget;
					
					double currentMonthValue = OLAPCellReadNumber(connection, MainCube, 1.0, targetMonth, cycle, versionTarget, levelDefault,step,entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					
					double copyValueToWrite = value - currentMonthValue;
					
					OLAPCellWriteNumber(connection, MainCube, copyValueToWrite, targetMonth, cycle, versionTarget,levelInput,step ,entity, intercompany, organization,account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
				}
			}
		}
		
		//Calculate opening balance for the accounts in the target version
		if (accountType == ""A"" or accountType == ""L"")
		{
			
			//First delete all existing opening balance values for the input level of the target version
			foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
			{
				
				if (StringLength(year) == 4)
				{
					// check if the current year in the loop is after the specified month and before the end year of the cycle
					double checkYear = ToDouble(year);
					
					// for all years in the cycle after the entered period calculate the opening balance
					if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
					{
						string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
						string currentYearFirstMonth = ""01_"" + checkYear;

						
						OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, currentYearFirstMonth, cycle, versionTarget,levelOpeningBalance,NA, entity, ""TOTAL_PARTNER"", organization, account, currencyWrite, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read, analysis2read, analysis3read, analysis4read, analysis5read, analysis6read, analysis7read, analysis8read, analysis9read, analysis10read, analysis11read, analysis12read);
						
					}
				}
			}
			
			//Loop over all existing data cells of the target area for all years of the cycle to calculate the opening balance
			foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
			{
				
				//Loop over all years
				if (StringLength(year) == 4)
				{
					// check if the current year in the loop is after the specified month and before the end year of the cycle
					double checkYear = ToDouble(year);
					
					// for all years in the cycle after the entered period calculate the opening balance
					if (checkYear > cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
					{
						string lastYearTotal = ""12_"" + (checkYear-1) + ""_YTD"";
						
						//Create a data area to determine cells with data in the target version
						//empty cells will be skipped
						OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
						                                             lastYearTotal, cycle, versionTarget,levelInput,OlapDataAreaBCells, entity, OlapDataAreaBCells, organization, account ,currencyRead, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
						
						foreach (OLAPCell cell in sourceData)
						{
							string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
							string primarySegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
							string secondarySegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
							string tertiarySegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
							string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
							string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS1"");
							string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS2"");
							string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS3"");
							string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS4"");
							string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS5"");
							string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS6"");
							string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS7"");
							string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS8"");
							string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS9"");
							string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS10"");
							string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS11"");
							string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS12"");
							step = OLAPCellGetElement(cell, ""BPDSTEP"");
							
							//from the perspective of a cell with data the opening balance values for all remaining years of the cycle will be calculated
							foreach (OLAPElement innerYear in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
							{
								if (StringLength(innerYear) == 4)
								{
									double innerCheckYear = ToDouble(innerYear);
									
									if (innerCheckYear > cycleYearStart and innerCheckYear >= checkYear and (innerCheckYear - cycleYearStart) < cycleYears)
									{
										string innerLastYearTotal = ""12_"" + (innerCheckYear-1) + ""_YTD"";
										string currentYearFirstMonth = ""01_"" + innerCheckYear;
										
										double lastYearMovement = OLAPCellReadNumber(connection, MainCube, 1.0, innerLastYearTotal, cycle, versionTarget,levelInput,step, entity, intercompany, organization, account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
										double lastYearOpeningBalance = OLAPCellReadNumber(connection, MainCube, 1.0, innerLastYearTotal, cycle, versionTarget,levelOpeningBalance,step, entity, intercompany, organization,account,currencyRead, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
										
										double openingBalance = lastYearMovement + lastYearOpeningBalance;

										OLAPCellWriteNumber(connection, MainCube, openingBalance, currentYearFirstMonth, cycle, versionTarget,levelOpeningBalance,step, entity, intercompany, organization, account, currencyWrite, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
									}
								}
							}
							
						}
						
					}
				}
			}
		}
		
	}

	return true;
}"	1	3D9FCDD1-0B21-43AD-A1E4-0D29B3678683	Copies all data of activated accounts for a step between selected versions	1	1	1	1583	NULL	0	45708.67505	0	0
8E366C43-3EB0-41DC-9AC0-85611A8743DC	CD491758-D9DF-4002-94C8-8006E1855F86	BAPPopulateDefaultSalesConfiguration	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The cycle to configure."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPPopulateDefaultSalesConfiguration(string database, string ticket, string cycle)
@Description: ""Populates the default cost centers and segment relationships for the sales configuration."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The cycle to configure."";
@Returns: ""True, if successful."";
{
	LogInformation(""BPPopulateDefaultSalesConfiguration: Starting process"");
	
	// constants used in the process
	string NA = ""N.A."";
	string TargetCube = ""BPCCONFIG_SALES"";
	string SourceCube1 = ""BPCCONFIG_ENTITY"";
	string SourceCube2 = ""BPCCONFIG_ENTITY_SEGMENT"";
	string SourceCube3 = ""BPCCONFIG_MAIN"";
	string EntityDimensionName = ""BPDENTITY"";
	string OrganizationDimensionName = ""BPDORGANIZATION"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	// convert unique name cylce into native representation
	cycle = ResolveUniqueName(connection, cycle);


	// get the required dimensions
	OLAPElementList entityDimension = OLAPGetElementList(connection, EntityDimensionName, true);
	OLAPElementList organizationDimension = OLAPGetElementList(connection, OrganizationDimensionName, true);
	OLAPElementList psegmentDimension = OLAPGetElementList(connection, PSegmentDimensionName, true);
	OLAPElementList ssegmentDimension = OLAPGetElementList(connection, SSegmentDimensionName, true);
	OLAPElementList tsegmentDimension = OLAPGetElementList(connection, TSegmentDimensionName, true);
	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);

	OLAPDataArea targetsegmentConfiguration = OLAPCreateDataArea(connection, TargetCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                                             OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                             cycle, NA,  OlapDataAreaBCells, NA, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""DEFAULT_RELATIONS"");
	
	OLAPDeleteDataArea(targetsegmentConfiguration);
	

	// for all activated companies in the specified cycle
	foreach(OLAPElement version in budgetElements)
	{

		foreach (OLAPElement entity in entityDimension where OLAPCellReadNumber(connection, SourceCube1, 1.0, cycle, version, entity, NA, NA, ""GLOBAL_ENTITY_ACTIVE"") &gt; 0)
		{
			// if costcenters are enabled
			if (OLAPCellReadNumber(connection, SourceCube3, 1.0, cycle, NA, NA, NA, NA, NA, ""SUBPLAN_SALES_ACTIVE_ORGANIZATION"", ""value"") == 1)
			{
				// for every costcenter get all active segment combinations
				foreach (OLAPElement organization in organizationDimension where OLAPCellReadNumber(connection, SourceCube1, 1.0, cycle, version, entity, NA, organization, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"") &gt; 0)
				{
					OLAPDataArea segmentConfiguration = OLAPCreateDataArea(connection, SourceCube2, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
					                                                       OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                       cycle, version, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""GLOBAL_SEGMENT_ACTIVE"");
					
					foreach (OLAPCell cell in segmentConfiguration)
					{
						string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
						string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
						string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);
						
						OLAPCellWriteNumber(connection, TargetCube, 1.0, cycle, NA, entity, NA, organization, psegment, ssegment, tsegment, ""DEFAULT_RELATIONS"");
						
						
					}
				}
			}
			else
			{
				// costcenters are not active for current company
				LogDebug(""BAPPopulateDefaultSalesConfiguration: Cost centers not active in entity "" + entity);

				OLAPDataArea segmentConfiguration = OLAPCreateDataArea(connection, SourceCube2, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                                       OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                       cycle,version, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""GLOBAL_SEGMENT_ACTIVE"");

				foreach (OLAPCell cell in segmentConfiguration)
				{
					string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
					string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
					string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);

					OLAPCellWriteNumber(connection, TargetCube, 1.0, cycle, NA, entity, NA, NA, psegment, ssegment, tsegment, ""DEFAULT_RELATIONS"");

				}
			}
		}
	}

	LogInformation(""BPPopulateDefaultSalesConfiguration: Process complete"");

	// The process cannot fail unless it ends with an exception before. Thus if we reach this point it was successful.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPPopulateDefaultSalesConfiguration(string database, string ticket, string cycle)
@Description: ""Populates the default cost centers and segment relationships for the sales configuration."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The cycle to configure."";
@Returns: ""True, if successful."";
{
	LogInformation(""BPPopulateDefaultSalesConfiguration: Starting process"");
	
	// constants used in the process
	string NA = ""N.A."";
	string TargetCube = ""BPCCONFIG_SALES"";
	string SourceCube1 = ""BPCCONFIG_ENTITY"";
	string SourceCube2 = ""BPCCONFIG_ENTITY_SEGMENT"";
	string SourceCube3 = ""BPCCONFIG_MAIN"";
	string EntityDimensionName = ""BPDENTITY"";
	string OrganizationDimensionName = ""BPDORGANIZATION"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	// create connection
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	// convert unique name cylce into native representation
	cycle = ResolveUniqueName(connection, cycle);


	// get the required dimensions
	OLAPElementList entityDimension = OLAPGetElementList(connection, EntityDimensionName, true);
	OLAPElementList organizationDimension = OLAPGetElementList(connection, OrganizationDimensionName, true);
	OLAPElementList psegmentDimension = OLAPGetElementList(connection, PSegmentDimensionName, true);
	OLAPElementList ssegmentDimension = OLAPGetElementList(connection, SSegmentDimensionName, true);
	OLAPElementList tsegmentDimension = OLAPGetElementList(connection, TSegmentDimensionName, true);
	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);

	OLAPDataArea targetsegmentConfiguration = OLAPCreateDataArea(connection, TargetCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
	                                                             OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
	                                                             cycle, NA,  OlapDataAreaBCells, NA, OlapDataAreaBCells,OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""DEFAULT_RELATIONS"");
	
	OLAPDeleteDataArea(targetsegmentConfiguration);
	

	// for all activated companies in the specified cycle
	foreach(OLAPElement version in budgetElements)
	{

		foreach (OLAPElement entity in entityDimension where OLAPCellReadNumber(connection, SourceCube1, 1.0, cycle, version, entity, NA, NA, ""GLOBAL_ENTITY_ACTIVE"") > 0)
		{
			// if costcenters are enabled
			if (OLAPCellReadNumber(connection, SourceCube3, 1.0, cycle, NA, NA, NA, NA, NA, ""SUBPLAN_SALES_ACTIVE_ORGANIZATION"", ""value"") == 1)
			{
				// for every costcenter get all active segment combinations
				foreach (OLAPElement organization in organizationDimension where OLAPCellReadNumber(connection, SourceCube1, 1.0, cycle, version, entity, NA, organization, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"") > 0)
				{
					OLAPDataArea segmentConfiguration = OLAPCreateDataArea(connection, SourceCube2, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
					                                                       OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                       cycle, version, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""GLOBAL_SEGMENT_ACTIVE"");
					
					foreach (OLAPCell cell in segmentConfiguration)
					{
						string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
						string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
						string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);
						
						OLAPCellWriteNumber(connection, TargetCube, 1.0, cycle, NA, entity, NA, organization, psegment, ssegment, tsegment, ""DEFAULT_RELATIONS"");
						
						
					}
				}
			}
			else
			{
				// costcenters are not active for current company
				LogDebug(""BAPPopulateDefaultSalesConfiguration: Cost centers not active in entity "" + entity);

				OLAPDataArea segmentConfiguration = OLAPCreateDataArea(connection, SourceCube2, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                                       OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                       cycle,version, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, ""GLOBAL_SEGMENT_ACTIVE"");

				foreach (OLAPCell cell in segmentConfiguration)
				{
					string psegment = OLAPCellGetElement(cell, PSegmentDimensionName);
					string ssegment = OLAPCellGetElement(cell, SSegmentDimensionName);
					string tsegment = OLAPCellGetElement(cell, TSegmentDimensionName);

					OLAPCellWriteNumber(connection, TargetCube, 1.0, cycle, NA, entity, NA, NA, psegment, ssegment, tsegment, ""DEFAULT_RELATIONS"");

				}
			}
		}
	}

	LogInformation(""BPPopulateDefaultSalesConfiguration: Process complete"");

	// The process cannot fail unless it ends with an exception before. Thus if we reach this point it was successful.
	return true;
}"	1	AAB8F1AD-32E3-4877-8196-BCE5769D7F4D	Populates the default cost centers and segment relationships for the sales configuration.	1	1	1	1584	NULL	0	45708.67505	0	0
6F142B0D-3D04-4B8B-BE3B-21569E7D6B51	CD491758-D9DF-4002-94C8-8006E1855F86	BAPPublishSalesData	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 for wrong sales account configuration."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""The organization element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""The currency element to write from."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""The primary element to be used."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""The secondary element to be used."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""The tertiary element to be used."" parameter-order=""10"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPPublishSalesData(
	string database, string ticket, string cycle, string version, string entity, string intercompany, string organization,
	string currency, string primarySegment, string secondarySegment, string tertiarySegment)
@Description: ""Makes the sales planning data visible in the financial statements (balance sheet and profit and loss)."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPPublishSalesData: Starting process"");
	
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currency = ResolveUniqueName(connection, currency);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);

	// constants used in the process
	string TimeDimension = ""BPDTIME"";
	string entityDimension = ""BPDENTITY"";
	string AccountDimension = ""BPDACCOUNT"";
	string ConfigDimension = ""PCONFIGURATION"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));
	
	double cycleYearStart = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension,""TOTAL_ACCOUNT"" , true);

	OLAPElement entityElement = OLAPGetDimensionElement(connection, entityDimension, entity);
	bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);

	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear &gt;= cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
			{
				OLAPElementList basePeriods = OLAPGetChildElementList(connection, TimeDimension, year, true);
				
				// Delete original content in target
				
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES"",step, entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_RECEIVABLES"",step, entity, intercompany, organization,""TOTAL_ACCOUNT"", currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_LIABILITIES"",step, entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_OB"", step,entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency, ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read  );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version, ""CALC_SALES_CASH_RECEIVABLES_OB"",step,entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_LIABILITIES_OB"",step, entity, intercompany, organization,""TOTAL_ACCOUNT"", currency, ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             basePeriods, cycle, version,OlapDataAreaBCells,OlapDataAreaBCells, entity, intercompany, organization, baseAccounts,currency, OlapDataAreaBCells, primarySegment, secondarySegment, tertiarySegment, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach (OLAPCell cell in sourceData)
				{
					string period = OLAPCellGetElement(cell, ""BPDTIME"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;
					
					string targetLevel = """";
					if (level == ""CALC_SALES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES"";
					}
					else if (level == ""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES_CASH_RECEIVABLES"";
					}
					else if (level == ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES_CASH_LIABILITIES"";
					}
					else if (level == ""CALC_SALES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_OB"";
					}
					else if (level == ""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_CASH_RECEIVABLES_OB"";
					}
					else if (level == ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_CASH_LIABILITIES_OB"";
					}
					
					if (targetLevel != """")
					{
						OLAPCellWriteNumber(connection, MainCube, value, period, cycle, version,targetLevel,step, entity, intercompany, organization,account,  currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					}
				}
			}
		}
	}
	
	LogInformation(""BPPublishSalesData: Process complete"");

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPPublishSalesData(
	string database, string ticket, string cycle, string version, string entity, string intercompany, string organization,
	string currency, string primarySegment, string secondarySegment, string tertiarySegment)
@Description: ""Makes the sales planning data visible in the financial statements (balance sheet and profit and loss)."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[version]: ""The version element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[intercompany]: ""The intercompany element to be used."";
@Parameter[organization]: ""The organization element to be used."";
@Parameter[currency]: ""The currency element to write from."";
@Parameter[primarySegment]: ""The primary element to be used."";
@Parameter[secondarySegment]: ""The secondary element to be used."";
@Parameter[tertiarySegment]: ""The tertiary element to be used."";
@Returns: ""0 for ok, -1 for wrong sales account configuration."";
{
	LogInformation(""BPPublishSalesData: Starting process"");
	
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	cycle = ResolveUniqueName(connection, cycle);
	version = ResolveUniqueName(connection, version);
	entity = ResolveUniqueName(connection, entity);
	intercompany = ResolveUniqueName(connection, intercompany);
	organization = ResolveUniqueName(connection, organization);
	currency = ResolveUniqueName(connection, currency);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);

	// constants used in the process
	string TimeDimension = ""BPDTIME"";
	string entityDimension = ""BPDENTITY"";
	string AccountDimension = ""BPDACCOUNT"";
	string ConfigDimension = ""PCONFIGURATION"";
	string MainCube = ""BPCMAIN"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";

	string analysis1read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(connection, ""BPDANALYSIS_12""));
	string step = ToString(BP_GetTopElement(connection, ""BPDSTEP""));
	
	double cycleYearStart = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle,NA, ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");

	OLAPElementList baseAccounts = OLAPGetChildElementList(connection, AccountDimension,""TOTAL_ACCOUNT"" , true);

	OLAPElement entityElement = OLAPGetDimensionElement(connection, entityDimension, entity);
	bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);

	foreach (OLAPElement year in OLAPGetChildElementList(connection, TimeDimension, ""TOTAL_TIME"", false))
	{
		// this is a workaround as we are lacking the function to get only direct children for an element
		if (StringLength(year) == 4)
		{
			// check if the current year in the loop is after the specified month and before the end year of the cycle
			double checkYear = ToDouble(year);
			
			// for all years in the cycle after the entered period calculate the opening balance
			if (checkYear >= cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
			{
				OLAPElementList basePeriods = OLAPGetChildElementList(connection, TimeDimension, year, true);
				
				// Delete original content in target
				
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES"",step, entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_RECEIVABLES"",step, entity, intercompany, organization,""TOTAL_ACCOUNT"", currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_LIABILITIES"",step, entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_OB"", step,entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency, ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read  );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version, ""CALC_SALES_CASH_RECEIVABLES_OB"",step,entity, intercompany, organization, ""TOTAL_ACCOUNT"",currency,  ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read );
				OLAPSplashValue(connection, MainCube, 0, ""Equal"", false, 20, false, year, cycle, version,""CALC_SALES_CASH_LIABILITIES_OB"",step, entity, intercompany, organization,""TOTAL_ACCOUNT"", currency, ""TOTAL_DETAIL"" , primarySegment, secondarySegment, tertiarySegment, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
				
				OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             basePeriods, cycle, version,OlapDataAreaBCells,OlapDataAreaBCells, entity, intercompany, organization, baseAccounts,currency, OlapDataAreaBCells, primarySegment, secondarySegment, tertiarySegment, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

				foreach (OLAPCell cell in sourceData)
				{
					string period = OLAPCellGetElement(cell, ""BPDTIME"");
					string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
					string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
					string level = OLAPCellGetElement(cell, ""BPDLEVEL"");
					string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
					string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
					string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
					string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
					string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
					string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
					string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
					string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
					string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
					string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
					string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
					string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
					step = OLAPCellGetElement(cell, ""BPDSTEP"");
					double value = cell;
					
					string targetLevel = """";
					if (level == ""CALC_SALES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES"";
					}
					else if (level == ""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES_CASH_RECEIVABLES"";
					}
					else if (level == ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED"")
					{
						targetLevel = ""CALC_SALES_CASH_LIABILITIES"";
					}
					else if (level == ""CALC_SALES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_OB"";
					}
					else if (level == ""CALC_SALES_CASH_RECEIVABLES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_CASH_RECEIVABLES_OB"";
					}
					else if (level == ""CALC_SALES_CASH_LIABILITIES_UNAPPROVED_OB"")
					{
						targetLevel = ""CALC_SALES_CASH_LIABILITIES_OB"";
					}
					
					if (targetLevel != """")
					{
						OLAPCellWriteNumber(connection, MainCube, value, period, cycle, version,targetLevel,step, entity, intercompany, organization,account,  currency, detail, primarySegment, secondarySegment, tertiarySegment, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
					}
				}
			}
		}
	}
	
	LogInformation(""BPPublishSalesData: Process complete"");

	return 0;
}"	1	1C20CA07-22FB-4265-AC49-C183CF7F98DA	Makes the sales planning data visible in the financial statements (balance sheet and profit and loss).	1	1	1	1585	NULL	0	45708.67504	0	0
9027CA3D-017E-4AD2-B310-4BBBAF17286D	CD491758-D9DF-4002-94C8-8006E1855F86	BAPSales_SpreadOrganizationToVersions	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesful"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to configure."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""Intercompany element in use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Organization element in use"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected for configuration"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""segmentParameter1"" parameter-type=""string"" parameter-description=""First Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""segmentParameter2"" parameter-type=""string"" parameter-description=""Second Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""segmentParameter3"" parameter-type=""string"" parameter-description=""Third Segment information. Will be turned to correct dimension reference in the process"" parameter-order=""8"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPSales_SpreadOrganizationToVersions(string database, string ticket, string cycle, string intercompany,string organization, string entity, string segmentParameter1, string segmentParameter2,
                                           string segmentParameter3)
@Description: ""Write to all completed versions + N.A. version, if organization is active,1 into sales cube, to VALID, STATUS1-3 and FINAL_STATUS"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[organization]: ""Organization element in use"";
@Parameter[segmentParameter1]: ""First Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter2]: ""Second Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter3]: ""Third Segment information. Will be turned to correct dimension reference in the process"";
@Returns: ""true if process was succesful"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");

	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	segmentParameter1=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	segmentParameter2=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	segmentParameter3=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string primarySegment = """";
	string secondarySegment = """";
	string tertiarySegment = """";
	string costGroup = """";
	string salesGroup = """";
	string NA = ""N.A."";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string organizationDimension = ""BPDORGANIZATION"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	//determine segment dimension of first segment paramater
	if (StringContains(segmentParameter1, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter1;
	}
	else if (StringContains(segmentParameter1, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter1;
	}
	else
	{
		tertiarySegment = segmentParameter1;
	}
	
	//determine segment dimension of second segment paramater
	if (StringContains(segmentParameter2, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter2;
	}
	else if (StringContains(segmentParameter2, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter2;
	}
	else
	{
		tertiarySegment = segmentParameter2;
	}
	
	//determine segment dimension of third segment paramater
	if (StringContains(segmentParameter3, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter3;
	}
	else if (StringContains(segmentParameter3, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter3;
	}
	else
	{
		tertiarySegment = segmentParameter3;
	}
	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	organization = ResolveUniqueName(connection, organization);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	
	OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organization);
	bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);

	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}

	foreach (string version in budgetArray)
	{
		
		if (baseOrganizationElement)
		{
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""VALID"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
		}
		else
		{
			OLAPElementList organizationElements= OLAPGetChildElementList(connection, organizationDimension,organization, true);
			StringList  organizationStringList = ToStringList(organizationElements);
			foreach(string cOrganization in organizationStringList)
			{
				double value = OLAPCellReadNumber(connection, EntityConfigurationCube,1.0, cycle, ""TOTAL_BUDGET"", entity, NA,cOrganization, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				if(value&gt;0)
				{
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""VALID"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
				}

			}
		}

	}

	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPSales_SpreadOrganizationToVersions(string database, string ticket, string cycle, string intercompany,string organization, string entity, string segmentParameter1, string segmentParameter2,
                                           string segmentParameter3)
@Description: ""Write to all completed versions + N.A. version, if organization is active,1 into sales cube, to VALID, STATUS1-3 and FINAL_STATUS"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[organization]: ""Organization element in use"";
@Parameter[segmentParameter1]: ""First Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter2]: ""Second Segment information. Will be turned to correct dimension reference in the process"";
@Parameter[segmentParameter3]: ""Third Segment information. Will be turned to correct dimension reference in the process"";
@Returns: ""true if process was succesful"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");

	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	segmentParameter1=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	segmentParameter2=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	segmentParameter3=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string primarySegment = """";
	string secondarySegment = """";
	string tertiarySegment = """";
	string costGroup = """";
	string salesGroup = """";
	string NA = ""N.A."";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string EntityConfigurationCube = ""BPCCONFIG_ENTITY"";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string organizationDimension = ""BPDORGANIZATION"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	
	//determine segment dimension of first segment paramater
	if (StringContains(segmentParameter1, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter1;
	}
	else if (StringContains(segmentParameter1, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter1;
	}
	else
	{
		tertiarySegment = segmentParameter1;
	}
	
	//determine segment dimension of second segment paramater
	if (StringContains(segmentParameter2, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter2;
	}
	else if (StringContains(segmentParameter2, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter2;
	}
	else
	{
		tertiarySegment = segmentParameter2;
	}
	
	//determine segment dimension of third segment paramater
	if (StringContains(segmentParameter3, ""BPDPSEGMENT""))
	{
		primarySegment = segmentParameter3;
	}
	else if (StringContains(segmentParameter3, ""BPDSSEGMENT""))
	{
		secondarySegment = segmentParameter3;
	}
	else
	{
		tertiarySegment = segmentParameter3;
	}
	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	organization = ResolveUniqueName(connection, organization);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);
	
	OLAPElement organizationElement = OLAPGetDimensionElement(connection, organizationDimension, organization);
	bool baseOrganizationElement = OLAPIsBaseElement(connection, organizationElement);

	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}

	foreach (string version in budgetArray)
	{
		
		if (baseOrganizationElement)
		{
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""VALID"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
			OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, organization, primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
		}
		else
		{
			OLAPElementList organizationElements= OLAPGetChildElementList(connection, organizationDimension,organization, true);
			StringList  organizationStringList = ToStringList(organizationElements);
			foreach(string cOrganization in organizationStringList)
			{
				double value = OLAPCellReadNumber(connection, EntityConfigurationCube,1.0, cycle, ""TOTAL_BUDGET"", entity, NA,cOrganization, ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"");
				if(value>0)
				{
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""VALID"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
					OLAPCellWriteNumber(connection, SalesConfigurationCube, 1.0, cycle, version, entity, intercompany, cOrganization, primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
				}

			}
		}

	}

	return true;
}"	1	95E8D285-23B1-4FE5-85FB-9F3D1B44A444	Write to all completed versions + N.A. version, if organization is active,1 into sales cube, to VALID, STATUS1-3 and FINAL_STATUS	1	1	1	1586	NULL	0	45708.67503	0	0
6D97B485-2364-4EAF-BB87-15449F2FD01F	CD491758-D9DF-4002-94C8-8006E1855F86	BAPSales_SpreadRelationToVersions	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True- script run correctly"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set to configure."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected for configuration"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""Intercompany element in use"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""primarySegment"" parameter-type=""string"" parameter-description=""First Segment element in use"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""secondarySegment"" parameter-type=""string"" parameter-description=""Second Segment element in use"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""tertiarySegment"" parameter-type=""string"" parameter-description=""Third Segment element in use"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPSales_SpreadRelationToVersions(string database, string ticket, string cycle,string entity, string intercompany,  string primarySegment, string secondarySegment,
                                       string tertiarySegment)
@Description: ""Spread sales ralations from N.A. version to completeded budget versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[primarySegment]: ""First Segment element in use"";
@Parameter[secondarySegment]: ""Second Segment element in use"";
@Parameter[tertiarySegment]: ""Third Segment element in use"";
@Returns: ""True- script run correctly"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	primarySegment=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	secondarySegment=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	tertiarySegment=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string NA = ""N.A."";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	

	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);

	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList organizationElements= OLAPGetChildElementList(connection, ""BPDORGANIZATION"",""TOTAL_ORGANIZATION"", true);
	StringList  organizationStringList = ToStringList(organizationElements);

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}
	StringList budgetStringList = ToStringList(budgetArray);

	
	foreach (string budget in budgetArray)
	{
		foreach (string organization in organizationStringList)
		{

			double value = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");

			if(value ==1)
			{
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""VALID"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
			}
			
		}

		
	}

	
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPSales_SpreadRelationToVersions(string database, string ticket, string cycle,string entity, string intercompany,  string primarySegment, string secondarySegment,
                                       string tertiarySegment)
@Description: ""Spread sales ralations from N.A. version to completeded budget versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set to configure."";
@Parameter[entity]: ""Entity selected for configuration"";
@Parameter[intercompany]: ""Intercompany element in use"";
@Parameter[primarySegment]: ""First Segment element in use"";
@Parameter[secondarySegment]: ""Second Segment element in use"";
@Parameter[tertiarySegment]: ""Third Segment element in use"";
@Returns: ""True- script run correctly"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""testuser"", """");
	cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	entity= ""[BPDENTITY].[RU0001].[1]"";
	intercompany=""[BPDINTERCOMPANY].[EXTERNAL].[1]"";//RU0004
	primarySegment=""[BPDPSEGMENT].[N.A.].[1]"";//BU3001
	secondarySegment=""[BPDSSEGMENT].[N.A.].[1]"";//CH
	tertiarySegment=""[BPDTSEGMENT].[N.A.].[1]"";*/
	
	string NA = ""N.A."";
	string SalesConfigurationCube = ""BPCCONFIG_SALES"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
	string PSegmentDimensionName = ""BPDPSEGMENT"";
	string SSegmentDimensionName = ""BPDSSEGMENT"";
	string TSegmentDimensionName = ""BPDTSEGMENT"";
	

	
	cycle = ResolveUniqueName(connection, cycle);
	intercompany = ResolveUniqueName(connection, intercompany);
	entity = ResolveUniqueName(connection, entity);
	primarySegment = ResolveUniqueName(connection, primarySegment);
	secondarySegment = ResolveUniqueName(connection, secondarySegment);
	tertiarySegment = ResolveUniqueName(connection, tertiarySegment);

	StringArray budgetArray = CreateStringArray();
	Append(budgetArray,""N.A."");

	OLAPElementList organizationElements= OLAPGetChildElementList(connection, ""BPDORGANIZATION"",""TOTAL_ORGANIZATION"", true);
	StringList  organizationStringList = ToStringList(organizationElements);

	OLAPElementList budgetElements= OLAPGetChildElementList(connection, ""BPDVERSION"",""TOTAL_BUDGET"", true);
	StringList  budgetElementsList = ToStringList(budgetElements);
	foreach (string budgetString in budgetElementsList)
	{
		double completed = OLAPCellReadNumber(connection, CycleConfigurationCube,1.0, cycle, budgetString, ""GLOBAL_CYCLE_VERSION_COMPLETED"",""Value"");
		if(completed == 1)
		{
			Append(budgetArray,budgetString);
		}
	}
	StringList budgetStringList = ToStringList(budgetArray);

	
	foreach (string budget in budgetArray)
	{
		foreach (string organization in organizationStringList)
		{

			double value = OLAPCellReadNumber(connection, SalesConfigurationCube, 1.0, cycle, NA, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""ACTIV"");

			if(value ==1)
			{
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""VALID"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS1"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS2"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""STATUS3"");
				OLAPCellWriteNumber(connection, SalesConfigurationCube, value, cycle, budget, entity, intercompany, organization,  primarySegment, secondarySegment, tertiarySegment, ""FINAL STATUS"");
			}
			
		}

		
	}

	
	return true;
}"	1	E121348E-E99A-4C9B-B8F8-13EBC6F6B624	Spread sales ralations from N.A. version to completeded budget versions	1	1	1	1587	NULL	0	45708.67509	0	0
E69E1702-F12B-45F7-B67F-01676A08289A	CD491758-D9DF-4002-94C8-8006E1855F86	BAPSubplanConfiguration	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0, if script was successful"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""mode"" parameter-type=""string"" parameter-description=""Mode of execution: Add, Delete"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""subplanName"" parameter-type=""string"" parameter-description=""Name of the subplan to be created"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPSubplanConfiguration(string database, string ticket, string mode, string subplanName)
@Description: ""Creates a new sub plan and the basic structure under it"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[mode]: ""Mode of execution: Add, Delete"";
@Parameter[subplanName]: ""Name of the subplan to be created"";
@Returns: ""0, if script was successful"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	
	string parameterDimension = ""BPDPARAMETER"";
	string levelDimension = ""BPDLEVEL"";

	if(mode == ""Delete"")
    {
		subplanName = ResolveUniqueName(connection, subplanName);
		int numberOfLetters = StringFind(subplanName, ""_"", 1) + 1;
		subplanName = StringSubstring(subplanName, numberOfLetters, StringLength(subplanName) - numberOfLetters);
    }


	string subplan = ""SUBPLAN_"" + ToUpper(StringReplace(subplanName, "" "", """", false));
	string subplanReports = subplan + ""_REPORTS"";
	string subplanAccounts = subplan + ""_ACC"";
	string subplanConfingReport = subplan + ""_CONFIGREPORTS"";
	string subplanParameters = subplan + ""_PARAM"";
	string subplanLevel = ""CALC_"" + ToUpper(StringReplace(subplanName, "" "", """", false));


	if(mode == ""Add"")
	{
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplan, ""Subplan Parameter"" , 1.0);
		
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanReports, subplan , 1.0);
		
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanAccounts, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanConfingReport, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanParameters, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, levelDimension, subplanLevel, ""TOTAL_DEFAULT"" , 1.0);

		OLAPElement elementsubplan = OLAPGetDimensionElement(connection, parameterDimension, subplan);
		OLAPSetStringAttribute(connection, elementsubplan, ""English"", subplanName);
		OLAPElement elementsubplanReports = OLAPGetDimensionElement(connection, parameterDimension, subplanReports);
		OLAPSetStringAttribute(connection, elementsubplanReports, ""English"", subplanName + "" - Reports"");
		OLAPElement elementsubplanAccounts = OLAPGetDimensionElement(connection, parameterDimension, subplanAccounts);
		OLAPSetStringAttribute(connection, elementsubplanAccounts, ""English"", subplanName + "" - Account Parameters"");
		OLAPElement elementsubplanConfingReport = OLAPGetDimensionElement(connection, parameterDimension, subplanConfingReport);
		OLAPSetStringAttribute(connection, elementsubplanConfingReport, ""English"", subplanName + "" - Configuration reports"");
		OLAPElement elementsubplanParameters = OLAPGetDimensionElement(connection, parameterDimension, subplanParameters);
		OLAPSetStringAttribute(connection, elementsubplanParameters, ""English"", subplanName + "" - additional Parameters"");
	}

	if(mode == ""Delete"")
	{
		OLAPElementList childElementList = OLAPGetDirectChildrenList(connection, parameterDimension, subplan, false);

		int childrenCount = 0;

		foreach(OLAPElement childElement in childElementList)
		{

			LogDebug(childElement);
			childrenCount = Count(OLAPGetDirectChildrenList(connection, parameterDimension, childElement, false));

			if(childrenCount &gt;0)
			{
				foreach(OLAPElement subChildElement in OLAPGetDirectChildrenList(connection, parameterDimension, childElement, false))
				{
					OLAPDeleteDimensionElement(connection, parameterDimension, subChildElement);

				}

			}

			OLAPDeleteDimensionElement(connection, parameterDimension, childElement);

		}

		OLAPDeleteDimensionElement(connection, parameterDimension, subplan);
		OLAPDeleteDimensionElement(connection, levelDimension, subplanLevel);

	}
	
	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPSubplanConfiguration(string database, string ticket, string mode, string subplanName)
@Description: ""Creates a new sub plan and the basic structure under it"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[mode]: ""Mode of execution: Add, Delete"";
@Parameter[subplanName]: ""Name of the subplan to be created"";
@Returns: ""0, if script was successful"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	
	string parameterDimension = ""BPDPARAMETER"";
	string levelDimension = ""BPDLEVEL"";

	if(mode == ""Delete"")
    {
		subplanName = ResolveUniqueName(connection, subplanName);
		int numberOfLetters = StringFind(subplanName, ""_"", 1) + 1;
		subplanName = StringSubstring(subplanName, numberOfLetters, StringLength(subplanName) - numberOfLetters);
    }


	string subplan = ""SUBPLAN_"" + ToUpper(StringReplace(subplanName, "" "", """", false));
	string subplanReports = subplan + ""_REPORTS"";
	string subplanAccounts = subplan + ""_ACC"";
	string subplanConfingReport = subplan + ""_CONFIGREPORTS"";
	string subplanParameters = subplan + ""_PARAM"";
	string subplanLevel = ""CALC_"" + ToUpper(StringReplace(subplanName, "" "", """", false));


	if(mode == ""Add"")
	{
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplan, ""Subplan Parameter"" , 1.0);
		
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanReports, subplan , 1.0);
		
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanAccounts, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanConfingReport, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, parameterDimension, subplanParameters, subplan , 1.0);

		OLAPCreateNumericalDimensionElement(connection, levelDimension, subplanLevel, ""TOTAL_DEFAULT"" , 1.0);

		OLAPElement elementsubplan = OLAPGetDimensionElement(connection, parameterDimension, subplan);
		OLAPSetStringAttribute(connection, elementsubplan, ""English"", subplanName);
		OLAPElement elementsubplanReports = OLAPGetDimensionElement(connection, parameterDimension, subplanReports);
		OLAPSetStringAttribute(connection, elementsubplanReports, ""English"", subplanName + "" - Reports"");
		OLAPElement elementsubplanAccounts = OLAPGetDimensionElement(connection, parameterDimension, subplanAccounts);
		OLAPSetStringAttribute(connection, elementsubplanAccounts, ""English"", subplanName + "" - Account Parameters"");
		OLAPElement elementsubplanConfingReport = OLAPGetDimensionElement(connection, parameterDimension, subplanConfingReport);
		OLAPSetStringAttribute(connection, elementsubplanConfingReport, ""English"", subplanName + "" - Configuration reports"");
		OLAPElement elementsubplanParameters = OLAPGetDimensionElement(connection, parameterDimension, subplanParameters);
		OLAPSetStringAttribute(connection, elementsubplanParameters, ""English"", subplanName + "" - additional Parameters"");
	}

	if(mode == ""Delete"")
	{
		OLAPElementList childElementList = OLAPGetDirectChildrenList(connection, parameterDimension, subplan, false);

		int childrenCount = 0;

		foreach(OLAPElement childElement in childElementList)
		{

			LogDebug(childElement);
			childrenCount = Count(OLAPGetDirectChildrenList(connection, parameterDimension, childElement, false));

			if(childrenCount >0)
			{
				foreach(OLAPElement subChildElement in OLAPGetDirectChildrenList(connection, parameterDimension, childElement, false))
				{
					OLAPDeleteDimensionElement(connection, parameterDimension, subChildElement);

				}

			}

			OLAPDeleteDimensionElement(connection, parameterDimension, childElement);

		}

		OLAPDeleteDimensionElement(connection, parameterDimension, subplan);
		OLAPDeleteDimensionElement(connection, levelDimension, subplanLevel);

	}
	
	return 0;
}"	1	7303D2E0-8B21-4B16-B2B7-19B2C157D088	Creates a new sub plan and the basic structure under it	1	1	1	1588	NULL	0	45708.67505	0	0
C8DA46ED-4578-40EF-9BA6-A28CE631EBE9	CD491758-D9DF-4002-94C8-8006E1855F86	BAPSubplanConfigurationReports	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 if script was successful"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""mode"" parameter-type=""string"" parameter-description=""Adding report (report), configuration report (config) or parameter (param); or deleting (delete)"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""subplanName"" parameter-type=""string"" parameter-description=""Name of the subplan to be created"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""reportName"" parameter-type=""string"" parameter-description=""Name of the report to be created or managed"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPSubplanConfigurationReports(string database, string ticket, string mode, string subplanName, string reportName)
@Description: ""Creates new reports and parameters for a sub plan"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[mode]: ""Adding report (report), configuration report (config) or parameter (param); or deleting (delete)"";
@Parameter[subplanName]: ""Name of the subplan to be created"";
@Parameter[reportName]: ""Name of the report to be created or managed"";
@Returns: ""0 if script was successful"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	string parameterDimension = ""BPDPARAMETER"";
	subplanName = ResolveUniqueName(connection, subplanName);
	string subplan = ToUpper(subplanName);
	
	string reportNameElement = ToUpper(StringReplace(reportName, "" "", """", false));

	reportNameElement = subplan + ""_"" + reportNameElement;

	if(mode == ""report"")
	{

		string subplanReports = subplan + ""_REPORTS"";
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanReports , 1.0);

		OLAPElement elementsubplanReport = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanReport, ""English"", reportName);
	}

	if(mode == ""config"")
	{

		string subplanConfigReports = subplan + ""_CONFIGREPORTS"";
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanConfigReports , 1.0);

		OLAPElement elementsubplanConfigReports = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanConfigReports, ""English"", reportName);
	}

	if(mode == ""param"")
	{
		string subplanParam = subplan + ""_ACC"";
		reportNameElement =subplanParam + ""_"" + reportName;

			OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanParam , 1.0);

		OLAPElement elementsubplanParam = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanParam, ""English"", reportName);
	}

	if(mode == ""delete"")
	{
		reportName = ResolveUniqueName(connection, reportName);
		OLAPDeleteDimensionElement(connection, parameterDimension, reportName);
		
	}
	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BAPSubplanConfigurationReports(string database, string ticket, string mode, string subplanName, string reportName)
@Description: ""Creates new reports and parameters for a sub plan"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[mode]: ""Adding report (report), configuration report (config) or parameter (param); or deleting (delete)"";
@Parameter[subplanName]: ""Name of the subplan to be created"";
@Parameter[reportName]: ""Name of the report to be created or managed"";
@Returns: ""0 if script was successful"";
{
	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);

	string parameterDimension = ""BPDPARAMETER"";
	subplanName = ResolveUniqueName(connection, subplanName);
	string subplan = ToUpper(subplanName);
	
	string reportNameElement = ToUpper(StringReplace(reportName, "" "", """", false));

	reportNameElement = subplan + ""_"" + reportNameElement;

	if(mode == ""report"")
	{

		string subplanReports = subplan + ""_REPORTS"";
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanReports , 1.0);

		OLAPElement elementsubplanReport = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanReport, ""English"", reportName);
	}

	if(mode == ""config"")
	{

		string subplanConfigReports = subplan + ""_CONFIGREPORTS"";
		OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanConfigReports , 1.0);

		OLAPElement elementsubplanConfigReports = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanConfigReports, ""English"", reportName);
	}

	if(mode == ""param"")
	{
		string subplanParam = subplan + ""_ACC"";
		reportNameElement =subplanParam + ""_"" + reportName;

			OLAPCreateNumericalDimensionElement(connection, parameterDimension, reportNameElement, subplanParam , 1.0);

		OLAPElement elementsubplanParam = OLAPGetDimensionElement(connection, parameterDimension, reportNameElement);
		OLAPSetStringAttribute(connection, elementsubplanParam, ""English"", reportName);
	}

	if(mode == ""delete"")
	{
		reportName = ResolveUniqueName(connection, reportName);
		OLAPDeleteDimensionElement(connection, parameterDimension, reportName);
		
	}
	return 0;
}"	1	83B24574-E395-431C-B7E2-2D98743F256A	Creates new reports and parameters for a sub plan	1	1	1	1589	NULL	0	45708.67507	0	0
AA875639-0FC7-4269-9520-8E8FABF54D11	CD491758-D9DF-4002-94C8-8006E1855F86	BAPTransferFinancialDataToConsolidation	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 for ok, -1 if the specified company has no currency, -2 if the company has a different currency in source and target."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""planningDatabase"" parameter-type=""string"" parameter-description=""The Budgeting and Planning OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""planningTicket"" parameter-type=""string"" parameter-description=""The ticket to connect with the planning database."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""consolidationDatabase"" parameter-type=""string"" parameter-description=""The Consolidation OLAP database to use in form Servername/Databasename."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""consolidationTicket"" parameter-type=""string"" parameter-description=""The ticket to connect with the consolidation database."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""planningVersion"" parameter-type=""string"" parameter-description=""The planning version element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The company to copy."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to copy from, if this is a parent element, all months below will be copied."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""consolidationVersion"" parameter-type=""string"" parameter-description=""The consolidation version to copy to."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""targetLevel"" parameter-type=""string"" parameter-description=""The level to copy to."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""reverseSignExpenditures"" parameter-type=""bool"" parameter-description=""If true, for all expenditure accounts the sign of the value is reversed in the target."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""reverseSignRevenues"" parameter-type=""bool"" parameter-description=""If true, for all revenue accounts the sign of the value is reversed in the target."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""reverseSignAssets"" parameter-type=""bool"" parameter-description=""If true, for all asset accounts the sign of the value is reversed in the target."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""reverseSignLiabilities"" parameter-type=""bool"" parameter-description=""If true, for all liability accounts the sign of the value is reversed in the target."" parameter-order=""13"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPTransferFinancialDataToConsolidation(
	string planningDatabase, string planningTicket, string consolidationDatabase, string consolidationTicket,
	string cycle, string planningVersion, string entity, string time, string consolidationVersion, string targetLevel,
	bool reverseSignExpenditures, bool reverseSignRevenues, bool reverseSignAssets, bool reverseSignLiabilities)

@Description: ""Copies data for a specific company and Configuration Set from Budgeting&amp;Planning to Consolidation."";
@Category: ""Budgeting and Planning"";
@Parameter[planningDatabase]: ""The Budgeting and Planning OLAP database to use in form Servername/Databasename."";
@Parameter[planningTicket]: ""The ticket to connect with the planning database."";
@Parameter[consolidationDatabase]: ""The Consolidation OLAP database to use in form Servername/Databasename."";
@Parameter[consolidationTicket]: ""The ticket to connect with the consolidation database."";
@Parameter[time]: ""The time element to copy from, if this is a parent element, all months below will be copied."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[planningVersion]: ""The planning version element to be used."";
@Parameter[entity]: ""The company to copy."";
@Parameter[consolidationVersion]: ""The consolidation version to copy to."";
@Parameter[targetLevel]: ""The level to copy to."";
@Parameter[reverseSignExpenditures]: ""If true, for all expenditure accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignRevenues]: ""If true, for all revenue accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignAssets]: ""If true, for all asset accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignLiabilities]: ""If true, for all liability accounts the sign of the value is reversed in the target."";
@Returns: ""0 for ok, -1 if the specified company has no currency, -2 if the company has a different currency in source and target."";
{

	OLAPConnection planningConnection = OLAPCreatePooledNamedConnection(planningDatabase);
	OLAPConnection consolidationConnection = OLAPCreatePooledNamedConnection(consolidationDatabase);
	
	string AccountDimension = ""BPDACCOUNT"";
	string PrimarySegmentDimension = ""BPDPSEGMENT"";
	string SecondarySegmentDimension = ""BPDSSEGMENT"";
	string TertiarySegmentDimension = ""BPDTSEGMENT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CompanyConfigurationCube = ""BPCCONFIG_ENTITY"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";

	
	string analysis1read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_12""));
	string step = ToString(BP_GetTopElement(planningConnection , ""BPDSTEP""));
	
	string ConsolidationFinanceCube = ""TFINANC"";
	string ConsolidationDetailCube = ""TDETAIC"";
	string ConsolidationSegmentCube = ""TSEGMC"";
	string ConsolidationComanyCube = ""TCOMPPA"";
	string ConsolidationConfigurationCube = ""TFLAGS"";
	string ConsolidationAccountDimension = ""DACOUNT"";
	string ConsolidationDetailDimension = ""DDETAIL"";
	string ConsolidationSegment1Dimension = ""DPSEGM"";
	string ConsolidationSegment2Dimension = ""DSSEGM"";
	string ConsolidationSegment3Dimension = ""DTSEGM"";

	
	string NA = ""N.A."";
	string DashElement = ""-"";
	
	time = ResolveUniqueName(planningConnection, time);
	cycle = ResolveUniqueName(planningConnection, cycle);
	planningVersion = ResolveUniqueName(planningConnection, planningVersion);
	entity = ResolveUniqueName(planningConnection, entity);
	consolidationVersion = ResolveUniqueName(consolidationConnection,consolidationVersion);
	targetLevel = ResolveUniqueName(consolidationConnection, targetLevel);

	// get company currency
	string currency = OLAPCellReadString(planningConnection, CompanyConfigurationCube, cycle, entity, NA, NA, ""GLOBAL_ENTITY_CURRENCY"");
	currency = ResolveUniqueName(planningConnection, currency);
	currency = StringReplace(currency, ""_LC"", """", false);
	
	LogDebug(""Using currency: "" + currency);
	if (currency == """")
	{
		LogError(""BPTransferFinancialDataToConsolidation: The selected company has no currency defined."");
		return -1;
	}
	
	// check if details are in use
	bool detailsActive = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_DETAIL"", ""Value"") == 1;

	// check if segments are in use
	bool segment1Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_PSEGMENT"", ""Value"") == 1;
	bool segment2Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_SSEGMENT"", ""Value"") == 1;
	bool segment3Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_TSEGMENT"", ""Value"") == 1;
	bool segmentsActive = segment1Active or segment2Active or segment3Active;
	
	// get configuration of segments from consolidation
	double consolidationSegment1Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Primary Segment"");
	double consolidationSegment2Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Secondary Segment"");
	double consolidationSegment3Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Tertiary Segment"");
	bool consolidationSegmentsActive = consolidationSegment1Type &gt; 0;

	// get the list of months to calculate effectively
	OLAPElement timeElement = OLAPGetDimensionElement(planningConnection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(planningConnection, timeElement);

	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(planningConnection, TimeDimension, time, true);
	}

	// B&amp;P can have extended the hierarchies so that base elements in Consolidation can be aggregated elements in B&amp;P
	OLAPElementList accounts = OLAPGetChildElementList(planningConnection, AccountDimension, ""TOTAL_ACCOUNT"", false);
	OLAPElementList primarySegments = OLAPGetChildElementList(planningConnection, PrimarySegmentDimension, ""TOTAL_SEGMENT"", false);
	OLAPElementList secondarySegments = OLAPGetChildElementList(planningConnection, SecondarySegmentDimension, ""TOTAL_SEGMENT"", false);
	OLAPElementList tertiarySegments = OLAPGetChildElementList(planningConnection, TertiarySegmentDimension, ""TOTAL_SEGMENT"", false);

	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		string sourcePeriod = currentMonth + ""_YTD"";
		string currentYear = OLAPGetStringAttribute(planningConnection, currentMonth, ""CURRENT_YEAR"");

		// get the current month id
		string targetPeriod = OLAPGetStringAttribute(planningConnection, currentMonth, ""CURRENT_MONTH_ID"");
		
		LogDebug(""Processing: "" + currentYear + "", "" + sourcePeriod);

		string consolidationCompanyCurrency = OLAPCellReadString(consolidationConnection, ConsolidationComanyCube, currentYear, targetPeriod, consolidationVersion, entity, ""Currency"");
		LogDebug(consolidationCompanyCurrency);
		if (consolidationCompanyCurrency != currency)
		{
			LogError(""BAPTransferFinancialDataToConsolidation: The selected company has a different currency in the source and the target."");
			return -1;
		}

		// delete target data
		OLAPDataArea deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationFinanceCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, OlapDataAreaBCells, OlapDataAreaBCells);
		
		OLAPDeleteDataArea(deleteData);
		
		// 1. Copy finance data
		// read all values from source using the YTD hierarchy to transfer it into Consolidation
		// for segments and schedules read from the totals
		OLAPDataArea sourceData = OLAPCreateDataArea(planningConnection, MainCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             sourcePeriod, cycle, planningVersion,""TOTAL_LEVEL"",step, entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"", accounts,currency, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		foreach (OLAPCell cell in sourceData)
		{
			string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");


			double value = cell;
			
			if (intercompany == NA)
			{
				intercompany = ""External"";
			}

			// check, if the account exists in the consolidation db
			if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account))
			{
				// TODO check if account is intercompany, if not, write to external or end the process when an intercompany is used
				
				// write only if the target account is a base element
				OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
				if (OLAPIsBaseElement(consolidationConnection, accountElement))
				{

					string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
					if (accountType == ""A"" and reverseSignAssets or
					    accountType == ""L"" and reverseSignLiabilities or
					    accountType == ""R"" and reverseSignRevenues or
					    accountType == ""E"" and reverseSignExpenditures)
					{
						value = value * -1;
					}

					// write the value to Consolidations
					OLAPCellWriteNumber(consolidationConnection, ConsolidationFinanceCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, intercompany, account);
				}
			}
		}
		
		if (detailsActive)
		{
			// delete target data
			deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationDetailCube,
			                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
			
			OLAPDeleteDataArea(deleteData);
			
			// 2. Copy schedule data
			// read all values from source using the YTD hierarchy to transfer it into Consolidation
			// for segments read from the totals
			sourceData = OLAPCreateDataArea(planningConnection, MainCube,
			                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                sourcePeriod, cycle, planningVersion, ""TOTAL_LEVEL"",step,entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"", accounts,currency, OlapDataAreaBCells, ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			foreach (OLAPCell cell in sourceData)
			{
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				
				double value = cell;
				
				if (intercompany == NA)
				{
					intercompany = ""External"";
				}
				if (detail == NA)
				{
					detail = DashElement;
				}
				
				// check, if the account exists in the consolidation db
				if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationDetailDimension, detail))
				{
					// write only if the target account and detail is a base element
					OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
					OLAPElement detailElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationDetailDimension, detail);
					if (OLAPIsBaseElement(consolidationConnection, accountElement) and OLAPIsBaseElement(consolidationConnection, detailElement))
					{
						string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
						if (accountType == ""A"" and reverseSignAssets or
						    accountType == ""L"" and reverseSignLiabilities or
						    accountType == ""R"" and reverseSignRevenues or
						    accountType == ""E"" and reverseSignExpenditures)
						{
							value = value * -1;
						}
						// write the value to Consolidations
						OLAPCellWriteNumber(consolidationConnection, ConsolidationDetailCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, intercompany, detail, account);
					}
				}
			}
		}

		if (segmentsActive)
		{
			LogDebug(""Processing segments"");
			
			// delete target data
			deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationSegmentCube,
			                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
			
			OLAPDeleteDataArea(deleteData);
			
			// 3. Copy segment data
			// read all values from source using the YTD hierarchy to transfer it into Consolidation
			// for details read from the total
			sourceData = OLAPCreateDataArea(planningConnection, MainCube,
			                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                sourcePeriod, cycle, planningVersion,""TOTAL_LEVEL"",step, entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"",accounts, currency, ""TOTAL_DETAIL"", primarySegments, secondarySegments, tertiarySegments, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			foreach (OLAPCell cell in sourceData)
			{
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string psegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string ssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tsegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string opsegment = psegment;
				string ossegment = ssegment;
				string otsegment = tsegment;
				
				double value = cell;
				
				if (intercompany == NA)
				{
					intercompany = ""External"";
				}
				if (psegment == NA)
				{
					psegment = ""Unassigned"";
				}
				if (ssegment == NA)
				{
					ssegment = ""Unassigned"";
				}
				if (tsegment == NA)
				{
					tsegment = ""Unassigned"";
				}

				// check, if the account exists in the consolidation db
				if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment1Dimension, psegment) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment2Dimension, ssegment) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment3Dimension, tsegment))
				{
					OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
					OLAPElement psegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment1Dimension, psegment);
					OLAPElement ssegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment2Dimension, ssegment);
					OLAPElement tsegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment3Dimension, tsegment);
					if (OLAPIsBaseElement(consolidationConnection, accountElement) and OLAPIsBaseElement(consolidationConnection, psegmentElement) and OLAPIsBaseElement(consolidationConnection, ssegmentElement) and OLAPIsBaseElement(consolidationConnection, tsegmentElement))
					{
						string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
						if (accountType == ""A"" and reverseSignAssets or
						    accountType == ""L"" and reverseSignLiabilities or
						    accountType == ""R"" and reverseSignRevenues or
						    accountType == ""E"" and reverseSignExpenditures)
						{
							value = value * -1;
						}

						if (consolidationSegment1Type == 1)
						{
							string targetPartnerSegment1 = ""Unassigned"";
							string targetPartnerSegment2 = ""Unassigned"";
							string targetPartnerSegment3 = ""Unassigned"";
							
							if (consolidationSegment2Type == 0)
							{
								psegment = DashElement;
								targetPartnerSegment2 = DashElement;
							}

							if (consolidationSegment3Type == 0)
							{
								tsegment = DashElement;
								targetPartnerSegment3 = DashElement;
							}
							// hierarchical segmentation in consolidation
							OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, psegment, ""Unassigned"", ssegment, ""Unassigned"", tsegment, ""Unassigned"", account);
						}
						else
						{
							// parallel segmentation in consolidation, only write values if segment is active in consolidaton and B&amp;P and if not NA is used
							if (opsegment != NA and segment1Active and consolidationSegment1Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, psegment, ""Unassigned"", DashElement, DashElement, DashElement, DashElement, account);
							}

							if (ossegment != NA and segment2Active and consolidationSegment2Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, DashElement, DashElement, ssegment, ""Unassigned"", DashElement, DashElement, account);
							}

							if (otsegment != NA and segment3Active and consolidationSegment3Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, DashElement, DashElement, DashElement, DashElement, tsegment, ""Unassigned"", account);
							}
						}
					}
				}
			}
		}
	}
	
	return 1;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""

int BAPTransferFinancialDataToConsolidation(
	string planningDatabase, string planningTicket, string consolidationDatabase, string consolidationTicket,
	string cycle, string planningVersion, string entity, string time, string consolidationVersion, string targetLevel,
	bool reverseSignExpenditures, bool reverseSignRevenues, bool reverseSignAssets, bool reverseSignLiabilities)

@Description: ""Copies data for a specific company and Configuration Set from Budgeting&Planning to Consolidation."";
@Category: ""Budgeting and Planning"";
@Parameter[planningDatabase]: ""The Budgeting and Planning OLAP database to use in form Servername/Databasename."";
@Parameter[planningTicket]: ""The ticket to connect with the planning database."";
@Parameter[consolidationDatabase]: ""The Consolidation OLAP database to use in form Servername/Databasename."";
@Parameter[consolidationTicket]: ""The ticket to connect with the consolidation database."";
@Parameter[time]: ""The time element to copy from, if this is a parent element, all months below will be copied."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[planningVersion]: ""The planning version element to be used."";
@Parameter[entity]: ""The company to copy."";
@Parameter[consolidationVersion]: ""The consolidation version to copy to."";
@Parameter[targetLevel]: ""The level to copy to."";
@Parameter[reverseSignExpenditures]: ""If true, for all expenditure accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignRevenues]: ""If true, for all revenue accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignAssets]: ""If true, for all asset accounts the sign of the value is reversed in the target."";
@Parameter[reverseSignLiabilities]: ""If true, for all liability accounts the sign of the value is reversed in the target."";
@Returns: ""0 for ok, -1 if the specified company has no currency, -2 if the company has a different currency in source and target."";
{

	OLAPConnection planningConnection = OLAPCreatePooledNamedConnection(planningDatabase);
	OLAPConnection consolidationConnection = OLAPCreatePooledNamedConnection(consolidationDatabase);
	
	string AccountDimension = ""BPDACCOUNT"";
	string PrimarySegmentDimension = ""BPDPSEGMENT"";
	string SecondarySegmentDimension = ""BPDSSEGMENT"";
	string TertiarySegmentDimension = ""BPDTSEGMENT"";
	string TimeDimension = ""BPDTIME"";
	string MainCube = ""BPCMAIN"";
	string CompanyConfigurationCube = ""BPCCONFIG_ENTITY"";
	string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";

	
	string analysis1read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_01""));
	string analysis2read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_02""));
	string analysis3read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_03""));
	string analysis4read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_04""));
	string analysis5read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_05""));
	string analysis6read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_06""));
	string analysis7read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_07""));
	string analysis8read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_08""));
	string analysis9read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_09""));
	string analysis10read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_10""));
	string analysis11read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_11""));
	string analysis12read = ToString(BP_GetTopElement(planningConnection , ""BPDANALYSIS_12""));
	string step = ToString(BP_GetTopElement(planningConnection , ""BPDSTEP""));
	
	string ConsolidationFinanceCube = ""TFINANC"";
	string ConsolidationDetailCube = ""TDETAIC"";
	string ConsolidationSegmentCube = ""TSEGMC"";
	string ConsolidationComanyCube = ""TCOMPPA"";
	string ConsolidationConfigurationCube = ""TFLAGS"";
	string ConsolidationAccountDimension = ""DACOUNT"";
	string ConsolidationDetailDimension = ""DDETAIL"";
	string ConsolidationSegment1Dimension = ""DPSEGM"";
	string ConsolidationSegment2Dimension = ""DSSEGM"";
	string ConsolidationSegment3Dimension = ""DTSEGM"";

	
	string NA = ""N.A."";
	string DashElement = ""-"";
	
	time = ResolveUniqueName(planningConnection, time);
	cycle = ResolveUniqueName(planningConnection, cycle);
	planningVersion = ResolveUniqueName(planningConnection, planningVersion);
	entity = ResolveUniqueName(planningConnection, entity);
	consolidationVersion = ResolveUniqueName(consolidationConnection,consolidationVersion);
	targetLevel = ResolveUniqueName(consolidationConnection, targetLevel);

	// get company currency
	string currency = OLAPCellReadString(planningConnection, CompanyConfigurationCube, cycle, entity, NA, NA, ""GLOBAL_ENTITY_CURRENCY"");
	currency = ResolveUniqueName(planningConnection, currency);
	currency = StringReplace(currency, ""_LC"", """", false);
	
	LogDebug(""Using currency: "" + currency);
	if (currency == """")
	{
		LogError(""BPTransferFinancialDataToConsolidation: The selected company has no currency defined."");
		return -1;
	}
	
	// check if details are in use
	bool detailsActive = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_DETAIL"", ""Value"") == 1;

	// check if segments are in use
	bool segment1Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_PSEGMENT"", ""Value"") == 1;
	bool segment2Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_SSEGMENT"", ""Value"") == 1;
	bool segment3Active = OLAPCellReadNumber(planningConnection, CycleConfigurationCube, 1.0, cycle, ""GLOBAL_CYCLE_ACTIVE_TSEGMENT"", ""Value"") == 1;
	bool segmentsActive = segment1Active or segment2Active or segment3Active;
	
	// get configuration of segments from consolidation
	double consolidationSegment1Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Primary Segment"");
	double consolidationSegment2Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Secondary Segment"");
	double consolidationSegment3Type = OLAPCellReadNumber(consolidationConnection, ConsolidationConfigurationCube, 1.0, ""M1"", ""Tertiary Segment"");
	bool consolidationSegmentsActive = consolidationSegment1Type > 0;

	// get the list of months to calculate effectively
	OLAPElement timeElement = OLAPGetDimensionElement(planningConnection, TimeDimension, time);
	bool baseTimeElement = OLAPIsBaseElement(planningConnection, timeElement);

	OLAPElementList months = OLAPGetElementList(timeElement);
	if (!baseTimeElement)
	{
		months = OLAPGetChildElementList(planningConnection, TimeDimension, time, true);
	}

	// B&P can have extended the hierarchies so that base elements in Consolidation can be aggregated elements in B&P
	OLAPElementList accounts = OLAPGetChildElementList(planningConnection, AccountDimension, ""TOTAL_ACCOUNT"", false);
	OLAPElementList primarySegments = OLAPGetChildElementList(planningConnection, PrimarySegmentDimension, ""TOTAL_SEGMENT"", false);
	OLAPElementList secondarySegments = OLAPGetChildElementList(planningConnection, SecondarySegmentDimension, ""TOTAL_SEGMENT"", false);
	OLAPElementList tertiarySegments = OLAPGetChildElementList(planningConnection, TertiarySegmentDimension, ""TOTAL_SEGMENT"", false);

	// for each month calculate sales values
	foreach (OLAPElement currentMonth in months)
	{
		string sourcePeriod = currentMonth + ""_YTD"";
		string currentYear = OLAPGetStringAttribute(planningConnection, currentMonth, ""CURRENT_YEAR"");

		// get the current month id
		string targetPeriod = OLAPGetStringAttribute(planningConnection, currentMonth, ""CURRENT_MONTH_ID"");
		
		LogDebug(""Processing: "" + currentYear + "", "" + sourcePeriod);

		string consolidationCompanyCurrency = OLAPCellReadString(consolidationConnection, ConsolidationComanyCube, currentYear, targetPeriod, consolidationVersion, entity, ""Currency"");
		LogDebug(consolidationCompanyCurrency);
		if (consolidationCompanyCurrency != currency)
		{
			LogError(""BAPTransferFinancialDataToConsolidation: The selected company has a different currency in the source and the target."");
			return -1;
		}

		// delete target data
		OLAPDataArea deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationFinanceCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, OlapDataAreaBCells, OlapDataAreaBCells);
		
		OLAPDeleteDataArea(deleteData);
		
		// 1. Copy finance data
		// read all values from source using the YTD hierarchy to transfer it into Consolidation
		// for segments and schedules read from the totals
		OLAPDataArea sourceData = OLAPCreateDataArea(planningConnection, MainCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             sourcePeriod, cycle, planningVersion,""TOTAL_LEVEL"",step, entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"", accounts,currency, ""TOTAL_DETAIL"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);

		foreach (OLAPCell cell in sourceData)
		{
			string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");


			double value = cell;
			
			if (intercompany == NA)
			{
				intercompany = ""External"";
			}

			// check, if the account exists in the consolidation db
			if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account))
			{
				// TODO check if account is intercompany, if not, write to external or end the process when an intercompany is used
				
				// write only if the target account is a base element
				OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
				if (OLAPIsBaseElement(consolidationConnection, accountElement))
				{

					string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
					if (accountType == ""A"" and reverseSignAssets or
					    accountType == ""L"" and reverseSignLiabilities or
					    accountType == ""R"" and reverseSignRevenues or
					    accountType == ""E"" and reverseSignExpenditures)
					{
						value = value * -1;
					}

					// write the value to Consolidations
					OLAPCellWriteNumber(consolidationConnection, ConsolidationFinanceCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, intercompany, account);
				}
			}
		}
		
		if (detailsActive)
		{
			// delete target data
			deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationDetailCube,
			                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
			
			OLAPDeleteDataArea(deleteData);
			
			// 2. Copy schedule data
			// read all values from source using the YTD hierarchy to transfer it into Consolidation
			// for segments read from the totals
			sourceData = OLAPCreateDataArea(planningConnection, MainCube,
			                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                sourcePeriod, cycle, planningVersion, ""TOTAL_LEVEL"",step,entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"", accounts,currency, OlapDataAreaBCells, ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", ""TOTAL_SEGMENT"", analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			foreach (OLAPCell cell in sourceData)
			{
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
				
				double value = cell;
				
				if (intercompany == NA)
				{
					intercompany = ""External"";
				}
				if (detail == NA)
				{
					detail = DashElement;
				}
				
				// check, if the account exists in the consolidation db
				if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationDetailDimension, detail))
				{
					// write only if the target account and detail is a base element
					OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
					OLAPElement detailElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationDetailDimension, detail);
					if (OLAPIsBaseElement(consolidationConnection, accountElement) and OLAPIsBaseElement(consolidationConnection, detailElement))
					{
						string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
						if (accountType == ""A"" and reverseSignAssets or
						    accountType == ""L"" and reverseSignLiabilities or
						    accountType == ""R"" and reverseSignRevenues or
						    accountType == ""E"" and reverseSignExpenditures)
						{
							value = value * -1;
						}
						// write the value to Consolidations
						OLAPCellWriteNumber(consolidationConnection, ConsolidationDetailCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", entity, intercompany, detail, account);
					}
				}
			}
		}

		if (segmentsActive)
		{
			LogDebug(""Processing segments"");
			
			// delete target data
			deleteData = OLAPCreateDataArea(consolidationConnection, ConsolidationSegmentCube,
			                                OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells);
			
			OLAPDeleteDataArea(deleteData);
			
			// 3. Copy segment data
			// read all values from source using the YTD hierarchy to transfer it into Consolidation
			// for details read from the total
			sourceData = OLAPCreateDataArea(planningConnection, MainCube,
			                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
			                                sourcePeriod, cycle, planningVersion,""TOTAL_LEVEL"",step, entity, OlapDataAreaBCells, ""TOTAL_ORGANIZATION"",accounts, currency, ""TOTAL_DETAIL"", primarySegments, secondarySegments, tertiarySegments, analysis1read,analysis2read,analysis3read,analysis4read,analysis5read,analysis6read,analysis7read,analysis8read,analysis9read,analysis10read,analysis11read,analysis12read);
			
			foreach (OLAPCell cell in sourceData)
			{
				string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
				string account = OLAPCellGetElement(cell, ""BPDACCOUNT"");
				string psegment = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
				string ssegment = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
				string tsegment = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
				string opsegment = psegment;
				string ossegment = ssegment;
				string otsegment = tsegment;
				
				double value = cell;
				
				if (intercompany == NA)
				{
					intercompany = ""External"";
				}
				if (psegment == NA)
				{
					psegment = ""Unassigned"";
				}
				if (ssegment == NA)
				{
					ssegment = ""Unassigned"";
				}
				if (tsegment == NA)
				{
					tsegment = ""Unassigned"";
				}

				// check, if the account exists in the consolidation db
				if (OLAPDimensionElementExists(consolidationConnection, ConsolidationAccountDimension, account) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment1Dimension, psegment) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment2Dimension, ssegment) and
				    OLAPDimensionElementExists(consolidationConnection, ConsolidationSegment3Dimension, tsegment))
				{
					OLAPElement accountElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationAccountDimension, account);
					OLAPElement psegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment1Dimension, psegment);
					OLAPElement ssegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment2Dimension, ssegment);
					OLAPElement tsegmentElement = OLAPGetDimensionElement(consolidationConnection, ConsolidationSegment3Dimension, tsegment);
					if (OLAPIsBaseElement(consolidationConnection, accountElement) and OLAPIsBaseElement(consolidationConnection, psegmentElement) and OLAPIsBaseElement(consolidationConnection, ssegmentElement) and OLAPIsBaseElement(consolidationConnection, tsegmentElement))
					{
						string accountType = OLAPGetStringAttribute(consolidationConnection, accountElement, ""ALRE"");
						if (accountType == ""A"" and reverseSignAssets or
						    accountType == ""L"" and reverseSignLiabilities or
						    accountType == ""R"" and reverseSignRevenues or
						    accountType == ""E"" and reverseSignExpenditures)
						{
							value = value * -1;
						}

						if (consolidationSegment1Type == 1)
						{
							string targetPartnerSegment1 = ""Unassigned"";
							string targetPartnerSegment2 = ""Unassigned"";
							string targetPartnerSegment3 = ""Unassigned"";
							
							if (consolidationSegment2Type == 0)
							{
								psegment = DashElement;
								targetPartnerSegment2 = DashElement;
							}

							if (consolidationSegment3Type == 0)
							{
								tsegment = DashElement;
								targetPartnerSegment3 = DashElement;
							}
							// hierarchical segmentation in consolidation
							OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, psegment, ""Unassigned"", ssegment, ""Unassigned"", tsegment, ""Unassigned"", account);
						}
						else
						{
							// parallel segmentation in consolidation, only write values if segment is active in consolidaton and B&P and if not NA is used
							if (opsegment != NA and segment1Active and consolidationSegment1Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, psegment, ""Unassigned"", DashElement, DashElement, DashElement, DashElement, account);
							}

							if (ossegment != NA and segment2Active and consolidationSegment2Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, DashElement, DashElement, ssegment, ""Unassigned"", DashElement, DashElement, account);
							}

							if (otsegment != NA and segment3Active and consolidationSegment3Type == 2)
							{
								OLAPCellWriteNumber(consolidationConnection, ConsolidationSegmentCube, value, currentYear, targetPeriod, consolidationVersion, ""LC (scaled)"", targetLevel, ""Balance Sheet"", ""Segment"", entity, intercompany, DashElement, DashElement, DashElement, DashElement, tsegment, ""Unassigned"", account);
							}
						}
					}
				}
			}
		}
	}
	
	return 1;
}"	1	354D5DFF-2554-43F6-8810-2538A4A6F7A1	Copies data for a specific company and Configuration Set from Budgeting&Planning to Consolidation.	1	1	1	1590	NULL	0	45708.67502	0	0
ED75D217-772A-4490-8A58-8F038F1C8DE3	CD491758-D9DF-4002-94C8-8006E1855F86	BAPTransferFromProfitAndLoss	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""0 is ok"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""The time element to copy.  Multiple elements should be comma separated unique names"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""The currency element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""BP_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_ElementStringSplit"", ""*""

int BAPTransferFromProfitAndLoss(string database, string ticket, string time, string cycle, string entity, string currency, string version)
@Description: ""Transfers the profit and loss data to the profit and loss account in the balance sheet and calculates opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[time]: ""The time element to copy.  Multiple elements should be comma separated unique names"";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currency]: ""The currency element to be used."";
@Parameter[version]: ""The version element to be used."";
@Returns: ""0 is ok"";
{
	string functionName = ""BPTransferFromProfitAndLoss :"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;
	string result ="""";


	try {
		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		
		StringList timeElements = BP_ElementStringSplit(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		entity = ResolveUniqueName(connection, entity);
		currency = ResolveUniqueName(connection, currency);
		version = ResolveUniqueName(connection, version);

		// constants used in the process
		string currencyDimension = ""BPDCURRENCY"";
		string TimeDimension = ""BPDTIME"";
		string EntityDimension = ""BPDENTITY"";
		string LevelDimension = ""BPDLEVEL"";
		string TotalTime = ""TOTAL_TIME"";

		string ConfigDimension = ""BPDCONFIGURATION"";
		string MainCube = ""BPCMAIN"";
		string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
		string NA = ""N.A."";

		string levelSource = ""TOTAL_CHANGE"";
		string levelTarget = ""CALC_PANDL"";

		OLAPElement profitAndLossSourceElement = OLAPGetDimensionElement(connection, ConfigDimension, ""TOP_PROFIT_LOSS"");
		string profitAndLossSourceAccount = OLAPGetStringAttribute(connection, profitAndLossSourceElement, ""VALUE"");

		OLAPElement profitAndLossTargetElement = OLAPGetDimensionElement(connection, ""BPDCONFIGURATION"", ""TOP_PROFIT_LOSS_ACCOUNT"");
		string profitAndLossTargetAccount = OLAPGetStringAttribute(connection, profitAndLossTargetElement, ""VALUE"");
		
		string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
		double cycleYearStart = ToDouble(cycleYearStarthelp);
		double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, NA,""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
		
		LogDebug(""BPTransferFromProfitAndLoss: From: "" + profitAndLossSourceAccount + "" To: "" + profitAndLossTargetAccount);

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		// Get base periods for the time value specified
		OLAPElementList basePeriods = CreateOLAPElementList();
		if (time == ""ALL"") {
			// Special indicator; need to process all years in the planning cycle
			OLAPElementList years = OLAPGetLevelElements(connection, TimeDimension, TotalTime, 1, false);
			foreach (OLAPElement year in years) {
				double checkYear = ToDouble(year);
				
				// for all years in the cycle, get base periods
				if (checkYear &gt;= cycleYearStart and (checkYear - cycleYearStart) &lt; cycleYears)
				{
					OLAPElementList periods = OLAPGetChildElementList(connection, TimeDimension, year, true);
					foreach (OLAPElement p in periods) {
						OLAPElementListAddElement(basePeriods, p);
					}
				}
			}
		} else {
			foreach (string element in timeElements) {
				OLAPElementList periods = OLAPGetChildElementList(connection, TimeDimension, element, true);
				foreach (OLAPElement p in periods) {
					OLAPElementListAddElement(basePeriods, p);
				}
			}
		}

		OLAPElementList baseLevels = OLAPGetChildElementList(connection, LevelDimension, levelSource, true);

		OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension, entity);
		bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);
		
		//Delete target area before transfer

		OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB| OlapDataAreaIncludeC | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             basePeriods, cycle, version, baseLevels,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells,  profitAndLossTargetAccount ,currenList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData);
		int counter = 0;
		
		NotifyInformation(""Transfer of Profit and Loss data started"");

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             basePeriods, cycle, version,levelSource,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells,  profitAndLossSourceAccount ,currenList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		foreach (OLAPCell cell in sourceData)
		{
			string period = OLAPCellGetElement(cell, ""BPDTIME"");
			string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string segment1 = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
			string segment2 = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
			string segment3 = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
			string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			currency = OLAPCellGetElement(cell,""BPDCURRENCY"");
			string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
			string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
			string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
			string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
			string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
			string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
			string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
			string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
			string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
			string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
			string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
			string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
			string step = OLAPCellGetElement(cell, ""BPDSTEP"");
			double value = cell;
			
			
			OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, period, cycle, version,levelTarget,step, entity, intercompany, organization,  profitAndLossTargetAccount,currency, detail, segment1, segment2, segment3, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			counter = counter +1;
		}
		
		
		OLAPCommitCellWriteBuffer(buffer);
		NotifyInformation(""Number of Profit and Loss data transferred: "" + counter + ""."");
		NotifyInformation(""Transfer of Profit and Loss data finished"");


		LogInformation(""BPTransferFromProfitAndLoss: Process complete"");

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	return 0;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""BP_ElementStringSplit"", ""*""

int BAPTransferFromProfitAndLoss(string database, string ticket, string time, string cycle, string entity, string currency, string version)
@Description: ""Transfers the profit and loss data to the profit and loss account in the balance sheet and calculates opening balances."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[time]: ""The time element to copy.  Multiple elements should be comma separated unique names"";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[currency]: ""The currency element to be used."";
@Parameter[version]: ""The version element to be used."";
@Returns: ""0 is ok"";
{
	string functionName = ""BPTransferFromProfitAndLoss :"";
	string errorMessage = """";

	string hierarchy= """";
	int errorCode = 0;
	string result ="""";


	try {
		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		
		StringList timeElements = BP_ElementStringSplit(connection, time);
		cycle = ResolveUniqueName(connection, cycle);
		entity = ResolveUniqueName(connection, entity);
		currency = ResolveUniqueName(connection, currency);
		version = ResolveUniqueName(connection, version);

		// constants used in the process
		string currencyDimension = ""BPDCURRENCY"";
		string TimeDimension = ""BPDTIME"";
		string EntityDimension = ""BPDENTITY"";
		string LevelDimension = ""BPDLEVEL"";
		string TotalTime = ""TOTAL_TIME"";

		string ConfigDimension = ""BPDCONFIGURATION"";
		string MainCube = ""BPCMAIN"";
		string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
		string NA = ""N.A."";

		string levelSource = ""TOTAL_CHANGE"";
		string levelTarget = ""CALC_PANDL"";

		OLAPElement profitAndLossSourceElement = OLAPGetDimensionElement(connection, ConfigDimension, ""TOP_PROFIT_LOSS"");
		string profitAndLossSourceAccount = OLAPGetStringAttribute(connection, profitAndLossSourceElement, ""VALUE"");

		OLAPElement profitAndLossTargetElement = OLAPGetDimensionElement(connection, ""BPDCONFIGURATION"", ""TOP_PROFIT_LOSS_ACCOUNT"");
		string profitAndLossTargetAccount = OLAPGetStringAttribute(connection, profitAndLossTargetElement, ""VALUE"");
		
		string cycleYearStarthelp = OLAPCellReadString(connection, CycleConfigurationCube, cycle,NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
		cycleYearStarthelp  = ResolveUniqueName(connection, cycleYearStarthelp );
		double cycleYearStart = ToDouble(cycleYearStarthelp);
		double cycleYears = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0, cycle, NA,""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value"");
		
		LogDebug(""BPTransferFromProfitAndLoss: From: "" + profitAndLossSourceAccount + "" To: "" + profitAndLossTargetAccount);

		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		// Get base periods for the time value specified
		OLAPElementList basePeriods = CreateOLAPElementList();
		if (time == ""ALL"") {
			// Special indicator; need to process all years in the planning cycle
			OLAPElementList years = OLAPGetLevelElements(connection, TimeDimension, TotalTime, 1, false);
			foreach (OLAPElement year in years) {
				double checkYear = ToDouble(year);
				
				// for all years in the cycle, get base periods
				if (checkYear >= cycleYearStart and (checkYear - cycleYearStart) < cycleYears)
				{
					OLAPElementList periods = OLAPGetChildElementList(connection, TimeDimension, year, true);
					foreach (OLAPElement p in periods) {
						OLAPElementListAddElement(basePeriods, p);
					}
				}
			}
		} else {
			foreach (string element in timeElements) {
				OLAPElementList periods = OLAPGetChildElementList(connection, TimeDimension, element, true);
				foreach (OLAPElement p in periods) {
					OLAPElementListAddElement(basePeriods, p);
				}
			}
		}

		OLAPElementList baseLevels = OLAPGetChildElementList(connection, LevelDimension, levelSource, true);

		OLAPElement entityElement = OLAPGetDimensionElement(connection, EntityDimension, entity);
		bool baseEntityElement = OLAPIsBaseElement(connection, entityElement);
		
		//Delete target area before transfer

		OLAPDataArea targetData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB| OlapDataAreaIncludeC | OlapDataAreaSuppressNull , OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             basePeriods, cycle, version, baseLevels,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells,  profitAndLossTargetAccount ,currenList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData);
		int counter = 0;
		
		NotifyInformation(""Transfer of Profit and Loss data started"");

		OLAPDataArea sourceData = OLAPCreateDataArea(connection, MainCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             basePeriods, cycle, version,levelSource,OlapDataAreaBCells, entity, OlapDataAreaBCells, OlapDataAreaBCells,  profitAndLossSourceAccount ,currenList, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		foreach (OLAPCell cell in sourceData)
		{
			string period = OLAPCellGetElement(cell, ""BPDTIME"");
			string intercompany = OLAPCellGetElement(cell, ""BPDINTERCOMPANY"");
			string organization = OLAPCellGetElement(cell, ""BPDORGANIZATION"");
			string segment1 = OLAPCellGetElement(cell, ""BPDPSEGMENT"");
			string segment2 = OLAPCellGetElement(cell, ""BPDSSEGMENT"");
			string segment3 = OLAPCellGetElement(cell, ""BPDTSEGMENT"");
			string detail = OLAPCellGetElement(cell, ""BPDDETAIL"");
			currency = OLAPCellGetElement(cell,""BPDCURRENCY"");
			string analysis1 = OLAPCellGetElement(cell, ""BPDANALYSIS_01"");
			string analysis2 = OLAPCellGetElement(cell, ""BPDANALYSIS_02"");
			string analysis3 = OLAPCellGetElement(cell, ""BPDANALYSIS_03"");
			string analysis4 = OLAPCellGetElement(cell, ""BPDANALYSIS_04"");
			string analysis5 = OLAPCellGetElement(cell, ""BPDANALYSIS_05"");
			string analysis6 = OLAPCellGetElement(cell, ""BPDANALYSIS_06"");
			string analysis7 = OLAPCellGetElement(cell, ""BPDANALYSIS_07"");
			string analysis8 = OLAPCellGetElement(cell, ""BPDANALYSIS_08"");
			string analysis9 = OLAPCellGetElement(cell, ""BPDANALYSIS_09"");
			string analysis10 = OLAPCellGetElement(cell, ""BPDANALYSIS_10"");
			string analysis11 = OLAPCellGetElement(cell, ""BPDANALYSIS_11"");
			string analysis12 = OLAPCellGetElement(cell, ""BPDANALYSIS_12"");
			string step = OLAPCellGetElement(cell, ""BPDSTEP"");
			double value = cell;
			
			
			OLAPCellWriteBufferWriteNumber(buffer, MainCube, value, period, cycle, version,levelTarget,step, entity, intercompany, organization,  profitAndLossTargetAccount,currency, detail, segment1, segment2, segment3, analysis1, analysis2, analysis3, analysis4, analysis5, analysis6, analysis7, analysis8, analysis9, analysis10, analysis11, analysis12);
			counter = counter +1;
		}
		
		
		OLAPCommitCellWriteBuffer(buffer);
		NotifyInformation(""Number of Profit and Loss data transferred: "" + counter + ""."");
		NotifyInformation(""Transfer of Profit and Loss data finished"");


		LogInformation(""BPTransferFromProfitAndLoss: Process complete"");

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);

	}

	return 0;
}"	1	444DBE32-7B3C-4D66-BB26-291EC4AAA27D	Transfers the profit and loss data to the profit and loss account in the balance sheet and calculates opening balances.	1	1	1	1591	NULL	0	45708.67502	0	0
B9DCBB4B-52D4-41C7-80E9-B17AC46E56FB	CD491758-D9DF-4002-94C8-8006E1855F86	BAPTransferWorkforceDataToFinancialPlanning	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration Set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The version element to be used for the source."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The version element to be used for the target."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""organizations"" parameter-type=""string"" parameter-description=""One or multiple organizations to be used in a comma separated list."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetPlanningCycleYears"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2017 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""

/*
bool Test() {
	string database = ""local/Planning"";
	string ticket = """";
	string cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	string sourceVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
	string targetVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
	string entity = ""[BPDENTITY].[RU0001].[1]"";
	string organizations = ""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
	//string entity = ""[BPDENTITY].[TOTAL_ENTITY].[1]"";

	BAPTransferWorkforceDataToFinancialPlanning(database, ticket, cycle, version, entity, organizations);
}
 */

bool BAPTransferWorkforceDataToFinancialPlanning(
	string database,
	string ticket,
	string cycle,
	string sourceVersion,
	string targetVersion,
	string entity,
	string organizations
)
@Description: ""Transfers the data from the workforce budgeting subplan into the main financial planning."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceVersion]: ""The version element to be used for the source."";
@Parameter[targetVersion]: ""The version element to be used for the target."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organizations]: ""One or multiple organizations to be used in a comma separated list."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPTransferWorkforceDataToFinancialPlanning: "";
	string errorMessage = """";
	int errorCode = 0;
	int count = 0;

	try {
		return WB_TransferWBDataToFinancialPlanning_Addin(database, cycle, sourceVersion, targetVersion, entity, organizations);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		LogDebug(functionName + ""count="" + count);
		return false;
	}

	// This is only here because AppEngine won't compile unless it is.
	return false;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2017 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""
#include ""BP_GetResolvedUniqueName"", ""*""

/*
bool Test() {
	string database = ""local/Planning"";
	string ticket = """";
	string cycle = ""[BPDCYCLE].[CYCLE_001].[1]"";
	string sourceVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
	string targetVersion = ""[BPDVERSION].[BUDGET_01].[1]"";
	string entity = ""[BPDENTITY].[RU0001].[1]"";
	string organizations = ""[BPDORGANIZATION].[TOTAL_ORGANIZATION].[1]"";
	//string entity = ""[BPDENTITY].[TOTAL_ENTITY].[1]"";

	BAPTransferWorkforceDataToFinancialPlanning(database, ticket, cycle, version, entity, organizations);
}
 */

bool BAPTransferWorkforceDataToFinancialPlanning(
	string database,
	string ticket,
	string cycle,
	string sourceVersion,
	string targetVersion,
	string entity,
	string organizations
)
@Description: ""Transfers the data from the workforce budgeting subplan into the main financial planning."";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycle]: ""The Configuration Set element to be used."";
@Parameter[sourceVersion]: ""The version element to be used for the source."";
@Parameter[targetVersion]: ""The version element to be used for the target."";
@Parameter[entity]: ""The entity element to be used."";
@Parameter[organizations]: ""One or multiple organizations to be used in a comma separated list."";
@Returns: ""True, if successful."";
{
	string functionName = ""BAPTransferWorkforceDataToFinancialPlanning: "";
	string errorMessage = """";
	int errorCode = 0;
	int count = 0;

	try {
		return WB_TransferWBDataToFinancialPlanning_Addin(database, cycle, sourceVersion, targetVersion, entity, organizations);
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		LogDebug(functionName + ""count="" + count);
		return false;
	}

	// This is only here because AppEngine won't compile unless it is.
	return false;
}"	1	566BC600-4F13-4F05-855E-6369D37FC47C	Transfers the data from the workforce budgeting subplan into the main financial planning.	1	1	1	1592	NULL	0	45708.67505	0	0
7F4CF148-815E-4991-98FE-6DFEB3B7A5BB	CD491758-D9DF-4002-94C8-8006E1855F86	BAPUpdateForecastParameters	Budgeting and Planning	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Nothing. It writes directly to OLAP"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""Configuration Set element of Cycle Dimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""yearUN"" parameter-type=""string"" parameter-description=""Year element of Time Dimension"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPUpdateForecastParameters(
	string database,
	string ticket,
	string cycleUN,
	string yearUN
)
@Description: ""Writes the changed start year of Configuration Set for forecast versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycleUN]: ""Configuration Set element of Cycle Dimension"";
@Parameter[yearUN]: ""Year element of Time Dimension"";
@Returns: ""Nothing. It writes directly to OLAP"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	cycleUN = ""[BPDCYCLE].[CYCLE_033].[1] "";
	yearUN = ""[BPDTIME].[2015].[1] "";*/

	// Constants
	string CycleConfigCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string ParameterDimension = ""BPDPARAMETER"";
	string VersionDimension = ""BPDVERSION"";


	string cycle = ResolveUniqueName(connection, cycleUN);
	string inputYear = ResolveUniqueName(connection, yearUN);
	int inputYearInt = ToInt(inputYear);
	string startYear = OLAPCellReadString(connection, CycleConfigCube, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	int diff = inputYearInt - ToInt(startYear);

	StringArray versionArray = CreateStringArray();
	OLAPElementList versionElems = OLAPGetChildElementList(connection, VersionDimension,""TOTAL"", true);
	StringList versions = ToStringList(versionElems);
	string created = """";
	foreach (string versionItem in versions){
		if(StringContains(versionItem,""FC_"")==true){
			created = OLAPCellReadString(connection, CycleConfigCube, cycle, versionItem, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");
			if(created != """"){
				if(ToInt(created)==1){
					Append(versionArray,versionItem);
				}
			}
		}
	}
	
	OLAPElementList levelElems = OLAPGetChildElementList(connection, ParameterDimension,""GLOBAL_CYCLE_FORECAST_LEVEL_TOTAL"", true);
	StringList levels = ToStringList(levelElems);
	string leftPart = """";
	string value = """";
	string writeString = """";
	int newYear = 0;
	int year = 0;
	foreach(string levelItem in levels){
		foreach(string version in versionArray){
			value = OLAPCellReadString(connection, CycleConfigCube, cycle, version, levelItem, ""Parameter"");
			if(value!=""""){
				year = ToInt(StringLeft(StringRight(value, 9),4));
				newYear = year + diff;
				leftPart = StringLeft(value, StringLength(value)-9);
				writeString = leftPart+ToString(newYear)+""].[1]"";
				OLAPCellWriteString(connection, CycleConfigCube,writeString, cycle, version, levelItem, ""Parameter"");
			}
		}
	}
	OLAPCellWriteString(connection, CycleConfigCube,yearUN, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	OLAPCellWriteNumber(connection, CycleConfigCube,inputYearInt, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	return true;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BAPUpdateForecastParameters(
	string database,
	string ticket,
	string cycleUN,
	string yearUN
)
@Description: ""Writes the changed start year of Configuration Set for forecast versions"";
@Category: ""Budgeting and Planning"";
@Parameter[database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[ticket]: ""The ticket to connect with."";
@Parameter[cycleUN]: ""Configuration Set element of Cycle Dimension"";
@Parameter[yearUN]: ""Year element of Time Dimension"";
@Returns: ""Nothing. It writes directly to OLAP"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(database);
	/*OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");
	cycleUN = ""[BPDCYCLE].[CYCLE_033].[1] "";
	yearUN = ""[BPDTIME].[2015].[1] "";*/

	// Constants
	string CycleConfigCube = ""BPCCONFIG_CYCLE"";
	string NA = ""N.A."";
	string ParameterDimension = ""BPDPARAMETER"";
	string VersionDimension = ""BPDVERSION"";


	string cycle = ResolveUniqueName(connection, cycleUN);
	string inputYear = ResolveUniqueName(connection, yearUN);
	int inputYearInt = ToInt(inputYear);
	string startYear = OLAPCellReadString(connection, CycleConfigCube, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	int diff = inputYearInt - ToInt(startYear);

	StringArray versionArray = CreateStringArray();
	OLAPElementList versionElems = OLAPGetChildElementList(connection, VersionDimension,""TOTAL"", true);
	StringList versions = ToStringList(versionElems);
	string created = """";
	foreach (string versionItem in versions){
		if(StringContains(versionItem,""FC_"")==true){
			created = OLAPCellReadString(connection, CycleConfigCube, cycle, versionItem, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");
			if(created != """"){
				if(ToInt(created)==1){
					Append(versionArray,versionItem);
				}
			}
		}
	}
	
	OLAPElementList levelElems = OLAPGetChildElementList(connection, ParameterDimension,""GLOBAL_CYCLE_FORECAST_LEVEL_TOTAL"", true);
	StringList levels = ToStringList(levelElems);
	string leftPart = """";
	string value = """";
	string writeString = """";
	int newYear = 0;
	int year = 0;
	foreach(string levelItem in levels){
		foreach(string version in versionArray){
			value = OLAPCellReadString(connection, CycleConfigCube, cycle, version, levelItem, ""Parameter"");
			if(value!=""""){
				year = ToInt(StringLeft(StringRight(value, 9),4));
				newYear = year + diff;
				leftPart = StringLeft(value, StringLength(value)-9);
				writeString = leftPart+ToString(newYear)+""].[1]"";
				OLAPCellWriteString(connection, CycleConfigCube,writeString, cycle, version, levelItem, ""Parameter"");
			}
		}
	}
	OLAPCellWriteString(connection, CycleConfigCube,yearUN, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
	OLAPCellWriteNumber(connection, CycleConfigCube,inputYearInt, cycle, NA, ""GLOBAL_CYCLE_YEAR_START"", ""Value"");
	return true;
}"	1	1F452A26-7E69-48E9-8E26-50A62D79EBE5	Writes the changed start year of Configuration Set for forecast versions	1	1	1	1593	NULL	0	45708.67501	0	0
81E439B6-BE8E-4463-9C33-AF65A720A6FE	CD491758-D9DF-4002-94C8-8006E1855F86	BP_CreateGenericElement	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimensionName"" parameter-type=""string"" parameter-description=""Dimension name where element have to added. in format [BPDVERSION]"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""hierarchyName"" parameter-type=""string"" parameter-description=""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""parentName"" parameter-type=""string"" parameter-description=""UN of Parent name for new dimension element, If it is element in alternate hierarchy, should be hierarchy part of UN e.g. [BPDLEVEL].[WORKFLOW].[PLANNING_STAGE].[1]"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""stringPartOfElement"" parameter-type=""string"" parameter-description=""String part of element to be created (DRIVER, CYCLE ect) ."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""numberOfDecimals"" parameter-type=""int"" parameter-description=""How many decimals is used in ID, 3 for e.g. PNO_001, 4 for DRIVER_0001, 0 for ALLOCATION 1 ect."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""delimiter"" parameter-type=""string"" parameter-description=""That symbol is between Textual and numerical part, can be empty string, empty space or _ ."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""elementType"" parameter-type=""string"" parameter-description=""Type of element what have to be added, can be S for string or N for numeric ."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""weight"" parameter-type=""int"" parameter-description=""Type of element what have to be added, can be S for string or N for numeric ."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""hasNumericalPart"" parameter-type=""bool"" parameter-description=""True if element has numerical part (DRIVER_0001), false if not."" parameter-order=""9"" />
  <dependencies />
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_CreateGenericElement(string server,string dimensionName,string hierarchyName, string parentName,string stringPartOfElement, int numberOfDecimals,string delimiter,  string elementType, int weight, bool hasNumericalPart)
@Description: ""Create element for specified dimension, hierarchy and parent element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[dimensionName]: ""Dimension name where element have to added. in format [BPDVERSION]"";
@Parameter[hierarchyName]: ""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"";
@Parameter[parentName]: ""UN of Parent name for new dimension element, If it is element in alternate hierarchy, should be hierarchy part of UN e.g. [BPDLEVEL].[WORKFLOW].[PLANNING_STAGE].[1]"";
@Parameter[stringPartOfElement]: ""String part of element to be created (DRIVER, CYCLE ect) ."";
@Parameter[numberOfDecimals]: ""How many decimals is used in ID, 3 for e.g. PNO_001, 4 for DRIVER_0001, 0 for ALLOCATION 1 ect."";
@Parameter[delimiter]: ""That symbol is between Textual and numerical part, can be empty string, empty space or _ ."";
@Parameter[elementType]: ""Type of element what have to be added, can be S for string or N for numeric ."";
@Parameter[weight]: ""Type of element what have to be added, can be S for string or N for numeric ."";
@Parameter[hasNumericalPart]: ""True if element has numerical part (DRIVER_0001), false if not."";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_CreateGenericElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*dimensionName =""[BPDVERSION]"";
		hierarchyName=""[BPDVERSION].[BPDVERSION]"";//""[BPDCONFIG_PHASING].[BPDCONFIG_PHASING]"";
		parentName = ""[BPDVERSION].[TOTAL_FORECAST_FISCAL].[1]"";//[BPDCONFIG_PHASING].[BPDCONFIG_PHASING].[PREDEFINED].[1]""
		stringPartOfElement= ""FC_FISCAL"";
		delimiter =  """";
		elementType = ""N"";
		weight = 1 ;*/

		//cut brackets from dimensionName
		int numberOfLettersdim = StringFind(dimensionName,""]"",0);
		string dimensionNameHelp = StringSubstring(dimensionName, 1, numberOfLettersdim-1);
		dimensionName = dimensionNameHelp;

		int numberOfLettersHie = StringFind(hierarchyName,""."",0);
		int numberOfLettersHieTotal = StringLength(hierarchyName);

		string hierarchyNameHelp = StringSubstring(hierarchyName, numberOfLettersHie+2, numberOfLettersHieTotal-1-numberOfLettersHie-2);
		hierarchyName = hierarchyNameHelp;

		//hierarchyName = ResolveUniqueName(olapconnection, hierarchyName);
		if(parentName != """")
		{
			parentName= ResolveUniqueName(olapconnection , parentName);
		}

		OLAPEditDimensionRequest request = OLAPCreateEditDimensionRequest(dimensionName,hierarchyName);
		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName, hierarchyName, false, true, true);
		string element = """";
		string counterString = """";
		bool isElementIn = false;

		int counter = 1;
		if(hasNumericalPart)
		{
			while(counter &lt;=9999)
			{
				counterString =ToString(counter);
				int numberOfdigits = StringLength(counterString);
				string zerosString = """";

				if(numberOfDecimals != 0)
				{
					int zeros = numberOfDecimals - numberOfdigits;
					if(zeros ==3)
					{
						zerosString = ""000"";
					}
					if(zeros ==2)
					{
						zerosString = ""00"";
					}

					if(zeros ==1)
					{
						zerosString = ""0"";
					}
				}
				element =stringPartOfElement+delimiter+zerosString+counterString;
				isElementIn = OLAPElementListContainsElement(elementList, element);
				if(!isElementIn)
				{
					break;

				}
				counter = counter + 1;
			}
		}
		else
		{
			element =stringPartOfElement+delimiter;
		}

		if (elementType == ""S"")
		{
			OLAPAddTextualElement(request, element, parentName);
			OLAPSendRequest(olapconnection, request, false);

		}
		if (elementType == ""N"")
		{
			OLAPAddNumericalElement(request, element, parentName, 1);
			OLAPSendRequest(olapconnection, request, false);
		}

		string result = ""[""+dimensionName+""].[""+ hierarchyName +""].[""+element +""].[1]"";
		return result;

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
	
}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_CreateGenericElement(string server,string dimensionName,string hierarchyName, string parentName,string stringPartOfElement, int numberOfDecimals,string delimiter,  string elementType, int weight, bool hasNumericalPart)
@Description: ""Create element for specified dimension, hierarchy and parent element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[dimensionName]: ""Dimension name where element have to added. in format [BPDVERSION]"";
@Parameter[hierarchyName]: ""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"";
@Parameter[parentName]: ""UN of Parent name for new dimension element, If it is element in alternate hierarchy, should be hierarchy part of UN e.g. [BPDLEVEL].[WORKFLOW].[PLANNING_STAGE].[1]"";
@Parameter[stringPartOfElement]: ""String part of element to be created (DRIVER, CYCLE ect) ."";
@Parameter[numberOfDecimals]: ""How many decimals is used in ID, 3 for e.g. PNO_001, 4 for DRIVER_0001, 0 for ALLOCATION 1 ect."";
@Parameter[delimiter]: ""That symbol is between Textual and numerical part, can be empty string, empty space or _ ."";
@Parameter[elementType]: ""Type of element what have to be added, can be S for string or N for numeric ."";
@Parameter[weight]: ""Type of element what have to be added, can be S for string or N for numeric ."";
@Parameter[hasNumericalPart]: ""True if element has numerical part (DRIVER_0001), false if not."";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_CreateGenericElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*dimensionName =""[BPDVERSION]"";
		hierarchyName=""[BPDVERSION].[BPDVERSION]"";//""[BPDCONFIG_PHASING].[BPDCONFIG_PHASING]"";
		parentName = ""[BPDVERSION].[TOTAL_FORECAST_FISCAL].[1]"";//[BPDCONFIG_PHASING].[BPDCONFIG_PHASING].[PREDEFINED].[1]""
		stringPartOfElement= ""FC_FISCAL"";
		delimiter =  """";
		elementType = ""N"";
		weight = 1 ;*/

		//cut brackets from dimensionName
		int numberOfLettersdim = StringFind(dimensionName,""]"",0);
		string dimensionNameHelp = StringSubstring(dimensionName, 1, numberOfLettersdim-1);
		dimensionName = dimensionNameHelp;

		int numberOfLettersHie = StringFind(hierarchyName,""."",0);
		int numberOfLettersHieTotal = StringLength(hierarchyName);

		string hierarchyNameHelp = StringSubstring(hierarchyName, numberOfLettersHie+2, numberOfLettersHieTotal-1-numberOfLettersHie-2);
		hierarchyName = hierarchyNameHelp;

		//hierarchyName = ResolveUniqueName(olapconnection, hierarchyName);
		if(parentName != """")
		{
			parentName= ResolveUniqueName(olapconnection , parentName);
		}

		OLAPEditDimensionRequest request = OLAPCreateEditDimensionRequest(dimensionName,hierarchyName);
		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName, hierarchyName, false, true, true);
		string element = """";
		string counterString = """";
		bool isElementIn = false;

		int counter = 1;
		if(hasNumericalPart)
		{
			while(counter <=9999)
			{
				counterString =ToString(counter);
				int numberOfdigits = StringLength(counterString);
				string zerosString = """";

				if(numberOfDecimals != 0)
				{
					int zeros = numberOfDecimals - numberOfdigits;
					if(zeros ==3)
					{
						zerosString = ""000"";
					}
					if(zeros ==2)
					{
						zerosString = ""00"";
					}

					if(zeros ==1)
					{
						zerosString = ""0"";
					}
				}
				element =stringPartOfElement+delimiter+zerosString+counterString;
				isElementIn = OLAPElementListContainsElement(elementList, element);
				if(!isElementIn)
				{
					break;

				}
				counter = counter + 1;
			}
		}
		else
		{
			element =stringPartOfElement+delimiter;
		}

		if (elementType == ""S"")
		{
			OLAPAddTextualElement(request, element, parentName);
			OLAPSendRequest(olapconnection, request, false);

		}
		if (elementType == ""N"")
		{
			OLAPAddNumericalElement(request, element, parentName, 1);
			OLAPSendRequest(olapconnection, request, false);
		}

		string result = ""[""+dimensionName+""].[""+ hierarchyName +""].[""+element +""].[1]"";
		return result;

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
	
}"	1	2DE108D4-B129-4E31-8FD4-059DA78691AD	Create element for specified dimension, hierarchy and parent element.	1	1	1	1594	NULL	0	45708.67506	0	0
EC533A6D-E9F8-44DE-884C-1581B0754FCC	CD491758-D9DF-4002-94C8-8006E1855F86	BP_CreateNewPlaceholderElements	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE if successful, ERROR if an error occurs, FALSE otherwise"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""An open OLAP connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension getting the new elements"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""numberOfElements"" parameter-type=""int"" parameter-description=""The number of elements to create"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""digitCount"" parameter-type=""int"" parameter-description=""The number of digits for the number part of the placeholder name"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""memberNamePrefix"" parameter-type=""string"" parameter-description=""The prefix of the placeholder member names"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""parent"" parameter-type=""string"" parameter-description=""The new elements' parent"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
bool test()
{
	OLAPConnection connection = OLAPCreatePooledConnection(""usalvwpsdemo/Planning_COGNOS"", ""Admin"", ""Infor2014"");
	LogDebug(BP_CreateNewPlaceholderElements(connection, ""ALDITERATION"", 1, 4, ""Iteration_"", ""TOTAL""));

	return true;
}
*/

string BP_CreateNewPlaceholderElements(OLAPConnection connection, string dimension, int numberOfElements, int digitCount, string memberNamePrefix, string parent)
@Description: ""Creates placeholder dimension elements. Finds next highest number and adds the elements from there."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""TRUE if successful, ERROR if an error occurs, FALSE otherwise"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[dimension]: ""The dimension getting the new elements"";
@Parameter[numberOfElements]: ""The number of elements to create"";
@Parameter[digitCount]: ""The number of digits for the number part of the placeholder name"";
@Parameter[memberNamePrefix]: ""The prefix of the placeholder member names"";
@Parameter[parent]: ""The new elements' parent"";
{
	string functionName = ""BP_CreateNewPlaceholderElements:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPElementList dimensionElements = OLAPGetElementList(connection, dimension, false);

		int heighestValue = 1;
		foreach(OLAPElement dimElement in dimensionElements)
		{
			string elementToTest = dimElement;
			
			if(StringStartsWith(elementToTest, memberNamePrefix))
			{
				elementToTest = StringReplace(elementToTest, memberNamePrefix, """", true);
			}

			if(IsNumeric(elementToTest))
			{
				int value = ToInt(elementToTest);
				if(value &gt; heighestValue)
				{
					heighestValue = value;
				}
			}
		}

		//LogDebug(ToString(heighestValue));

		string concatString = ""000"";
		int startNumber = heighestValue + 1;
		int index = 0;
		while(numberOfElements &gt; index)
		{
			string elementName = ToString(startNumber);
			if(StringLength(elementName) &lt; digitCount)
			{
				elementName = StringSubstring(concatString, 0, digitCount - StringLength(elementName)) + elementName;
			}

			elementName = memberNamePrefix + elementName;
			OLAPCreateNumericalDimensionElement(connection, dimension, elementName, parent, 1);

			startNumber = startNumber + 1;
			index = index + 1;
		}

		return ""TRUE"";
		
	} catch(errorMessage, errorCode) {
		// If the error code is somehow less than 0, calling RaiseError will throw an exception
		// that negative error codes cannot be used.
		if(errorCode &lt; 0) {
			errorCode = 0;
		}

		RaiseError(functionName + errorMessage, 99);
	}

	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
bool test()
{
	OLAPConnection connection = OLAPCreatePooledConnection(""usalvwpsdemo/Planning_COGNOS"", ""Admin"", ""Infor2014"");
	LogDebug(BP_CreateNewPlaceholderElements(connection, ""ALDITERATION"", 1, 4, ""Iteration_"", ""TOTAL""));

	return true;
}
*/

string BP_CreateNewPlaceholderElements(OLAPConnection connection, string dimension, int numberOfElements, int digitCount, string memberNamePrefix, string parent)
@Description: ""Creates placeholder dimension elements. Finds next highest number and adds the elements from there."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""TRUE if successful, ERROR if an error occurs, FALSE otherwise"";
@Parameter[connection]: ""An open OLAP connection"";
@Parameter[dimension]: ""The dimension getting the new elements"";
@Parameter[numberOfElements]: ""The number of elements to create"";
@Parameter[digitCount]: ""The number of digits for the number part of the placeholder name"";
@Parameter[memberNamePrefix]: ""The prefix of the placeholder member names"";
@Parameter[parent]: ""The new elements' parent"";
{
	string functionName = ""BP_CreateNewPlaceholderElements:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPElementList dimensionElements = OLAPGetElementList(connection, dimension, false);

		int heighestValue = 1;
		foreach(OLAPElement dimElement in dimensionElements)
		{
			string elementToTest = dimElement;
			
			if(StringStartsWith(elementToTest, memberNamePrefix))
			{
				elementToTest = StringReplace(elementToTest, memberNamePrefix, """", true);
			}

			if(IsNumeric(elementToTest))
			{
				int value = ToInt(elementToTest);
				if(value > heighestValue)
				{
					heighestValue = value;
				}
			}
		}

		//LogDebug(ToString(heighestValue));

		string concatString = ""000"";
		int startNumber = heighestValue + 1;
		int index = 0;
		while(numberOfElements > index)
		{
			string elementName = ToString(startNumber);
			if(StringLength(elementName) < digitCount)
			{
				elementName = StringSubstring(concatString, 0, digitCount - StringLength(elementName)) + elementName;
			}

			elementName = memberNamePrefix + elementName;
			OLAPCreateNumericalDimensionElement(connection, dimension, elementName, parent, 1);

			startNumber = startNumber + 1;
			index = index + 1;
		}

		return ""TRUE"";
		
	} catch(errorMessage, errorCode) {
		// If the error code is somehow less than 0, calling RaiseError will throw an exception
		// that negative error codes cannot be used.
		if(errorCode < 0) {
			errorCode = 0;
		}

		RaiseError(functionName + errorMessage, 99);
	}

	return ""FALSE"";
}"	1	924F74FB-B03B-4CE1-952F-710482A7C0CA	Creates placeholder dimension elements. Finds next highest number and adds the elements from there.	1	1	1	1595	NULL	0	45708.67502	0	0
A2B7747B-39C1-4462-B0C4-225DC37384C2	CD491758-D9DF-4002-94C8-8006E1855F86	BP_DisconnectPooledConnection	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if pooled connection was disconnected, otherwise false"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_DisconnectPooledConnection(string server)
@Description: ""Disconnect pooled connection for current user"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""true if pooled connection was disconnected, otherwise false"";
{
	string functionName = ""BP_DisconnectPooledConnection:"";
	int errorCode = 0;
	string errorMessage = """";
	int connectionsToClose = 3;
	try {
		while (connectionsToClose &gt; 0) {
			OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
			OLAPDisconnectPooledConnection(connection);
			connectionsToClose --;
		}
		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_DisconnectPooledConnection(string server)
@Description: ""Disconnect pooled connection for current user"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""true if pooled connection was disconnected, otherwise false"";
{
	string functionName = ""BP_DisconnectPooledConnection:"";
	int errorCode = 0;
	string errorMessage = """";
	int connectionsToClose = 3;
	try {
		while (connectionsToClose > 0) {
			OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
			OLAPDisconnectPooledConnection(connection);
			connectionsToClose --;
		}
		return true;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	8C1F4FB9-9115-42BD-88C9-E6216AACAC82	Disconnect pooled connection for current user	1	1	1	1596	NULL	0	45708.67503	0	0
CB041739-BE90-4DF1-A5AD-4427CE9D22CC	CD491758-D9DF-4002-94C8-8006E1855F86	BP_ElementStringSplit	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""A StringList containing the elements found in the provided string, each having been passed through ResolveUnique"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Active OLAP database connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""stringList"" parameter-type=""string"" parameter-description=""A comma-separated list of dimension elements"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

StringList BP_ElementStringSplit(
	OLAPConnection connection,
	string stringList
)
@Description: ""This function is used to split a list of comma separated dimension elements and resolve their unique name."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""A StringList containing the elements found in the provided string, each having been passed through ResolveUnique"";
@Parameter[connection]: ""Active OLAP database connection"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringList resultList = CreateStringList();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos &lt; 0) {

			Append(resultList, BP_GetResolvedUniqueName(connection, stringList));
		} else {

			while (pos &gt;= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				Append(resultList, BP_GetResolvedUniqueName(connection, element));
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			Append(resultList, BP_GetResolvedUniqueName(connection, stringList));
		}
	}

	return resultList;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

StringList BP_ElementStringSplit(
	OLAPConnection connection,
	string stringList
)
@Description: ""This function is used to split a list of comma separated dimension elements and resolve their unique name."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""A StringList containing the elements found in the provided string, each having been passed through ResolveUnique"";
@Parameter[connection]: ""Active OLAP database connection"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringList resultList = CreateStringList();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos < 0) {

			Append(resultList, BP_GetResolvedUniqueName(connection, stringList));
		} else {

			while (pos >= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				Append(resultList, BP_GetResolvedUniqueName(connection, element));
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			Append(resultList, BP_GetResolvedUniqueName(connection, stringList));
		}
	}

	return resultList;
}"	1	F4F73457-1CAB-4E25-BAC5-4D9464B1AE45	This function is used to split a list of comma separated dimension elements and resolve their unique name.	1	1	1	1597	NULL	0	45708.67504	0	0
8C131B4C-BFB9-4C62-9CF7-FCDCA7896A23	CD491758-D9DF-4002-94C8-8006E1855F86	BP_ExecuteMDXToXml	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Xml string from MDX"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""mdx"" parameter-type=""string"" parameter-description=""Mdx query"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""costicket"" parameter-type=""string"" parameter-description=""Cos Ticket"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""url"" parameter-type=""string"" parameter-description=""Server Url"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""databasename"" parameter-type=""string"" parameter-description=""Database Name"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_ExecuteMDXToXml(string mdx, string costicket, string url, string databasename)
@Description: ""ExecuteToXml"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[costicket]: ""Cos Ticket"";
@Parameter[url]: ""Server Url"";
@Parameter[databasename]: ""Database Name"";
@Parameter[mdx]: ""Mdx query"";
@Returns: ""Xml string from MDX"";
{
	//mdx = ""WITH SET [__WBDEMPLOYEE_selection] AS '{{AddCalculatedMembers(Descendants([WBDEMPLOYEE].[TOTAL_EMPLOYEE].[1],50,Leaves)}}' SELECT {[WDDCALC_METHOD].[N.A.].[1]} ON ROWS,{[__WBDEMPLOYEE_selection]} ON COLUMNS FROM [WDCCALCULATION] WHERE ( [WDDFORECAST_PERIOD].[N.A.].[1],[WDDPERIOD].[PERIOD_001].[1],[BPDORGANIZATION].[BPDORGANIZATION_WD].[TOTAL_ORGANIZATION_WD].[1],[WBDJOB].[WBDJOB_WD].[TOTAL_JOB_WD].[1],[BPDACCOUNT].[WFD_FTE].[1],[BPDCYCLE].[CYCLE_004].[1],[BPDANALYSIS_01].[BPDANALYSIS_01_WD].[TOTAL_ANALYSIS01_WD].[1],[BPDANALYSIS_02].[BPDANALYSIS_02_WD].[TOTAL_ANALYSIS02_WD].[1],[BPDANALYSIS_03].[BPDANALYSIS_03_WD].[TOTAL_ANALYSIS03_WD].[1],[BPDANALYSIS_04].[BPDANALYSIS_04_WD].[TOTAL_ANALYSIS04_WD].[1],[BPDANALYSIS_05].[BPDANALYSIS_05_WD].[TOTAL_ANALYSIS05_WD].[1],[BPDANALYSIS_07].[BPDANALYSIS_07_WD].[TOTAL_ANALYSIS07_WD].[1],[BPDANALYSIS_08].[BPDANALYSIS_08_WD].[TOTAL_ANALYSIS08_WD].[1],[BPDANALYSIS_09].[BPDANALYSIS_09_WD].[TOTAL_ANALYSIS09_WD].[1],[BPDANALYSIS_10].[BPDANALYSIS_10_WD].[TOTAL_ANALYSIS10_WD].[1],[BPDANALYSIS_11].[BPDANALYSIS_11_WD].[TOTAL_ANALYSIS11_WD].[1],[BPDPSEGMENT].[BPDPSEGMENT_WD].[TOTAL_SEGMENT_WD].[1],[BPDSSEGMENT].[BPDSSEGMENT_WD].[TOTAL_SEGMENT_WD].[1],[BPDTSEGMENT].[BPDTSEGMENT_WD].[TOTAL_SEGMENT_WD].[1])"";
	//mdx = ""WITH MEMBER [WBDEMPLOYEE].[C] AS 'Sum ( { { Filter ( Filtergt ( AddCalculatedMembers ( Descendants ( [WBDEMPLOYEE].[TOTAL_EMPLOYEE].[1] ,50 ,Leaves ) ) ,0 ) , 1 = 1 ) } } )' SELECT Filtergt ( BPDORGANIZATION.[BPDORGANIZATION_WD].ALLMEMBERS ,0 ) ON 0 ,{[WBDEMPLOYEE].[C]} ON 1 FROM [WDCCALCULATION] WHERE ( [BPDACCOUNT].[WFD_FTE].[1] ,[BPDANALYSIS_01].[BPDANALYSIS_01_WD].[TOTAL_ANALYSIS01_WD].[1] ,[BPDANALYSIS_02].[BPDANALYSIS_02_WD].[TOTAL_ANALYSIS02_WD].[1] ,[BPDANALYSIS_03].[BPDANALYSIS_03_WD].[TOTAL_ANALYSIS03_WD].[1] ,[BPDANALYSIS_04].[BPDANALYSIS_04_WD].[TOTAL_ANALYSIS04_WD].[1] ,[BPDANALYSIS_05].[BPDANALYSIS_05_WD].[TOTAL_ANALYSIS05_WD].[1] ,[BPDANALYSIS_07].[BPDANALYSIS_07_WD].[TOTAL_ANALYSIS07_WD].[1] ,[BPDANALYSIS_08].[BPDANALYSIS_08_WD].[TOTAL_ANALYSIS08_WD].[1] ,[BPDANALYSIS_09].[BPDANALYSIS_09_WD].[TOTAL_ANALYSIS09_WD].[1] ,[BPDANALYSIS_10].[BPDANALYSIS_10_WD].[TOTAL_ANALYSIS10_WD].[1] ,[BPDANALYSIS_11].[BPDANALYSIS_11_WD].[TOTAL_ANALYSIS11_WD].[1] ,[BPDCYCLE].[CYCLE_004].[1] ,[BPDENTITY].[N.A.].[1] ,[BPDPSEGMENT].[BPDPSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDSSEGMENT].[BPDSSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDTSEGMENT].[BPDTSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDVERSION].[ACTUAL_SOURCE_SYSTEM].[1] ,[WBDJOB].[WBDJOB_WD].[TOTAL_JOB_WD].[1] ,[WBDPOSITION].[TOTAL_POSITION].[1] ,[WDDCALC_METHOD].[N.A.].[1] ,[WDDDRIVER].[N.A.].[1] ,[WDDFORECAST_PERIOD].[N.A.].[1] )"";

	//costicket = ""+++COS+++0001/SQkuBbrRkAsT40nIpJsP/OPHTqs/enoYeoWcZH4aaLQrPncxrdKNKpgH/TbDAMoKUqmAvM6tTzwVXOZXGor6e6qPZxh/Oi8vOC9OYmOJRQ22cvXROZf4JvmGK1SC3ZAx2BbQj51a0toMcZBOnNDwCLErKmPjq8Umbe3MxO/z9F7cR5i8TaPgdmgklzMST0BVexxXDbdZzqf5jJ/TpQKTZzftJawM3oDyYiRZB8acvXlbVen37D+cLa29vU0JwTGYLTRzJU0rJrpyhtN1mEFWMv0bWAeykL2KIRDgXEiyVC8g4Hs7r3NojQsabJWhHC04t1IfqM0fZMMVMRXsogjmiqjpW0YvRvNiu8Hc/H8fKczoeV6ofk7iznW/n4APXac/RxwP1haIb3z10ltKV+dx1Vo+60Nl3ZcRlmUrVdHLEavHc/d9hFehUJ2Y9cjk927EpJ6m7+4O/LHqXpJiozut3hP9gK0oN1+fMr0FA0IE5aYgz4eKNEZRi7Mog+Sphwv"";
	//url = ""https://usalvwpsolap:8215"";
	//databasename = ""Planning"";

	XMLAConnection connection = XMLACreateNamedConnection(databasename);
	XMLAStringCellList result = XMLAExecuteMdxString(connection, mdx);
	
	string xml = ""&lt;Table&gt;"";

	foreach(XMLAStringCell cell in result)
	{
		xml = xml + ""&lt;Row name=\"""";
		string first = """";

		foreach(string coordinate in XMLAGetCoordinates(cell))
		{
			first = coordinate;
			break;
		}
		xml = xml + first + ""\""&gt;"";

		xml = xml + ""&lt;Property name=\""value\"" value=\""0"";
		xml =  xml + XMLAGetValue(cell);
		xml = xml + ""\"" /&gt;"";

		xml = xml + ""&lt;/Row&gt;"";

	}

	xml = xml + ""&lt;/Table&gt;"";

	LogDebug(xml);

	return xml;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_ExecuteMDXToXml(string mdx, string costicket, string url, string databasename)
@Description: ""ExecuteToXml"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[costicket]: ""Cos Ticket"";
@Parameter[url]: ""Server Url"";
@Parameter[databasename]: ""Database Name"";
@Parameter[mdx]: ""Mdx query"";
@Returns: ""Xml string from MDX"";
{
	//mdx = ""WITH SET [__WBDEMPLOYEE_selection] AS '{{AddCalculatedMembers(Descendants([WBDEMPLOYEE].[TOTAL_EMPLOYEE].[1],50,Leaves)}}' SELECT {[WDDCALC_METHOD].[N.A.].[1]} ON ROWS,{[__WBDEMPLOYEE_selection]} ON COLUMNS FROM [WDCCALCULATION] WHERE ( [WDDFORECAST_PERIOD].[N.A.].[1],[WDDPERIOD].[PERIOD_001].[1],[BPDORGANIZATION].[BPDORGANIZATION_WD].[TOTAL_ORGANIZATION_WD].[1],[WBDJOB].[WBDJOB_WD].[TOTAL_JOB_WD].[1],[BPDACCOUNT].[WFD_FTE].[1],[BPDCYCLE].[CYCLE_004].[1],[BPDANALYSIS_01].[BPDANALYSIS_01_WD].[TOTAL_ANALYSIS01_WD].[1],[BPDANALYSIS_02].[BPDANALYSIS_02_WD].[TOTAL_ANALYSIS02_WD].[1],[BPDANALYSIS_03].[BPDANALYSIS_03_WD].[TOTAL_ANALYSIS03_WD].[1],[BPDANALYSIS_04].[BPDANALYSIS_04_WD].[TOTAL_ANALYSIS04_WD].[1],[BPDANALYSIS_05].[BPDANALYSIS_05_WD].[TOTAL_ANALYSIS05_WD].[1],[BPDANALYSIS_07].[BPDANALYSIS_07_WD].[TOTAL_ANALYSIS07_WD].[1],[BPDANALYSIS_08].[BPDANALYSIS_08_WD].[TOTAL_ANALYSIS08_WD].[1],[BPDANALYSIS_09].[BPDANALYSIS_09_WD].[TOTAL_ANALYSIS09_WD].[1],[BPDANALYSIS_10].[BPDANALYSIS_10_WD].[TOTAL_ANALYSIS10_WD].[1],[BPDANALYSIS_11].[BPDANALYSIS_11_WD].[TOTAL_ANALYSIS11_WD].[1],[BPDPSEGMENT].[BPDPSEGMENT_WD].[TOTAL_SEGMENT_WD].[1],[BPDSSEGMENT].[BPDSSEGMENT_WD].[TOTAL_SEGMENT_WD].[1],[BPDTSEGMENT].[BPDTSEGMENT_WD].[TOTAL_SEGMENT_WD].[1])"";
	//mdx = ""WITH MEMBER [WBDEMPLOYEE].[C] AS 'Sum ( { { Filter ( Filtergt ( AddCalculatedMembers ( Descendants ( [WBDEMPLOYEE].[TOTAL_EMPLOYEE].[1] ,50 ,Leaves ) ) ,0 ) , 1 = 1 ) } } )' SELECT Filtergt ( BPDORGANIZATION.[BPDORGANIZATION_WD].ALLMEMBERS ,0 ) ON 0 ,{[WBDEMPLOYEE].[C]} ON 1 FROM [WDCCALCULATION] WHERE ( [BPDACCOUNT].[WFD_FTE].[1] ,[BPDANALYSIS_01].[BPDANALYSIS_01_WD].[TOTAL_ANALYSIS01_WD].[1] ,[BPDANALYSIS_02].[BPDANALYSIS_02_WD].[TOTAL_ANALYSIS02_WD].[1] ,[BPDANALYSIS_03].[BPDANALYSIS_03_WD].[TOTAL_ANALYSIS03_WD].[1] ,[BPDANALYSIS_04].[BPDANALYSIS_04_WD].[TOTAL_ANALYSIS04_WD].[1] ,[BPDANALYSIS_05].[BPDANALYSIS_05_WD].[TOTAL_ANALYSIS05_WD].[1] ,[BPDANALYSIS_07].[BPDANALYSIS_07_WD].[TOTAL_ANALYSIS07_WD].[1] ,[BPDANALYSIS_08].[BPDANALYSIS_08_WD].[TOTAL_ANALYSIS08_WD].[1] ,[BPDANALYSIS_09].[BPDANALYSIS_09_WD].[TOTAL_ANALYSIS09_WD].[1] ,[BPDANALYSIS_10].[BPDANALYSIS_10_WD].[TOTAL_ANALYSIS10_WD].[1] ,[BPDANALYSIS_11].[BPDANALYSIS_11_WD].[TOTAL_ANALYSIS11_WD].[1] ,[BPDCYCLE].[CYCLE_004].[1] ,[BPDENTITY].[N.A.].[1] ,[BPDPSEGMENT].[BPDPSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDSSEGMENT].[BPDSSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDTSEGMENT].[BPDTSEGMENT_WD].[TOTAL_SEGMENT_WD].[1] ,[BPDVERSION].[ACTUAL_SOURCE_SYSTEM].[1] ,[WBDJOB].[WBDJOB_WD].[TOTAL_JOB_WD].[1] ,[WBDPOSITION].[TOTAL_POSITION].[1] ,[WDDCALC_METHOD].[N.A.].[1] ,[WDDDRIVER].[N.A.].[1] ,[WDDFORECAST_PERIOD].[N.A.].[1] )"";

	//costicket = ""+++COS+++0001/SQkuBbrRkAsT40nIpJsP/OPHTqs/enoYeoWcZH4aaLQrPncxrdKNKpgH/TbDAMoKUqmAvM6tTzwVXOZXGor6e6qPZxh/Oi8vOC9OYmOJRQ22cvXROZf4JvmGK1SC3ZAx2BbQj51a0toMcZBOnNDwCLErKmPjq8Umbe3MxO/z9F7cR5i8TaPgdmgklzMST0BVexxXDbdZzqf5jJ/TpQKTZzftJawM3oDyYiRZB8acvXlbVen37D+cLa29vU0JwTGYLTRzJU0rJrpyhtN1mEFWMv0bWAeykL2KIRDgXEiyVC8g4Hs7r3NojQsabJWhHC04t1IfqM0fZMMVMRXsogjmiqjpW0YvRvNiu8Hc/H8fKczoeV6ofk7iznW/n4APXac/RxwP1haIb3z10ltKV+dx1Vo+60Nl3ZcRlmUrVdHLEavHc/d9hFehUJ2Y9cjk927EpJ6m7+4O/LHqXpJiozut3hP9gK0oN1+fMr0FA0IE5aYgz4eKNEZRi7Mog+Sphwv"";
	//url = ""https://usalvwpsolap:8215"";
	//databasename = ""Planning"";

	XMLAConnection connection = XMLACreateNamedConnection(databasename);
	XMLAStringCellList result = XMLAExecuteMdxString(connection, mdx);
	
	string xml = ""<Table>"";

	foreach(XMLAStringCell cell in result)
	{
		xml = xml + ""<Row name=\"""";
		string first = """";

		foreach(string coordinate in XMLAGetCoordinates(cell))
		{
			first = coordinate;
			break;
		}
		xml = xml + first + ""\"">"";

		xml = xml + ""<Property name=\""value\"" value=\""0"";
		xml =  xml + XMLAGetValue(cell);
		xml = xml + ""\"" />"";

		xml = xml + ""</Row>"";

	}

	xml = xml + ""</Table>"";

	LogDebug(xml);

	return xml;
}"	1	4AA65E2C-30B8-4AFF-9912-A5CD1378E2E8	ExecuteToXml	1	1	1	1598	NULL	0	45708.67509	0	0
463BA2F2-4EA5-4514-A3AF-9C58B1697FB6	CD491758-D9DF-4002-94C8-8006E1855F86	BP_FillCyclePeriodicity	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""true if successful, otherwise error message"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""Cube where data should be filled"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""Configuration Set element  of configuration set Dimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""parametersUN"" parameter-type=""string"" parameter-description=""Comma separated string of parameter elements"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""valuesUN"" parameter-type=""string"" parameter-description=""Comma separated string of values to be written"" parameter-order=""4"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

string BP_FillCyclePeriodicity(string server, string cube, string cycleUN, string parametersUN, string valuesUN)
@Description: ""Script for given years fills periodicity in BPCCONFIG_CYCLE cube"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cube]: ""Cube where data should be filled"";
@Parameter[cycleUN]: ""Configuration Set element  of configuration set Dimension"";
@Parameter[parametersUN]: ""Comma separated string of parameter elements"";
@Parameter[valuesUN]: ""Comma separated string of values to be written"";
@Returns: ""true if successful, otherwise error message"";
{
	string functionName = ""BP_FillCyclePeriodicity:"";
	string parameterDimension = ""BPDPARAMETER"";
	string NA = ""N.A."";

	string errorMessage = """";
	int errorCode = 0;
	string result ="""";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		/*cube = ""BPCCONFIG_CYCLE"";
		cycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";
		parametersUN = ""[BPDPARAMETER].[GLOBAL_CYCLE_YEAR01_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR02_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR03_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR04_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR05_LEVEL].[1]"";
		valuesUN = ""[BPDPARAMETER].[GLOBAL_MONTH].[1],[BPDPARAMETER].[GLOBAL_MONTH].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1]"";*/
		string cycle = ResolveUniqueName(connection, cycleUN);
		StringArray parameters = CF_ElementStringSplit(parametersUN);
		StringArray values = CF_ElementStringSplit(valuesUN);
		if(Count(parameters) != Count(values))
		{
			return ""Number of values and parameters don't match"";
		}

		StringArray parametrs = CreateStringArray();
		Append(parametrs, """");

		OLAPElementList paramList = OLAPGetChildElementList(connection, parameterDimension, ""GLOBAL_CYCLE_YEAR_TOTAL"", false);
		
		foreach(OLAPElement paramelement in paramList)
		{
			string paramString = ToString(paramelement);
			Append(parametrs, paramString);
		}
		
		StringList paramsStringList = ToStringList(parametrs);

		// Definition of the target data area
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             cycle, NA ,paramsStringList, ""Text Value"");

		// Clear target data area before copying
		OLAPDeleteDataArea(TargetData);


		int index = 0;
		while(index &lt; Count(parameters))
		{
			string paramStringinLoop = parameters[index];
			paramStringinLoop = ResolveUniqueName(connection, paramStringinLoop);
			OLAPCellWriteBufferWriteString(buffer, cube, values[index],  cycle, NA, paramStringinLoop, ""Text Value"");
			index = index + 1;
		}


		OLAPCommitCellWriteBuffer(buffer);
		return ""True"";

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

string BP_FillCyclePeriodicity(string server, string cube, string cycleUN, string parametersUN, string valuesUN)
@Description: ""Script for given years fills periodicity in BPCCONFIG_CYCLE cube"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cube]: ""Cube where data should be filled"";
@Parameter[cycleUN]: ""Configuration Set element  of configuration set Dimension"";
@Parameter[parametersUN]: ""Comma separated string of parameter elements"";
@Parameter[valuesUN]: ""Comma separated string of values to be written"";
@Returns: ""true if successful, otherwise error message"";
{
	string functionName = ""BP_FillCyclePeriodicity:"";
	string parameterDimension = ""BPDPARAMETER"";
	string NA = ""N.A."";

	string errorMessage = """";
	int errorCode = 0;
	string result ="""";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		/*cube = ""BPCCONFIG_CYCLE"";
		cycleUN = ""[BPDCYCLE].[CYCLE_005].[1]"";
		parametersUN = ""[BPDPARAMETER].[GLOBAL_CYCLE_YEAR01_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR02_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR03_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR04_LEVEL].[1],[BPDPARAMETER].[GLOBAL_CYCLE_YEAR05_LEVEL].[1]"";
		valuesUN = ""[BPDPARAMETER].[GLOBAL_MONTH].[1],[BPDPARAMETER].[GLOBAL_MONTH].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1],[BPDPARAMETER].[GLOBAL_YEAR].[1]"";*/
		string cycle = ResolveUniqueName(connection, cycleUN);
		StringArray parameters = CF_ElementStringSplit(parametersUN);
		StringArray values = CF_ElementStringSplit(valuesUN);
		if(Count(parameters) != Count(values))
		{
			return ""Number of values and parameters don't match"";
		}

		StringArray parametrs = CreateStringArray();
		Append(parametrs, """");

		OLAPElementList paramList = OLAPGetChildElementList(connection, parameterDimension, ""GLOBAL_CYCLE_YEAR_TOTAL"", false);
		
		foreach(OLAPElement paramelement in paramList)
		{
			string paramString = ToString(paramelement);
			Append(parametrs, paramString);
		}
		
		StringList paramsStringList = ToStringList(parametrs);

		// Definition of the target data area
		OLAPDataArea TargetData = OLAPCreateDataArea(connection, cube,
		                                             OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             cycle, NA ,paramsStringList, ""Text Value"");

		// Clear target data area before copying
		OLAPDeleteDataArea(TargetData);


		int index = 0;
		while(index < Count(parameters))
		{
			string paramStringinLoop = parameters[index];
			paramStringinLoop = ResolveUniqueName(connection, paramStringinLoop);
			OLAPCellWriteBufferWriteString(buffer, cube, values[index],  cycle, NA, paramStringinLoop, ""Text Value"");
			index = index + 1;
		}


		OLAPCommitCellWriteBuffer(buffer);
		return ""True"";

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	
}"	1	033061A4-1DEB-4241-9E12-E7CB192644E1	Script for given years fills periodicity in BPCCONFIG_CYCLE cube	1	1	1	1599	NULL	0	45708.67505	0	0
029A3FA1-1269-41DA-A159-0E3A73159571	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GenericCopy	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""An open Olap connection to the database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The name of the cube"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cubeDimensions"" parameter-type=""StringArray"" parameter-description=""An array of the dimensions of the cube in cube order. See BP_GetCubeDimensions."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceDefinition"" parameter-type=""StringListList"" parameter-description=""A list of OLAPElementLists in dimension order defining the source data area. Must be all base cells."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetDifferences"" parameter-type=""StringArray"" parameter-description=""A string array of elements in dimension order with the difference from source data area defining the target. Must be empty (meaning same as source) or single base target element."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GenericCopy(OLAPConnection connection, string cube, StringArray cubeDimensions, StringListList sourceDefinition, StringArray targetDifferences)
@Description: ""Copies the values obtained from the source definition to the base elements identified in the targetDifferences"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""An open Olap connection to the database"";
@Parameter[cube]: ""The name of the cube"";
@Parameter[cubeDimensions]: ""An array of the dimensions of the cube in cube order. See BP_GetCubeDimensions."";
@Parameter[sourceDefinition]: ""A list of OLAPElementLists in dimension order defining the source data area. Must be all base cells."";
@Parameter[targetDifferences]: ""A string array of elements in dimension order with the difference from source data area defining the target. Must be empty (meaning same as source) or single base target element."";
{
	string functionName = ""BP_GenericCopy:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube + ""'"");
	try
	{
		// Define the target data area by combining the sourceDefinition with the target difference list
		LogDebug(""Getting target data area definition."");
		int dimensionCount = Count(cubeDimensions);
		int index = 0;
		StringListList targetDefinition = CreateStringListList();
		while (index &lt; dimensionCount)
		{
			if (StringLength(targetDifferences[index]) &gt; 0)
			{
				Append(targetDefinition, ConvertToStringList(targetDifferences[index]));
			}
			else
			{
				Append(targetDefinition, sourceDefinition[index]);
			}

			index = index + 1;
		}

		// Clear the target area
		OLAPDataArea targetData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetDefinition);

		OLAPDeleteDataArea(targetData); // Clear destination

		// Get the source data area
		OLAPDataArea sourceData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             sourceDefinition);

		// Loop through the source data area and write to the target data area
		int counter = 0;
		foreach (OLAPCell cell in sourceData)
		{
			StringArray targetElements = CreateStringArray();
			StringArray sourceElements = CreateStringArray();
			index = 0;
			while (index &lt; dimensionCount)
			{
				Append(sourceElements, OLAPCellGetElement(cell, cubeDimensions[index]));

				if (StringLength(targetDifferences[index]) &gt; 0)
				{
					Append(targetElements, targetDifferences[index]);
				}
				else
				{
					Append(targetElements, OLAPCellGetElement(cell, cubeDimensions[index]));
				}

				index = index + 1;
			}

			string value = OLAPCellReadStringDynamic(connection, cube, sourceElements);
			OLAPCellWriteStringDynamic(connection, cube, value, targetElements);
			counter = counter + 1;
		}

		LogInformation(functionName + "" Copied "" + counter + "" values"");
		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR - "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GenericCopy(OLAPConnection connection, string cube, StringArray cubeDimensions, StringListList sourceDefinition, StringArray targetDifferences)
@Description: ""Copies the values obtained from the source definition to the base elements identified in the targetDifferences"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""An open Olap connection to the database"";
@Parameter[cube]: ""The name of the cube"";
@Parameter[cubeDimensions]: ""An array of the dimensions of the cube in cube order. See BP_GetCubeDimensions."";
@Parameter[sourceDefinition]: ""A list of OLAPElementLists in dimension order defining the source data area. Must be all base cells."";
@Parameter[targetDifferences]: ""A string array of elements in dimension order with the difference from source data area defining the target. Must be empty (meaning same as source) or single base target element."";
{
	string functionName = ""BP_GenericCopy:"";
	string errorMessage = """";
	int errorCode = 0;

	LogInformation(functionName + "" Cube '"" + cube + ""'"");
	try
	{
		// Define the target data area by combining the sourceDefinition with the target difference list
		LogDebug(""Getting target data area definition."");
		int dimensionCount = Count(cubeDimensions);
		int index = 0;
		StringListList targetDefinition = CreateStringListList();
		while (index < dimensionCount)
		{
			if (StringLength(targetDifferences[index]) > 0)
			{
				Append(targetDefinition, ConvertToStringList(targetDifferences[index]));
			}
			else
			{
				Append(targetDefinition, sourceDefinition[index]);
			}

			index = index + 1;
		}

		// Clear the target area
		OLAPDataArea targetData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetDefinition);

		OLAPDeleteDataArea(targetData); // Clear destination

		// Get the source data area
		OLAPDataArea sourceData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             sourceDefinition);

		// Loop through the source data area and write to the target data area
		int counter = 0;
		foreach (OLAPCell cell in sourceData)
		{
			StringArray targetElements = CreateStringArray();
			StringArray sourceElements = CreateStringArray();
			index = 0;
			while (index < dimensionCount)
			{
				Append(sourceElements, OLAPCellGetElement(cell, cubeDimensions[index]));

				if (StringLength(targetDifferences[index]) > 0)
				{
					Append(targetElements, targetDifferences[index]);
				}
				else
				{
					Append(targetElements, OLAPCellGetElement(cell, cubeDimensions[index]));
				}

				index = index + 1;
			}

			string value = OLAPCellReadStringDynamic(connection, cube, sourceElements);
			OLAPCellWriteStringDynamic(connection, cube, value, targetElements);
			counter = counter + 1;
		}

		LogInformation(functionName + "" Copied "" + counter + "" values"");
		return ""TRUE"";
	}
	catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR - "" + functionName + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	E579A8DC-A623-403A-A998-A518944D50A8	Copies the values obtained from the source definition to the base elements identified in the targetDifferences	1	1	1	1600	NULL	0	45708.67501	0	0
67F2EBC9-EB3D-4172-BEA0-EF7174764284	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetActualVersionedHierarchy	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""actual hierarchy for the given period"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""data_connection"" parameter-type=""string"" parameter-description=""Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""period_start_date"" parameter-type=""int"" parameter-description=""Start Date in format YYYYMMDD"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period_end_date"" parameter-type=""int"" parameter-description=""End Date in format YYYYMMDD"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetActualVersionedHierarchy(string data_connection, string dimension, int period_start_date, int period_end_date)
@Parameter[data_connection]: ""Data Connection Name"";
@Parameter[dimension]: ""Dimension"";
@Parameter[period_start_date]: ""Start Date in format YYYYMMDD"";
@Parameter[period_end_date]: ""End Date in format YYYYMMDD"";
@Category: ""Budgeting and Planning Utilities"";
@Description: ""Process returns the actual hierarchy for the given period"";
@Returns: ""actual hierarchy for the given period"";
{
	/* To use intellisense press Ctrl-Space and select a function from the list.
	 * To use autocompletion start typing the function. When the right function
	 * appears type the round opening bracket and select from the list of available
	 * signatures.
	 */

	// Add your BI# code here.

	OLAPConnection conn = OLAPCreatePooledNamedConnection(data_connection);
	string request =
		""&lt;Alea:Document xmlns:Alea=\""http://www.misag.com\""&gt;"" +
		""&lt;Alea:Request RequestID=\""001\"" Class=\""Dimension\"" Method=\""GetProperties\""&gt;"" +
		""&lt;Alea:Dimension Name=\"""" + dimension + ""\""/&gt;"" +
		""&lt;/Alea:Request&gt;"" +
		""&lt;/Alea:Document&gt;"";
	//WriteLine(request);
	string resultXmlString = OLAPXMLRequest(conn,request);
	
	
	//WriteLine(resultXmlString);

	XMLDocument xml = XMLParseDocument(resultXmlString);
	string OlapNamespaceURI = ""http://www.misag.com"";
	XMLNamespaceManager xmlnsManager = XMLCreateNamespaceManager(xml);
	XMLAddNamespace(xmlnsManager, ""Alea"", OlapNamespaceURI);
	XMLElement root = XMLGetRootElement(xml);
	XMLElementList hierarchies = XMLXPathSelectElements(root, ""//Alea:Return/Alea:Properties/Alea:Hierarchy"", xmlnsManager);

	int lowestHierarchyAfterEndDate = 99999999;

	foreach(XMLElement hierarchy in hierarchies){
		if(!XMLHasAttribute(hierarchy, ""name"")){
			continue;
		}
		string hierarchyName = XMLGetAttributeValue(hierarchy,""Name"");
		if(!StringMatchesRegex(hierarchyName,""V\\d{8}"")){
			continue;
		}
		int hierarchyDateValue = ToInt(StringSubstring(hierarchyName,1,8));

		if(hierarchyDateValue &gt;= period_end_date and lowestHierarchyAfterEndDate &gt; hierarchyDateValue){
			lowestHierarchyAfterEndDate = hierarchyDateValue;
		}
	}

	//WriteLine(lowestHierarchyAfterEndDate);

	OLAPReleasePooledConnection(conn);
	
	if(lowestHierarchyAfterEndDate != 99999999){
		return ""[""+ dimension +""].[V"" + lowestHierarchyAfterEndDate + ""]"";
	}

	return ""[""+ dimension +""].[VCURRENT]"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetActualVersionedHierarchy(string data_connection, string dimension, int period_start_date, int period_end_date)
@Parameter[data_connection]: ""Data Connection Name"";
@Parameter[dimension]: ""Dimension"";
@Parameter[period_start_date]: ""Start Date in format YYYYMMDD"";
@Parameter[period_end_date]: ""End Date in format YYYYMMDD"";
@Category: ""Budgeting and Planning Utilities"";
@Description: ""Process returns the actual hierarchy for the given period"";
@Returns: ""actual hierarchy for the given period"";
{
	/* To use intellisense press Ctrl-Space and select a function from the list.
	 * To use autocompletion start typing the function. When the right function
	 * appears type the round opening bracket and select from the list of available
	 * signatures.
	 */

	// Add your BI# code here.

	OLAPConnection conn = OLAPCreatePooledNamedConnection(data_connection);
	string request =
		""<Alea:Document xmlns:Alea=\""http://www.misag.com\"">"" +
		""<Alea:Request RequestID=\""001\"" Class=\""Dimension\"" Method=\""GetProperties\"">"" +
		""<Alea:Dimension Name=\"""" + dimension + ""\""/>"" +
		""</Alea:Request>"" +
		""</Alea:Document>"";
	//WriteLine(request);
	string resultXmlString = OLAPXMLRequest(conn,request);
	
	
	//WriteLine(resultXmlString);

	XMLDocument xml = XMLParseDocument(resultXmlString);
	string OlapNamespaceURI = ""http://www.misag.com"";
	XMLNamespaceManager xmlnsManager = XMLCreateNamespaceManager(xml);
	XMLAddNamespace(xmlnsManager, ""Alea"", OlapNamespaceURI);
	XMLElement root = XMLGetRootElement(xml);
	XMLElementList hierarchies = XMLXPathSelectElements(root, ""//Alea:Return/Alea:Properties/Alea:Hierarchy"", xmlnsManager);

	int lowestHierarchyAfterEndDate = 99999999;

	foreach(XMLElement hierarchy in hierarchies){
		if(!XMLHasAttribute(hierarchy, ""name"")){
			continue;
		}
		string hierarchyName = XMLGetAttributeValue(hierarchy,""Name"");
		if(!StringMatchesRegex(hierarchyName,""V\\d{8}"")){
			continue;
		}
		int hierarchyDateValue = ToInt(StringSubstring(hierarchyName,1,8));

		if(hierarchyDateValue >= period_end_date and lowestHierarchyAfterEndDate > hierarchyDateValue){
			lowestHierarchyAfterEndDate = hierarchyDateValue;
		}
	}

	//WriteLine(lowestHierarchyAfterEndDate);

	OLAPReleasePooledConnection(conn);
	
	if(lowestHierarchyAfterEndDate != 99999999){
		return ""[""+ dimension +""].[V"" + lowestHierarchyAfterEndDate + ""]"";
	}

	return ""[""+ dimension +""].[VCURRENT]"";
}"	1	3ACBDBCC-42F2-487B-A7BF-800F8DFDD1C5	Process returns the actual hierarchy for the given period	1	1	1	1601	NULL	0	45708.67508	0	0
FB3E6705-C530-4B95-BA13-E1FC57AA020E	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetBaseCountForLevel	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""Number of base elements associated with the specified level of the specified dimension"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database to interact with"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Name of the dimension"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""level"" parameter-type=""string"" parameter-description=""Identifier of the level of the dimension"" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BP_GetBaseCountForLevel(
	OLAPConnection connection,
	string dimension,
	string level
)
@Description: ""Determine number of base elements for provided level of provided dimension"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[dimension]: ""Name of the dimension"";
@Parameter[level]: ""Identifier of the level of the dimension"";
@Returns: ""Number of base elements associated with the specified level of the specified dimension"";
{
	int result = 0;
	string TimeDimension = ""BPDTIME"";

	// Hardcoded until I can find a way to retrieve this information from OLAP
	if (dimension == TimeDimension) {
		if (level == ""[BPDTIME].[Years]"") {
			result = 12;
		} else if (level == ""[BPDTIME].[Quarters]"") {
			result = 3;
		} else if (level == ""[BPDTIME].[Months]"") {
			result = 1;
		}
	}

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BP_GetBaseCountForLevel(
	OLAPConnection connection,
	string dimension,
	string level
)
@Description: ""Determine number of base elements for provided level of provided dimension"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[dimension]: ""Name of the dimension"";
@Parameter[level]: ""Identifier of the level of the dimension"";
@Returns: ""Number of base elements associated with the specified level of the specified dimension"";
{
	int result = 0;
	string TimeDimension = ""BPDTIME"";

	// Hardcoded until I can find a way to retrieve this information from OLAP
	if (dimension == TimeDimension) {
		if (level == ""[BPDTIME].[Years]"") {
			result = 12;
		} else if (level == ""[BPDTIME].[Quarters]"") {
			result = 3;
		} else if (level == ""[BPDTIME].[Months]"") {
			result = 1;
		}
	}

	return result;
}"	1	B51F7A32-77C7-4E5B-A20A-0D41D7C0E4FA	Determine number of base elements for provided level of provided dimension	1	1	1	1602	NULL	0	45708.67507	0	0
332C95B0-F611-4A07-9C8E-98B4E50152EA	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetBudgetEndDate	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use for access"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set for which to retrieve the configured years"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""BP_GetPlanningCycleYears"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""

string BP_GetBudgetEndDate(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to calculate the Budget End Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetEndDate: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetEndDate = """";
	string configCube = ""BPCCONFIGURATION"";
	string ConfigurationDimension = ""BPDCONFIGURATION"";
	string CalendarStartMonthElement = ""CALENDER_START_MONTH"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""Configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			OLAPElementList years = BP_GetPlanningCycleYears(connection, cycle);
			if (Count(years) == 0) {
				LogWarning(functionName + ""No Configuration set years returned from BP_GetPlanningCycleYears for Configuration set "" + cycle);
				return """";
			}

			string endYear = ToString(years[Count(years)-1]);
			string startMonth = OLAPGetStringAttribute(connection, ConfigurationDimension, CalendarStartMonthElement, ""VALUE"");
			string endMonth = """";

			// End month is 1 before the start month
			if (ToInt(startMonth) == 1) {
				endMonth = ""12"";
			} else {
				endMonth = ToString(ToInt(startMonth) - 1);
				if (StringLength(endMonth) == 1) {
					endMonth = ""0"" + endMonth;
				}
			}

			int monthDays = DaysInMonth(ToInt(endYear), ToInt(endMonth));

			budgetEndDate = endYear + ""/"" + endMonth + ""/"" + ToString(monthDays);
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""returning "" + budgetEndDate);
		}

		return budgetEndDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetEndDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetEndDate;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""

string BP_GetBudgetEndDate(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to calculate the Budget End Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetEndDate: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetEndDate = """";
	string configCube = ""BPCCONFIGURATION"";
	string ConfigurationDimension = ""BPDCONFIGURATION"";
	string CalendarStartMonthElement = ""CALENDER_START_MONTH"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""Configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			OLAPElementList years = BP_GetPlanningCycleYears(connection, cycle);
			if (Count(years) == 0) {
				LogWarning(functionName + ""No Configuration set years returned from BP_GetPlanningCycleYears for Configuration set "" + cycle);
				return """";
			}

			string endYear = ToString(years[Count(years)-1]);
			string startMonth = OLAPGetStringAttribute(connection, ConfigurationDimension, CalendarStartMonthElement, ""VALUE"");
			string endMonth = """";

			// End month is 1 before the start month
			if (ToInt(startMonth) == 1) {
				endMonth = ""12"";
			} else {
				endMonth = ToString(ToInt(startMonth) - 1);
				if (StringLength(endMonth) == 1) {
					endMonth = ""0"" + endMonth;
				}
			}

			int monthDays = DaysInMonth(ToInt(endYear), ToInt(endMonth));

			budgetEndDate = endYear + ""/"" + endMonth + ""/"" + ToString(monthDays);
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""returning "" + budgetEndDate);
		}

		return budgetEndDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetEndDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetEndDate;
}"	1	F50E02FF-083E-4685-8E93-24D4A376C303	This function is used to calculate the Budget End Date for the provided Configuration set.	1	1	1	1603	NULL	0	45708.67502	0	0
C6E6D5A0-E662-4684-BBB2-CA1B5251AC52	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetBudgetEndDate_UI	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server database to connect to, in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credentials as returned from an AppStudio call to the function GETTICKET()"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set for which to retrieve the configured years"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""BP_GetBudgetEndDate"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetBudgetEndDate"", ""*""

string BP_GetBudgetEndDate_UI(
	string server,
	string ticket,
	string cycle
)
@Description: ""This function is used to calculate the Budget End Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[server]: ""The OLAP server database to connect to, in the form server/database"";
@Parameter[ticket]: ""The user credentials as returned from an AppStudio call to the function GETTICKET()"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetEndDate_UI: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetEndDate = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		if (StringStartsWith(cycle, ""["")) {
			cycle = ResolveUniqueName(connection, cycle);
		}

		if (cycle == """") {
			LogError(functionName + ""Configuration set is a require parameter"");
			return ""ERROR: Configuration set required"";
		}

		budgetEndDate = BP_GetBudgetEndDate(connection, cycle);
		return budgetEndDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetEndDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetEndDate;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetBudgetEndDate"", ""*""

string BP_GetBudgetEndDate_UI(
	string server,
	string ticket,
	string cycle
)
@Description: ""This function is used to calculate the Budget End Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget End Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[server]: ""The OLAP server database to connect to, in the form server/database"";
@Parameter[ticket]: ""The user credentials as returned from an AppStudio call to the function GETTICKET()"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetEndDate_UI: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetEndDate = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		if (StringStartsWith(cycle, ""["")) {
			cycle = ResolveUniqueName(connection, cycle);
		}

		if (cycle == """") {
			LogError(functionName + ""Configuration set is a require parameter"");
			return ""ERROR: Configuration set required"";
		}

		budgetEndDate = BP_GetBudgetEndDate(connection, cycle);
		return budgetEndDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetEndDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetEndDate;
}"	1	E5803C30-5984-4A8A-B180-C31C7D7C66B5	This function is used to calculate the Budget End Date for the provided Configuration set.	1	1	1	1604	NULL	0	45708.67506	0	0
B8190C88-760D-4391-AFEA-513A122374FF	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetBudgetStartDate	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The Budget Start Date in YYYY/MM/DD format for the provided Configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use for access"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The Configuration set for which to retrieve the configured years"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""BP_GetPlanningCycleYears"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""

string BP_GetBudgetStartDate(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to calculate the Budget Start Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget Start Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetStartDate: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetStartDate = """";
	string configCube = ""BPCCONFIGURATION"";
	string ConfigurationDimension = ""BPDCONFIGURATION"";
	string CalendarStartMonthElement = ""CALENDER_START_MONTH"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""Configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			OLAPElementList years = BP_GetPlanningCycleYears(connection, cycle);
			int startYear = ToInt(years[0]);
			string startMonth = OLAPGetStringAttribute(connection, ConfigurationDimension, CalendarStartMonthElement, ""VALUE"");
			if (CV(""WBDebugLogging"") == ""1"") {
				LogDebug(functionName + ""startMonth="" + startMonth);
			}

			if (StringLength(startMonth) == 1) {
				startMonth = ""0"" + startMonth; // Must have 2 digit month
			}

			if (ToInt(startMonth) &gt; 1) {
				// Fiscal year does not start in January
				startYear = startYear - 1;
			}

			budgetStartDate = ToString(startYear) + ""/"" + startMonth + ""/"" + ""01"";
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""returning "" + budgetStartDate);
		}

		return budgetStartDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetStartDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetStartDate;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""

string BP_GetBudgetStartDate(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to calculate the Budget Start Date for the provided Configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Budget Start Date in YYYY/MM/DD format for the provided Configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The Configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetBudgetStartDate: "";
	string errorMessage = """";
	int errorCode = 0;
	string budgetStartDate = """";
	string configCube = ""BPCCONFIGURATION"";
	string ConfigurationDimension = ""BPDCONFIGURATION"";
	string CalendarStartMonthElement = ""CALENDER_START_MONTH"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""Configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			OLAPElementList years = BP_GetPlanningCycleYears(connection, cycle);
			int startYear = ToInt(years[0]);
			string startMonth = OLAPGetStringAttribute(connection, ConfigurationDimension, CalendarStartMonthElement, ""VALUE"");
			if (CV(""WBDebugLogging"") == ""1"") {
				LogDebug(functionName + ""startMonth="" + startMonth);
			}

			if (StringLength(startMonth) == 1) {
				startMonth = ""0"" + startMonth; // Must have 2 digit month
			}

			if (ToInt(startMonth) > 1) {
				// Fiscal year does not start in January
				startYear = startYear - 1;
			}

			budgetStartDate = ToString(startYear) + ""/"" + startMonth + ""/"" + ""01"";
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + ""returning "" + budgetStartDate);
		}

		return budgetStartDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + ""Error code: "" + errorCode);
		return budgetStartDate;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return budgetStartDate;
}"	1	A9BD0257-C4A8-47C7-9073-09ED81BD9FD4	This function is used to calculate the Budget Start Date for the provided Configuration set.	1	1	1	1605	NULL	0	45708.67504	0	0
FC36295C-5E24-40C3-AB8E-28B350635871	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetChildStringListOrItself	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""the list of elements under element or a list containing only element"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The olap connection used for this operation."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the element belongs to."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""element"" parameter-type=""string"" parameter-description=""The element that shall be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""onlyBaseElements"" parameter-type=""bool"" parameter-description=""true returns only basic childs, false returns all childs in case of a C-element"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""forDataArea"" parameter-type=""bool"" parameter-description=""true add empty string into first position, and list should be used in dataarea"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetChildStringListOrItself(OLAPConnection connection, string dimension, string element, bool onlyBaseElements, bool forDataArea)
@Description: ""Returns the childs of 'element' or a list containing only 'element' if it is a base element"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""The olap connection used for this operation."";
@Parameter[dimension]: ""The dimension the element belongs to."";
@Parameter[element]: ""The element that shall be used."";
@Parameter[onlyBaseElements]: ""true returns only basic childs, false returns all childs in case of a C-element"";
@Parameter[forDataArea]: ""true add empty string into first position, and list should be used in dataarea"";
@Returns: ""the list of elements under element or a list containing only element"";
{
	OLAPElement oElement = OLAPGetDimensionElement(connection, dimension, element);
	bool baseElement = OLAPIsBaseElement(connection, oElement);


	StringArray array = CreateStringArray();
	if(forDataArea)
	{
		Append(array, """");
	}

	if(baseElement)
	{
		Append(array, element);
	}
	else
	{

		OLAPElementList oList = OLAPGetChildElementList(connection, dimension, element, onlyBaseElements);
		StringList stringListHelp = ToStringList(oList);

		foreach(string oHelpElement in stringListHelp )
		{
			Append(array, oHelpElement);
		}
	}
	StringList stringList = ToStringList(array);
	return stringList;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetChildStringListOrItself(OLAPConnection connection, string dimension, string element, bool onlyBaseElements, bool forDataArea)
@Description: ""Returns the childs of 'element' or a list containing only 'element' if it is a base element"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""The olap connection used for this operation."";
@Parameter[dimension]: ""The dimension the element belongs to."";
@Parameter[element]: ""The element that shall be used."";
@Parameter[onlyBaseElements]: ""true returns only basic childs, false returns all childs in case of a C-element"";
@Parameter[forDataArea]: ""true add empty string into first position, and list should be used in dataarea"";
@Returns: ""the list of elements under element or a list containing only element"";
{
	OLAPElement oElement = OLAPGetDimensionElement(connection, dimension, element);
	bool baseElement = OLAPIsBaseElement(connection, oElement);


	StringArray array = CreateStringArray();
	if(forDataArea)
	{
		Append(array, """");
	}

	if(baseElement)
	{
		Append(array, element);
	}
	else
	{

		OLAPElementList oList = OLAPGetChildElementList(connection, dimension, element, onlyBaseElements);
		StringList stringListHelp = ToStringList(oList);

		foreach(string oHelpElement in stringListHelp )
		{
			Append(array, oHelpElement);
		}
	}
	StringList stringList = ToStringList(array);
	return stringList;
}"	1	85C9D82B-7CE6-4FD9-A143-DE4D9127FA22	Returns the childs of 'element' or a list containing only 'element' if it is a base element	1	1	1	1606	NULL	0	45708.67507	0	0
0DD8C666-AA83-4BC5-BEA3-62A42E57AB15	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetCubeDimensions	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""An array of the dimensions, in order"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The open Olap connection"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The cube name whose dimensions are to be returned"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray BP_GetCubeDimensions(OLAPConnection connection, string cube)
@Description: ""Gets a list of dimensions, in order, in the cube"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""An array of the dimensions, in order"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[cube]: ""The cube name whose dimensions are to be returned"";
{
	StringArray dimensions = CreateStringArray();
	string functionName = ""BP_GetCubeDimensions:"";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		foreach (OLAPCube olapCube in OLAPGetCubeList(connection))
		{
			string name = OLAPGetCubeName(olapCube);
			if(name == cube)
			{
				OLAPDimensionList cubeDimensions = OLAPGetDimensionList(olapCube);
				foreach (OLAPDimension dimension in cubeDimensions)
				{
					Append(dimensions, dimension);
				}

				return dimensions;
			}
		}
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}

	// This is only here because AppEngine won't compile unless it is.
	return dimensions;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray BP_GetCubeDimensions(OLAPConnection connection, string cube)
@Description: ""Gets a list of dimensions, in order, in the cube"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""An array of the dimensions, in order"";
@Parameter[connection]: ""The open Olap connection"";
@Parameter[cube]: ""The cube name whose dimensions are to be returned"";
{
	StringArray dimensions = CreateStringArray();
	string functionName = ""BP_GetCubeDimensions:"";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		foreach (OLAPCube olapCube in OLAPGetCubeList(connection))
		{
			string name = OLAPGetCubeName(olapCube);
			if(name == cube)
			{
				OLAPDimensionList cubeDimensions = OLAPGetDimensionList(olapCube);
				foreach (OLAPDimension dimension in cubeDimensions)
				{
					Append(dimensions, dimension);
				}

				return dimensions;
			}
		}
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}

	// This is only here because AppEngine won't compile unless it is.
	return dimensions;
}"	1	67606486-2FDF-46BA-846A-079D9F68FAEF	Gets a list of dimensions, in order, in the cube	1	1	1	1607	NULL	0	45708.67504	0	0
55CF8993-C212-4D4B-9F0D-92B45243217B	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetCurrentTimestampInDays	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The current time stamp in days."" process-is-protected=""True"">
  <dependencies>
    <process process-name=""BP_GetTimestampInDays"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTimestampInDays"", ""*""

double BP_GetCurrentTimestampInDays()
@Description: ""Returns the current time stamp in days."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The current time stamp in days."";
{
	DateTime currentTime = CreateDateTime();
	double days = BP_GetTimestampInDays(currentTime);

	return days;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTimestampInDays"", ""*""

double BP_GetCurrentTimestampInDays()
@Description: ""Returns the current time stamp in days."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The current time stamp in days."";
{
	DateTime currentTime = CreateDateTime();
	double days = BP_GetTimestampInDays(currentTime);

	return days;
}"	1	690F44BA-2C1B-4745-9531-CA4BDC9A570F	Returns the current time stamp in days.	1	1	1	1608	NULL	0	45708.67504	0	0
379095EF-EA68-4E98-A1D4-3B924EEAA583	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetCycleAccounts	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""StringList of the activated Accounts"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database to interact with"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Element of Configuration set Dimension"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Element of VersionDimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Element of the EntityDimension"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Element of the OrganizationDimension"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""planningStep"" parameter-type=""string"" parameter-description=""Element of the NumberDimension"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetCycleAccounts(
	OLAPConnection connection,
	string cycle,
	string version,
	string entity,
	string organization,
	string planningStep
)
@Description: ""Retrieve a collection of distinct Accounts activated for the specified Configuration set and planning step"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Parameter[version]: ""Element of VersionDimension"";
@Parameter[entity]: ""Element of the EntityDimension"";
@Parameter[organization]: ""Element of the OrganizationDimension"";
@Parameter[planningStep]: ""Element of the NumberDimension"";
@Returns: ""StringList of the activated Accounts"";
{
	string functionName = ""BP_GetCycleAccounts: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set="" + cycle);
		LogDebug(functionName + ""version="" + version);
		LogDebug(functionName + ""entity="" + entity);
		LogDebug(functionName + ""organization="" + organization);
		LogDebug(functionName + ""planningStep="" + planningStep);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		if (version == """") {
			LogError(functionName + ""Version must be provided"");
			RaiseError(functionName + ""Version must be provided"", 1);
		}

		if (entity == """") {
			LogError(functionName + ""Entity must be provided"");
			RaiseError(functionName + ""Entity must be provided"", 1);
		}

		if (organization == """") {
			LogError(functionName + ""Organization must be provided"");
			RaiseError(functionName + ""Organization must be provided"", 1);
		}

		if (planningStep == """") {
			LogError(functionName + ""PlanningStep must be provided"");
			RaiseError(functionName + ""PlanningStep must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		string AccountDimension = ""BPDACCOUNT"";

		// Gather the activated accounts
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           ConvertToStringList(cycle),
		                                           ConvertToStringList(version),
		                                           ConvertToStringList(entity), // BPDENTITY
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDORGANIZATION,
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDACCOUNT
		                                           ConvertToStringList(planningStep), // BPDNO
		                                           ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE""), // BPDPARAMETER
		                                           ConvertToStringList(""Value"") // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string account = OLAPCellGetElement(cell, AccountDimension);
				AppendDistinct(result, account);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetCycleAccounts(
	OLAPConnection connection,
	string cycle,
	string version,
	string entity,
	string organization,
	string planningStep
)
@Description: ""Retrieve a collection of distinct Accounts activated for the specified Configuration set and planning step"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Parameter[version]: ""Element of VersionDimension"";
@Parameter[entity]: ""Element of the EntityDimension"";
@Parameter[organization]: ""Element of the OrganizationDimension"";
@Parameter[planningStep]: ""Element of the NumberDimension"";
@Returns: ""StringList of the activated Accounts"";
{
	string functionName = ""BP_GetCycleAccounts: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set="" + cycle);
		LogDebug(functionName + ""version="" + version);
		LogDebug(functionName + ""entity="" + entity);
		LogDebug(functionName + ""organization="" + organization);
		LogDebug(functionName + ""planningStep="" + planningStep);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		if (version == """") {
			LogError(functionName + ""Version must be provided"");
			RaiseError(functionName + ""Version must be provided"", 1);
		}

		if (entity == """") {
			LogError(functionName + ""Entity must be provided"");
			RaiseError(functionName + ""Entity must be provided"", 1);
		}

		if (organization == """") {
			LogError(functionName + ""Organization must be provided"");
			RaiseError(functionName + ""Organization must be provided"", 1);
		}

		if (planningStep == """") {
			LogError(functionName + ""PlanningStep must be provided"");
			RaiseError(functionName + ""PlanningStep must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		string AccountDimension = ""BPDACCOUNT"";

		// Gather the activated accounts
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           ConvertToStringList(cycle),
		                                           ConvertToStringList(version),
		                                           ConvertToStringList(entity), // BPDENTITY
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDORGANIZATION,
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDACCOUNT
		                                           ConvertToStringList(planningStep), // BPDNO
		                                           ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE""), // BPDPARAMETER
		                                           ConvertToStringList(""Value"") // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string account = OLAPCellGetElement(cell, AccountDimension);
				AppendDistinct(result, account);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}"	1	F1D99EC3-0011-4BB6-8526-BB617680BD8C	Retrieve a collection of distinct Accounts activated for the specified Configuration set and planning step	1	1	1	1609	NULL	0	45708.67502	0	0
B94B8020-8A6A-4885-9967-ECADF4FB12BF	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetCycleOrganizations	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""StringList of the activated Accounts"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database to interact with"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Element of Configuration set Dimension"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Element of VersionDimension"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Element of the EntityDimension"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Element of the OrganizationDimension"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""planningStep"" parameter-type=""string"" parameter-description=""Element of the NumberDimension"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetCycleOrganizations(
	OLAPConnection connection,
	string cycle,
	string version,
	string entity,
	string organization,
	string planningStep
)
@Description: ""Retrieve a collection of distinct Accounts activated for the specified cycle and planning step"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Parameter[version]: ""Element of VersionDimension"";
@Parameter[entity]: ""Element of the EntityDimension"";
@Parameter[organization]: ""Element of the OrganizationDimension"";
@Parameter[planningStep]: ""Element of the NumberDimension"";
@Returns: ""StringList of the activated Accounts"";
{
	string functionName = ""BP_GetCycleOrganizations: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set ="" + cycle);
		LogDebug(functionName + ""version="" + version);
		LogDebug(functionName + ""entity="" + entity);
		LogDebug(functionName + ""organization="" + organization);
		LogDebug(functionName + ""planningStep="" + planningStep);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		if (version == """") {
			LogError(functionName + ""Version must be provided"");
			RaiseError(functionName + ""Version must be provided"", 1);
		}

		if (entity == """") {
			LogError(functionName + ""Entity must be provided"");
			RaiseError(functionName + ""Entity must be provided"", 1);
		}

		if (organization == """") {
			LogError(functionName + ""Organization must be provided"");
			RaiseError(functionName + ""Organization must be provided"", 1);
		}

		if (planningStep == """") {
			LogError(functionName + ""PlanningStep must be provided"");
			RaiseError(functionName + ""PlanningStep must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		string OrganizationDimension = ""BPDORGANIZATION"";

		// Gather the activated accounts
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           ConvertToStringList(cycle),
		                                           ConvertToStringList(version),
		                                           ConvertToStringList(entity), // BPDENTITY
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDORGANIZATION,
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDACCOUNT
		                                           ConvertToStringList(planningStep), // BPDNO
		                                           ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE""), // BPDPARAMETER
		                                           ConvertToStringList(""Value"") // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string organizationInDataCell = OLAPCellGetElement(cell, OrganizationDimension);
				AppendDistinct(result, organizationInDataCell);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetCycleOrganizations(
	OLAPConnection connection,
	string cycle,
	string version,
	string entity,
	string organization,
	string planningStep
)
@Description: ""Retrieve a collection of distinct Accounts activated for the specified cycle and planning step"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Parameter[version]: ""Element of VersionDimension"";
@Parameter[entity]: ""Element of the EntityDimension"";
@Parameter[organization]: ""Element of the OrganizationDimension"";
@Parameter[planningStep]: ""Element of the NumberDimension"";
@Returns: ""StringList of the activated Accounts"";
{
	string functionName = ""BP_GetCycleOrganizations: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set ="" + cycle);
		LogDebug(functionName + ""version="" + version);
		LogDebug(functionName + ""entity="" + entity);
		LogDebug(functionName + ""organization="" + organization);
		LogDebug(functionName + ""planningStep="" + planningStep);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		if (version == """") {
			LogError(functionName + ""Version must be provided"");
			RaiseError(functionName + ""Version must be provided"", 1);
		}

		if (entity == """") {
			LogError(functionName + ""Entity must be provided"");
			RaiseError(functionName + ""Entity must be provided"", 1);
		}

		if (organization == """") {
			LogError(functionName + ""Organization must be provided"");
			RaiseError(functionName + ""Organization must be provided"", 1);
		}

		if (planningStep == """") {
			LogError(functionName + ""PlanningStep must be provided"");
			RaiseError(functionName + ""PlanningStep must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_MAIN"";
		string NA = ""N.A."";
		string OrganizationDimension = ""BPDORGANIZATION"";

		// Gather the activated accounts
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           ConvertToStringList(cycle),
		                                           ConvertToStringList(version),
		                                           ConvertToStringList(entity), // BPDENTITY
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDORGANIZATION,
		                                           ConvertToStringList(OlapDataAreaBCells), // BPDACCOUNT
		                                           ConvertToStringList(planningStep), // BPDNO
		                                           ConvertToStringList(""SUBPLAN_FINANCE_ACC_ACTIVE""), // BPDPARAMETER
		                                           ConvertToStringList(""Value"") // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string organizationInDataCell = OLAPCellGetElement(cell, OrganizationDimension);
				AppendDistinct(result, organizationInDataCell);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}"	1	F76F6337-019F-4DD4-ACF2-9CDE35186EA6	Retrieve a collection of distinct Accounts activated for the specified cycle and planning step	1	1	1	1610	NULL	0	45708.67507	0	0
EE48D2A0-A2B8-415D-AD1C-73B04D375E8C	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetCycleVersions	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""StringList of the activated Versions"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database to interact with"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Element of Configuration set Dimension"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
void Test() {
	string server = ""usalvwpsolap/Planning"";
	string cycle = ""CYCLE_001"";
	OLAPConnection connection = OLAPCreatePooledConnection(server, ""testuser"", """");

	StringList versions = BP_GetCycleVersions(connection, cycle);

	foreach(string version in versions) {
		Write(version);
	}
}
 */


StringList BP_GetCycleVersions(
	OLAPConnection connection,
	string cycle
)
@Description: ""Retrieve a collection of distinct Versions activated for the specified cycle"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Returns: ""StringList of the activated Versions"";
{
	string functionName = ""BP_GetCycleVersions: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set="" + cycle);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_CYCLE"";
		string NA = ""N.A."";
		string VersionDimension = ""BPDVERSION"";

		// Gather the activated versions
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           cycle,
		                                           OlapDataAreaBCells,     // BPDVERSION
		                                           ""GLOBAL_CYCLE_VERSION"", // BPDPARAMETER
		                                           ""Value""                 // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string version = OLAPCellGetElement(cell, VersionDimension);
				AppendDistinct(result, version);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
void Test() {
	string server = ""usalvwpsolap/Planning"";
	string cycle = ""CYCLE_001"";
	OLAPConnection connection = OLAPCreatePooledConnection(server, ""testuser"", """");

	StringList versions = BP_GetCycleVersions(connection, cycle);

	foreach(string version in versions) {
		Write(version);
	}
}
 */


StringList BP_GetCycleVersions(
	OLAPConnection connection,
	string cycle
)
@Description: ""Retrieve a collection of distinct Versions activated for the specified cycle"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]: ""Connection to the OLAP database to interact with"";
@Parameter[cycle]: ""Element of Configuration set Dimension"";
@Returns: ""StringList of the activated Versions"";
{
	string functionName = ""BP_GetCycleVersions: "";
	string errorMessage = """";
	int errorCode = 0;
	StringList result = CreateStringList();

	try {
		LogDebug(functionName + ""Configuration set="" + cycle);

		if (cycle == """") {
			LogError(functionName + ""Configuration set must be provided"");
			RaiseError(functionName + ""Configuration set must be provided"", 1);
		}

		// Constants
		string ConfigCube = ""BPCCONFIG_CYCLE"";
		string NA = ""N.A."";
		string VersionDimension = ""BPDVERSION"";

		// Gather the activated versions
		OLAPDataArea dataArea = OLAPCreateDataArea(connection, ConfigCube,
		                                           OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                           OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
		                                           cycle,
		                                           OlapDataAreaBCells,     // BPDVERSION
		                                           ""GLOBAL_CYCLE_VERSION"", // BPDPARAMETER
		                                           ""Value""                 // BPDLANGUAGE
		                                          );
		foreach (OLAPCell cell in dataArea) {
			if (ToDouble(cell) == 1) {
				string version = OLAPCellGetElement(cell, VersionDimension);
				AppendDistinct(result, version);
			}
		}

		return result;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return result;
}"	1	6ED1165F-CF04-449A-8672-69D5FAFFC65B	Retrieve a collection of distinct Versions activated for the specified cycle	1	1	1	1611	NULL	0	45708.67503	0	0
EEE2FD93-46E3-4846-910F-9AAED39B447E	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetDateFromDays	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""DateTime"" return-value-description=""The date associated with the provided days"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""days"" parameter-type=""double"" parameter-description=""Nubmer of days representing the date to return"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

DateTime BP_GetDateFromDays(
	double days
)
@Description: ""Function to return the date associated with the number of days since AppStudio start (as stored in Dynamic Attributes)"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[days]: ""Nubmer of days representing the date to return"";
@Returns: ""The date associated with the provided days"";
{
	// AppStudio stores dates as the number of days since 1899/12/30.
	// We will add the number of days provided to that base date to get the
	// actual date those days represent.
	DateTime baseDate = CreateDateTime(1899, 12, 30, 0, 0, 0);
	DateTime resultDate = DateTimeAddDays(baseDate, days);

	return resultDate;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

DateTime BP_GetDateFromDays(
	double days
)
@Description: ""Function to return the date associated with the number of days since AppStudio start (as stored in Dynamic Attributes)"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[days]: ""Nubmer of days representing the date to return"";
@Returns: ""The date associated with the provided days"";
{
	// AppStudio stores dates as the number of days since 1899/12/30.
	// We will add the number of days provided to that base date to get the
	// actual date those days represent.
	DateTime baseDate = CreateDateTime(1899, 12, 30, 0, 0, 0);
	DateTime resultDate = DateTimeAddDays(baseDate, days);

	return resultDate;
}"	1	46675657-4504-464D-BCB3-436D8B3F5D87	Function to return the date associated with the number of days since AppStudio start (as stored in Dynamic Attributes)	1	1	1	1612	NULL	0	45708.67502	0	0
DE1CE9A9-BFD0-433E-9F89-6AF095489B67	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetEntityCurrency	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The Currency element that is configured for the provided Entity"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use to retrieve data"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Configuration set element to use"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""organization"" parameter-type=""string"" parameter-description=""Organization element to use"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity element to use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""Intercompany element to use"" parameter-order=""4"" />
  <dependencies>
    <process process-name=""BP_GetResolvedUniqueName"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string BP_GetEntityCurrency(
	OLAPConnection connection,
	string cycle,
	string organization,
	string entity,
	string intercompany)
@Description: ""Retrieve the configured Currency element for the provided Entity"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Currency element that is configured for the provided Entity"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[cycle]: ""Configuration set element to use"";
@Parameter[organization]: ""Organization element to use"";
@Parameter[entity]: ""Entity element to use"";
@Parameter[intercompany]: ""Intercompany element to use"";
{
	string functionName = ""BP_GetEntityCurrency:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		string currency = OLAPCellReadString(connection, ""BPCCONFIG_ENTITY"", cycle, ""N.A."", entity, intercompany, organization, ""GLOBAL_ENTITY_CURRENCY"");
		currency = BP_GetResolvedUniqueName(connection, currency);
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug (functionName + "" returning '"" + currency + ""' for Cycle="" + cycle + "", Organization="" + organization + "", Entity="" + entity + "", Intercompany="" + intercompany);
		}

		return currency;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""N.A."";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetResolvedUniqueName"", ""*""

string BP_GetEntityCurrency(
	OLAPConnection connection,
	string cycle,
	string organization,
	string entity,
	string intercompany)
@Description: ""Retrieve the configured Currency element for the provided Entity"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The Currency element that is configured for the provided Entity"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[cycle]: ""Configuration set element to use"";
@Parameter[organization]: ""Organization element to use"";
@Parameter[entity]: ""Entity element to use"";
@Parameter[intercompany]: ""Intercompany element to use"";
{
	string functionName = ""BP_GetEntityCurrency:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		string currency = OLAPCellReadString(connection, ""BPCCONFIG_ENTITY"", cycle, ""N.A."", entity, intercompany, organization, ""GLOBAL_ENTITY_CURRENCY"");
		currency = BP_GetResolvedUniqueName(connection, currency);
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug (functionName + "" returning '"" + currency + ""' for Cycle="" + cycle + "", Organization="" + organization + "", Entity="" + entity + "", Intercompany="" + intercompany);
		}

		return currency;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""N.A."";
}"	1	EF70E51E-1D38-49D1-89F3-10AABA3934A4	Retrieve the configured Currency element for the provided Entity	1	1	1	1613	NULL	0	45708.67506	0	0
B42B6E8B-4A03-430A-B7A4-520B93AECA63	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetIndexOfList	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""The index of the value in the list."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""list"" parameter-type=""StringList"" parameter-description=""The string list to look up the value in."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""value"" parameter-type=""string"" parameter-description=""The value to look up the index for."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BP_GetIndexOfList(StringList list, string value)
@Description: ""Returns the index of the value in the list."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[list]: ""The string list to look up the value in."";
@Parameter[value]: ""The value to look up the index for."";
@Returns: ""The index of the value in the list."";
{
	StringArray array = ConvertToStringArray(list);
	int index = 0;
	foreach(string newString in array)
	{
		if(newString == value) {
			return index;
		}
		index = index + 1;
	}
	
	return -1;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

int BP_GetIndexOfList(StringList list, string value)
@Description: ""Returns the index of the value in the list."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[list]: ""The string list to look up the value in."";
@Parameter[value]: ""The value to look up the index for."";
@Returns: ""The index of the value in the list."";
{
	StringArray array = ConvertToStringArray(list);
	int index = 0;
	foreach(string newString in array)
	{
		if(newString == value) {
			return index;
		}
		index = index + 1;
	}
	
	return -1;
}"	1	EAB659F7-B429-45CE-AD0D-36351A0CFD39	Returns the index of the value in the list.	1	1	1	1614	NULL	0	45708.67507	0	0
8B571723-A52B-4BCB-9FC4-718C7DDCAEAC	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextAllocationDriver	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextAllocationDriver(string server)
@Description: ""Create new driver element below allocation drivers(ALLOCATION_DRIVER) in BPDACCOUNT dim "";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextAllocationDriver: "";
	string DimensionName = ""BPDACCOUNT"";
	string HierarchyName = ""BPDACCOUNT"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		//server = ""DEPM"";

		OLAPElementList ElementList = OLAPGetElementList(olapconnection, DimensionName,  true);

		string element = """";
		string counterString = """";
		bool isElementIn = false;
		int counter = 1;
		bool needToCreateElement = false;
		string zerosTocaption = """";
		

		while(counter &lt;=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			zerosTocaption =zerosString;
			

			element = ""DRIVER_"" +zerosString+counterString;
			isElementIn = OLAPElementListContainsElement(ElementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string ElementUn =  BP_CreateGenericElement(server,""[""+DimensionName+""]"",""[""+DimensionName+""].[""+HierarchyName+""]"", ""[BPDACCOUNT].[ALLOCATION_DRIVER].[1]"",element, 3,"""", ""N"", 1, false);
			ElementUn = ResolveUniqueName(olapconnection , ElementUn);
			element=ElementUn;
		}
		OLAPConnection olapconnection2 = OLAPCreatePooledNamedConnection(server);

		OLAPElement OElement = OLAPGetDimensionElement(olapconnection2, DimensionName, element);

		bool setAttributeIC = OLAPSetBoolAttribute(olapconnection2, OElement, ""IC"", false);
		bool setAttributeSEG1 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG1"", false);
		bool setAttributeSEG2 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG2"", false);
		bool setAttributeSEG3 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG3"", false);

		bool setAttributeName = OLAPSetStringAttribute(olapconnection2, OElement,""Name"", ""Driver "" + zerosTocaption + counterString);
		bool setAttributeEnglish = OLAPSetStringAttribute(olapconnection2, OElement,""English"", ""Driver "" + zerosTocaption + counterString);

		return ""[""+DimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextAllocationDriver(string server)
@Description: ""Create new driver element below allocation drivers(ALLOCATION_DRIVER) in BPDACCOUNT dim "";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextAllocationDriver: "";
	string DimensionName = ""BPDACCOUNT"";
	string HierarchyName = ""BPDACCOUNT"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		//server = ""DEPM"";

		OLAPElementList ElementList = OLAPGetElementList(olapconnection, DimensionName,  true);

		string element = """";
		string counterString = """";
		bool isElementIn = false;
		int counter = 1;
		bool needToCreateElement = false;
		string zerosTocaption = """";
		

		while(counter <=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			zerosTocaption =zerosString;
			

			element = ""DRIVER_"" +zerosString+counterString;
			isElementIn = OLAPElementListContainsElement(ElementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string ElementUn =  BP_CreateGenericElement(server,""[""+DimensionName+""]"",""[""+DimensionName+""].[""+HierarchyName+""]"", ""[BPDACCOUNT].[ALLOCATION_DRIVER].[1]"",element, 3,"""", ""N"", 1, false);
			ElementUn = ResolveUniqueName(olapconnection , ElementUn);
			element=ElementUn;
		}
		OLAPConnection olapconnection2 = OLAPCreatePooledNamedConnection(server);

		OLAPElement OElement = OLAPGetDimensionElement(olapconnection2, DimensionName, element);

		bool setAttributeIC = OLAPSetBoolAttribute(olapconnection2, OElement, ""IC"", false);
		bool setAttributeSEG1 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG1"", false);
		bool setAttributeSEG2 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG2"", false);
		bool setAttributeSEG3 = OLAPSetBoolAttribute(olapconnection2, OElement, ""SEG3"", false);

		bool setAttributeName = OLAPSetStringAttribute(olapconnection2, OElement,""Name"", ""Driver "" + zerosTocaption + counterString);
		bool setAttributeEnglish = OLAPSetStringAttribute(olapconnection2, OElement,""English"", ""Driver "" + zerosTocaption + counterString);

		return ""[""+DimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	7104789C-4FB2-4471-81F1-AA29D180C3C2	Create new driver element below allocation drivers(ALLOCATION_DRIVER) in BPDACCOUNT dim	1	1	1	1615	NULL	0	45708.67506	0	0
BA33C41E-5480-43BB-AB5B-C19FBAF371A8	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextAssumptionElements	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""if parent is SOURCE_ACCOUNT then CONTRA_xx.if parent is TOTAL_OTF_PREMISES then ACCOUNT_xx, if parent start with ACCOUNT then CONTRA_xx"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""Configuration set Un where is created version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""VersionUN"" parameter-type=""string"" parameter-description=""Version Un where are created new assuptions elements"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""ParentUN"" parameter-type=""string"" parameter-description=""Parent element, below elements should be created"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""EntityUN"" parameter-type=""string"" parameter-description=""Entity where assumtions are created"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""AccountUN"" parameter-type=""string"" parameter-description=""Account where assumtions are created"" parameter-order=""5"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextAssumptionElements(string server,string CycleUN,string VersionUN,string ParentUN,string EntityUN, string AccountUN)
@Description: ""Create elements in BPDPREMISE dimension, due to the parent."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""Configuration set Un where is created version"";
@Parameter[VersionUN]: ""Version Un where are created new assuptions elements"";
@Parameter[ParentUN]: ""Parent element, below elements should be created"";
@Parameter[EntityUN]: ""Entity where assumtions are created"";
@Parameter[AccountUN]: ""Account where assumtions are created"";
@Returns: ""if parent is SOURCE_ACCOUNT then CONTRA_xx.if parent is TOTAL_OTF_PREMISES then ACCOUNT_xx, if parent start with ACCOUNT then CONTRA_xx"";
{
	string functionName = ""BP_GetNextAssumptionElements: "";
	string dimensionName = ""BPDPREMISE"";
	string hierarchyName = ""BPDPREMISE"";
	string cube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	bool needToCreateElement = false;
	string result ="""";


	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		VersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		ParentUN= ""[BPDPREMISE].[ACCOUNT_2].[1]"";
		EntityUN= ""[BPDENTITY].[RU0002].[1]"";
		AccountUN= ""[BPDACCOUNT].[I000000].[1]"";*/

		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName,  false);
		string element = """";
		string counterString = """";
		bool isElementIn = false;
		string stringPartOfElement = """";
		string delimier = """";

		string cycle = ResolveUniqueName(olapconnection, CycleUN);
		string parent = ResolveUniqueName(olapconnection, ParentUN);
		string version = ResolveUniqueName(olapconnection, VersionUN);
		string entity = ResolveUniqueName(olapconnection, EntityUN);
		string account = ResolveUniqueName(olapconnection, AccountUN);

		int counter = 1;
		while(counter &lt;=99)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);

			if(parent == ""SOURCE_ACCOUNT"")
			{
				element = ""CONTRA""+counterString;
			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				element = ""TARGET_ACCOUNT_"" +counterString;
			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				element = ""CONTRA""+ counterString + ""_""+parent;
			}

			isElementIn = OLAPElementListContainsElement(elementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				string created = OLAPCellReadString(olapconnection, cube, NA, cycle,version,entity,account, element);

				if(created =="""")
				{
					break;
				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{
			if(parent == ""SOURCE_ACCOUNT"")
			{
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""S"", 1, false);
				result = element;
				OLAPCellWriteString(olapconnection, cube,""test"", NA, cycle,version,entity,account, element);
				element = element + ""_FACTOR"";
				ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);

			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				element = ""ACCOUNT_"" +counterString;
				result = element;
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);
				string elementTarget = ""TARGET_"" + element;
				string nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""FACTOR_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""PERIOD_SCOPE_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""TARGET_MONTH_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""ACTIVE_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ACTIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""CASH_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ARCHIVE].[1]"",elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""VALID_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ARCHIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""ACTIVE_TARGET_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_TARGET_ACTIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);

			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				element = ""CONTRA""+ counterString + ""_""+parent;
				result = ""CONTRA""+ counterString ;
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""S"", 1, false);
				element = ""CONTRA""+ counterString + ""_FACTOR_""+parent;
				ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);
			}
		}
		else
		{
			if(parent == ""SOURCE_ACCOUNT"")
			{
				result = ""CONTRA""+ counterString ;
			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				result = ""ACCOUNT_"" +counterString;
			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				result = ""CONTRA""+ counterString ;
			}
		}
		return result;
	}


	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextAssumptionElements(string server,string CycleUN,string VersionUN,string ParentUN,string EntityUN, string AccountUN)
@Description: ""Create elements in BPDPREMISE dimension, due to the parent."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""Configuration set Un where is created version"";
@Parameter[VersionUN]: ""Version Un where are created new assuptions elements"";
@Parameter[ParentUN]: ""Parent element, below elements should be created"";
@Parameter[EntityUN]: ""Entity where assumtions are created"";
@Parameter[AccountUN]: ""Account where assumtions are created"";
@Returns: ""if parent is SOURCE_ACCOUNT then CONTRA_xx.if parent is TOTAL_OTF_PREMISES then ACCOUNT_xx, if parent start with ACCOUNT then CONTRA_xx"";
{
	string functionName = ""BP_GetNextAssumptionElements: "";
	string dimensionName = ""BPDPREMISE"";
	string hierarchyName = ""BPDPREMISE"";
	string cube = ""BPCCONFIG_PREMISES"";
	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	bool needToCreateElement = false;
	string result ="""";


	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		VersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		ParentUN= ""[BPDPREMISE].[ACCOUNT_2].[1]"";
		EntityUN= ""[BPDENTITY].[RU0002].[1]"";
		AccountUN= ""[BPDACCOUNT].[I000000].[1]"";*/

		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName,  false);
		string element = """";
		string counterString = """";
		bool isElementIn = false;
		string stringPartOfElement = """";
		string delimier = """";

		string cycle = ResolveUniqueName(olapconnection, CycleUN);
		string parent = ResolveUniqueName(olapconnection, ParentUN);
		string version = ResolveUniqueName(olapconnection, VersionUN);
		string entity = ResolveUniqueName(olapconnection, EntityUN);
		string account = ResolveUniqueName(olapconnection, AccountUN);

		int counter = 1;
		while(counter <=99)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);

			if(parent == ""SOURCE_ACCOUNT"")
			{
				element = ""CONTRA""+counterString;
			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				element = ""TARGET_ACCOUNT_"" +counterString;
			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				element = ""CONTRA""+ counterString + ""_""+parent;
			}

			isElementIn = OLAPElementListContainsElement(elementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				string created = OLAPCellReadString(olapconnection, cube, NA, cycle,version,entity,account, element);

				if(created =="""")
				{
					break;
				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{
			if(parent == ""SOURCE_ACCOUNT"")
			{
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""S"", 1, false);
				result = element;
				OLAPCellWriteString(olapconnection, cube,""test"", NA, cycle,version,entity,account, element);
				element = element + ""_FACTOR"";
				ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);

			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				element = ""ACCOUNT_"" +counterString;
				result = element;
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);
				string elementTarget = ""TARGET_"" + element;
				string nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""FACTOR_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""PERIOD_SCOPE_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""TARGET_MONTH_"" + element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ElementUn,elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""ACTIVE_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ACTIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""CASH_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ARCHIVE].[1]"",elementTarget, 2,delimier, ""S"", 1, false);
				elementTarget = ""VALID_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_ARCHIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);
				elementTarget = ""ACTIVE_TARGET_""+element;
				nextElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",""[BPDPREMISE].[TOTAL_OTF_PREMISES_TARGET_ACTIVE].[1]"",elementTarget, 2,delimier, ""N"", 1, false);

			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				element = ""CONTRA""+ counterString + ""_""+parent;
				result = ""CONTRA""+ counterString ;
				string ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""S"", 1, false);
				element = ""CONTRA""+ counterString + ""_FACTOR_""+parent;
				ElementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"",ParentUN,element, 2,delimier, ""N"", 1, false);
			}
		}
		else
		{
			if(parent == ""SOURCE_ACCOUNT"")
			{
				result = ""CONTRA""+ counterString ;
			}
			if(parent == ""TOTAL_OTF_PREMISES"")
			{
				result = ""ACCOUNT_"" +counterString;
			}
			if(StringStartsWith(parent, ""ACCOUNT""))
			{
				result = ""CONTRA""+ counterString ;
			}
		}
		return result;
	}


	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		result = """";
		return result;
	}


}"	1	89CBD2BE-1AF4-4165-85A2-D29948DED5FA	Create elements in BPDPREMISE dimension, due to the parent.	1	1	1	1616	NULL	0	45708.67508	0	0
1A42D8DC-4A34-48DC-BEBC-407C1A739404	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextCycle	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""UserUN"" parameter-type=""string"" parameter-description=""User Un what is creating cycle"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextCycle(string server,string UserUN)
@Description: ""Create cycle element for BPDCYCLE dimension or get next free element, and BUDGET_01 element if needed."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[UserUN]: ""User Un what is creating cycle"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextCycle: "";
	string cycleDimensionName = ""BPDCYCLE"";
	string cycleHierarchyName = ""BPDCYCLE"";
	string versionDimensionName = ""BPDVERSION"";
	string versionHierarchyName = ""BPDVERSION"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_CYCLE"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		//UserUN = ""[#_SysUsr].[Admin].[1]: "";

		OLAPElementList CycleElementList = OLAPGetElementList(olapconnection, cycleDimensionName,  true);
		OLAPElementList versionElementList = OLAPGetElementList(olapconnection, versionDimensionName,  true);

		string element = """";
		string counterString = """";
		bool isElementCycleIn = false;
		bool isElementVersionIn = false;


		int counter = 1;
		bool needToCreateElement = false;

		while(counter &lt;=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 3 - numberOfdigits;
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}


			element = ""CYCLE_"" +zerosString+counterString;
			isElementCycleIn = OLAPElementListContainsElement(CycleElementList, element);
			if(!isElementCycleIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Value"");

				if(created !=1)
				{
					string user = OLAPCellReadString(olapconnection, cube, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");
					if(user =="""")
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string CycleElementUn =  BP_CreateGenericElement(server,""[""+cycleDimensionName+""]"",""[""+cycleDimensionName+""].[""+cycleHierarchyName+""]"", """",""CYCLE"", 3,""_"", ""N"", 1, true);
			CycleElementUn = ResolveUniqueName(olapconnection , CycleElementUn);
			element=CycleElementUn;
		}

		isElementVersionIn = OLAPElementListContainsElement(versionElementList, ""BUDGET_01"");
		if(!isElementVersionIn)
		{
			string versionElementUn =  BP_CreateGenericElement(server,""[""+versionDimensionName+""]"",""[""+versionDimensionName+""].[""+versionHierarchyName+""]"", ""[BPDVERSION].[TOTAL].[1]"",""BUDGET"", 2,""_"", ""N"", 1, true);
			bool addParent = OLAPAddParentElement(olapconnection, versionDimensionName, ""BUDGET_01"", ""TOTAL_BUDGET"");


		}

		OLAPCellWriteString(olapconnection, cube, UserUN, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");

		return ""[""+cycleDimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextCycle(string server,string UserUN)
@Description: ""Create cycle element for BPDCYCLE dimension or get next free element, and BUDGET_01 element if needed."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[UserUN]: ""User Un what is creating cycle"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextCycle: "";
	string cycleDimensionName = ""BPDCYCLE"";
	string cycleHierarchyName = ""BPDCYCLE"";
	string versionDimensionName = ""BPDVERSION"";
	string versionHierarchyName = ""BPDVERSION"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_CYCLE"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		//UserUN = ""[#_SysUsr].[Admin].[1]: "";

		OLAPElementList CycleElementList = OLAPGetElementList(olapconnection, cycleDimensionName,  true);
		OLAPElementList versionElementList = OLAPGetElementList(olapconnection, versionDimensionName,  true);

		string element = """";
		string counterString = """";
		bool isElementCycleIn = false;
		bool isElementVersionIn = false;


		int counter = 1;
		bool needToCreateElement = false;

		while(counter <=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 3 - numberOfdigits;
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}


			element = ""CYCLE_"" +zerosString+counterString;
			isElementCycleIn = OLAPElementListContainsElement(CycleElementList, element);
			if(!isElementCycleIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Value"");

				if(created !=1)
				{
					string user = OLAPCellReadString(olapconnection, cube, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");
					if(user =="""")
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string CycleElementUn =  BP_CreateGenericElement(server,""[""+cycleDimensionName+""]"",""[""+cycleDimensionName+""].[""+cycleHierarchyName+""]"", """",""CYCLE"", 3,""_"", ""N"", 1, true);
			CycleElementUn = ResolveUniqueName(olapconnection , CycleElementUn);
			element=CycleElementUn;
		}

		isElementVersionIn = OLAPElementListContainsElement(versionElementList, ""BUDGET_01"");
		if(!isElementVersionIn)
		{
			string versionElementUn =  BP_CreateGenericElement(server,""[""+versionDimensionName+""]"",""[""+versionDimensionName+""].[""+versionHierarchyName+""]"", ""[BPDVERSION].[TOTAL].[1]"",""BUDGET"", 2,""_"", ""N"", 1, true);
			bool addParent = OLAPAddParentElement(olapconnection, versionDimensionName, ""BUDGET_01"", ""TOTAL_BUDGET"");


		}

		OLAPCellWriteString(olapconnection, cube, UserUN, element, NA,""GLOBAL_CYCLE_ACTIVE"", ""Parameter"");

		return ""[""+cycleDimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	392F3170-BC5F-4A49-B2E4-0FED205063AD	Create cycle element for BPDCYCLE dimension or get next free element, and BUDGET_01 element if needed.	1	1	1	1617	NULL	0	45708.67503	0	0
921218E7-946C-488A-B44F-7A8F8E73B3FD	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextLineDetail	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""UN of next free line datail element."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""Configuration set Un, where line detail should be created."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""VersionUN"" parameter-type=""string"" parameter-description=""Version Un, where line detail should be created."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""OrganizationUN"" parameter-type=""string"" parameter-description=""Organization UN, where line detail should be created."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""EntityUN"" parameter-type=""string"" parameter-description=""EntityUN, where line detail should be created."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""AccountUN"" parameter-type=""string"" parameter-description=""AccountUN, where line detail should be created."" parameter-order=""5"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextLineDetail(string server,string CycleUN,string VersionUN,string OrganizationUN,string EntityUN, string AccountUN)
@Description: ""Create line detail element for BPDDETAIL dimension, TOTAL_LINE_DETAIL Hierarchy or get next free element there."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database."";
@Parameter[CycleUN]: ""Configuration set Un, where line detail should be created."";
@Parameter[VersionUN]: ""Version Un, where line detail should be created."";
@Parameter[OrganizationUN]: ""Organization UN, where line detail should be created."";
@Parameter[EntityUN]: ""EntityUN, where line detail should be created."";
@Parameter[AccountUN]: ""AccountUN, where line detail should be created."";
@Returns: ""UN of next free line datail element."";
{
	string functionName = ""BP_GetNextLineDetail: "";
	string detailDimensionName = ""BPDDETAIL"";
	string detailHierarchyName = ""TOTAL_DETAIL_LINE"";
	string NA = ""N.A."";
	string cube = ""ATCDATA_DETAIL"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		VersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		OrganizationUN=""[BPDORGANIZATION].[N.A.].[1]"";
		EntityUN= ""[BPDENTITY].[RU0001].[1]"";
		AccountUN= ""[BPDACCOUNT].[L110510].[1]"";*/
		string cycle = """";
		string version = """";
		string organization = """";
		string entity = """";
		string account = """";
		if(StringContains(CycleUN,""[""))
		{
			cycle = ResolveUniqueName(olapconnection, CycleUN);
		}
		else
		{
			cycle = CycleUN;
		}
		if(StringContains(VersionUN,""[""))
		{
			version = ResolveUniqueName(olapconnection, VersionUN);
		}
		else
		{
			version = VersionUN;
		}
		if(StringContains(OrganizationUN,""[""))
		{
			organization = ResolveUniqueName(olapconnection, OrganizationUN);
		}
		else
		{
			organization = OrganizationUN;
		}
		if(StringContains(EntityUN,""[""))
		{
			entity = ResolveUniqueName(olapconnection, EntityUN);
		}
		else
		{
			entity = EntityUN;
		}
		if(StringContains(AccountUN,""[""))
		{
			account = ResolveUniqueName(olapconnection, AccountUN);
		}
		else
		{
			account = AccountUN;
		}

		OLAPElementList lineLineDetailElementList = OLAPGetElementList(olapconnection, detailDimensionName,detailHierarchyName,  false, true,false);

		string element = """";
		string counterString = """";
		bool isElementLDIn = false;
		int counter = 1;
		bool needToCreateElement = false;

		while(counter &lt;=9999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}

			element = ""DETAIL_LINE_"" +zerosString+counterString;
			isElementLDIn = OLAPElementListContainsElement(lineLineDetailElementList, element);
			if(!isElementLDIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				string created = OLAPCellReadString(olapconnection, cube, cycle, version,organization, entity, NA,""BASE_STEP"",NA,account,""Text Value"",  detailHierarchyName+""\t""+element,""Detail_Line_Name"");
				if(created =="""")
				{
					break;
				}
				else
				{
					double timeset = OLAPCellReadNumber(olapconnection, cube,1.0, cycle, version,organization, entity, NA,""BASE_STEP"",""TOTAL_TIME"",account,""Value"",  detailHierarchyName+""\t""+element,""Detail_Line_Flag"");
					if(timeset == 0)
					{
						break;
					}
				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string LDElementUn =  BP_CreateGenericElement(server,""[""+detailDimensionName+""]"",""[""+detailDimensionName+""].[""+detailHierarchyName+""]"", ""[BPDDETAIL].[TOTAL_DETAIL_LINE].[TOTAL_DETAIL_LINE].[1]"",element, 3,"""", ""N"", 1, false);
			LDElementUn = ResolveUniqueName(olapconnection , LDElementUn);
			element=LDElementUn;
		}

		return ""[""+detailDimensionName+""].[""+detailHierarchyName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextLineDetail(string server,string CycleUN,string VersionUN,string OrganizationUN,string EntityUN, string AccountUN)
@Description: ""Create line detail element for BPDDETAIL dimension, TOTAL_LINE_DETAIL Hierarchy or get next free element there."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database."";
@Parameter[CycleUN]: ""Configuration set Un, where line detail should be created."";
@Parameter[VersionUN]: ""Version Un, where line detail should be created."";
@Parameter[OrganizationUN]: ""Organization UN, where line detail should be created."";
@Parameter[EntityUN]: ""EntityUN, where line detail should be created."";
@Parameter[AccountUN]: ""AccountUN, where line detail should be created."";
@Returns: ""UN of next free line datail element."";
{
	string functionName = ""BP_GetNextLineDetail: "";
	string detailDimensionName = ""BPDDETAIL"";
	string detailHierarchyName = ""TOTAL_DETAIL_LINE"";
	string NA = ""N.A."";
	string cube = ""ATCDATA_DETAIL"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		VersionUN = ""[BPDVERSION].[BUDGET_01].[1]"";
		OrganizationUN=""[BPDORGANIZATION].[N.A.].[1]"";
		EntityUN= ""[BPDENTITY].[RU0001].[1]"";
		AccountUN= ""[BPDACCOUNT].[L110510].[1]"";*/
		string cycle = """";
		string version = """";
		string organization = """";
		string entity = """";
		string account = """";
		if(StringContains(CycleUN,""[""))
		{
			cycle = ResolveUniqueName(olapconnection, CycleUN);
		}
		else
		{
			cycle = CycleUN;
		}
		if(StringContains(VersionUN,""[""))
		{
			version = ResolveUniqueName(olapconnection, VersionUN);
		}
		else
		{
			version = VersionUN;
		}
		if(StringContains(OrganizationUN,""[""))
		{
			organization = ResolveUniqueName(olapconnection, OrganizationUN);
		}
		else
		{
			organization = OrganizationUN;
		}
		if(StringContains(EntityUN,""[""))
		{
			entity = ResolveUniqueName(olapconnection, EntityUN);
		}
		else
		{
			entity = EntityUN;
		}
		if(StringContains(AccountUN,""[""))
		{
			account = ResolveUniqueName(olapconnection, AccountUN);
		}
		else
		{
			account = AccountUN;
		}

		OLAPElementList lineLineDetailElementList = OLAPGetElementList(olapconnection, detailDimensionName,detailHierarchyName,  false, true,false);

		string element = """";
		string counterString = """";
		bool isElementLDIn = false;
		int counter = 1;
		bool needToCreateElement = false;

		while(counter <=9999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 4 - numberOfdigits;
			if(zeros ==3)
			{
				zerosString = ""000"";
			}
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}

			element = ""DETAIL_LINE_"" +zerosString+counterString;
			isElementLDIn = OLAPElementListContainsElement(lineLineDetailElementList, element);
			if(!isElementLDIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				string created = OLAPCellReadString(olapconnection, cube, cycle, version,organization, entity, NA,""BASE_STEP"",NA,account,""Text Value"",  detailHierarchyName+""\t""+element,""Detail_Line_Name"");
				if(created =="""")
				{
					break;
				}
				else
				{
					double timeset = OLAPCellReadNumber(olapconnection, cube,1.0, cycle, version,organization, entity, NA,""BASE_STEP"",""TOTAL_TIME"",account,""Value"",  detailHierarchyName+""\t""+element,""Detail_Line_Flag"");
					if(timeset == 0)
					{
						break;
					}
				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string LDElementUn =  BP_CreateGenericElement(server,""[""+detailDimensionName+""]"",""[""+detailDimensionName+""].[""+detailHierarchyName+""]"", ""[BPDDETAIL].[TOTAL_DETAIL_LINE].[TOTAL_DETAIL_LINE].[1]"",element, 3,"""", ""N"", 1, false);
			LDElementUn = ResolveUniqueName(olapconnection , LDElementUn);
			element=LDElementUn;
		}

		return ""[""+detailDimensionName+""].[""+detailHierarchyName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	8E64CE63-6789-40EB-AD10-F46D525255B8	Create line detail element for BPDDETAIL dimension, TOTAL_LINE_DETAIL Hierarchy or get next free element there.	1	1	1	1618	NULL	0	45708.67505	0	0
EED4D06D-74EE-490E-B621-FDD36C8C7DFC	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextPhasingMethod	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ParentUN"" parameter-type=""string"" parameter-description=""Parent element, below element should be created"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""UserUN"" parameter-type=""string"" parameter-description=""User Un what is creating new method"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextPhasingMethod(string server,string ParentUN,string UserUN)
@Description: ""Create new element into BPDCONFIG_PHASING dimension or get next free element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[ParentUN]: ""Parent element, below element should be created"";
@Parameter[UserUN]: ""User Un what is creating new method"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextPhasingMethod: "";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_PHASING"";
	string phasingDimension = ""BPDCONFIG_PHASING"";
	string phasingHierarchy = ""BPDCONFIG_PHASING"";

	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*ParentUN = ""[BPDCONFIG_PHASING].[USERDEFINED].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]"";*/
		string user = ResolveUniqueName(olapconnection, UserUN);
		OLAPElementList phasingElementList = OLAPGetElementList(olapconnection, phasingDimension,  true);
		string contraParentElement = """";
		string element = """";
		string counterString = """";
		bool isElementPhasingIn = false;
		int counter = 1;
		if(ParentUN == ""[BPDCONFIG_PHASING].[PREDEFINED].[1]"")
		{
			counter = 1;
			contraParentElement =  ""USERDEFINED"" ;

		}
		if(ParentUN == ""[BPDCONFIG_PHASING].[USERDEFINED].[1]"")
		{
			counter = 11;
			contraParentElement = ""PREDEFINED"";

		}
		OLAPElementList userDefinedElementList = OLAPGetChildElementList(olapconnection, phasingDimension, contraParentElement, true);

		int numberOfdigits =0;
		bool needToCreateElement = false;

		while(counter &lt;=99)
		{
			counterString =ToString(counter);
			numberOfdigits = StringLength(counterString);
			element = ""ALLOCATION""+ "" "" +counterString;

			isElementPhasingIn = OLAPElementListContainsElement(phasingElementList, element);
			if(!isElementPhasingIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, user, ""GLOBAL_Y"",element, ""Value"");

				if(created !=1)
				{
					if(!OLAPElementListContainsElement(userDefinedElementList, element))
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string phasingElementUn =  BP_CreateGenericElement(server,""[""+phasingDimension+""]"",""[""+phasingDimension+""].[""+phasingHierarchy+""]"", ParentUN,element, numberOfdigits,"""", ""N"", 1, false);
			phasingElementUn = ResolveUniqueName(olapconnection , phasingElementUn);
			element=phasingElementUn;
		}

		return ""[""+phasingDimension+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextPhasingMethod(string server,string ParentUN,string UserUN)
@Description: ""Create new element into BPDCONFIG_PHASING dimension or get next free element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[ParentUN]: ""Parent element, below element should be created"";
@Parameter[UserUN]: ""User Un what is creating new method"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextPhasingMethod: "";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_PHASING"";
	string phasingDimension = ""BPDCONFIG_PHASING"";
	string phasingHierarchy = ""BPDCONFIG_PHASING"";

	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*ParentUN = ""[BPDCONFIG_PHASING].[USERDEFINED].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]"";*/
		string user = ResolveUniqueName(olapconnection, UserUN);
		OLAPElementList phasingElementList = OLAPGetElementList(olapconnection, phasingDimension,  true);
		string contraParentElement = """";
		string element = """";
		string counterString = """";
		bool isElementPhasingIn = false;
		int counter = 1;
		if(ParentUN == ""[BPDCONFIG_PHASING].[PREDEFINED].[1]"")
		{
			counter = 1;
			contraParentElement =  ""USERDEFINED"" ;

		}
		if(ParentUN == ""[BPDCONFIG_PHASING].[USERDEFINED].[1]"")
		{
			counter = 11;
			contraParentElement = ""PREDEFINED"";

		}
		OLAPElementList userDefinedElementList = OLAPGetChildElementList(olapconnection, phasingDimension, contraParentElement, true);

		int numberOfdigits =0;
		bool needToCreateElement = false;

		while(counter <=99)
		{
			counterString =ToString(counter);
			numberOfdigits = StringLength(counterString);
			element = ""ALLOCATION""+ "" "" +counterString;

			isElementPhasingIn = OLAPElementListContainsElement(phasingElementList, element);
			if(!isElementPhasingIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, user, ""GLOBAL_Y"",element, ""Value"");

				if(created !=1)
				{
					if(!OLAPElementListContainsElement(userDefinedElementList, element))
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string phasingElementUn =  BP_CreateGenericElement(server,""[""+phasingDimension+""]"",""[""+phasingDimension+""].[""+phasingHierarchy+""]"", ParentUN,element, numberOfdigits,"""", ""N"", 1, false);
			phasingElementUn = ResolveUniqueName(olapconnection , phasingElementUn);
			element=phasingElementUn;
		}

		return ""[""+phasingDimension+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	2D4A774D-ACBA-4DF4-AA5D-02B83E753972	Create new element into BPDCONFIG_PHASING dimension or get next free element.	1	1	1	1619	NULL	0	45708.67504	0	0
0C57BEAF-F670-4275-8881-DC73BAB88446	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextPNO	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""Dimension name where element have to added. in format [BPDVERSION]"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""UserUN"" parameter-type=""string"" parameter-description=""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextPNO(string server,string CycleUN,string UserUN)
@Description: ""Create element for specified dimension, hierarchy and parent element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""Dimension name where element have to added. in format [BPDVERSION]"";
@Parameter[UserUN]: ""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""WF_GetNextPNO: "";
	string dimensionName = ""BPDNO"";
	string hierarchyName = ""BPDNO"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_MAIN"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]: "";*/

		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName, hierarchyName, true, true, true);
		string element = """";
		string counterString = """";
		bool isElementIn = false;

		string cycle = ResolveUniqueName(olapconnection , CycleUN);

		int counter = 1;
		bool needToCreateElement = false;

		while(counter &lt;=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 3 - numberOfdigits;
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			

			element = ""PNO_"" +zerosString+counterString;
			isElementIn = OLAPElementListContainsElement(elementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double Created = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_CREATED"", ""Value"");
				if(Created != 1)
				{
					double EditedV = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Value"");
					string EditedU = OLAPCellReadString(olapconnection, cube, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Text Value"");
					if( EditedV != 1 or (EditedV == 1 and EditedU == """") or (EditedV == 1 and EditedU == UserUN))
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{
			string elementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"", ""[BPDNO].[TOTAL].[1]"",""PNO"", 3,""_"", ""N"", 1, true);
			elementUn = ResolveUniqueName(olapconnection , elementUn);
			element=elementUn;
		}


		OLAPCellWriteNumber(olapconnection, cube, 1, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Value"");
		OLAPCellWriteString(olapconnection, cube, UserUN, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Text Value"");

		return ""[""+dimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextPNO(string server,string CycleUN,string UserUN)
@Description: ""Create element for specified dimension, hierarchy and parent element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""Dimension name where element have to added. in format [BPDVERSION]"";
@Parameter[UserUN]: ""Hierarchy name where element have to added, in format [BPDVERSION].[BPDVERSION], if default hierarchy, name is same as dimension name"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""WF_GetNextPNO: "";
	string dimensionName = ""BPDNO"";
	string hierarchyName = ""BPDNO"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_MAIN"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]: "";*/

		OLAPElementList elementList = OLAPGetElementList(olapconnection, dimensionName, hierarchyName, true, true, true);
		string element = """";
		string counterString = """";
		bool isElementIn = false;

		string cycle = ResolveUniqueName(olapconnection , CycleUN);

		int counter = 1;
		bool needToCreateElement = false;

		while(counter <=999)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 3 - numberOfdigits;
			if(zeros ==2)
			{
				zerosString = ""00"";
			}

			if(zeros ==1)
			{
				zerosString = ""0"";
			}
			

			element = ""PNO_"" +zerosString+counterString;
			isElementIn = OLAPElementListContainsElement(elementList, element);
			if(!isElementIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double Created = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_CREATED"", ""Value"");
				if(Created != 1)
				{
					double EditedV = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Value"");
					string EditedU = OLAPCellReadString(olapconnection, cube, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Text Value"");
					if( EditedV != 1 or (EditedV == 1 and EditedU == """") or (EditedV == 1 and EditedU == UserUN))
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{
			string elementUn =  BP_CreateGenericElement(server,""[""+dimensionName+""]"",""[""+dimensionName+""].[""+hierarchyName+""]"", ""[BPDNO].[TOTAL].[1]"",""PNO"", 3,""_"", ""N"", 1, true);
			elementUn = ResolveUniqueName(olapconnection , elementUn);
			element=elementUn;
		}


		OLAPCellWriteNumber(olapconnection, cube, 1, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Value"");
		OLAPCellWriteString(olapconnection, cube, UserUN, cycle, NA, NA, NA, NA, element, ""SUBPLAN_FINANCE_EDIT"", ""Text Value"");

		return ""[""+dimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	CDCFBFE1-7F96-4588-AA7A-997352A22172	Create element for specified dimension, hierarchy and parent element.	1	1	1	1620	NULL	0	45708.67504	0	0
5112D934-873C-4443-AC8F-F26088745C64	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetNextVersion	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""configuration set Un where is created version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""ParentUN"" parameter-type=""string"" parameter-description=""Parent element, below element should be created"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""UserUN"" parameter-type=""string"" parameter-description=""User Un what is creating version"" parameter-order=""3"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextVersion(string server,string CycleUN,string ParentUN, string UserUN)
@Description: ""Create version element for BPDVERSION dimension or get next free element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""configuration set Un where is created version"";
@Parameter[ParentUN]: ""Parent element, below element should be created"";
@Parameter[UserUN]: ""User Un what is creating version"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextVersion: "";
	string versionDimensionName = ""BPDVERSION"";
	string versionHierarchyName = ""BPDVERSION"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_CYCLE"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		ParentUN = ""[BPDVERSION].[TOTAL_FORECAST_ROLLING].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]"";*/

		string cycle = ResolveUniqueName(olapconnection, CycleUN);
		string parent = ResolveUniqueName(olapconnection, ParentUN);
		string version = ResolveUniqueName(olapconnection, UserUN);


		OLAPElementList versionElementList = OLAPGetElementList(olapconnection, versionDimensionName,  true);

		string element = """";
		string stringPartOfElement = """";
		string counterString = """";
		string delimier = """";
		bool isElementCycleIn = false;
		bool isElementVersionIn = false;
		if(StringContains(parent, ""BUDGET""))
		{
			stringPartOfElement =""BUDGET"";
			delimier=""_"";
		}
		if(StringContains(parent, ""FISCAL""))
		{
			stringPartOfElement =""FC_FISCAL"";
		}
		if(StringContains(parent, ""ROLLING""))
		{
			stringPartOfElement =""FC_ROLLING"";
		}
		if(StringContains(parent, ""PROJECTION""))
		{
			stringPartOfElement =""PROJECTION"";
			delimier=""_"";
		}

		int counter = 1;
		bool needToCreateElement = false;

		while(counter &lt;=99)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 2 - numberOfdigits;
			if(zeros ==1)
			{
				zerosString = ""0"";
			}

			element = stringPartOfElement+ delimier +zerosString+counterString;

			isElementVersionIn = OLAPElementListContainsElement(versionElementList, element);
			if(!isElementVersionIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");

				if(created !=1)
				{
					string user = OLAPCellReadString(olapconnection, cube, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");
					if(user =="""")
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string ElementUn =  BP_CreateGenericElement(server,""[""+versionDimensionName+""]"",""[""+versionDimensionName+""].[""+versionHierarchyName+""]"",""[BPDVERSION].[TOTAL].[1]"",stringPartOfElement, 2,delimier, ""N"", 1, true);
			ElementUn = ResolveUniqueName(olapconnection , ElementUn);
			bool addParent = OLAPAddParentElement(olapconnection, versionDimensionName, ElementUn, parent);
			element=ElementUn;
		}


		OLAPCellWriteString(olapconnection, cube, UserUN, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");

		return ""[""+versionDimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string BP_GetNextVersion(string server,string CycleUN,string ParentUN, string UserUN)
@Description: ""Create version element for BPDVERSION dimension or get next free element."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[CycleUN]: ""configuration set Un where is created version"";
@Parameter[ParentUN]: ""Parent element, below element should be created"";
@Parameter[UserUN]: ""User Un what is creating version"";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""BP_GetNextVersion: "";
	string versionDimensionName = ""BPDVERSION"";
	string versionHierarchyName = ""BPDVERSION"";
	string NA = ""N.A."";
	string cube = ""BPCCONFIG_CYCLE"";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		ParentUN = ""[BPDVERSION].[TOTAL_FORECAST_ROLLING].[1]"";
		UserUN = ""[#_SysUsr].[Admin].[1]"";*/

		string cycle = ResolveUniqueName(olapconnection, CycleUN);
		string parent = ResolveUniqueName(olapconnection, ParentUN);
		string version = ResolveUniqueName(olapconnection, UserUN);


		OLAPElementList versionElementList = OLAPGetElementList(olapconnection, versionDimensionName,  true);

		string element = """";
		string stringPartOfElement = """";
		string counterString = """";
		string delimier = """";
		bool isElementCycleIn = false;
		bool isElementVersionIn = false;
		if(StringContains(parent, ""BUDGET""))
		{
			stringPartOfElement =""BUDGET"";
			delimier=""_"";
		}
		if(StringContains(parent, ""FISCAL""))
		{
			stringPartOfElement =""FC_FISCAL"";
		}
		if(StringContains(parent, ""ROLLING""))
		{
			stringPartOfElement =""FC_ROLLING"";
		}
		if(StringContains(parent, ""PROJECTION""))
		{
			stringPartOfElement =""PROJECTION"";
			delimier=""_"";
		}

		int counter = 1;
		bool needToCreateElement = false;

		while(counter <=99)
		{
			counterString =ToString(counter);
			int numberOfdigits = StringLength(counterString);
			string zerosString = """";
			int zeros = 2 - numberOfdigits;
			if(zeros ==1)
			{
				zerosString = ""0"";
			}

			element = stringPartOfElement+ delimier +zerosString+counterString;

			isElementVersionIn = OLAPElementListContainsElement(versionElementList, element);
			if(!isElementVersionIn)
			{
				needToCreateElement = true;
				break;
			}
			else
			{
				double created = OLAPCellReadNumber(olapconnection, cube, 1.0, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Value"");

				if(created !=1)
				{
					string user = OLAPCellReadString(olapconnection, cube, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");
					if(user =="""")
					{
						break;
					}

				}
			}
			counter = counter + 1;
		}

		if(needToCreateElement)
		{

			string ElementUn =  BP_CreateGenericElement(server,""[""+versionDimensionName+""]"",""[""+versionDimensionName+""].[""+versionHierarchyName+""]"",""[BPDVERSION].[TOTAL].[1]"",stringPartOfElement, 2,delimier, ""N"", 1, true);
			ElementUn = ResolveUniqueName(olapconnection , ElementUn);
			bool addParent = OLAPAddParentElement(olapconnection, versionDimensionName, ElementUn, parent);
			element=ElementUn;
		}


		OLAPCellWriteString(olapconnection, cube, UserUN, cycle, element, ""GLOBAL_CYCLE_VERSION_CREATED"", ""Parameter"");

		return ""[""+versionDimensionName+""].[""+element+""].[1]"";

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}


}"	1	311F4831-A82D-457A-913D-80C9E3C8BC49	Create version element for BPDVERSION dimension or get next free element.	1	1	1	1621	NULL	0	45708.67506	0	0
C94F7341-1301-4978-8555-429A2D82D6CA	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetPlanningCycleEntities	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""List of entity identifiers configured for the provided configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The identifier of the configuration set to process"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetPlanningCycleEntities(
	OLAPConnection connection,
	string cycle
)
@Description: ""This process returns a list of the entities configured for the specified configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""List of entity identifiers configured for the provided configuration set"";
@Parameter[connection]: ""Connection to the OLAP database"";
@Parameter[cycle]: ""The identifier of the configuration set to process"";
{
	string functionName = ""BP_GetPlanningCycleEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	StringList entities = CreateStringList();

	try {
		// Validate we received values for each parameter
		if (cycle == """") {
			LogWarning(functionName + "" No value was provided for the configuration set parameter"");
			return entities;
		}

		// Define constants
		string cube = ""BPCCONFIG_ENTITY"";
		string CycleDimension = ""BPDCYCLE"";
		string EntityDimension = ""BPDENTITY"";
		string IntercompanyDimension = ""BPDINTERCOMPANY"";
		string OrganizationDimension = ""BPDORGANIZATION"";
		string ParameterDimension = ""BPDPARAMETER"";
		string UnassignedElement = ""N.A."";
		string CompanyActiveParameter = ""GLOBAL_ENTITY_ACTIVE"";

		// Retrieve configured entities for the specified Planning Cycle
		OLAPDataArea entityData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             cycle,
		                                             OlapDataAreaBCells,    // BPDVERSION
		                                             OlapDataAreaBCells,    // BPDENTITY
		                                             UnassignedElement,     // BPDINTERCOMPANY
		                                             UnassignedElement,     // BPDORGANIZATION,
		                                             CompanyActiveParameter // BPDPARAMETER
		                                            );

		// Each cell that has a value of 1 represents a configured Entity
		foreach (OLAPCell cell in entityData) {
			double value = cell;

			if (value == 1.0) {
				Append(entities, OLAPCellGetElement(cell, EntityDimension));
			}
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" returning "" + Count(entities) + "" entities"");
		}

		return entities;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return entities;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetPlanningCycleEntities(
	OLAPConnection connection,
	string cycle
)
@Description: ""This process returns a list of the entities configured for the specified configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""List of entity identifiers configured for the provided configuration set"";
@Parameter[connection]: ""Connection to the OLAP database"";
@Parameter[cycle]: ""The identifier of the configuration set to process"";
{
	string functionName = ""BP_GetPlanningCycleEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	StringList entities = CreateStringList();

	try {
		// Validate we received values for each parameter
		if (cycle == """") {
			LogWarning(functionName + "" No value was provided for the configuration set parameter"");
			return entities;
		}

		// Define constants
		string cube = ""BPCCONFIG_ENTITY"";
		string CycleDimension = ""BPDCYCLE"";
		string EntityDimension = ""BPDENTITY"";
		string IntercompanyDimension = ""BPDINTERCOMPANY"";
		string OrganizationDimension = ""BPDORGANIZATION"";
		string ParameterDimension = ""BPDPARAMETER"";
		string UnassignedElement = ""N.A."";
		string CompanyActiveParameter = ""GLOBAL_ENTITY_ACTIVE"";

		// Retrieve configured entities for the specified Planning Cycle
		OLAPDataArea entityData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             cycle,
		                                             OlapDataAreaBCells,    // BPDVERSION
		                                             OlapDataAreaBCells,    // BPDENTITY
		                                             UnassignedElement,     // BPDINTERCOMPANY
		                                             UnassignedElement,     // BPDORGANIZATION,
		                                             CompanyActiveParameter // BPDPARAMETER
		                                            );

		// Each cell that has a value of 1 represents a configured Entity
		foreach (OLAPCell cell in entityData) {
			double value = cell;

			if (value == 1.0) {
				Append(entities, OLAPCellGetElement(cell, EntityDimension));
			}
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" returning "" + Count(entities) + "" entities"");
		}

		return entities;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return entities;
}"	1	BC0AB59D-FDED-4786-A0F0-5B68E25CA609	This process returns a list of the entities configured for the specified configuration set.	1	1	1	1622	NULL	0	45708.67503	0	0
667E3185-30CC-470C-9B5D-A673264A7E99	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetPlanningCycleEntityOrgs	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringList"" return-value-description=""List of organization identifiers configured for the provided Entity and configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""Connection to the OLAP database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The identifier of the configuration set to process"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The identifier of the Entity to process"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""The identifier of the Version to process"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetPlanningCycleEntityOrgs(
	OLAPConnection connection,
	string cycle,
	string entity,
	string version
)
@Description: ""This process returns a list of the organizations configured for the specified Entity and configuration set"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""List of organization identifiers configured for the provided Entity and configuration set"";
@Parameter[connection]: ""Connection to the OLAP database"";
@Parameter[cycle]: ""The identifier of the configuration set to process"";
@Parameter[entity]: ""The identifier of the Entity to process"";
@Parameter[version]: ""The identifier of the Version to process"";
{
	string functionName = ""BP_GetPlanningCycleEntityOrgs:"";
	string errorMessage = """";
	int errorCode = 0;
	StringList orgs = CreateStringList();

	try {
		// Validate we received values for each parameter
		if (cycle == """") {
			LogWarning(functionName + "" No value was provided for the configuration set parameter"");
			return orgs;
		}

		if (entity == """") {
			LogWarning(functionName + "" No value was provided for the entity parameter"");
			return orgs;
		}
		if (version == """") {
			LogWarning(functionName + "" No value was provided for the version parameter"");
			return orgs;
		}

		// Define constants
		string cube = ""BPCCONFIG_ENTITY"";
		string CycleDimension = ""BPDCYCLE"";
		string EntityDimension = ""BPDENTITY"";
		string IntercompanyDimension = ""BPDINTERCOMPANY"";
		string OrganizationDimension = ""BPDORGANIZATION"";
		string ParameterDimension = ""BPDPARAMETER"";
		string UnassignedElement = ""N.A."";
		string CompanyActiveParameter = ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"";

		// Retrieve configured organizations for the specified Entity and Planning Cycle
		OLAPDataArea entityData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             cycle,
		                                             version,
		                                             entity,
		                                             UnassignedElement,     // BPDINTERCOMPANY
		                                             OlapDataAreaBCells,    // BPDORGANIZATION,
		                                             CompanyActiveParameter // BPDPARAMETER
		                                            );

		// Each cell that has a value of 1 represents a configured Organization for the entity
		foreach (OLAPCell cell in entityData) {
			double value = cell;

			if (value == 1.0) {
				Append(orgs, OLAPCellGetElement(cell, OrganizationDimension));
			}
		}

		LogDebug(functionName + "" returning "" + Count(orgs) + "" organizations"");
		return orgs;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return orgs;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringList BP_GetPlanningCycleEntityOrgs(
	OLAPConnection connection,
	string cycle,
	string entity,
	string version
)
@Description: ""This process returns a list of the organizations configured for the specified Entity and configuration set"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""List of organization identifiers configured for the provided Entity and configuration set"";
@Parameter[connection]: ""Connection to the OLAP database"";
@Parameter[cycle]: ""The identifier of the configuration set to process"";
@Parameter[entity]: ""The identifier of the Entity to process"";
@Parameter[version]: ""The identifier of the Version to process"";
{
	string functionName = ""BP_GetPlanningCycleEntityOrgs:"";
	string errorMessage = """";
	int errorCode = 0;
	StringList orgs = CreateStringList();

	try {
		// Validate we received values for each parameter
		if (cycle == """") {
			LogWarning(functionName + "" No value was provided for the configuration set parameter"");
			return orgs;
		}

		if (entity == """") {
			LogWarning(functionName + "" No value was provided for the entity parameter"");
			return orgs;
		}
		if (version == """") {
			LogWarning(functionName + "" No value was provided for the version parameter"");
			return orgs;
		}

		// Define constants
		string cube = ""BPCCONFIG_ENTITY"";
		string CycleDimension = ""BPDCYCLE"";
		string EntityDimension = ""BPDENTITY"";
		string IntercompanyDimension = ""BPDINTERCOMPANY"";
		string OrganizationDimension = ""BPDORGANIZATION"";
		string ParameterDimension = ""BPDPARAMETER"";
		string UnassignedElement = ""N.A."";
		string CompanyActiveParameter = ""GLOBAL_ENTITY_ACTIVE_ORGANIZATION"";

		// Retrieve configured organizations for the specified Entity and Planning Cycle
		OLAPDataArea entityData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             cycle,
		                                             version,
		                                             entity,
		                                             UnassignedElement,     // BPDINTERCOMPANY
		                                             OlapDataAreaBCells,    // BPDORGANIZATION,
		                                             CompanyActiveParameter // BPDPARAMETER
		                                            );

		// Each cell that has a value of 1 represents a configured Organization for the entity
		foreach (OLAPCell cell in entityData) {
			double value = cell;

			if (value == 1.0) {
				Append(orgs, OLAPCellGetElement(cell, OrganizationDimension));
			}
		}

		LogDebug(functionName + "" returning "" + Count(orgs) + "" organizations"");
		return orgs;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return orgs;
}"	1	FFF55FF5-1422-4F26-8C64-E0BABEE8D818	This process returns a list of the organizations configured for the specified Entity and configuration set	1	1	1	1623	NULL	0	45708.67508	0	0
0907130A-FF4E-4F06-A7AB-DB4ABF22F2B5	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetPlanningCycleYears	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""An OLAPElementList containing elements for each year configured for the provided configuration set"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use for access"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""The configuration set for which to retrieve the configured years"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList BP_GetPlanningCycleYears(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to retrieve the list of years configured for the provided configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""An OLAPElementList containing elements for each year configured for the provided configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetPlanningCycleYears:"";
	string errorMessage = """";
	int errorCode = 0;
	OLAPElementList years = CreateOLAPElementList();
	string configCube = ""BPCCONFIG_CYCLE"";
	string timeDimension = ""BPDTIME"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			string yearUN = OLAPCellReadString(connection, configCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
			string year = ResolveUniqueName(connection, yearUN);
			int numberOfYears = ToInt(OLAPCellReadNumber(connection, configCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));

			if (CV(""WBDebugLogging"") == ""1"") {
				LogDebug(functionName + "" starting year='"" + year + ""', numberOfYears="" + numberOfYears);
			}

			if (year != """") {
				int y = 0;
				while (y &lt; numberOfYears) {
					OLAPElement yearElement = OLAPGetDimensionElement(connection, timeDimension, year);
					OLAPElementListAddElement(years, yearElement);
					year = OLAPGetStringAttribute(connection, timeDimension, yearElement, ""NEXT_YEAR"");
					y = y + 1;
				}
			}
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" returning "" + Count(years) + "" elements"");
		}

		return years;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return years;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList BP_GetPlanningCycleYears(
	OLAPConnection connection,
	string cycle
)
@Description: ""This function is used to retrieve the list of years configured for the provided configuration set."";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""An OLAPElementList containing elements for each year configured for the provided configuration set"";
@Parameter[connection]: ""OLAP connection to use for access"";
@Parameter[cycle]: ""The configuration set for which to retrieve the configured years"";
{
	string functionName = ""BP_GetPlanningCycleYears:"";
	string errorMessage = """";
	int errorCode = 0;
	OLAPElementList years = CreateOLAPElementList();
	string configCube = ""BPCCONFIG_CYCLE"";
	string timeDimension = ""BPDTIME"";

	try {
		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" configuration set='"" + cycle + ""'"");
		}

		if (cycle != """") {
			string yearUN = OLAPCellReadString(connection, configCube, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_START"", ""Text Value"");
			string year = ResolveUniqueName(connection, yearUN);
			int numberOfYears = ToInt(OLAPCellReadNumber(connection, configCube, 1, cycle,""N.A."", ""GLOBAL_CYCLE_YEAR_NUMBER"", ""Value""));

			if (CV(""WBDebugLogging"") == ""1"") {
				LogDebug(functionName + "" starting year='"" + year + ""', numberOfYears="" + numberOfYears);
			}

			if (year != """") {
				int y = 0;
				while (y < numberOfYears) {
					OLAPElement yearElement = OLAPGetDimensionElement(connection, timeDimension, year);
					OLAPElementListAddElement(years, yearElement);
					year = OLAPGetStringAttribute(connection, timeDimension, yearElement, ""NEXT_YEAR"");
					y = y + 1;
				}
			}
		}

		if (CV(""WBDebugLogging"") == ""1"") {
			LogDebug(functionName + "" returning "" + Count(years) + "" elements"");
		}

		return years;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return years;
}"	1	A9A05A2F-C649-47C8-AC07-789CA74AAEB1	This function is used to retrieve the list of years configured for the provided configuration set.	1	1	1	1624	NULL	0	45708.67509	0	0
F9C31394-98C9-46BE-B5B5-97CF257B9BA5	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetResolvedUniqueName	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Returns the resolved unique name."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""An already established OLAP connection."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""uniqueName"" parameter-type=""string"" parameter-description=""The unique name to resolve."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetResolvedUniqueName(OLAPConnection connection, string uniqueName)
@Description: ""Attempts to resolve the provided unique name. If it's in XMLA form, it is resolved to the native form. Otherwise, it is returned. This does not check to see if the unique name is valid."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]:""An already established OLAP connection."";
@Parameter[uniqueName]:""The unique name to resolve."";
@Returns: ""Returns the resolved unique name."";
{
	if (uniqueName == """") {
		return uniqueName;
	}

	string attemptedResolution = ResolveUniqueName(connection, uniqueName);
	if(attemptedResolution == """") {

		return uniqueName;
	}

	return attemptedResolution;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetResolvedUniqueName(OLAPConnection connection, string uniqueName)
@Description: ""Attempts to resolve the provided unique name. If it's in XMLA form, it is resolved to the native form. Otherwise, it is returned. This does not check to see if the unique name is valid."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[connection]:""An already established OLAP connection."";
@Parameter[uniqueName]:""The unique name to resolve."";
@Returns: ""Returns the resolved unique name."";
{
	if (uniqueName == """") {
		return uniqueName;
	}

	string attemptedResolution = ResolveUniqueName(connection, uniqueName);
	if(attemptedResolution == """") {

		return uniqueName;
	}

	return attemptedResolution;
}"	1	99FC1B87-3AF9-4E28-9FF3-DC5ECD706EC7	Attempts to resolve the provided unique name. If it's in XMLA form, it is resolved to the native form. Otherwise, it is returned. This does not check to see if the unique name is valid.	1	1	1	1625	NULL	0	45708.67503	0	0
2DDBCAD0-843B-4012-8A41-991DB3F99CE7	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetSourceVersions	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated string of source entities"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The configuration set element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""versionsUN"" parameter-type=""string"" parameter-description=""Comma separated list of versions be checked."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetSourceVersions(string Database, string CycleUN, string versionsUN)
@Description: ""Find for referenced version version, from where it is refenced, if it is base version return this one."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[CycleUN]: ""The configuration set element to be used."";
@Parameter[versionsUN]: ""Comma separated list of versions be checked."";
@Returns: ""Comma separated string of source entities"";
{

	string functionName = ""BP_GetSourceVersions: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		versionsUN = ""[BPDVERSION].[BUDGET_02].[1]"";//""[BPDVERSION].[BUDGET_01].[1],[BPDVERSION].[BUDGET_02].[1],[BPDVERSION].[BUDGET_03].[1],[BPDVERSION].[FC_FISCAL01].[1],[BPDVERSION].[FC_FISCAL02].[1],[BPDVERSION].[FC_FISCAL03].[1],[BPDVERSION].[FC_FISCAL04].[1],[BPDVERSION].[FC_FISCAL05].[1],[BPDVERSION].[FC_FISCAL06].[1],[BPDVERSION].[FC_FISCAL07].[1],[BPDVERSION].[FC_FISCAL08].[1],[BPDVERSION].[FC_FISCAL09].[1]"";
		 */

		string Cycle = ResolveUniqueName(connection, CycleUN);
		string Cube = ""BPCCONFIG_CYCLE"";
		
		//procedure to fill array with entities from string paramater
		StringArray versions = CreateStringArray();
		if(!StringContains(versionsUN, "",""))
		{
			versionsUN = ResolveUniqueName(connection, versionsUN);
			Append(versions, versionsUN);
		}

		while(StringContains(versionsUN, "",""))
		{
			int numberOfLetters = StringFind(versionsUN,"","",1);

			string versionHelp = StringSubstring(versionsUN, 0, numberOfLetters);
			versionHelp = ResolveUniqueName(connection, versionHelp);
			AppendDistinct(versions, versionHelp);

			versionsUN = StringSubstring(versionsUN, numberOfLetters + 1, StringLength(versionsUN)-(numberOfLetters + 1));
			numberOfLetters = StringFind(versionsUN,"","",1);
			if(numberOfLetters&lt;0)
			{
				numberOfLetters = StringLength(versionsUN);
			}
			versionHelp = StringSubstring(versionsUN, 0, numberOfLetters);
			versionHelp = ResolveUniqueName(connection, versionHelp);
			AppendDistinct(versions, versionHelp);
		}


		StringArray results = CreateStringArray();

		foreach(string version in versions)
		{
			double refVersionNum = OLAPCellReadNumber(connection, Cube,1.0, Cycle,version, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
			
			if(refVersionNum == 1)
			{
				string refVersion = OLAPCellReadString(connection, Cube, Cycle,version, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
				AppendDistinct(results, refVersion);
			}
			if(refVersionNum != 1)
			{
				string ver = ""[BPDVERSION].[""+version+""].[1]"";
				AppendDistinct(results, ver);
			}
		}

		int i = 0;
		string result = """";

		while(i &lt;= Count(results)-1)
		{
			string versionInResult = GetElementByIndex(results, i);
			result = result + versionInResult +  "","";
			i = i + 1;
		}
		int lenght = StringLength(result);
		result = StringSubstring(result, 0, lenght - 1);



		return result;

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
	
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetSourceVersions(string Database, string CycleUN, string versionsUN)
@Description: ""Find for referenced version version, from where it is refenced, if it is base version return this one."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[CycleUN]: ""The configuration set element to be used."";
@Parameter[versionsUN]: ""Comma separated list of versions be checked."";
@Returns: ""Comma separated string of source entities"";
{

	string functionName = ""BP_GetSourceVersions: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);
		/*CycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		versionsUN = ""[BPDVERSION].[BUDGET_02].[1]"";//""[BPDVERSION].[BUDGET_01].[1],[BPDVERSION].[BUDGET_02].[1],[BPDVERSION].[BUDGET_03].[1],[BPDVERSION].[FC_FISCAL01].[1],[BPDVERSION].[FC_FISCAL02].[1],[BPDVERSION].[FC_FISCAL03].[1],[BPDVERSION].[FC_FISCAL04].[1],[BPDVERSION].[FC_FISCAL05].[1],[BPDVERSION].[FC_FISCAL06].[1],[BPDVERSION].[FC_FISCAL07].[1],[BPDVERSION].[FC_FISCAL08].[1],[BPDVERSION].[FC_FISCAL09].[1]"";
		 */

		string Cycle = ResolveUniqueName(connection, CycleUN);
		string Cube = ""BPCCONFIG_CYCLE"";
		
		//procedure to fill array with entities from string paramater
		StringArray versions = CreateStringArray();
		if(!StringContains(versionsUN, "",""))
		{
			versionsUN = ResolveUniqueName(connection, versionsUN);
			Append(versions, versionsUN);
		}

		while(StringContains(versionsUN, "",""))
		{
			int numberOfLetters = StringFind(versionsUN,"","",1);

			string versionHelp = StringSubstring(versionsUN, 0, numberOfLetters);
			versionHelp = ResolveUniqueName(connection, versionHelp);
			AppendDistinct(versions, versionHelp);

			versionsUN = StringSubstring(versionsUN, numberOfLetters + 1, StringLength(versionsUN)-(numberOfLetters + 1));
			numberOfLetters = StringFind(versionsUN,"","",1);
			if(numberOfLetters<0)
			{
				numberOfLetters = StringLength(versionsUN);
			}
			versionHelp = StringSubstring(versionsUN, 0, numberOfLetters);
			versionHelp = ResolveUniqueName(connection, versionHelp);
			AppendDistinct(versions, versionHelp);
		}


		StringArray results = CreateStringArray();

		foreach(string version in versions)
		{
			double refVersionNum = OLAPCellReadNumber(connection, Cube,1.0, Cycle,version, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Value"");
			
			if(refVersionNum == 1)
			{
				string refVersion = OLAPCellReadString(connection, Cube, Cycle,version, ""GLOBAL_CYCLE_VERSION_CONFIGURATION"", ""Text Value"");
				AppendDistinct(results, refVersion);
			}
			if(refVersionNum != 1)
			{
				string ver = ""[BPDVERSION].[""+version+""].[1]"";
				AppendDistinct(results, ver);
			}
		}

		int i = 0;
		string result = """";

		while(i <= Count(results)-1)
		{
			string versionInResult = GetElementByIndex(results, i);
			result = result + versionInResult +  "","";
			i = i + 1;
		}
		int lenght = StringLength(result);
		result = StringSubstring(result, 0, lenght - 1);



		return result;

	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
	
}"	1	303189CF-F3C1-4E07-A2DB-FE500AFAC2DF	Find for referenced version version, from where it is refenced, if it is base version return this one.	1	1	1	1626	NULL	0	45708.67502	0	0
A14C4BCC-74B3-4F90-BDD6-61F372A48CE7	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetSplashOperationLimit	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Splash operation limit info if successful othervise error message"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetSplashOperationLimit(string server)
@Description: ""Get Splash operation limit as info for users when do writeback"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Splash operation limit info if successful othervise error message"";
{
	string functionName = ""BP_GetSplashOperationLimit: "";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		string xml = ""&lt;Alea:Document xmlns:Alea=\""http://www.misag.com\""&gt;"";
		xml = xml + ""&lt;Alea:Request RequestID=\""001\"" Class=\""Database\"" Method=\""GetInfo\""/&gt;"";
		xml = xml + ""&lt;/Alea:Document&gt;"";

		string resultXML = OLAPXMLRequest(connection, xml);
		XMLDocument xmlDoc =  XMLParseDocument(resultXML);
		XMLNamespaceManager nm = xmlDoc.CreateNamespaceManager();
		nm.AddNamespace(""Alea"", ""http://www.misag.com"");
		XMLElement accessCubes = xmlDoc.GetRootElement().XPathSelectElement(""//Alea:Property[@Name ='SplashOperationLimit']"", nm);
		string result  = ToString(accessCubes.GetContent());
		
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string BP_GetSplashOperationLimit(string server)
@Description: ""Get Splash operation limit as info for users when do writeback"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Splash operation limit info if successful othervise error message"";
{
	string functionName = ""BP_GetSplashOperationLimit: "";
	string errorMessage = """";
	int errorCode = 0;
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		string xml = ""<Alea:Document xmlns:Alea=\""http://www.misag.com\"">"";
		xml = xml + ""<Alea:Request RequestID=\""001\"" Class=\""Database\"" Method=\""GetInfo\""/>"";
		xml = xml + ""</Alea:Document>"";

		string resultXML = OLAPXMLRequest(connection, xml);
		XMLDocument xmlDoc =  XMLParseDocument(resultXML);
		XMLNamespaceManager nm = xmlDoc.CreateNamespaceManager();
		nm.AddNamespace(""Alea"", ""http://www.misag.com"");
		XMLElement accessCubes = xmlDoc.GetRootElement().XPathSelectElement(""//Alea:Property[@Name ='SplashOperationLimit']"", nm);
		string result  = ToString(accessCubes.GetContent());
		
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR:"" + errorMessage;
	}
}"	1	25B45083-666C-46D0-A944-E2531CE78D2B	Get Splash operation limit as info for users when do writeback	1	1	1	1627	NULL	0	45708.67501	0	0
D1F13E1D-C13D-4226-B815-ACE7069A65DD	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetTimestampInDays	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The provided time stamp in days."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""dateTime"" parameter-type=""DateTime"" parameter-description=""Timestamp to convert to days from AppStudio DateTime start"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


double BP_GetTimestampInDays(
	DateTime dateTime
)
@Description: ""Returns the provided time stamp in days."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[dateTime]: ""Timestamp to convert to days from AppStudio DateTime start"";
@Returns: ""The provided time stamp in days."";
{
	double SecondsInDay = 60 * 60 * 24;
	// AppStudio DateTime starts from 12/30/1899 12:00 AM, so set that as the base time.
	DateTime baseTime = CreateDateTime(1899, 12, 30, 0, 0, 0);

	// Calculate the number of days between the base and provided time.
	double duration = GetDurationAsDouble(baseTime, dateTime);
	double days = Truncate(duration / SecondsInDay);

	return days;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2016 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0


double BP_GetTimestampInDays(
	DateTime dateTime
)
@Description: ""Returns the provided time stamp in days."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[dateTime]: ""Timestamp to convert to days from AppStudio DateTime start"";
@Returns: ""The provided time stamp in days."";
{
	double SecondsInDay = 60 * 60 * 24;
	// AppStudio DateTime starts from 12/30/1899 12:00 AM, so set that as the base time.
	DateTime baseTime = CreateDateTime(1899, 12, 30, 0, 0, 0);

	// Calculate the number of days between the base and provided time.
	double duration = GetDurationAsDouble(baseTime, dateTime);
	double days = Truncate(duration / SecondsInDay);

	return days;
}"	1	1B9A9E49-5927-4B14-812B-6FA898F94860	Returns the provided time stamp in days.	1	1	1	1628	NULL	0	45708.67507	0	0
7EDF4095-9107-4010-A74F-CAC21BFA8463	CD491758-D9DF-4002-94C8-8006E1855F86	BP_GetTopElement	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElement"" return-value-description=""The first top level element for the provided dimension"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use to retrieve data"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension to query"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElement BP_GetTopElement(
	OLAPConnection connection,
	string dimension)
@Description: ""Retrieve the first top level element of the requested dimension"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The first top level element for the provided dimension"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[dimension]: ""Dimension to query"";
{
	string functionName = ""BP_GetTopElement:"";
	string errorMessage = """";
	int errorCode = 0;
    OLAPElementList elements = CreateOLAPElementList();
    
	try {
		elements = OLAPGetLevelElements(connection, dimension, 0, false);
		OLAPElement topElement = elements[0];

		LogDebug (functionName + "" returning "" + topElement + "" as top element for dimension "" + dimension);
		return topElement;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return elements[0];
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElement BP_GetTopElement(
	OLAPConnection connection,
	string dimension)
@Description: ""Retrieve the first top level element of the requested dimension"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""The first top level element for the provided dimension"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[dimension]: ""Dimension to query"";
{
	string functionName = ""BP_GetTopElement:"";
	string errorMessage = """";
	int errorCode = 0;
    OLAPElementList elements = CreateOLAPElementList();
    
	try {
		elements = OLAPGetLevelElements(connection, dimension, 0, false);
		OLAPElement topElement = elements[0];

		LogDebug (functionName + "" returning "" + topElement + "" as top element for dimension "" + dimension);
		return topElement;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage, 99);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return elements[0];
}"	1	D4E80805-FBD6-4260-B569-20CE042C10D4	Retrieve the first top level element of the requested dimension	1	1	1	1629	NULL	0	45708.67506	0	0
AAE6C288-E933-4854-8776-6DFE317AB5E5	CD491758-D9DF-4002-94C8-8006E1855F86	BP_IncrementDateByMonths	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The incremented date"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""baseDate"" parameter-type=""string"" parameter-description=""Date to be incremented in yyyy/MM/dd format"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""monthIncrement"" parameter-type=""int"" parameter-description=""Number of months to increment date"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
void Test() {
	Write(BP_IncrementDateByMonths(""2015/06/30"", 20));
}
 */

string BP_IncrementDateByMonths(
	string baseDate,
	int monthIncrement
)
@Description: ""Increment a provided date (yyyy/MM/dd format) by the provided number of months"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[baseDate]: ""Date to be incremented in yyyy/MM/dd format"";
@Parameter[monthIncrement]: ""Number of months to increment date"";
@Returns: ""The incremented date"";
{
	string functionName = ""BP_IncrementDateByMonths: "";
	string errorMessage = """";
	int errorCode = 0;

	string newDate = baseDate;
	try {
		LogDebug(functionName + ""baseDate="" + baseDate + "", monthIncrement="" + monthIncrement);

		if (baseDate == """" or StringLength(baseDate) != 10) {
			LogError(functionName + ""baseDate is required and must be in the format yyyy/MM/dd"");
			return newDate;
		}

		if (monthIncrement != 0) {
			// Only process if there is an increment
			StringArray parts = StringSplit(baseDate, ""/"");
			if (Count(parts) != 3) {
				LogError(functionName + ""baseDate is required and must be in the format yyyy/MM/dd"");
				return newDate;
			}

			int year = ToInt(parts[0]);
			int month = ToInt(parts[1]);
			int days = ToInt(parts[2]);
			int newMonth = month + monthIncrement;
			int yearIncrement = 0;

			if (newMonth &gt; 12 or newMonth &lt;= 0) {
				newMonth = (newMonth) % 12;

				// handle 12th month where modulus is zero
				if (newMonth == 0) {
					newMonth = 12;
					yearIncrement = (monthIncrement / 12);
				}
				else if (newMonth &lt; 0) {
					// handle decrementing year
					yearIncrement = (newMonth / 12) - 1;
					// correct newMonth because it is negative
					newMonth = 13 + newMonth;
				}
				
				else {
					yearIncrement = (month + monthIncrement) / 12;
				}
			}

			year = year + yearIncrement;
			newMonth = Abs(newMonth); // Handle decrement
			days = Min(days, DaysInMonth(year, newMonth));

			newDate = ToString(year) + ""/"" + StringSubstring(ToString(100 + newMonth), 1, 2) + ""/"" + StringSubstring(ToString(100 + days), 1, 2);
		}
		
		return newDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage + "" Error code: "" + errorCode, 99);
	}

	return newDate; // Should never be hit, but AppEngine requires it to compile

}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

/*
void Test() {
	Write(BP_IncrementDateByMonths(""2015/06/30"", 20));
}
 */

string BP_IncrementDateByMonths(
	string baseDate,
	int monthIncrement
)
@Description: ""Increment a provided date (yyyy/MM/dd format) by the provided number of months"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[baseDate]: ""Date to be incremented in yyyy/MM/dd format"";
@Parameter[monthIncrement]: ""Number of months to increment date"";
@Returns: ""The incremented date"";
{
	string functionName = ""BP_IncrementDateByMonths: "";
	string errorMessage = """";
	int errorCode = 0;

	string newDate = baseDate;
	try {
		LogDebug(functionName + ""baseDate="" + baseDate + "", monthIncrement="" + monthIncrement);

		if (baseDate == """" or StringLength(baseDate) != 10) {
			LogError(functionName + ""baseDate is required and must be in the format yyyy/MM/dd"");
			return newDate;
		}

		if (monthIncrement != 0) {
			// Only process if there is an increment
			StringArray parts = StringSplit(baseDate, ""/"");
			if (Count(parts) != 3) {
				LogError(functionName + ""baseDate is required and must be in the format yyyy/MM/dd"");
				return newDate;
			}

			int year = ToInt(parts[0]);
			int month = ToInt(parts[1]);
			int days = ToInt(parts[2]);
			int newMonth = month + monthIncrement;
			int yearIncrement = 0;

			if (newMonth > 12 or newMonth <= 0) {
				newMonth = (newMonth) % 12;

				// handle 12th month where modulus is zero
				if (newMonth == 0) {
					newMonth = 12;
					yearIncrement = (monthIncrement / 12);
				}
				else if (newMonth < 0) {
					// handle decrementing year
					yearIncrement = (newMonth / 12) - 1;
					// correct newMonth because it is negative
					newMonth = 13 + newMonth;
				}
				
				else {
					yearIncrement = (month + monthIncrement) / 12;
				}
			}

			year = year + yearIncrement;
			newMonth = Abs(newMonth); // Handle decrement
			days = Min(days, DaysInMonth(year, newMonth));

			newDate = ToString(year) + ""/"" + StringSubstring(ToString(100 + newMonth), 1, 2) + ""/"" + StringSubstring(ToString(100 + days), 1, 2);
		}
		
		return newDate;
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(errorMessage + "" Error code: "" + errorCode, 99);
	}

	return newDate; // Should never be hit, but AppEngine requires it to compile

}"	1	4BE0A620-7AC3-4102-8E30-63F2814D3887	Increment a provided date (yyyy/MM/dd format) by the provided number of months	1	1	1	1630	NULL	0	45708.67504	0	0
7AEC8281-0686-457B-B4C9-C2CC06B2523F	CD491758-D9DF-4002-94C8-8006E1855F86	BP_IsDesignerExclusive	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""false -  db is not locked by designer, true designer is locked by designer"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""User credentials as obtained from AppStudio function GETTICKET()"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsDesignerExclusive(string server, string ticket)
@Description: ""Check if is db locked by designer"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[ticket]: ""User credentials as obtained from AppStudio function GETTICKET()"";
@Returns: ""false -  db is not locked by designer, true designer is locked by designer"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	//OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");

	string xml = ""&lt;Alea:Document xmlns:Alea=\""http://www.misag.com\""&gt;"";
	xml = xml + ""&lt;Alea:Request RequestID=\""001\"" Class=\""Database\"" Method=\""GetProperties\""/&gt;"";
	xml = xml + ""&lt;/Alea:Document&gt;"";
	
	LogDebug(""Request: "" + xml);
	string resultXML = OLAPXMLRequest(connection, xml);
	LogDebug(""Result: "" + resultXML);

	int numberOfLetters = StringFind(resultXML,""Exclusive=\"""",1);
	string isDesignerExclusive = StringSubstring(resultXML, numberOfLetters + 11, 5);


	if (isDesignerExclusive == ""false"")
	{
		return false;
	}
	else
	{
		return true;

	}

}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsDesignerExclusive(string server, string ticket)
@Description: ""Check if is db locked by designer"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[ticket]: ""User credentials as obtained from AppStudio function GETTICKET()"";
@Returns: ""false -  db is not locked by designer, true designer is locked by designer"";
{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
	//OLAPConnection connection = OLAPCreateConnection(""usalvwpsolap/Planning"", ""approver fin"", """");

	string xml = ""<Alea:Document xmlns:Alea=\""http://www.misag.com\"">"";
	xml = xml + ""<Alea:Request RequestID=\""001\"" Class=\""Database\"" Method=\""GetProperties\""/>"";
	xml = xml + ""</Alea:Document>"";
	
	LogDebug(""Request: "" + xml);
	string resultXML = OLAPXMLRequest(connection, xml);
	LogDebug(""Result: "" + resultXML);

	int numberOfLetters = StringFind(resultXML,""Exclusive=\"""",1);
	string isDesignerExclusive = StringSubstring(resultXML, numberOfLetters + 11, 5);


	if (isDesignerExclusive == ""false"")
	{
		return false;
	}
	else
	{
		return true;

	}

}"	1	0DEE141E-B768-48B5-947F-600E21E0FD50	Check if is db locked by designer	1	1	1	1631	NULL	0	45708.67503	0	0
4251EBF7-5C7C-45D2-A1B6-16AE2AF54A66	CD491758-D9DF-4002-94C8-8006E1855F86	BP_IsDimensionActive	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if the dimension is active, false if not"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use to retrieve data"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Configuration set element to use"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version element to use"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""dimensionName"" parameter-type=""string"" parameter-description=""Name of the dimension to check"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsDimensionActive(OLAPConnection connection,
                          string cycle,
                          string version,
                          string dimensionName)
@Description: ""Retrieve the active status of the supplied dimension for the cycle"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""true if the dimension is active, false if not"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[cycle]: ""Configuration set element to use"";
@Parameter[version]: ""Version element to use"";
@Parameter[dimensionName]: ""Name of the dimension to check"";
{
	string functionName = ""BP_IsDimensionActive:"";
	string errorMessage = """";
	int errorCode = 0;
	string BPCCONFIG_CYCLE = ""BPCCONFIG_CYCLE"";

	try {
		string parameter = """";

		if (dimensionName == ""BPDORGANIZATION"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_ORGANIZATION"";
		} else if (dimensionName == ""BPDINTERCOMPANY"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_IC"";
		} else if (dimensionName == ""BPDPSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_PSEGMENT"";
		} else if (dimensionName == ""BPDSSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_SSEGMENT"";
		} else if (dimensionName == ""BPDTSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_TSEGMENT"";
		} else if (dimensionName == ""BPDDETAIL"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_DETAIL"";
		}

		// All other dimensions are active
		bool active = true;
		if (StringLength(parameter) &gt; 0) {
			double value = OLAPCellReadNumber(connection, BPCCONFIG_CYCLE, 1.0, cycle,version, parameter, ""Value"");
			active = value &gt; 0.0;
		}
		
		LogDebug (functionName + "" returning '"" + active + ""' for configuration set ="" + cycle + "", for Version="" + version + "" Dimension="" + dimensionName);
		return active;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsDimensionActive(OLAPConnection connection,
                          string cycle,
                          string version,
                          string dimensionName)
@Description: ""Retrieve the active status of the supplied dimension for the cycle"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""true if the dimension is active, false if not"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[cycle]: ""Configuration set element to use"";
@Parameter[version]: ""Version element to use"";
@Parameter[dimensionName]: ""Name of the dimension to check"";
{
	string functionName = ""BP_IsDimensionActive:"";
	string errorMessage = """";
	int errorCode = 0;
	string BPCCONFIG_CYCLE = ""BPCCONFIG_CYCLE"";

	try {
		string parameter = """";

		if (dimensionName == ""BPDORGANIZATION"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_ORGANIZATION"";
		} else if (dimensionName == ""BPDINTERCOMPANY"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_IC"";
		} else if (dimensionName == ""BPDPSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_PSEGMENT"";
		} else if (dimensionName == ""BPDSSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_SSEGMENT"";
		} else if (dimensionName == ""BPDTSEGMENT"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_TSEGMENT"";
		} else if (dimensionName == ""BPDDETAIL"") {
			parameter = ""GLOBAL_CYCLE_ACTIVE_DETAIL"";
		}

		// All other dimensions are active
		bool active = true;
		if (StringLength(parameter) > 0) {
			double value = OLAPCellReadNumber(connection, BPCCONFIG_CYCLE, 1.0, cycle,version, parameter, ""Value"");
			active = value > 0.0;
		}
		
		LogDebug (functionName + "" returning '"" + active + ""' for configuration set ="" + cycle + "", for Version="" + version + "" Dimension="" + dimensionName);
		return active;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return true;
}"	1	847B7ECB-E1B3-45B2-B6DC-394E9C46A503	Retrieve the active status of the supplied dimension for the cycle	1	1	1	1632	NULL	0	45708.67501	0	0
2E17541E-D0FD-41B9-91E6-65E3EA35200A	CD491758-D9DF-4002-94C8-8006E1855F86	BP_IsNAUsedForTarget	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if if dimension is active in sourcecycle/version and not active in cycle/version, othervise false"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection to use to retrieve data"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceCycle"" parameter-type=""string"" parameter-description=""Source configuration set element to use"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""Source version element to use"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""targetCycle"" parameter-type=""string"" parameter-description=""Target configuration set element to use"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""Target version element to use"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""parameter"" parameter-type=""string"" parameter-description=""Parameter representing dimension"" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsNAUsedForTarget(OLAPConnection connection,string sourceCycle, string sourceVersion,string targetCycle, string targetVersion, string parameter)
@Description: ""Compare source cycle/version activation for dimension with target cycle/version"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""true if the dimension is active, false if not"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[sourceCycle]: ""Source configuration set element to use"";
@Parameter[sourceVersion]: ""Source version element to use"";
@Parameter[targetCycle]: ""Target configuration set element to use"";
@Parameter[targetVersion]: ""Target version element to use"";
@Parameter[parameter]: ""Parameter representing dimension"";
@Returns: ""true if if dimension is active in sourcecycle/version and not active in cycle/version, othervise false"";
{
	string functionName = ""BP_IsNAUsedForTarget:"";
	string errorMessage = """";
	int errorCode = 0;
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	bool result = false;

	try {
		double sourceActiveFlag =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,sourceCycle, sourceVersion,parameter,""Value"");
		double targetActiveFlag =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,targetCycle, targetVersion,parameter,""Value"");

		bool useOfNa = false;
		if (sourceActiveFlag ==1 and targetActiveFlag == 0)
		{
			useOfNa = true;
		}
		result = useOfNa;
		return result;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
		return result;
	}

}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool BP_IsNAUsedForTarget(OLAPConnection connection,string sourceCycle, string sourceVersion,string targetCycle, string targetVersion, string parameter)
@Description: ""Compare source cycle/version activation for dimension with target cycle/version"";
@Category: ""Budgeting and Planning Utilities"";
@Returns: ""true if the dimension is active, false if not"";
@Parameter[connection]: ""OLAP connection to use to retrieve data"";
@Parameter[sourceCycle]: ""Source configuration set element to use"";
@Parameter[sourceVersion]: ""Source version element to use"";
@Parameter[targetCycle]: ""Target configuration set element to use"";
@Parameter[targetVersion]: ""Target version element to use"";
@Parameter[parameter]: ""Parameter representing dimension"";
@Returns: ""true if if dimension is active in sourcecycle/version and not active in cycle/version, othervise false"";
{
	string functionName = ""BP_IsNAUsedForTarget:"";
	string errorMessage = """";
	int errorCode = 0;
	string ConfigCycleCube = ""BPCCONFIG_CYCLE"";
	bool result = false;

	try {
		double sourceActiveFlag =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,sourceCycle, sourceVersion,parameter,""Value"");
		double targetActiveFlag =  OLAPCellReadNumber(connection, ConfigCycleCube, 1.0,targetCycle, targetVersion,parameter,""Value"");

		bool useOfNa = false;
		if (sourceActiveFlag ==1 and targetActiveFlag == 0)
		{
			useOfNa = true;
		}
		result = useOfNa;
		return result;

	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		RaiseError(functionName + errorMessage, 1);
		return result;
	}

}"	1	66F5B943-E07A-41F8-A84D-CA16CDF90AFC	Compare source cycle/version activation for dimension with target cycle/version	1	1	1	1633	NULL	0	45708.67501	0	0
DE380D90-D7A0-400A-A979-4881BFC97847	CD491758-D9DF-4002-94C8-8006E1855F86	BP_UpdateAttributeDrivenHierarchy	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""void"" return-value-description="""" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""Olap connection server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension where attribute driven hierarchy should be updated"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

void BP_UpdateAttributeDrivenHierarchy(string server, string dimension)
@Description: ""Update attribute driven hierarchy"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""Olap connection server/database"";
@Parameter[dimension]: ""Dimension where attribute driven hierarchy should be updated"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		UpdateAttributeDrivenHierarchy(olapconnection, dimension);


	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

void BP_UpdateAttributeDrivenHierarchy(string server, string dimension)
@Description: ""Update attribute driven hierarchy"";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""Olap connection server/database"";
@Parameter[dimension]: ""Dimension where attribute driven hierarchy should be updated"";
{
	string errorMessage = """";
	int errorNum = 0;

	try
	{
		OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
		UpdateAttributeDrivenHierarchy(olapconnection, dimension);


	} catch (errorMessage, errorNum)
	{
		NotifyError(""Error: "" + errorMessage);
		
	}
}"	1	E127AB00-4070-4D29-BDA9-705AC7219B6D	Update attribute driven hierarchy	1	1	1	1634	NULL	0	45708.67501	0	0
C30DF063-A7E0-4081-A4A0-64C91C8E43A3	CD491758-D9DF-4002-94C8-8006E1855F86	CF_CalculateCashflow	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server and database to connect to in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCube"" parameter-type=""string"" parameter-description=""The OLAP cube containing the Budgeting and Planning data from which Cashflow is to be calculated"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The Configuration Set element for which to perform the calculation"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceVersionUN"" parameter-type=""string"" parameter-description=""The Version element for which to perform the calculation"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""sourceTimeUN"" parameter-type=""string"" parameter-description=""The Time element for which to perform the calculation or a comma delimited list of multiple Time elements"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""sourceEntityUN"" parameter-type=""string"" parameter-description=""The Entity element for which to perform the calculation"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetPlanningCycleYears"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""CF_CalculateCurrencyConversion"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""CF_TransferOpeningBalances"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""
#include ""BP_GetTopElement"", ""*""
#include ""CF_CalculateCurrencyConversion"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""CF_TransferOpeningBalances"", ""*""

string CF_CalculateCashflow(
	string server,
	string ticket,
	string sourceCube,
	string sourceCycleUN,
	string sourceVersionUN,
	string sourceTimeUN,
	string sourceEntityUN
)
@Description: ""This function is used to calculate Cashflow from Budgeting and Planning, writing to the Cashflow cube based upon configuration."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""The OLAP cube containing the Budgeting and Planning data from which Cashflow is to be calculated"";
@Parameter[sourceCycleUN]: ""The Configuration Set element for which to perform the calculation"";
@Parameter[sourceVersionUN]: ""The Version element for which to perform the calculation"";
@Parameter[sourceTimeUN]: ""The Time element for which to perform the calculation or a comma delimited list of multiple Time elements"";
@Parameter[sourceEntityUN]: ""The Entity element for which to perform the calculation"";
{
	string functionName = ""CF_CalculateCashflow: "";
	string errorMessage = """";
	int errorCode = 0;
	try {

		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCube = ""BPCMAIN"";
		sourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceVersionUN= ""[BPDVERSION].[BUDGET_01].[1]"";//[BPDVERSION].[BUDGET_01].[1],[BPDVERSION].[BUDGET_02].[1]
		sourceTimeUN = """";
		sourceEntityUN= ""[BPDENTITY].[RU0001].[1]"";//[BPDENTITY].[RU0001].[1],[BPDENTITY].[RU0002].[1]*/

		
		// Define cube, dimension and element names
		string CF_CUBE_CONFIGURATION = ""CFCCONFIG_CASHFLOW"";
		string CF_CUBE_DATA = ""CFCCASHFLOW"";
		string CF_DIMENSION_ACCOUNT = ""CFDCASHFLOW"";
		string CF_DIMENSION_CONFIGURATION = ""CFDCONFIG_CASHFLOW"";

		string configCube = CF_CUBE_CONFIGURATION;
		string targetCube = CF_CUBE_DATA;
		string accountDimension = ""BPDACCOUNT"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";

		string NA = ""N.A."";
		string cashflowAccountElement = OLAPGetStringAttribute(connection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");
		string cashflowDetailElement = NA;
		//string stepElement = ""BASE_STEP""; // One day may be passed in
		string topLevelElement = ""TOTAL_LEVEL"";
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));
		string timeElement = NA;

		// Resolve Unique Names
		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		StringArray versionsUN = CF_ElementStringSplit(sourceVersionUN);
		StringArray versions = CreateStringArray();
		foreach(string v in versionsUN)
		{
			string sourceV= ResolveUniqueName(connection, v);
			Append(versions,sourceV);
		}

		StringArray entitiesUN = CF_ElementStringSplit(sourceEntityUN);
		StringArray translatedEntities = CreateStringArray();
		OLAPElementList entities = CreateOLAPElementList();
		foreach(string e in entitiesUN)
		{
			string en = ResolveUniqueName(connection, e);
			string nameOfEntity = OLAPGetStringAttribute(connection,entityDimension,en, ""Name"");
			Append(translatedEntities,nameOfEntity);
			OLAPElementListAddElement(entities, OLAPGetDimensionElement(connection, entityDimension, en));
		}
		string translatedCommaSeparatedStr = StringJoin(translatedEntities, "","");
		// If sourceTimeUN is empty, get the years from the Planning Cycle configuration
		OLAPElementList sourceYearsActuals = CreateOLAPElementList();
		OLAPElementList sourceTimeActuals = CreateOLAPElementList();
		if (sourceTimeUN != """") {
			// Handle multi-select
			StringArray years = CF_ElementStringSplit(sourceTimeUN);
			foreach (string year in years) {
				OLAPElementListAddElement(sourceYearsActuals, OLAPGetDimensionElement(connection, timeDimension, ResolveUniqueName(connection, year)));
			}
			foreach (OLAPElement year in sourceYearsActuals) {
				OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, year, true);
				foreach (OLAPElement period in periods) {
					OLAPElementListAddElement(sourceTimeActuals, period);
				}
			}
		}
		// Get the element list from the Planning Cycle configuration
		OLAPElementList sourceYearsBudget = BP_GetPlanningCycleYears(connection, sourceCycle);
		OLAPElementList sourceTimeBudget = CreateOLAPElementList();

		foreach (OLAPElement year in sourceYearsBudget) {
			OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, year, true);
			foreach (OLAPElement period in periods) {
				OLAPElementListAddElement(sourceTimeBudget, period);
			}
		}

		// Gather element lists
		OLAPElementList allCashflowAccounts = OLAPGetElementList(connection, CF_DIMENSION_ACCOUNT, true);
		OLAPElementList allAccounts = OLAPGetElementList(connection, accountDimension, false);
		OLAPElementList allDetails = OLAPGetElementList(connection, detailDimension, false);
		OLAPElementList levels = OLAPGetChildElementList(connection, levelDimension, topLevelElement, true);
		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList  LevelList = CreateStringList();
		StringList  LevelListAll = CreateStringList();
		Append(LevelListAll, """");
		//need to exclude TOTAL_INPUT_ALLOCATION and TOTAL_INPUT_ALLOCATION_DP from transfer
		foreach(OLAPElement level in levels)
		{
			string levelForArray =ToString(level);
			if(levelForArray != ""TOTAL_INPUT_ALLOCATION"")
			{
				if(levelForArray != ""TOTAL_INPUT_ALLOCATION_DP"")
				{
					Append(LevelListAll ,levelForArray);
				}
			}

		}
		OLAPElementList LevelChange = OLAPGetChildElementList(connection, levelDimension, ""TOTAL_INPUT"", true);
		StringList LevelListMovements = ConvertToStringList(LevelChange);

		OLAPElementList movements= OLAPGetChildElementList(connection, ""BPDDETAIL"", ""MOVEMENTS"", true);
		StringList  detailsWithoutOB = ConvertToStringList(movements);

		bool processedData = false;
		int totalValues = 0;
		bool cfAccountConfigured = false;
		NotifyInformation(""Transfer of financial data to cashflow started."");
		OLAPElementList versionsOList = OLAPGetChildElementList(connection, versionDimension, ""TOTAL_ACTUAL"", true);
		OLAPElementList sourceTime = CreateOLAPElementList();
		StringListList times = CreateStringListList();
		foreach(string sourceVersion in versions)
		{
			if(OLAPElementListContainsElement(versionsOList, sourceVersion))
			{
				sourceTime = sourceTimeActuals;
			}
			else
			{
				sourceTime = sourceTimeBudget;
			}

			Append(times,ToStringList(sourceTime));
			int numberOfValues = 0;
			string versionTranslate = OLAPCellReadString(connection, ""BPCCONFIG_CYCLE"",sourceCycle, sourceVersion, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"", ""Default"");
			NotifyInformation(""Transfering of financial data to cashflow for version: "" + versionTranslate + "" and for Entity/ies: ""+ translatedCommaSeparatedStr+ "" started."");
			/* Cache the Cashflow Configuration
			 * Unfortunately, because WEIGHTs are stored as text, we have to use the TYPE.
			 * Using TYPE, though, can only tell us which Cashflow Accounts are configured. :(
			 * For everything else, we are going to have to read the WEIGHT individually
			 */
			LogDebug(functionName + "" Configuration Set='"" + sourceCycle + ""', sourceVersion='"" + sourceVersion);
			OLAPCubeCache configCache = OLAPCreateCubeCache(connection,
			                                                configCube,
			                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
			                                                OlapDataAreaOperatorNotEqual,
			                                                0.0,
			                                                OlapDataAreaOperatorNone,
			                                                0,
			                                                timeElement,
			                                                sourceCycle,
			                                                sourceVersion,
			                                                OlapDataAreaAllCells, // BPDDETAIL
			                                                OlapDataAreaAllCells, // BPDACCOUNT
			                                                OlapDataAreaBCells, // CFDCASHFLOW
			                                                ""TYPE"");
			OLAPFillCubeCache(connection, configCache, accountDimension, detailDimension, CF_DIMENSION_ACCOUNT);

			// Need a list of the AccountType 4 Cashflow Accounts.  We will not delete the target for these accounts
			OLAPElementList typeFourAccounts = CreateOLAPElementList();

			// Need a list of Cashflow Accounts that have had their target area cleared.  Only clear the target area once.
			OLAPElementList clearedCashflowAccounts = CreateOLAPElementList();
			
			foreach (OLAPElement cashflowAccount in allCashflowAccounts where OLAPCubeCacheHasValue(configCache, 2, cashflowAccount)) {
				double accountType =  OLAPCellReadNumber(connection, configCube, 1, timeElement, sourceCycle, sourceVersion, cashflowDetailElement, cashflowAccountElement, cashflowAccount, ""TYPE"");
				if (accountType == 4) {
					OLAPElementListAddElement(typeFourAccounts, cashflowAccount);
				}
			}
			
			// Define and Clear the target cashflowAccount cells if not in typeFourAccount list and not previously cleared
			foreach (OLAPElement cashflowAccountDelete in allCashflowAccounts)
			{
				if (!OLAPElementListContainsElement(typeFourAccounts, cashflowAccountDelete) and
				    !OLAPElementListContainsElement(clearedCashflowAccounts, cashflowAccountDelete)) {
					LevelList = LevelListAll;
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, targetCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 sourceTime,
					                                                 sourceCycle,
					                                                 sourceVersion,
					                                                 LevelList,
					                                                 OlapDataAreaBCells, // BPDSTEP
					                                                 entities,
					                                                 OlapDataAreaBCells, // BPDINTERCOMPANY
					                                                 OlapDataAreaBCells, // BPDORGANIZATION
					                                                 currenList, // BPDCURRENCY
					                                                 OlapDataAreaBCells, // BPDPSEGMENT
					                                                 OlapDataAreaBCells, // BPDSSEGMENT
					                                                 OlapDataAreaBCells, // BPDTSEGMENT
					                                                 cashflowAccountDelete,
					                                                 OlapDataAreaBCells, // BPDANALYSIS_01
					                                                 OlapDataAreaBCells, // BPDANALYSIS_02
					                                                 OlapDataAreaBCells, // BPDANALYSIS_03
					                                                 OlapDataAreaBCells, // BPDANALYSIS_04
					                                                 OlapDataAreaBCells, // BPDANALYSIS_05
					                                                 OlapDataAreaBCells, // BPDANALYSIS_06
					                                                 OlapDataAreaBCells, // BPDANALYSIS_07
					                                                 OlapDataAreaBCells, // BPDANALYSIS_08
					                                                 OlapDataAreaBCells, // BPDANALYSIS_09
					                                                 OlapDataAreaBCells, // BPDANALYSIS_10
					                                                 OlapDataAreaBCells, // BPDANALYSIS_11
					                                                 OlapDataAreaBCells // BPDANALYSIS_12
					                                                );
					OLAPDeleteDataArea(targetDataArea);
					OLAPElementListAddElement(clearedCashflowAccounts, cashflowAccountDelete);
				}
			}
			foreach (OLAPElement cashflowAccount in allCashflowAccounts where OLAPCubeCacheHasValue(configCache, 2, cashflowAccount)) {
				
				cfAccountConfigured = true;
				
				StringList  configuredAccounts = CreateStringList();
				Append(configuredAccounts, """");
				StringList  configuredDetails = CreateStringList();
				Append(configuredDetails, """");

				OLAPDataArea configDataArea = OLAPCreateDataArea(connection, configCube,
				                                                 OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 timeElement, sourceCycle,sourceVersion, allDetails, allAccounts, cashflowAccount, ""WEIGHT"");
				foreach (OLAPCell cell in configDataArea)
				{
					string account = OLAPCellGetElement(cell, accountDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string weighttxt = cell;
					if (weighttxt != """")
					{
						AppendDistinct(configuredAccounts,account);
						AppendDistinct(configuredDetails,detail);
					}
				}

				double numberaccount = Count(configuredAccounts) ;

				
				// Process by cash flow account type
				double accountType =  OLAPCellReadNumber(connection, configCube, 1, timeElement, sourceCycle, sourceVersion, cashflowDetailElement, cashflowAccountElement, cashflowAccount, ""TYPE"");


				if (accountType == 1 or accountType == 2 or accountType == 3) {
					StringList  detailsToDataArea = CreateStringList();
					if(accountType == 1)
					{
						detailsToDataArea = configuredDetails;
						LevelList = LevelListAll;

					}
					if(accountType == 2)
					{
						detailsToDataArea = ConvertToStringList(OlapDataAreaBCells);
						LevelList = LevelListAll;
					}

					if(accountType == 3)
					{

						detailsToDataArea = detailsWithoutOB;
						LevelList = LevelListMovements;
					}

					//LogDebug(functionName + "" Top of accountType="" + accountType);
					if(Count(configuredAccounts) != 1) {
						// Need a source DataArea to be processed
						OLAPDataArea sourceDataArea = OLAPCreateDataArea(connection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
						                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
						                                                 sourceTime,
						                                                 sourceCycle,
						                                                 sourceVersion,
						                                                 LevelList,
						                                                 OlapDataAreaBCells, // BPDSTEP
						                                                 entities,
						                                                 OlapDataAreaBCells, // BPDINTERCOMPANY
						                                                 OlapDataAreaBCells, // BPDORGANIZATION
						                                                 configuredAccounts, // BPDACCOUNT
						                                                 currenList, // BPDCURRENCY
						                                                 detailsToDataArea,//OlapDataAreaAllCells, // BPDDETAIL
						                                                 OlapDataAreaBCells, // BPDPSEGMENT
						                                                 OlapDataAreaBCells, // BPDSSEGMENT
						                                                 OlapDataAreaBCells, // BPDTSEGMENT
						                                                 OlapDataAreaBCells, // BPDANALYSIS_01
						                                                 OlapDataAreaBCells, // BPDANALYSIS_02
						                                                 OlapDataAreaBCells, // BPDANALYSIS_03
						                                                 OlapDataAreaBCells, // BPDANALYSIS_04
						                                                 OlapDataAreaBCells, // BPDANALYSIS_05
						                                                 OlapDataAreaBCells, // BPDANALYSIS_06
						                                                 OlapDataAreaBCells, // BPDANALYSIS_07
						                                                 OlapDataAreaBCells, // BPDANALYSIS_08
						                                                 OlapDataAreaBCells, // BPDANALYSIS_09
						                                                 OlapDataAreaBCells, // BPDANALYSIS_10
						                                                 OlapDataAreaBCells, // BPDANALYSIS_11
						                                                 OlapDataAreaBCells // BPDANALYSIS_12
						                                                );

						foreach (OLAPCell cell in sourceDataArea) {
							string account = OLAPCellGetElement(cell, accountDimension);
							string detail = OLAPCellGetElement(cell, detailDimension);
							double sourceValue = cell;
							//LogDebug("" account='"" + account + sourceValue + "" detail "" + detail);

							// only process detail N.A. for accountType 2/3
							if ( accountType == 1 or accountType == 2 or accountType == 3 ) {

								// if we have a configured combination, process it
								if ((accountType == 1 and """" !=  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, detail, account, cashflowAccount, ""WEIGHT"")) or accountType == 2 or accountType == 3 ) {
									string currency = OLAPCellGetElement(cell, currencyDimension);

									// only process local currencies

									string cycle = OLAPCellGetElement(cell, cycleDimension);
									string organization = OLAPCellGetElement(cell, organizationDimension);
									string entity = OLAPCellGetElement(cell, entityDimension);
									string time = OLAPCellGetElement(cell, timeDimension);
									string version = OLAPCellGetElement(cell, versionDimension);
									string level = OLAPCellGetElement(cell, levelDimension);
									string step = OLAPCellGetElement(cell, stepDimension);
									string interCompany = OLAPCellGetElement(cell, intercompanyDimension);
									string psegment = OLAPCellGetElement(cell, primarySegmentDimension);
									string ssegment = OLAPCellGetElement(cell, secondarySegmentDimension);
									string tsegment = OLAPCellGetElement(cell, tertiarySegmentDimension);
									string analysis01 = OLAPCellGetElement(cell, analysis01Dimension);
									string analysis02 = OLAPCellGetElement(cell, analysis02Dimension);
									string analysis03 = OLAPCellGetElement(cell, analysis03Dimension);
									string analysis04 = OLAPCellGetElement(cell, analysis04Dimension);
									string analysis05 = OLAPCellGetElement(cell, analysis05Dimension);
									string analysis06 = OLAPCellGetElement(cell, analysis06Dimension);
									string analysis07 = OLAPCellGetElement(cell, analysis07Dimension);
									string analysis08 = OLAPCellGetElement(cell, analysis08Dimension);
									string analysis09 = OLAPCellGetElement(cell, analysis09Dimension);
									string analysis10 = OLAPCellGetElement(cell, analysis10Dimension);
									string analysis11 = OLAPCellGetElement(cell, analysis11Dimension);
									string analysis12 = OLAPCellGetElement(cell, analysis12Dimension);
									

									// Expense account values must be multiplied by -1 for proper Cash Flow handling
									string BPAccountType =  OLAPGetStringAttribute(connection, accountDimension, account, ""ACCTYPE"");
									double accountWeight = 1;
									if (BPAccountType == ""E"") {
										accountWeight = -1;
									}
									string weightText = """";
									if(accountType == 1)
									{
										weightText =  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, detail, account, cashflowAccount, ""WEIGHT"");
									}
									else
									{
										weightText =  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, ""N.A."", account, cashflowAccount, ""WEIGHT"");
									}

									if (weightText != """") {
										double weightValue = ToInt(weightText);

										// Write calculated value
										if (RoundDecimals(sourceValue, 2) != 0) {

											double totalValue = (sourceValue * accountWeight*weightValue); //+ targetValue;
											
											OLAPCellWriteBufferIncrementNumber(buffer, targetCube, totalValue, time, cycle, version, level, step, entity, interCompany, organization, currency,
											                                   psegment, ssegment, tsegment,
											                                   cashflowAccount,
											                                   analysis01, analysis02, analysis03, analysis04, analysis05, analysis06, analysis07, analysis08, analysis09, analysis10, analysis11, analysis12
											                                  );
											numberOfValues = numberOfValues + 1;


											//LogDebug(functionName + "" Writing value="" + totalValue + "" for Account="" + account  + "", Detail="" + detail + "", Weight="" + weightText + "", sourceValue="" + sourceValue + "", targetValue="" + targetValue);
										}

										processedData = true; // We actually processed some data
									} // if weightText
								} // if count of account is not 0
							} // if configured account/detail/cashflowAccount
						} // detail must be N.A. for accountType 2/3
					} // end of foreach cell
				} // if accountType is 1/2/3
			} // foreach cashflow Account
			NotifyInformation(""Number of financial data transferred to cashflow: "" + numberOfValues);
			totalValues =totalValues+numberOfValues;
		}//foreach version

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(functionName + "" finished transfering values.  processedData="" + processedData);

		string result = CF_TransferOpeningBalances(connection, sourceCube, targetCube, times, sourceCycle, versions, entities);
		NotifyInformation(""Transfer of financial data to cashflow finished."");
		if (StringStartsWith(result, ""ERROR"")) {
			LogError(functionName + "" CF_TransferOpeningBalances returned "" + result);
			RaiseError(result, 1);
		}
		if (!cfAccountConfigured) {
			return ""-1"";
		}
		else if (!processedData) {
			return ""-2"";
		} else {
			return ""0"";
		}
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""-1"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetPlanningCycleYears"", ""*""
#include ""BP_GetTopElement"", ""*""
#include ""CF_CalculateCurrencyConversion"", ""*""
#include ""CF_ElementStringSplit"", ""*""
#include ""CF_TransferOpeningBalances"", ""*""

string CF_CalculateCashflow(
	string server,
	string ticket,
	string sourceCube,
	string sourceCycleUN,
	string sourceVersionUN,
	string sourceTimeUN,
	string sourceEntityUN
)
@Description: ""This function is used to calculate Cashflow from Budgeting and Planning, writing to the Cashflow cube based upon configuration."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""The OLAP cube containing the Budgeting and Planning data from which Cashflow is to be calculated"";
@Parameter[sourceCycleUN]: ""The Configuration Set element for which to perform the calculation"";
@Parameter[sourceVersionUN]: ""The Version element for which to perform the calculation"";
@Parameter[sourceTimeUN]: ""The Time element for which to perform the calculation or a comma delimited list of multiple Time elements"";
@Parameter[sourceEntityUN]: ""The Entity element for which to perform the calculation"";
{
	string functionName = ""CF_CalculateCashflow: "";
	string errorMessage = """";
	int errorCode = 0;
	try {

		NotifyInformation(""Process started."");
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		/*sourceCube = ""BPCMAIN"";
		sourceCycleUN = ""[BPDCYCLE].[CYCLE_001].[1]"";
		sourceVersionUN= ""[BPDVERSION].[BUDGET_01].[1]"";//[BPDVERSION].[BUDGET_01].[1],[BPDVERSION].[BUDGET_02].[1]
		sourceTimeUN = """";
		sourceEntityUN= ""[BPDENTITY].[RU0001].[1]"";//[BPDENTITY].[RU0001].[1],[BPDENTITY].[RU0002].[1]*/

		
		// Define cube, dimension and element names
		string CF_CUBE_CONFIGURATION = ""CFCCONFIG_CASHFLOW"";
		string CF_CUBE_DATA = ""CFCCASHFLOW"";
		string CF_DIMENSION_ACCOUNT = ""CFDCASHFLOW"";
		string CF_DIMENSION_CONFIGURATION = ""CFDCONFIG_CASHFLOW"";

		string configCube = CF_CUBE_CONFIGURATION;
		string targetCube = CF_CUBE_DATA;
		string accountDimension = ""BPDACCOUNT"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";

		string NA = ""N.A."";
		string cashflowAccountElement = OLAPGetStringAttribute(connection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");
		string cashflowDetailElement = NA;
		//string stepElement = ""BASE_STEP""; // One day may be passed in
		string topLevelElement = ""TOTAL_LEVEL"";
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));
		string timeElement = NA;

		// Resolve Unique Names
		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		StringArray versionsUN = CF_ElementStringSplit(sourceVersionUN);
		StringArray versions = CreateStringArray();
		foreach(string v in versionsUN)
		{
			string sourceV= ResolveUniqueName(connection, v);
			Append(versions,sourceV);
		}

		StringArray entitiesUN = CF_ElementStringSplit(sourceEntityUN);
		StringArray translatedEntities = CreateStringArray();
		OLAPElementList entities = CreateOLAPElementList();
		foreach(string e in entitiesUN)
		{
			string en = ResolveUniqueName(connection, e);
			string nameOfEntity = OLAPGetStringAttribute(connection,entityDimension,en, ""Name"");
			Append(translatedEntities,nameOfEntity);
			OLAPElementListAddElement(entities, OLAPGetDimensionElement(connection, entityDimension, en));
		}
		string translatedCommaSeparatedStr = StringJoin(translatedEntities, "","");
		// If sourceTimeUN is empty, get the years from the Planning Cycle configuration
		OLAPElementList sourceYearsActuals = CreateOLAPElementList();
		OLAPElementList sourceTimeActuals = CreateOLAPElementList();
		if (sourceTimeUN != """") {
			// Handle multi-select
			StringArray years = CF_ElementStringSplit(sourceTimeUN);
			foreach (string year in years) {
				OLAPElementListAddElement(sourceYearsActuals, OLAPGetDimensionElement(connection, timeDimension, ResolveUniqueName(connection, year)));
			}
			foreach (OLAPElement year in sourceYearsActuals) {
				OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, year, true);
				foreach (OLAPElement period in periods) {
					OLAPElementListAddElement(sourceTimeActuals, period);
				}
			}
		}
		// Get the element list from the Planning Cycle configuration
		OLAPElementList sourceYearsBudget = BP_GetPlanningCycleYears(connection, sourceCycle);
		OLAPElementList sourceTimeBudget = CreateOLAPElementList();

		foreach (OLAPElement year in sourceYearsBudget) {
			OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, year, true);
			foreach (OLAPElement period in periods) {
				OLAPElementListAddElement(sourceTimeBudget, period);
			}
		}

		// Gather element lists
		OLAPElementList allCashflowAccounts = OLAPGetElementList(connection, CF_DIMENSION_ACCOUNT, true);
		OLAPElementList allAccounts = OLAPGetElementList(connection, accountDimension, false);
		OLAPElementList allDetails = OLAPGetElementList(connection, detailDimension, false);
		OLAPElementList levels = OLAPGetChildElementList(connection, levelDimension, topLevelElement, true);
		OLAPElementList currencies = OLAPGetChildElementList(connection, currencyDimension, ""CURRENCY_DATAENTRY"", true);

		StringList  currenList = CreateStringList();
		Append(currenList, """");
		foreach(OLAPElement currencyOE in currencies)
		{
			string currency =ToString(currencyOE);
			Append(currenList ,currency);

		}

		StringList  LevelList = CreateStringList();
		StringList  LevelListAll = CreateStringList();
		Append(LevelListAll, """");
		//need to exclude TOTAL_INPUT_ALLOCATION and TOTAL_INPUT_ALLOCATION_DP from transfer
		foreach(OLAPElement level in levels)
		{
			string levelForArray =ToString(level);
			if(levelForArray != ""TOTAL_INPUT_ALLOCATION"")
			{
				if(levelForArray != ""TOTAL_INPUT_ALLOCATION_DP"")
				{
					Append(LevelListAll ,levelForArray);
				}
			}

		}
		OLAPElementList LevelChange = OLAPGetChildElementList(connection, levelDimension, ""TOTAL_INPUT"", true);
		StringList LevelListMovements = ConvertToStringList(LevelChange);

		OLAPElementList movements= OLAPGetChildElementList(connection, ""BPDDETAIL"", ""MOVEMENTS"", true);
		StringList  detailsWithoutOB = ConvertToStringList(movements);

		bool processedData = false;
		int totalValues = 0;
		bool cfAccountConfigured = false;
		NotifyInformation(""Transfer of financial data to cashflow started."");
		OLAPElementList versionsOList = OLAPGetChildElementList(connection, versionDimension, ""TOTAL_ACTUAL"", true);
		OLAPElementList sourceTime = CreateOLAPElementList();
		StringListList times = CreateStringListList();
		foreach(string sourceVersion in versions)
		{
			if(OLAPElementListContainsElement(versionsOList, sourceVersion))
			{
				sourceTime = sourceTimeActuals;
			}
			else
			{
				sourceTime = sourceTimeBudget;
			}

			Append(times,ToStringList(sourceTime));
			int numberOfValues = 0;
			string versionTranslate = OLAPCellReadString(connection, ""BPCCONFIG_CYCLE"",sourceCycle, sourceVersion, ""GLOBAL_CYCLE_VERSION_DESCRIPTION"", ""Default"");
			NotifyInformation(""Transfering of financial data to cashflow for version: "" + versionTranslate + "" and for Entity/ies: ""+ translatedCommaSeparatedStr+ "" started."");
			/* Cache the Cashflow Configuration
			 * Unfortunately, because WEIGHTs are stored as text, we have to use the TYPE.
			 * Using TYPE, though, can only tell us which Cashflow Accounts are configured. :(
			 * For everything else, we are going to have to read the WEIGHT individually
			 */
			LogDebug(functionName + "" Configuration Set='"" + sourceCycle + ""', sourceVersion='"" + sourceVersion);
			OLAPCubeCache configCache = OLAPCreateCubeCache(connection,
			                                                configCube,
			                                                OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
			                                                OlapDataAreaOperatorNotEqual,
			                                                0.0,
			                                                OlapDataAreaOperatorNone,
			                                                0,
			                                                timeElement,
			                                                sourceCycle,
			                                                sourceVersion,
			                                                OlapDataAreaAllCells, // BPDDETAIL
			                                                OlapDataAreaAllCells, // BPDACCOUNT
			                                                OlapDataAreaBCells, // CFDCASHFLOW
			                                                ""TYPE"");
			OLAPFillCubeCache(connection, configCache, accountDimension, detailDimension, CF_DIMENSION_ACCOUNT);

			// Need a list of the AccountType 4 Cashflow Accounts.  We will not delete the target for these accounts
			OLAPElementList typeFourAccounts = CreateOLAPElementList();

			// Need a list of Cashflow Accounts that have had their target area cleared.  Only clear the target area once.
			OLAPElementList clearedCashflowAccounts = CreateOLAPElementList();
			
			foreach (OLAPElement cashflowAccount in allCashflowAccounts where OLAPCubeCacheHasValue(configCache, 2, cashflowAccount)) {
				double accountType =  OLAPCellReadNumber(connection, configCube, 1, timeElement, sourceCycle, sourceVersion, cashflowDetailElement, cashflowAccountElement, cashflowAccount, ""TYPE"");
				if (accountType == 4) {
					OLAPElementListAddElement(typeFourAccounts, cashflowAccount);
				}
			}
			
			// Define and Clear the target cashflowAccount cells if not in typeFourAccount list and not previously cleared
			foreach (OLAPElement cashflowAccountDelete in allCashflowAccounts)
			{
				if (!OLAPElementListContainsElement(typeFourAccounts, cashflowAccountDelete) and
				    !OLAPElementListContainsElement(clearedCashflowAccounts, cashflowAccountDelete)) {
					LevelList = LevelListAll;
					OLAPDataArea targetDataArea = OLAPCreateDataArea(connection, targetCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
					                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
					                                                 sourceTime,
					                                                 sourceCycle,
					                                                 sourceVersion,
					                                                 LevelList,
					                                                 OlapDataAreaBCells, // BPDSTEP
					                                                 entities,
					                                                 OlapDataAreaBCells, // BPDINTERCOMPANY
					                                                 OlapDataAreaBCells, // BPDORGANIZATION
					                                                 currenList, // BPDCURRENCY
					                                                 OlapDataAreaBCells, // BPDPSEGMENT
					                                                 OlapDataAreaBCells, // BPDSSEGMENT
					                                                 OlapDataAreaBCells, // BPDTSEGMENT
					                                                 cashflowAccountDelete,
					                                                 OlapDataAreaBCells, // BPDANALYSIS_01
					                                                 OlapDataAreaBCells, // BPDANALYSIS_02
					                                                 OlapDataAreaBCells, // BPDANALYSIS_03
					                                                 OlapDataAreaBCells, // BPDANALYSIS_04
					                                                 OlapDataAreaBCells, // BPDANALYSIS_05
					                                                 OlapDataAreaBCells, // BPDANALYSIS_06
					                                                 OlapDataAreaBCells, // BPDANALYSIS_07
					                                                 OlapDataAreaBCells, // BPDANALYSIS_08
					                                                 OlapDataAreaBCells, // BPDANALYSIS_09
					                                                 OlapDataAreaBCells, // BPDANALYSIS_10
					                                                 OlapDataAreaBCells, // BPDANALYSIS_11
					                                                 OlapDataAreaBCells // BPDANALYSIS_12
					                                                );
					OLAPDeleteDataArea(targetDataArea);
					OLAPElementListAddElement(clearedCashflowAccounts, cashflowAccountDelete);
				}
			}
			foreach (OLAPElement cashflowAccount in allCashflowAccounts where OLAPCubeCacheHasValue(configCache, 2, cashflowAccount)) {
				
				cfAccountConfigured = true;
				
				StringList  configuredAccounts = CreateStringList();
				Append(configuredAccounts, """");
				StringList  configuredDetails = CreateStringList();
				Append(configuredDetails, """");

				OLAPDataArea configDataArea = OLAPCreateDataArea(connection, configCube,
				                                                 OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                 timeElement, sourceCycle,sourceVersion, allDetails, allAccounts, cashflowAccount, ""WEIGHT"");
				foreach (OLAPCell cell in configDataArea)
				{
					string account = OLAPCellGetElement(cell, accountDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string weighttxt = cell;
					if (weighttxt != """")
					{
						AppendDistinct(configuredAccounts,account);
						AppendDistinct(configuredDetails,detail);
					}
				}

				double numberaccount = Count(configuredAccounts) ;

				
				// Process by cash flow account type
				double accountType =  OLAPCellReadNumber(connection, configCube, 1, timeElement, sourceCycle, sourceVersion, cashflowDetailElement, cashflowAccountElement, cashflowAccount, ""TYPE"");


				if (accountType == 1 or accountType == 2 or accountType == 3) {
					StringList  detailsToDataArea = CreateStringList();
					if(accountType == 1)
					{
						detailsToDataArea = configuredDetails;
						LevelList = LevelListAll;

					}
					if(accountType == 2)
					{
						detailsToDataArea = ConvertToStringList(OlapDataAreaBCells);
						LevelList = LevelListAll;
					}

					if(accountType == 3)
					{

						detailsToDataArea = detailsWithoutOB;
						LevelList = LevelListMovements;
					}

					//LogDebug(functionName + "" Top of accountType="" + accountType);
					if(Count(configuredAccounts) != 1) {
						// Need a source DataArea to be processed
						OLAPDataArea sourceDataArea = OLAPCreateDataArea(connection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
						                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
						                                                 sourceTime,
						                                                 sourceCycle,
						                                                 sourceVersion,
						                                                 LevelList,
						                                                 OlapDataAreaBCells, // BPDSTEP
						                                                 entities,
						                                                 OlapDataAreaBCells, // BPDINTERCOMPANY
						                                                 OlapDataAreaBCells, // BPDORGANIZATION
						                                                 configuredAccounts, // BPDACCOUNT
						                                                 currenList, // BPDCURRENCY
						                                                 detailsToDataArea,//OlapDataAreaAllCells, // BPDDETAIL
						                                                 OlapDataAreaBCells, // BPDPSEGMENT
						                                                 OlapDataAreaBCells, // BPDSSEGMENT
						                                                 OlapDataAreaBCells, // BPDTSEGMENT
						                                                 OlapDataAreaBCells, // BPDANALYSIS_01
						                                                 OlapDataAreaBCells, // BPDANALYSIS_02
						                                                 OlapDataAreaBCells, // BPDANALYSIS_03
						                                                 OlapDataAreaBCells, // BPDANALYSIS_04
						                                                 OlapDataAreaBCells, // BPDANALYSIS_05
						                                                 OlapDataAreaBCells, // BPDANALYSIS_06
						                                                 OlapDataAreaBCells, // BPDANALYSIS_07
						                                                 OlapDataAreaBCells, // BPDANALYSIS_08
						                                                 OlapDataAreaBCells, // BPDANALYSIS_09
						                                                 OlapDataAreaBCells, // BPDANALYSIS_10
						                                                 OlapDataAreaBCells, // BPDANALYSIS_11
						                                                 OlapDataAreaBCells // BPDANALYSIS_12
						                                                );

						foreach (OLAPCell cell in sourceDataArea) {
							string account = OLAPCellGetElement(cell, accountDimension);
							string detail = OLAPCellGetElement(cell, detailDimension);
							double sourceValue = cell;
							//LogDebug("" account='"" + account + sourceValue + "" detail "" + detail);

							// only process detail N.A. for accountType 2/3
							if ( accountType == 1 or accountType == 2 or accountType == 3 ) {

								// if we have a configured combination, process it
								if ((accountType == 1 and """" !=  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, detail, account, cashflowAccount, ""WEIGHT"")) or accountType == 2 or accountType == 3 ) {
									string currency = OLAPCellGetElement(cell, currencyDimension);

									// only process local currencies

									string cycle = OLAPCellGetElement(cell, cycleDimension);
									string organization = OLAPCellGetElement(cell, organizationDimension);
									string entity = OLAPCellGetElement(cell, entityDimension);
									string time = OLAPCellGetElement(cell, timeDimension);
									string version = OLAPCellGetElement(cell, versionDimension);
									string level = OLAPCellGetElement(cell, levelDimension);
									string step = OLAPCellGetElement(cell, stepDimension);
									string interCompany = OLAPCellGetElement(cell, intercompanyDimension);
									string psegment = OLAPCellGetElement(cell, primarySegmentDimension);
									string ssegment = OLAPCellGetElement(cell, secondarySegmentDimension);
									string tsegment = OLAPCellGetElement(cell, tertiarySegmentDimension);
									string analysis01 = OLAPCellGetElement(cell, analysis01Dimension);
									string analysis02 = OLAPCellGetElement(cell, analysis02Dimension);
									string analysis03 = OLAPCellGetElement(cell, analysis03Dimension);
									string analysis04 = OLAPCellGetElement(cell, analysis04Dimension);
									string analysis05 = OLAPCellGetElement(cell, analysis05Dimension);
									string analysis06 = OLAPCellGetElement(cell, analysis06Dimension);
									string analysis07 = OLAPCellGetElement(cell, analysis07Dimension);
									string analysis08 = OLAPCellGetElement(cell, analysis08Dimension);
									string analysis09 = OLAPCellGetElement(cell, analysis09Dimension);
									string analysis10 = OLAPCellGetElement(cell, analysis10Dimension);
									string analysis11 = OLAPCellGetElement(cell, analysis11Dimension);
									string analysis12 = OLAPCellGetElement(cell, analysis12Dimension);
									

									// Expense account values must be multiplied by -1 for proper Cash Flow handling
									string BPAccountType =  OLAPGetStringAttribute(connection, accountDimension, account, ""ACCTYPE"");
									double accountWeight = 1;
									if (BPAccountType == ""E"") {
										accountWeight = -1;
									}
									string weightText = """";
									if(accountType == 1)
									{
										weightText =  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, detail, account, cashflowAccount, ""WEIGHT"");
									}
									else
									{
										weightText =  OLAPCellReadString(connection, configCube, timeElement, sourceCycle, sourceVersion, ""N.A."", account, cashflowAccount, ""WEIGHT"");
									}

									if (weightText != """") {
										double weightValue = ToInt(weightText);

										// Write calculated value
										if (RoundDecimals(sourceValue, 2) != 0) {

											double totalValue = (sourceValue * accountWeight*weightValue); //+ targetValue;
											
											OLAPCellWriteBufferIncrementNumber(buffer, targetCube, totalValue, time, cycle, version, level, step, entity, interCompany, organization, currency,
											                                   psegment, ssegment, tsegment,
											                                   cashflowAccount,
											                                   analysis01, analysis02, analysis03, analysis04, analysis05, analysis06, analysis07, analysis08, analysis09, analysis10, analysis11, analysis12
											                                  );
											numberOfValues = numberOfValues + 1;


											//LogDebug(functionName + "" Writing value="" + totalValue + "" for Account="" + account  + "", Detail="" + detail + "", Weight="" + weightText + "", sourceValue="" + sourceValue + "", targetValue="" + targetValue);
										}

										processedData = true; // We actually processed some data
									} // if weightText
								} // if count of account is not 0
							} // if configured account/detail/cashflowAccount
						} // detail must be N.A. for accountType 2/3
					} // end of foreach cell
				} // if accountType is 1/2/3
			} // foreach cashflow Account
			NotifyInformation(""Number of financial data transferred to cashflow: "" + numberOfValues);
			totalValues =totalValues+numberOfValues;
		}//foreach version

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(functionName + "" finished transfering values.  processedData="" + processedData);

		string result = CF_TransferOpeningBalances(connection, sourceCube, targetCube, times, sourceCycle, versions, entities);
		NotifyInformation(""Transfer of financial data to cashflow finished."");
		if (StringStartsWith(result, ""ERROR"")) {
			LogError(functionName + "" CF_TransferOpeningBalances returned "" + result);
			RaiseError(result, 1);
		}
		if (!cfAccountConfigured) {
			return ""-1"";
		}
		else if (!processedData) {
			return ""-2"";
		} else {
			return ""0"";
		}
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""-1"";
}"	1	640A08BA-38B8-46FA-A811-172D5EB60EBD	This function is used to calculate Cashflow from Budgeting and Planning, writing to the Cashflow cube based upon configuration.	1	1	1	1635	NULL	0	45708.67504	0	0
57FE0725-9319-475D-A1B1-2B6B9E33751D	CD491758-D9DF-4002-94C8-8006E1855F86	CF_CalculateCurrencyConversion	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server and database to connect to in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCube"" parameter-type=""string"" parameter-description=""OLAP cube containing the data"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""Planning Configuration Set unique name"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceEntityUN"" parameter-type=""string"" parameter-description=""Entity element unique name"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""sourceYearsUN"" parameter-type=""string"" parameter-description=""Comma delimited list of Year unique names from the TIME dimension"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""sourceVersionUN"" parameter-type=""string"" parameter-description=""Version element unique name"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetEntityCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetEntityCurrency"", ""*""
#include ""BP_GetTopElement"", ""*""

string CF_CalculateCurrencyConversion(
	string server,
	string ticket,
	string sourceCube,
	string sourceCycleUN,
	string sourceEntityUN,
	string sourceYearsUN,
	string sourceVersionUN
)
@Description: ""Calculate the difference in cash flow data due to exchange rate differences."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""OLAP cube containing the data"";
@Parameter[sourceCycleUN]: ""Planning Configuration Set unique name"";
@Parameter[sourceEntityUN]: ""Entity element unique name"";
@Parameter[sourceYearsUN]: ""Comma delimited list of Year unique names from the TIME dimension"";
@Parameter[sourceVersionUN]: ""Version element unique name"";
{

	string functionName = ""CF_CalculateCurrencyConversion:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		LogDebug(functionName + "" starting"");

		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define cubes, dimension and element names
		string cashflowCube = ""CFCCASHFLOW"";
		string accountDimension = ""BPDACCOUNT"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";
		string NA = ""N.A."";
		string cashflowDetailElement = NA;
		string stepElement = ""BASE_STEP""; // One day may be passed in

		string topDetailAccount = ToString(BP_GetTopElement(connection, detailDimension));
		string topIntercompanyElement = ToString(BP_GetTopElement(connection, intercompanyDimension));
		string topLevelChangeElement = ""TOTAL_CHANGE"";
		string topLevelElement = ToString(BP_GetTopElement(connection, levelDimension));
		string topOrganizationElement = ToString(BP_GetTopElement(connection, organizationDimension));
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));
		string topAnalysis01Element = ToString(BP_GetTopElement(connection, analysis01Dimension));
		string topAnalysis02Element = ToString(BP_GetTopElement(connection, analysis02Dimension));
		string topAnalysis03Element = ToString(BP_GetTopElement(connection, analysis03Dimension));
		string topAnalysis04Element = ToString(BP_GetTopElement(connection, analysis04Dimension));
		string topAnalysis05Element = ToString(BP_GetTopElement(connection, analysis05Dimension));
		string topAnalysis06Element = ToString(BP_GetTopElement(connection, analysis06Dimension));
		string topAnalysis07Element = ToString(BP_GetTopElement(connection, analysis07Dimension));
		string topAnalysis08Element = ToString(BP_GetTopElement(connection, analysis08Dimension));
		string topAnalysis09Element = ToString(BP_GetTopElement(connection, analysis09Dimension));
		string topAnalysis10Element = ToString(BP_GetTopElement(connection, analysis10Dimension));
		string topAnalysis11Element = ToString(BP_GetTopElement(connection, analysis11Dimension));
		string topAnalysis12Element = ToString(BP_GetTopElement(connection, analysis12Dimension));

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
		string sourceVersion = ResolveUniqueName(connection, sourceVersionUN);
		StringArray sourceYears = CF_ElementStringSplit(sourceYearsUN);

		// Need to get base periods for the years
		OLAPElementList sourcePeriods = CreateOLAPElementList();
		string sourceYear = """";
		int x = 0;
		while (x &lt; Count(sourceYears)) {
			sourceYear = ResolveUniqueName(connection, sourceYears[x]);
			OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, sourceYear, true);
			foreach (OLAPElement period in periods) {
				OLAPElementListAddElement(sourcePeriods, period);
			}

			x = x + 1;
		}


		/*
			Step 1: Validation of cash flow based on local currency
		 		- Check sum has to be ""0"": Check sum = Value 1 - Value 2
		 		- Loop for each month (of selected year or for whole planning cycle)
			Value 1: Change of ""Cash account"" in BPCMAIN in current period compared (minus) to period 12 / previous year
			Value 2: Net increase / decrease of in cash in cashflow cube CFCCASHFLOW
		 */

		// Read some configuration
		string cashAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CASH"", ""Value"");
		string netChangeCashAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CHANGE_CASH"", ""Value"");
		string currencyDifferenceAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CURR_DIFF"", ""Value"");
		string entityCurrency = BP_GetEntityCurrency(connection, sourceCycle, NA, sourceEntity, NA);
		if (entityCurrency == """" or StringStartsWith(entityCurrency, ""ERROR"")) {
			string msg = "" Could not find configured currency for entity "" + sourceEntity + "" : "" + entityCurrency;
			LogError(functionName + msg);
			RaiseError(msg, 1);
		} else if (StringStartsWith(entityCurrency, ""["")) {
			entityCurrency = ResolveUniqueName(connection, entityCurrency);
		}

		LogDebug(functionName + "" starting Validation step"");

		bool valid = true;

		foreach (OLAPElement period in sourcePeriods) {
			double value1Part1 = OLAPCellReadNumber(connection, sourceCube, 1,
			                                        period,
			                                        sourceCycle,
			                                        sourceVersion,
			                                        topLevelChangeElement,
			                                        stepElement,
			                                        sourceEntity,
			                                        topIntercompanyElement,
			                                        topOrganizationElement,
			                                        cashAccount,
			                                        entityCurrency,
			                                        topDetailAccount,
			                                        topPSegmentElement,
			                                        topSSegmentElement,
			                                        topTSegmentElement,
			                                        topAnalysis01Element,
			                                        topAnalysis02Element,
			                                        topAnalysis03Element,
			                                        topAnalysis04Element,
			                                        topAnalysis05Element,
			                                        topAnalysis06Element,
			                                        topAnalysis07Element,
			                                        topAnalysis08Element,
			                                        topAnalysis09Element,
			                                        topAnalysis10Element,
			                                        topAnalysis11Element,
			                                        topAnalysis12Element
			                                       );

			string priorYearPeriod12UN = OLAPGetStringAttribute(connection, timeDimension, period, ""LAST_MONTH_PREVIOUS_YEAR"");
			double value1Part2 = 0.0; // default value

			if (priorYearPeriod12UN != """") {
				string priorYearPeriod12 = ResolveUniqueName(connection, priorYearPeriod12UN);
				value1Part2 = OLAPCellReadNumber(connection, sourceCube, 1,
				                                 priorYearPeriod12,
				                                 sourceCycle,
				                                 sourceVersion,
				                                 topLevelChangeElement,
				                                 stepElement,
				                                 sourceEntity,
				                                 topIntercompanyElement,
				                                 topOrganizationElement,
				                                 cashAccount,
				                                 entityCurrency,
				                                 topDetailAccount,
				                                 topPSegmentElement,
				                                 topSSegmentElement,
				                                 topTSegmentElement,
				                                 topAnalysis01Element,
				                                 topAnalysis02Element,
				                                 topAnalysis03Element,
				                                 topAnalysis04Element,
				                                 topAnalysis05Element,
				                                 topAnalysis06Element,
				                                 topAnalysis07Element,
				                                 topAnalysis08Element,
				                                 topAnalysis09Element,
				                                 topAnalysis10Element,
				                                 topAnalysis11Element,
				                                 topAnalysis12Element
				                                );
			}

			double value1 = value1Part1 - value1Part2;

			double value2 = OLAPCellReadNumber(connection, cashflowCube, 1,
			                                   period,
			                                   sourceCycle,
			                                   sourceVersion,
			                                   topLevelChangeElement,
			                                   stepElement,
			                                   sourceEntity,
			                                   topIntercompanyElement,
			                                   topOrganizationElement,
			                                   entityCurrency,
			                                   topPSegmentElement,
			                                   topSSegmentElement,
			                                   topTSegmentElement,
			                                   netChangeCashAccount,
			                                   topAnalysis01Element,
			                                   topAnalysis02Element,
			                                   topAnalysis03Element,
			                                   topAnalysis04Element,
			                                   topAnalysis05Element,
			                                   topAnalysis06Element,
			                                   topAnalysis07Element,
			                                   topAnalysis08Element,
			                                   topAnalysis09Element,
			                                   topAnalysis10Element,
			                                   topAnalysis11Element,
			                                   topAnalysis12Element
			                                  );

			//LogDebug(functionName + "" Validation: Period "" + period + "", ("" + value1Part1 + "" - "" + value1Part2 + "") - "" + value2 + "" = "" + (value1 - value2));
			if (value1 - value2 != 0) {
				valid = false;
			}
		} // foreach period


		// If data passed validation, perform the currency conversion calculation
		if (valid) {
			//LogDebug(functionName + "" starting currency conversion calculation"");
			/*
				Step 2: Calculation of currency difference
					- should only be started if validation 1 is true for selected company / version / cycle for each period (month)
					- The calculation is based on nearly the same logic for calculating check sum in step 1, the main difference are references in BPDTIME (YTD instead of monthly based values), BPDLEVEL (Change or Total) and BPDCURRENCY (global currency instead of local)
					- Loop for each month (of selected year or for whole planning cycle) and for each currency
					- CalcDiff = Value 1 - Value 2
				 
				Value 1: Change of ""Cash account"" in BPCMAIN in current period YTD compared (minus) to period 12 / previous year YTD
				Value 2: Net increase / decrease of in cash in cashflow cube CFCCASHFLOW YTD
			 */

			OLAPElementList currencies = OLAPGetElementList(connection, currencyDimension, true);

			// processing each period
			foreach (OLAPElement period in sourcePeriods) {
				string ytdPeriod = period + ""_YTD"";

				// only process non-local currencies
				foreach (OLAPElement currency in currencies where !StringEndsWith(ToString(currency), ""_LC"")) {
					double value1Part1 = OLAPCellReadNumber(connection, sourceCube, 1,
					                                        ytdPeriod,
					                                        sourceCycle,
					                                        sourceVersion,
					                                        topLevelElement,
					                                        stepElement,
					                                        sourceEntity,
					                                        topIntercompanyElement,
					                                        topOrganizationElement,
					                                        cashAccount,
					                                        currency,
					                                        topDetailAccount,
					                                        topPSegmentElement,
					                                        topSSegmentElement,
					                                        topTSegmentElement,
					                                        topAnalysis01Element,
					                                        topAnalysis02Element,
					                                        topAnalysis03Element,
					                                        topAnalysis04Element,
					                                        topAnalysis05Element,
					                                        topAnalysis06Element,
					                                        topAnalysis07Element,
					                                        topAnalysis08Element,
					                                        topAnalysis09Element,
					                                        topAnalysis10Element,
					                                        topAnalysis11Element,
					                                        topAnalysis12Element
					                                       );

					string priorYearPeriod12UN = OLAPGetStringAttribute(connection, timeDimension, period, ""LAST_MONTH_PREVIOUS_YEAR_YTD"");
					double value1Part2 = 0.0; // default value

					if (priorYearPeriod12UN != """") {
						string priorYearPeriod12 = ResolveUniqueName(connection, priorYearPeriod12UN);
						value1Part2 = OLAPCellReadNumber(connection, sourceCube, 1,
						                                 priorYearPeriod12,
						                                 sourceCycle,
						                                 sourceVersion,
						                                 topLevelElement,
						                                 stepElement,
						                                 sourceEntity,
						                                 topIntercompanyElement,
						                                 topOrganizationElement,
						                                 cashAccount,
						                                 currency,
						                                 topDetailAccount,
						                                 topPSegmentElement,
						                                 topSSegmentElement,
						                                 topTSegmentElement,
						                                 topAnalysis01Element,
						                                 topAnalysis02Element,
						                                 topAnalysis03Element,
						                                 topAnalysis04Element,
						                                 topAnalysis05Element,
						                                 topAnalysis06Element,
						                                 topAnalysis07Element,
						                                 topAnalysis08Element,
						                                 topAnalysis09Element,
						                                 topAnalysis10Element,
						                                 topAnalysis11Element,
						                                 topAnalysis12Element
						                                );
					}

					double value1 = value1Part1 - value1Part2;

					double value2 = OLAPCellReadNumber(connection, cashflowCube, 1,
					                                   ytdPeriod,
					                                   sourceCycle,
					                                   sourceVersion,
					                                   topLevelChangeElement,
					                                   stepElement,
					                                   sourceEntity,
					                                   topIntercompanyElement,
					                                   topOrganizationElement,
					                                   entityCurrency,
					                                   topPSegmentElement,
					                                   topSSegmentElement,
					                                   topTSegmentElement,
					                                   netChangeCashAccount,
					                                   topAnalysis01Element,
					                                   topAnalysis02Element,
					                                   topAnalysis03Element,
					                                   topAnalysis04Element,
					                                   topAnalysis05Element,
					                                   topAnalysis06Element,
					                                   topAnalysis07Element,
					                                   topAnalysis08Element,
					                                   topAnalysis09Element,
					                                   topAnalysis10Element,
					                                   topAnalysis11Element,
					                                   topAnalysis12Element
					                                  );

					double difference = value1 - value2;
					//LogDebug(functionName + "" Calculated Currency Difference: Period "" + ytdPeriod + "", ("" + value1Part1 + "" - "" + value1Part2 + "") - "" + value2 + "" = "" + difference);

					// Now store the difference
					OLAPCellWriteNumber(connection, cashflowCube, difference,
					                    period,
					                    sourceCycle,
					                    sourceVersion,
					                    ""CALC_CF_CURRDIFF"", // Level
					                    NA, // Step
					                    sourceEntity,
					                    ""EXTERNAL"", // Intercompany
					                    NA, // Organization
					                    entityCurrency,
					                    NA, // PSEGMENT
					                    NA, // SSEGMENT
					                    NA, // TSEGMENT
					                    currencyDifferenceAccount, // CASHFLOW
					                    NA, // Analysis01
					                    NA, // Analysis02
					                    NA, // Analysis03
					                    NA, // Analysis04
					                    NA, // Analysis05
					                    NA, // Analysis06
					                    NA, // Analysis07
					                    NA, // Analysis08
					                    NA, // Analysis09
					                    NA, // Analysis10
					                    NA, // Analysis11
					                    NA // Analysis12
					                   );

				} // foreach global currency
			} // foreach period
		} // if valid
		else {
			LogDebug(functionName + "" not valid"");
		}

		LogDebug(functionName + "" finished calculating currency conversion"");
		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""BP_GetEntityCurrency"", ""*""
#include ""BP_GetTopElement"", ""*""

string CF_CalculateCurrencyConversion(
	string server,
	string ticket,
	string sourceCube,
	string sourceCycleUN,
	string sourceEntityUN,
	string sourceYearsUN,
	string sourceVersionUN
)
@Description: ""Calculate the difference in cash flow data due to exchange rate differences."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""OLAP cube containing the data"";
@Parameter[sourceCycleUN]: ""Planning Configuration Set unique name"";
@Parameter[sourceEntityUN]: ""Entity element unique name"";
@Parameter[sourceYearsUN]: ""Comma delimited list of Year unique names from the TIME dimension"";
@Parameter[sourceVersionUN]: ""Version element unique name"";
{

	string functionName = ""CF_CalculateCurrencyConversion:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		LogDebug(functionName + "" starting"");

		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define cubes, dimension and element names
		string cashflowCube = ""CFCCASHFLOW"";
		string accountDimension = ""BPDACCOUNT"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";
		string NA = ""N.A."";
		string cashflowDetailElement = NA;
		string stepElement = ""BASE_STEP""; // One day may be passed in

		string topDetailAccount = ToString(BP_GetTopElement(connection, detailDimension));
		string topIntercompanyElement = ToString(BP_GetTopElement(connection, intercompanyDimension));
		string topLevelChangeElement = ""TOTAL_CHANGE"";
		string topLevelElement = ToString(BP_GetTopElement(connection, levelDimension));
		string topOrganizationElement = ToString(BP_GetTopElement(connection, organizationDimension));
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));
		string topAnalysis01Element = ToString(BP_GetTopElement(connection, analysis01Dimension));
		string topAnalysis02Element = ToString(BP_GetTopElement(connection, analysis02Dimension));
		string topAnalysis03Element = ToString(BP_GetTopElement(connection, analysis03Dimension));
		string topAnalysis04Element = ToString(BP_GetTopElement(connection, analysis04Dimension));
		string topAnalysis05Element = ToString(BP_GetTopElement(connection, analysis05Dimension));
		string topAnalysis06Element = ToString(BP_GetTopElement(connection, analysis06Dimension));
		string topAnalysis07Element = ToString(BP_GetTopElement(connection, analysis07Dimension));
		string topAnalysis08Element = ToString(BP_GetTopElement(connection, analysis08Dimension));
		string topAnalysis09Element = ToString(BP_GetTopElement(connection, analysis09Dimension));
		string topAnalysis10Element = ToString(BP_GetTopElement(connection, analysis10Dimension));
		string topAnalysis11Element = ToString(BP_GetTopElement(connection, analysis11Dimension));
		string topAnalysis12Element = ToString(BP_GetTopElement(connection, analysis12Dimension));

		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string sourceEntity = ResolveUniqueName(connection, sourceEntityUN);
		string sourceVersion = ResolveUniqueName(connection, sourceVersionUN);
		StringArray sourceYears = CF_ElementStringSplit(sourceYearsUN);

		// Need to get base periods for the years
		OLAPElementList sourcePeriods = CreateOLAPElementList();
		string sourceYear = """";
		int x = 0;
		while (x < Count(sourceYears)) {
			sourceYear = ResolveUniqueName(connection, sourceYears[x]);
			OLAPElementList periods = OLAPGetChildElementList(connection, timeDimension, sourceYear, true);
			foreach (OLAPElement period in periods) {
				OLAPElementListAddElement(sourcePeriods, period);
			}

			x = x + 1;
		}


		/*
			Step 1: Validation of cash flow based on local currency
		 		- Check sum has to be ""0"": Check sum = Value 1 - Value 2
		 		- Loop for each month (of selected year or for whole planning cycle)
			Value 1: Change of ""Cash account"" in BPCMAIN in current period compared (minus) to period 12 / previous year
			Value 2: Net increase / decrease of in cash in cashflow cube CFCCASHFLOW
		 */

		// Read some configuration
		string cashAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CASH"", ""Value"");
		string netChangeCashAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CHANGE_CASH"", ""Value"");
		string currencyDifferenceAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CURR_DIFF"", ""Value"");
		string entityCurrency = BP_GetEntityCurrency(connection, sourceCycle, NA, sourceEntity, NA);
		if (entityCurrency == """" or StringStartsWith(entityCurrency, ""ERROR"")) {
			string msg = "" Could not find configured currency for entity "" + sourceEntity + "" : "" + entityCurrency;
			LogError(functionName + msg);
			RaiseError(msg, 1);
		} else if (StringStartsWith(entityCurrency, ""["")) {
			entityCurrency = ResolveUniqueName(connection, entityCurrency);
		}

		LogDebug(functionName + "" starting Validation step"");

		bool valid = true;

		foreach (OLAPElement period in sourcePeriods) {
			double value1Part1 = OLAPCellReadNumber(connection, sourceCube, 1,
			                                        period,
			                                        sourceCycle,
			                                        sourceVersion,
			                                        topLevelChangeElement,
			                                        stepElement,
			                                        sourceEntity,
			                                        topIntercompanyElement,
			                                        topOrganizationElement,
			                                        cashAccount,
			                                        entityCurrency,
			                                        topDetailAccount,
			                                        topPSegmentElement,
			                                        topSSegmentElement,
			                                        topTSegmentElement,
			                                        topAnalysis01Element,
			                                        topAnalysis02Element,
			                                        topAnalysis03Element,
			                                        topAnalysis04Element,
			                                        topAnalysis05Element,
			                                        topAnalysis06Element,
			                                        topAnalysis07Element,
			                                        topAnalysis08Element,
			                                        topAnalysis09Element,
			                                        topAnalysis10Element,
			                                        topAnalysis11Element,
			                                        topAnalysis12Element
			                                       );

			string priorYearPeriod12UN = OLAPGetStringAttribute(connection, timeDimension, period, ""LAST_MONTH_PREVIOUS_YEAR"");
			double value1Part2 = 0.0; // default value

			if (priorYearPeriod12UN != """") {
				string priorYearPeriod12 = ResolveUniqueName(connection, priorYearPeriod12UN);
				value1Part2 = OLAPCellReadNumber(connection, sourceCube, 1,
				                                 priorYearPeriod12,
				                                 sourceCycle,
				                                 sourceVersion,
				                                 topLevelChangeElement,
				                                 stepElement,
				                                 sourceEntity,
				                                 topIntercompanyElement,
				                                 topOrganizationElement,
				                                 cashAccount,
				                                 entityCurrency,
				                                 topDetailAccount,
				                                 topPSegmentElement,
				                                 topSSegmentElement,
				                                 topTSegmentElement,
				                                 topAnalysis01Element,
				                                 topAnalysis02Element,
				                                 topAnalysis03Element,
				                                 topAnalysis04Element,
				                                 topAnalysis05Element,
				                                 topAnalysis06Element,
				                                 topAnalysis07Element,
				                                 topAnalysis08Element,
				                                 topAnalysis09Element,
				                                 topAnalysis10Element,
				                                 topAnalysis11Element,
				                                 topAnalysis12Element
				                                );
			}

			double value1 = value1Part1 - value1Part2;

			double value2 = OLAPCellReadNumber(connection, cashflowCube, 1,
			                                   period,
			                                   sourceCycle,
			                                   sourceVersion,
			                                   topLevelChangeElement,
			                                   stepElement,
			                                   sourceEntity,
			                                   topIntercompanyElement,
			                                   topOrganizationElement,
			                                   entityCurrency,
			                                   topPSegmentElement,
			                                   topSSegmentElement,
			                                   topTSegmentElement,
			                                   netChangeCashAccount,
			                                   topAnalysis01Element,
			                                   topAnalysis02Element,
			                                   topAnalysis03Element,
			                                   topAnalysis04Element,
			                                   topAnalysis05Element,
			                                   topAnalysis06Element,
			                                   topAnalysis07Element,
			                                   topAnalysis08Element,
			                                   topAnalysis09Element,
			                                   topAnalysis10Element,
			                                   topAnalysis11Element,
			                                   topAnalysis12Element
			                                  );

			//LogDebug(functionName + "" Validation: Period "" + period + "", ("" + value1Part1 + "" - "" + value1Part2 + "") - "" + value2 + "" = "" + (value1 - value2));
			if (value1 - value2 != 0) {
				valid = false;
			}
		} // foreach period


		// If data passed validation, perform the currency conversion calculation
		if (valid) {
			//LogDebug(functionName + "" starting currency conversion calculation"");
			/*
				Step 2: Calculation of currency difference
					- should only be started if validation 1 is true for selected company / version / cycle for each period (month)
					- The calculation is based on nearly the same logic for calculating check sum in step 1, the main difference are references in BPDTIME (YTD instead of monthly based values), BPDLEVEL (Change or Total) and BPDCURRENCY (global currency instead of local)
					- Loop for each month (of selected year or for whole planning cycle) and for each currency
					- CalcDiff = Value 1 - Value 2
				 
				Value 1: Change of ""Cash account"" in BPCMAIN in current period YTD compared (minus) to period 12 / previous year YTD
				Value 2: Net increase / decrease of in cash in cashflow cube CFCCASHFLOW YTD
			 */

			OLAPElementList currencies = OLAPGetElementList(connection, currencyDimension, true);

			// processing each period
			foreach (OLAPElement period in sourcePeriods) {
				string ytdPeriod = period + ""_YTD"";

				// only process non-local currencies
				foreach (OLAPElement currency in currencies where !StringEndsWith(ToString(currency), ""_LC"")) {
					double value1Part1 = OLAPCellReadNumber(connection, sourceCube, 1,
					                                        ytdPeriod,
					                                        sourceCycle,
					                                        sourceVersion,
					                                        topLevelElement,
					                                        stepElement,
					                                        sourceEntity,
					                                        topIntercompanyElement,
					                                        topOrganizationElement,
					                                        cashAccount,
					                                        currency,
					                                        topDetailAccount,
					                                        topPSegmentElement,
					                                        topSSegmentElement,
					                                        topTSegmentElement,
					                                        topAnalysis01Element,
					                                        topAnalysis02Element,
					                                        topAnalysis03Element,
					                                        topAnalysis04Element,
					                                        topAnalysis05Element,
					                                        topAnalysis06Element,
					                                        topAnalysis07Element,
					                                        topAnalysis08Element,
					                                        topAnalysis09Element,
					                                        topAnalysis10Element,
					                                        topAnalysis11Element,
					                                        topAnalysis12Element
					                                       );

					string priorYearPeriod12UN = OLAPGetStringAttribute(connection, timeDimension, period, ""LAST_MONTH_PREVIOUS_YEAR_YTD"");
					double value1Part2 = 0.0; // default value

					if (priorYearPeriod12UN != """") {
						string priorYearPeriod12 = ResolveUniqueName(connection, priorYearPeriod12UN);
						value1Part2 = OLAPCellReadNumber(connection, sourceCube, 1,
						                                 priorYearPeriod12,
						                                 sourceCycle,
						                                 sourceVersion,
						                                 topLevelElement,
						                                 stepElement,
						                                 sourceEntity,
						                                 topIntercompanyElement,
						                                 topOrganizationElement,
						                                 cashAccount,
						                                 currency,
						                                 topDetailAccount,
						                                 topPSegmentElement,
						                                 topSSegmentElement,
						                                 topTSegmentElement,
						                                 topAnalysis01Element,
						                                 topAnalysis02Element,
						                                 topAnalysis03Element,
						                                 topAnalysis04Element,
						                                 topAnalysis05Element,
						                                 topAnalysis06Element,
						                                 topAnalysis07Element,
						                                 topAnalysis08Element,
						                                 topAnalysis09Element,
						                                 topAnalysis10Element,
						                                 topAnalysis11Element,
						                                 topAnalysis12Element
						                                );
					}

					double value1 = value1Part1 - value1Part2;

					double value2 = OLAPCellReadNumber(connection, cashflowCube, 1,
					                                   ytdPeriod,
					                                   sourceCycle,
					                                   sourceVersion,
					                                   topLevelChangeElement,
					                                   stepElement,
					                                   sourceEntity,
					                                   topIntercompanyElement,
					                                   topOrganizationElement,
					                                   entityCurrency,
					                                   topPSegmentElement,
					                                   topSSegmentElement,
					                                   topTSegmentElement,
					                                   netChangeCashAccount,
					                                   topAnalysis01Element,
					                                   topAnalysis02Element,
					                                   topAnalysis03Element,
					                                   topAnalysis04Element,
					                                   topAnalysis05Element,
					                                   topAnalysis06Element,
					                                   topAnalysis07Element,
					                                   topAnalysis08Element,
					                                   topAnalysis09Element,
					                                   topAnalysis10Element,
					                                   topAnalysis11Element,
					                                   topAnalysis12Element
					                                  );

					double difference = value1 - value2;
					//LogDebug(functionName + "" Calculated Currency Difference: Period "" + ytdPeriod + "", ("" + value1Part1 + "" - "" + value1Part2 + "") - "" + value2 + "" = "" + difference);

					// Now store the difference
					OLAPCellWriteNumber(connection, cashflowCube, difference,
					                    period,
					                    sourceCycle,
					                    sourceVersion,
					                    ""CALC_CF_CURRDIFF"", // Level
					                    NA, // Step
					                    sourceEntity,
					                    ""EXTERNAL"", // Intercompany
					                    NA, // Organization
					                    entityCurrency,
					                    NA, // PSEGMENT
					                    NA, // SSEGMENT
					                    NA, // TSEGMENT
					                    currencyDifferenceAccount, // CASHFLOW
					                    NA, // Analysis01
					                    NA, // Analysis02
					                    NA, // Analysis03
					                    NA, // Analysis04
					                    NA, // Analysis05
					                    NA, // Analysis06
					                    NA, // Analysis07
					                    NA, // Analysis08
					                    NA, // Analysis09
					                    NA, // Analysis10
					                    NA, // Analysis11
					                    NA // Analysis12
					                   );

				} // foreach global currency
			} // foreach period
		} // if valid
		else {
			LogDebug(functionName + "" not valid"");
		}

		LogDebug(functionName + "" finished calculating currency conversion"");
		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}

	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	9495C243-05B8-4455-A165-0C128AEA82FF	Calculate the difference in cash flow data due to exchange rate differences.	1	1	1	1636	NULL	0	45708.67502	0	0
C6114C7A-136A-46BC-80C3-59F84C09FA58	CD491758-D9DF-4002-94C8-8006E1855F86	CF_CopyConfiguration	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""The OLAP server and database to connect to in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""cube"" parameter-type=""string"" parameter-description=""The OLAP cube containing the Cash Flow configuration data to be copied"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration Set element to copy from"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceVersionUN"" parameter-type=""string"" parameter-description=""The source Version element(s) to copy from. If multiples, must be comma separated"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration Set element to copy to"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetVersionUN"" parameter-type=""string"" parameter-description=""The target Version element to copy to. If multiples, must be comma separated"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

string CF_CopyConfiguration(
	string server,
	string ticket,
	string cube,
	string sourceCycleUN,
	string sourceVersionUN,
	string targetCycleUN,
	string targetVersionUN)
@Description: ""This function is used to copy Cash Flow configuration from one Configuration Set/Version to another."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The OLAP cube containing the Cash Flow configuration data to be copied"";
@Parameter[sourceCycleUN]: ""The source Configuration Set element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element(s) to copy from. If multiples, must be comma separated"";
@Parameter[targetCycleUN]: ""The target Configuration Set element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to. If multiples, must be comma separated"";
{
	string functionName = ""CF_CopyConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define dimension and cubes names
		string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
		string accountDimension = ""BPDACCOUNT"";
		string cashflowDimension = ""CFDCASHFLOW"";
		string cashflowConfigDimension = ""CFDCONFIG_CASHFLOW"";
		string detailDimension = ""BPDDETAIL"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";
		string NA = ""N.A."";

		// Resolve Cycle identifiers
		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		// The source and target Version parameters may contain multiple selections.  Need to parse them and loop throught the resulting lists
		StringArray sourceVersions = CF_ElementStringSplit(sourceVersionUN);
		StringArray targetVersions = CreateStringArray();

		if (targetVersionUN != """") {
			targetVersions = CF_ElementStringSplit(targetVersionUN);
		} else {
			// Empty means target is all versions
			OLAPElementList versions = OLAPGetElementList(connection, versionDimension, true);

			foreach (OLAPElement version in versions) {
				if (ToString(version) != NA) { // Not NA
					double versionCompleted = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0,targetCycle,version, ""GLOBAL_CYCLE_VERSION_COMPLETED"", ""Value"");
					if(versionCompleted == 1)
					{
						Append(targetVersions, ToString(version));
					}

				}
			}

			OLAPElementList versionsActuals = OLAPGetChildElementList(connection, versionDimension,""TOTAL_ACTUAL"", true);
			foreach (OLAPElement version in versionsActuals)
			{
				AppendDistinct(targetVersions, ToString(version));
			}

		}

		// Make the arrays the same size for easier processing
		int sourceCount = Count(sourceVersions);
		int targetCount = Count(targetVersions);
		int x = 1;
		if (sourceCount &lt; targetCount) {
			while (sourceCount + x &lt;= targetCount) {
				Append(sourceVersions, sourceVersions[0]);
				x = x + 1;
			}
		}
		else if (sourceCount &gt; targetCount) {
			while (targetCount + x &lt;= sourceCount) {
				Append(targetVersions, sourceVersions[targetCount + x - 1]);
				x = x + 1;
			}
		}

		// now process the lists, copying source to target
		x = 0;
		while (x &lt; Count(sourceVersions)) {
			// Define variables and resolve unique names
			int counter = 0;
			string sourceVersion = sourceVersions[x];
			if (StringStartsWith(sourceVersion, ""["")) {
				sourceVersion = ResolveUniqueName(connection, sourceVersion);
			}

			string targetVersion = targetVersions[x];
			if (StringStartsWith(targetVersion, ""["")) {
				targetVersion = ResolveUniqueName(connection, targetVersion);
			}

			if (sourceCycle != targetCycle or sourceVersion != targetVersion) {
				LogInformation(functionName + "" Configuration Set '"" + sourceCycle + ""' Version '"" + sourceVersion + ""' -&gt; Configuration Set '"" + targetCycle + ""' Version '"" + targetVersion + ""'"");

				OLAPDataArea targetDataWeight = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaBCells,
				                                                   targetCycle,
				                                                   targetVersion,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaBCells,
				                                                   ""WEIGHT"");
				OLAPDeleteDataArea(targetDataWeight); // Clear destination

				OLAPDataArea sourceDataWeight = OLAPCreateDataArea(connection, cube,  OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaBCells,
				                                                   sourceCycle,
				                                                   sourceVersion,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaBCells,
				                                                   ""WEIGHT"");

				// Loop through the source data area and write to the destination data area
				foreach (OLAPCell cell in sourceDataWeight) {
					string time = OLAPCellGetElement(cell, timeDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string account = OLAPCellGetElement(cell, accountDimension);
					string cashflow = OLAPCellGetElement(cell, cashflowDimension);
					string value = OLAPCellReadString(connection, cube, time, sourceCycle, sourceVersion, detail, account, cashflow, ""WEIGHT"");

					OLAPCellWriteString(connection, cube, value, time, targetCycle, targetVersion, detail, account, cashflow, ""WEIGHT"");
					counter = counter + 1;
				}
				OLAPDataArea targetData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells,
				                                             targetCycle,
				                                             targetVersion,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             ""TYPE"");
				OLAPDeleteDataArea(targetData); // Clear destination

				OLAPDataArea sourceData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             ""TYPE"");

				// Loop through the source data area and write to the destination data area
				foreach (OLAPCell cell in sourceData) {
					string time = OLAPCellGetElement(cell, timeDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string account = OLAPCellGetElement(cell, accountDimension);
					string cashflow = OLAPCellGetElement(cell, cashflowDimension);
					string cashflowConfig = OLAPCellGetElement(cell, cashflowConfigDimension);
					double value = OLAPCellReadNumber(connection, cube,1.0, time, sourceCycle, sourceVersion, detail, account, cashflow, ""TYPE"");

					OLAPCellWriteNumber(connection, cube, value, time, targetCycle, targetVersion, detail, account, cashflow, ""TYPE"");
					counter = counter + 1;
				}
				LogInformation(functionName + "" Copied "" + counter + "" values"");
			}

			x = x + 1; // increment array element counter
		}

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

string CF_CopyConfiguration(
	string server,
	string ticket,
	string cube,
	string sourceCycleUN,
	string sourceVersionUN,
	string targetCycleUN,
	string targetVersionUN)
@Description: ""This function is used to copy Cash Flow configuration from one Configuration Set/Version to another."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[server]: ""The OLAP server and database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[cube]: ""The OLAP cube containing the Cash Flow configuration data to be copied"";
@Parameter[sourceCycleUN]: ""The source Configuration Set element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element(s) to copy from. If multiples, must be comma separated"";
@Parameter[targetCycleUN]: ""The target Configuration Set element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to. If multiples, must be comma separated"";
{
	string functionName = ""CF_CopyConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		// Define dimension and cubes names
		string CycleConfigurationCube = ""BPCCONFIG_CYCLE"";
		string accountDimension = ""BPDACCOUNT"";
		string cashflowDimension = ""CFDCASHFLOW"";
		string cashflowConfigDimension = ""CFDCONFIG_CASHFLOW"";
		string detailDimension = ""BPDDETAIL"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";
		string NA = ""N.A."";

		// Resolve Cycle identifiers
		string sourceCycle = ResolveUniqueName(connection, sourceCycleUN);
		string targetCycle = ResolveUniqueName(connection, targetCycleUN);

		// The source and target Version parameters may contain multiple selections.  Need to parse them and loop throught the resulting lists
		StringArray sourceVersions = CF_ElementStringSplit(sourceVersionUN);
		StringArray targetVersions = CreateStringArray();

		if (targetVersionUN != """") {
			targetVersions = CF_ElementStringSplit(targetVersionUN);
		} else {
			// Empty means target is all versions
			OLAPElementList versions = OLAPGetElementList(connection, versionDimension, true);

			foreach (OLAPElement version in versions) {
				if (ToString(version) != NA) { // Not NA
					double versionCompleted = OLAPCellReadNumber(connection, CycleConfigurationCube, 1.0,targetCycle,version, ""GLOBAL_CYCLE_VERSION_COMPLETED"", ""Value"");
					if(versionCompleted == 1)
					{
						Append(targetVersions, ToString(version));
					}

				}
			}

			OLAPElementList versionsActuals = OLAPGetChildElementList(connection, versionDimension,""TOTAL_ACTUAL"", true);
			foreach (OLAPElement version in versionsActuals)
			{
				AppendDistinct(targetVersions, ToString(version));
			}

		}

		// Make the arrays the same size for easier processing
		int sourceCount = Count(sourceVersions);
		int targetCount = Count(targetVersions);
		int x = 1;
		if (sourceCount < targetCount) {
			while (sourceCount + x <= targetCount) {
				Append(sourceVersions, sourceVersions[0]);
				x = x + 1;
			}
		}
		else if (sourceCount > targetCount) {
			while (targetCount + x <= sourceCount) {
				Append(targetVersions, sourceVersions[targetCount + x - 1]);
				x = x + 1;
			}
		}

		// now process the lists, copying source to target
		x = 0;
		while (x < Count(sourceVersions)) {
			// Define variables and resolve unique names
			int counter = 0;
			string sourceVersion = sourceVersions[x];
			if (StringStartsWith(sourceVersion, ""["")) {
				sourceVersion = ResolveUniqueName(connection, sourceVersion);
			}

			string targetVersion = targetVersions[x];
			if (StringStartsWith(targetVersion, ""["")) {
				targetVersion = ResolveUniqueName(connection, targetVersion);
			}

			if (sourceCycle != targetCycle or sourceVersion != targetVersion) {
				LogInformation(functionName + "" Configuration Set '"" + sourceCycle + ""' Version '"" + sourceVersion + ""' -> Configuration Set '"" + targetCycle + ""' Version '"" + targetVersion + ""'"");

				OLAPDataArea targetDataWeight = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaBCells,
				                                                   targetCycle,
				                                                   targetVersion,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaBCells,
				                                                   ""WEIGHT"");
				OLAPDeleteDataArea(targetDataWeight); // Clear destination

				OLAPDataArea sourceDataWeight = OLAPCreateDataArea(connection, cube,  OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                                   OlapDataAreaBCells,
				                                                   sourceCycle,
				                                                   sourceVersion,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaAllCells,
				                                                   OlapDataAreaBCells,
				                                                   ""WEIGHT"");

				// Loop through the source data area and write to the destination data area
				foreach (OLAPCell cell in sourceDataWeight) {
					string time = OLAPCellGetElement(cell, timeDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string account = OLAPCellGetElement(cell, accountDimension);
					string cashflow = OLAPCellGetElement(cell, cashflowDimension);
					string value = OLAPCellReadString(connection, cube, time, sourceCycle, sourceVersion, detail, account, cashflow, ""WEIGHT"");

					OLAPCellWriteString(connection, cube, value, time, targetCycle, targetVersion, detail, account, cashflow, ""WEIGHT"");
					counter = counter + 1;
				}
				OLAPDataArea targetData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells,
				                                             targetCycle,
				                                             targetVersion,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             ""TYPE"");
				OLAPDeleteDataArea(targetData); // Clear destination

				OLAPDataArea sourceData = OLAPCreateDataArea(connection, cube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             OlapDataAreaBCells,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             OlapDataAreaBCells,
				                                             ""TYPE"");

				// Loop through the source data area and write to the destination data area
				foreach (OLAPCell cell in sourceData) {
					string time = OLAPCellGetElement(cell, timeDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string account = OLAPCellGetElement(cell, accountDimension);
					string cashflow = OLAPCellGetElement(cell, cashflowDimension);
					string cashflowConfig = OLAPCellGetElement(cell, cashflowConfigDimension);
					double value = OLAPCellReadNumber(connection, cube,1.0, time, sourceCycle, sourceVersion, detail, account, cashflow, ""TYPE"");

					OLAPCellWriteNumber(connection, cube, value, time, targetCycle, targetVersion, detail, account, cashflow, ""TYPE"");
					counter = counter + 1;
				}
				LogInformation(functionName + "" Copied "" + counter + "" values"");
			}

			x = x + 1; // increment array element counter
		}

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	F291E17B-E6AA-434D-9E69-B2D3094CDD7D	This function is used to copy Cash Flow configuration from one Configuration Set/Version to another.	1	1	1	1637	NULL	0	45708.67502	0	0
DCBE01A4-B09D-44C2-ABFC-BEB26CD28075	CD491758-D9DF-4002-94C8-8006E1855F86	CF_CopyConfigurationFromConsolidation	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""sourceServer"" parameter-type=""string"" parameter-description=""The OLAP server and Consolidation database to connect to in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCube"" parameter-type=""string"" parameter-description=""The OLAP cube containing the Consolidation Cash Flow configuration data to be copied"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceYearUN"" parameter-type=""string"" parameter-description=""The source Year element to copy from"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourcePeriodUN"" parameter-type=""string"" parameter-description=""The source Period element to copy from"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""sourceVersionUN"" parameter-type=""string"" parameter-description=""The source Version element to copy from"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetServer"" parameter-type=""string"" parameter-description=""The OLAP server and Cash Flow datbase to connect to in the form server/database"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetCube"" parameter-type=""string"" parameter-description=""The OLAP Cash Flow Configuration cube where the data will be copied"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetCycleUN"" parameter-type=""string"" parameter-description=""The target Configuration Set element to copy to"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""targetVersionUN"" parameter-type=""string"" parameter-description=""The target Version element to copy to"" parameter-order=""9"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CF_CopyConfigurationFromConsolidation(
	string sourceServer,
	string ticket,
	string sourceCube,
	string sourceYearUN,
	string sourcePeriodUN,
	string sourceVersionUN,
	string targetServer,
	string targetCube,
	string targetCycleUN,
	string targetVersionUN)
@Description: ""This function is used to copy Cash Flow configuration from the Consolidation component to the Cash Flow component."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[sourceServer]: ""The OLAP server and Consolidation database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""The OLAP cube containing the Consolidation Cash Flow configuration data to be copied"";
@Parameter[sourceYearUN]: ""The source Year element to copy from"";
@Parameter[sourcePeriodUN]: ""The source Period element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element to copy from"";
@Parameter[targetServer]: ""The OLAP server and Cash Flow datbase to connect to in the form server/database"";
@Parameter[targetCube]: ""The OLAP Cash Flow Configuration cube where the data will be copied"";
@Parameter[targetCycleUN]: ""The target Configuration Set element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to"";
{
	string functionName = ""CF_CopyConfigurationFromConsolidation:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		// OLAPConnection sourceConnection = OLAPCreatePooledConnection(sourceServer, ""Admin"", ""Infor2014"");
		// OLAPConnection targetConnection = OLAPCreatePooledConnection(targetServer, ""Admin"", ""Infor2014"");
		OLAPConnection sourceConnection = OLAPCreatePooledNamedConnection(sourceServer);
		OLAPConnection targetConnection = OLAPCreatePooledNamedConnection(targetServer);
		string sourceYear = ResolveUniqueName(sourceConnection, sourceYearUN);
		string sourcePeriod = ResolveUniqueName(sourceConnection, sourcePeriodUN);
		string sourceVersion = ResolveUniqueName(sourceConnection, sourceVersionUN);
		string targetCycle = ResolveUniqueName(targetConnection, targetCycleUN);
		string targetVersion = ResolveUniqueName(targetConnection, targetVersionUN);

		if (sourceYear == """") {
			sourceYear = sourceYearUN;
		}
		if (sourcePeriod == """") {
			sourcePeriod = sourcePeriodUN;
		}
		if (sourceVersion == """") {
			sourceVersion = sourceVersionUN;
		}
		if (targetCycle == """") {
			RaiseError(""Configuration Set UN of '"" + targetCycleUN + ""' could not be resolved."", 1);
		}
		if (targetVersion == """") {
			RaiseError(""targetVersionUN of '"" + targetVersionUN + ""' could not be resolved."", 1);
		}

		// Define source dimension names
		string detailDimension = ""DDETAIL"";
		string accountDimension = ""DACOUNT"";
		string cashflowDimension = ""DSTDCASHACC"";
		string cashflowConfigDimension = ""DSTDCASHCFG"";
		string tFlagsCube = ""TFLAGS"";

		string NA = ""N.A."";

		// Target time element
		string targetTime = NA;
		string configurationDimension = ""BPDCONFIGURATION"";
		string cashflowAccountElement = OLAPGetStringAttribute(targetConnection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");

		// Define variables
		int counter = 0;

		LogInformation(functionName + "" Year '"" + sourceYear + ""' Period '"" + sourcePeriod + ""' Version '"" + sourceVersion + ""' -&gt; Configuration Set '"" + targetCycle + ""' Version '"" + targetVersion + ""'"");

		// Need to read account type weight configuration from Consolidation to properly convert Weight values.
		int AccountTypeAWeight = 1;
		int AccountTypeEWeight = 1;
		int AccountTypeLWeight = 1;
		int AccountTypeRWeight = 1;

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseAAccounts"") &gt; 0) {
			AccountTypeAWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseEAccounts"") &gt; 0) {
			AccountTypeEWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseLAccounts"") &gt; 0) {
			AccountTypeLWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseRAccounts"") &gt; 0) {
			AccountTypeRWeight = -1;
		}

		// Process
		OLAPDataArea targetData = OLAPCreateDataArea(targetConnection, targetCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetTime,
		                                             targetCycle,
		                                             targetVersion,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaBCells,
		                                             OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData); // Clear destination

		OLAPDataArea sourceDataType = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 sourceYear,
		                                                 sourcePeriod,
		                                                 sourceVersion,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 ""TYPE"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataType) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""TYPE"";
			double value = OLAPCellReadNumber(sourceConnection, sourceCube,1.0, sourceYear, sourcePeriod, sourceVersion, account, detail, cashflow, cashflowConfig);

			


			// convert some values
			if (account == ""Cashflow"" ) {
				account = cashflowAccountElement;
			}
			if (detail == ""-"") {
				detail = NA;
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to time='"" + targetTime + ""', Configuration Set='"" + targetCycle + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteNumber(targetConnection, targetCube, value, targetTime, targetCycle, targetVersion, detail, account, cashflow, cashflowConfig);
			counter = counter + 1;
		}
		OLAPDataArea sourceDataWeight = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                   sourceYear,
		                                                   sourcePeriod,
		                                                   sourceVersion,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaBCells,
		                                                   ""WEIGHT"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataWeight) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""WEIGHT"";
			string value = OLAPCellReadString(sourceConnection, sourceCube, sourceYear, sourcePeriod, sourceVersion, account, detail, cashflow, cashflowConfig);

			// Need to alter the sign of the Weight value based upon account type and Consolidation configuration
			if (cashflowConfig == ""Weight"") {
				int weightValue = ToInt(value);
				string AccountType = OLAPGetStringAttribute(sourceConnection, accountDimension, account, ""ALRE"");

				if (AccountType == ""A"") {
					weightValue = weightValue * AccountTypeAWeight;
				}
				else if (AccountType == ""E"") {
					weightValue = weightValue * AccountTypeEWeight;
				}
				else if (AccountType == ""L"") {
					weightValue = weightValue * AccountTypeLWeight;
				}
				else if (AccountType == ""R"") {
					weightValue = weightValue * AccountTypeRWeight;
				}

				value = ToString(weightValue);
			}

			// convert some values
			if (account == ""Cashflow"" ) {
				account = cashflowAccountElement;
			}
			if (detail == ""-"") {
				detail = NA;
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to time='"" + targetTime + ""', Configuration Set='"" + targetCycle + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteString(targetConnection, targetCube, value, targetTime, targetCycle, targetVersion, detail, account, cashflow, cashflowConfig);
			counter = counter + 1;
		}

		LogInformation(functionName + "" Copied "" + counter + "" values"");

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CF_CopyConfigurationFromConsolidation(
	string sourceServer,
	string ticket,
	string sourceCube,
	string sourceYearUN,
	string sourcePeriodUN,
	string sourceVersionUN,
	string targetServer,
	string targetCube,
	string targetCycleUN,
	string targetVersionUN)
@Description: ""This function is used to copy Cash Flow configuration from the Consolidation component to the Cash Flow component."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[sourceServer]: ""The OLAP server and Consolidation database to connect to in the form server/database"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceCube]: ""The OLAP cube containing the Consolidation Cash Flow configuration data to be copied"";
@Parameter[sourceYearUN]: ""The source Year element to copy from"";
@Parameter[sourcePeriodUN]: ""The source Period element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element to copy from"";
@Parameter[targetServer]: ""The OLAP server and Cash Flow datbase to connect to in the form server/database"";
@Parameter[targetCube]: ""The OLAP Cash Flow Configuration cube where the data will be copied"";
@Parameter[targetCycleUN]: ""The target Configuration Set element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to"";
{
	string functionName = ""CF_CopyConfigurationFromConsolidation:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		// OLAPConnection sourceConnection = OLAPCreatePooledConnection(sourceServer, ""Admin"", ""Infor2014"");
		// OLAPConnection targetConnection = OLAPCreatePooledConnection(targetServer, ""Admin"", ""Infor2014"");
		OLAPConnection sourceConnection = OLAPCreatePooledNamedConnection(sourceServer);
		OLAPConnection targetConnection = OLAPCreatePooledNamedConnection(targetServer);
		string sourceYear = ResolveUniqueName(sourceConnection, sourceYearUN);
		string sourcePeriod = ResolveUniqueName(sourceConnection, sourcePeriodUN);
		string sourceVersion = ResolveUniqueName(sourceConnection, sourceVersionUN);
		string targetCycle = ResolveUniqueName(targetConnection, targetCycleUN);
		string targetVersion = ResolveUniqueName(targetConnection, targetVersionUN);

		if (sourceYear == """") {
			sourceYear = sourceYearUN;
		}
		if (sourcePeriod == """") {
			sourcePeriod = sourcePeriodUN;
		}
		if (sourceVersion == """") {
			sourceVersion = sourceVersionUN;
		}
		if (targetCycle == """") {
			RaiseError(""Configuration Set UN of '"" + targetCycleUN + ""' could not be resolved."", 1);
		}
		if (targetVersion == """") {
			RaiseError(""targetVersionUN of '"" + targetVersionUN + ""' could not be resolved."", 1);
		}

		// Define source dimension names
		string detailDimension = ""DDETAIL"";
		string accountDimension = ""DACOUNT"";
		string cashflowDimension = ""DSTDCASHACC"";
		string cashflowConfigDimension = ""DSTDCASHCFG"";
		string tFlagsCube = ""TFLAGS"";

		string NA = ""N.A."";

		// Target time element
		string targetTime = NA;
		string configurationDimension = ""BPDCONFIGURATION"";
		string cashflowAccountElement = OLAPGetStringAttribute(targetConnection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");

		// Define variables
		int counter = 0;

		LogInformation(functionName + "" Year '"" + sourceYear + ""' Period '"" + sourcePeriod + ""' Version '"" + sourceVersion + ""' -> Configuration Set '"" + targetCycle + ""' Version '"" + targetVersion + ""'"");

		// Need to read account type weight configuration from Consolidation to properly convert Weight values.
		int AccountTypeAWeight = 1;
		int AccountTypeEWeight = 1;
		int AccountTypeLWeight = 1;
		int AccountTypeRWeight = 1;

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseAAccounts"") > 0) {
			AccountTypeAWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseEAccounts"") > 0) {
			AccountTypeEWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseLAccounts"") > 0) {
			AccountTypeLWeight = -1;
		}

		if (OLAPCellReadNumber(sourceConnection, tFlagsCube, 1, ""M1"", ""ReverseRAccounts"") > 0) {
			AccountTypeRWeight = -1;
		}

		// Process
		OLAPDataArea targetData = OLAPCreateDataArea(targetConnection, targetCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetTime,
		                                             targetCycle,
		                                             targetVersion,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaBCells,
		                                             OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData); // Clear destination

		OLAPDataArea sourceDataType = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 sourceYear,
		                                                 sourcePeriod,
		                                                 sourceVersion,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 ""TYPE"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataType) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""TYPE"";
			double value = OLAPCellReadNumber(sourceConnection, sourceCube,1.0, sourceYear, sourcePeriod, sourceVersion, account, detail, cashflow, cashflowConfig);

			


			// convert some values
			if (account == ""Cashflow"" ) {
				account = cashflowAccountElement;
			}
			if (detail == ""-"") {
				detail = NA;
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to time='"" + targetTime + ""', Configuration Set='"" + targetCycle + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteNumber(targetConnection, targetCube, value, targetTime, targetCycle, targetVersion, detail, account, cashflow, cashflowConfig);
			counter = counter + 1;
		}
		OLAPDataArea sourceDataWeight = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                   sourceYear,
		                                                   sourcePeriod,
		                                                   sourceVersion,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaBCells,
		                                                   ""WEIGHT"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataWeight) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""WEIGHT"";
			string value = OLAPCellReadString(sourceConnection, sourceCube, sourceYear, sourcePeriod, sourceVersion, account, detail, cashflow, cashflowConfig);

			// Need to alter the sign of the Weight value based upon account type and Consolidation configuration
			if (cashflowConfig == ""Weight"") {
				int weightValue = ToInt(value);
				string AccountType = OLAPGetStringAttribute(sourceConnection, accountDimension, account, ""ALRE"");

				if (AccountType == ""A"") {
					weightValue = weightValue * AccountTypeAWeight;
				}
				else if (AccountType == ""E"") {
					weightValue = weightValue * AccountTypeEWeight;
				}
				else if (AccountType == ""L"") {
					weightValue = weightValue * AccountTypeLWeight;
				}
				else if (AccountType == ""R"") {
					weightValue = weightValue * AccountTypeRWeight;
				}

				value = ToString(weightValue);
			}

			// convert some values
			if (account == ""Cashflow"" ) {
				account = cashflowAccountElement;
			}
			if (detail == ""-"") {
				detail = NA;
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to time='"" + targetTime + ""', Configuration Set='"" + targetCycle + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteString(targetConnection, targetCube, value, targetTime, targetCycle, targetVersion, detail, account, cashflow, cashflowConfig);
			counter = counter + 1;
		}

		LogInformation(functionName + "" Copied "" + counter + "" values"");

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	8802A32A-CA39-4DAC-BD2B-E6B406AC2D9D	This function is used to copy Cash Flow configuration from the Consolidation component to the Cash Flow component.	1	1	1	1638	NULL	0	45708.67501	0	0
068BF750-B70F-44F2-8583-5F4123B33F01	CD491758-D9DF-4002-94C8-8006E1855F86	CF_CopyConfigurationToConsolidation	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""ticket"" parameter-type=""string"" parameter-description=""The user credential ticket as obtained from the GETTICKET() function in Application Studio"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceServer"" parameter-type=""string"" parameter-description=""The OLAP server and Cash Flow datbase to connect to in the form server/database"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceCube"" parameter-type=""string"" parameter-description=""The OLAP Cash Flow Configuration cube containing the data to be copied"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceCycleUN"" parameter-type=""string"" parameter-description=""The source Configuration set element to copy from"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceVersionUN"" parameter-type=""string"" parameter-description=""The source Version element to copy from"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetServer"" parameter-type=""string"" parameter-description=""The OLAP server and Consolidation database to connect to in the form server/database"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetCube"" parameter-type=""string"" parameter-description=""The OLAP cube containing the Consolidation Cash Flow configuration data"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetYearUN"" parameter-type=""string"" parameter-description=""The target Year element to copy to"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetPeriodUN"" parameter-type=""string"" parameter-description=""The target Period element to copy to"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""targetVersionUN"" parameter-type=""string"" parameter-description=""The target Version element to copy to"" parameter-order=""9"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CF_CopyConfigurationToConsolidation(
	string ticket,
	string sourceServer,
	string sourceCube,
	string sourceCycleUN,
	string sourceVersionUN,
	string targetServer,
	string targetCube,
	string targetYearUN,
	string targetPeriodUN,
	string targetVersionUN
)
@Description: ""This function is used to copy Cash Flow configuration from the Global Cash Flow component to the Consolidation component."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceServer]: ""The OLAP server and Cash Flow datbase to connect to in the form server/database"";
@Parameter[sourceCube]: ""The OLAP Cash Flow Configuration cube containing the data to be copied"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element to copy from"";
@Parameter[targetServer]: ""The OLAP server and Consolidation database to connect to in the form server/database"";
@Parameter[targetCube]: ""The OLAP cube containing the Consolidation Cash Flow configuration data"";
@Parameter[targetYearUN]: ""The target Year element to copy to"";
@Parameter[targetPeriodUN]: ""The target Period element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to"";
{
	string functionName = ""CF_CopyConfigurationToConsolidation:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		OLAPConnection sourceConnection = OLAPCreatePooledNamedConnection(sourceServer);
		OLAPConnection targetConnection = OLAPCreatePooledNamedConnection(targetServer);

		// Resolve unique names and ensure they are valid
		string sourceCycle = ResolveUniqueName(sourceConnection, sourceCycleUN);
		string sourceVersion = ResolveUniqueName(sourceConnection, sourceVersionUN);
		string targetYear = ResolveUniqueName(targetConnection, targetYearUN);
		string targetPeriod = ResolveUniqueName(targetConnection, targetPeriodUN);
		string targetVersion = ResolveUniqueName(targetConnection, targetVersionUN);

		if (sourceCycle == """") {
			RaiseError(""Configuration set UN of '"" + sourceCycleUN + ""' could not be resolved."", 1);
		}
		if (sourceVersion == """") {
			RaiseError(""sourceVersionUN of '"" + sourceVersionUN + ""' could not be resolved."", 1);
		}
		if (targetYear == """") {
			targetYear = targetYearUN;
		}
		if (targetPeriod == """") {
			targetPeriod = targetPeriodUN;
		}
		if (targetVersion == """") {
			targetVersion = targetVersionUN;
		}

		// Define source dimension names
		string detailDimension = ""BPDDETAIL"";
		string accountDimension = ""BPDACCOUNT"";
		string cashflowDimension = ""CFDCASHFLOW"";
		string cashflowConfigDimension = ""CFDCONFIG_CASHFLOW"";
		string NA = ""N.A."";
		string configurationDimension = ""BPDCONFIGURATION"";
		string cashflowAccountElement = OLAPGetStringAttribute(sourceConnection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");


		// Source time element
		string sourceTime = NA;

		// Define variables
		int counter = 0;

		LogInformation(functionName + "" Configuration Set '"" + sourceCycle + ""' Version '"" + sourceVersion + ""' -&gt; Year '"" + targetYear + ""' Period '"" + targetPeriod + ""' Version '"" + targetVersion + ""'"");

		OLAPDataArea targetData = OLAPCreateDataArea(targetConnection, targetCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetYear,
		                                             targetPeriod,
		                                             targetVersion,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaBCells,
		                                             OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData); // Clear destination
		OLAPDataArea sourceDataType = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 sourceTime,
		                                                 sourceCycle,
		                                                 sourceVersion,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 ""TYPE"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataType) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""TYPE"";

			double value = OLAPCellReadNumber(sourceConnection, sourceCube,1.0, sourceTime, sourceCycle, sourceVersion, detail, account, cashflow, cashflowConfig);

			// convert some values
			if (account == cashflowAccountElement ) {
				account = ""Cashflow"";
			}
			if (detail == NA) {
				detail = ""-"";
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to Year='"" + targetYear + ""', Period='"" + targetPeriod + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteNumber(targetConnection, targetCube, value, targetYear, targetPeriod, targetVersion, account, detail, cashflow, cashflowConfig);
			counter = counter + 1;
		}

		OLAPDataArea sourceDataWeight = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                   sourceTime,
		                                                   sourceCycle,
		                                                   sourceVersion,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaBCells,
		                                                   ""WEIGHT"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataWeight) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""WEIGHT"";

			string value = OLAPCellReadString(sourceConnection, sourceCube, sourceTime, sourceCycle, sourceVersion, detail, account, cashflow, cashflowConfig);

			// convert some values
			if (account == cashflowAccountElement ) {
				account = ""Cashflow"";
			}
			if (detail == NA) {
				detail = ""-"";
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to Year='"" + targetYear + ""', Period='"" + targetPeriod + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteString(targetConnection, targetCube, value, targetYear, targetPeriod, targetVersion, account, detail, cashflow, cashflowConfig);
			counter = counter + 1;
		}
		LogInformation(functionName + "" Copied "" + counter + "" values"");

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CF_CopyConfigurationToConsolidation(
	string ticket,
	string sourceServer,
	string sourceCube,
	string sourceCycleUN,
	string sourceVersionUN,
	string targetServer,
	string targetCube,
	string targetYearUN,
	string targetPeriodUN,
	string targetVersionUN
)
@Description: ""This function is used to copy Cash Flow configuration from the Global Cash Flow component to the Consolidation component."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[ticket]: ""The user credential ticket as obtained from the GETTICKET() function in Application Studio"";
@Parameter[sourceServer]: ""The OLAP server and Cash Flow datbase to connect to in the form server/database"";
@Parameter[sourceCube]: ""The OLAP Cash Flow Configuration cube containing the data to be copied"";
@Parameter[sourceCycleUN]: ""The source Configuration set element to copy from"";
@Parameter[sourceVersionUN]: ""The source Version element to copy from"";
@Parameter[targetServer]: ""The OLAP server and Consolidation database to connect to in the form server/database"";
@Parameter[targetCube]: ""The OLAP cube containing the Consolidation Cash Flow configuration data"";
@Parameter[targetYearUN]: ""The target Year element to copy to"";
@Parameter[targetPeriodUN]: ""The target Period element to copy to"";
@Parameter[targetVersionUN]: ""The target Version element to copy to"";
{
	string functionName = ""CF_CopyConfigurationToConsolidation:"";
	string errorMessage = """";
	int errorCode = 0;
	try {
		// Create connection and resolve unique names
		OLAPConnection sourceConnection = OLAPCreatePooledNamedConnection(sourceServer);
		OLAPConnection targetConnection = OLAPCreatePooledNamedConnection(targetServer);

		// Resolve unique names and ensure they are valid
		string sourceCycle = ResolveUniqueName(sourceConnection, sourceCycleUN);
		string sourceVersion = ResolveUniqueName(sourceConnection, sourceVersionUN);
		string targetYear = ResolveUniqueName(targetConnection, targetYearUN);
		string targetPeriod = ResolveUniqueName(targetConnection, targetPeriodUN);
		string targetVersion = ResolveUniqueName(targetConnection, targetVersionUN);

		if (sourceCycle == """") {
			RaiseError(""Configuration set UN of '"" + sourceCycleUN + ""' could not be resolved."", 1);
		}
		if (sourceVersion == """") {
			RaiseError(""sourceVersionUN of '"" + sourceVersionUN + ""' could not be resolved."", 1);
		}
		if (targetYear == """") {
			targetYear = targetYearUN;
		}
		if (targetPeriod == """") {
			targetPeriod = targetPeriodUN;
		}
		if (targetVersion == """") {
			targetVersion = targetVersionUN;
		}

		// Define source dimension names
		string detailDimension = ""BPDDETAIL"";
		string accountDimension = ""BPDACCOUNT"";
		string cashflowDimension = ""CFDCASHFLOW"";
		string cashflowConfigDimension = ""CFDCONFIG_CASHFLOW"";
		string NA = ""N.A."";
		string configurationDimension = ""BPDCONFIGURATION"";
		string cashflowAccountElement = OLAPGetStringAttribute(sourceConnection, configurationDimension, ""CF_ACC_TYPE"", ""Value"");


		// Source time element
		string sourceTime = NA;

		// Define variables
		int counter = 0;

		LogInformation(functionName + "" Configuration Set '"" + sourceCycle + ""' Version '"" + sourceVersion + ""' -> Year '"" + targetYear + ""' Period '"" + targetPeriod + ""' Version '"" + targetVersion + ""'"");

		OLAPDataArea targetData = OLAPCreateDataArea(targetConnection, targetCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                             targetYear,
		                                             targetPeriod,
		                                             targetVersion,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaAllCells,
		                                             OlapDataAreaBCells,
		                                             OlapDataAreaBCells);
		OLAPDeleteDataArea(targetData); // Clear destination
		OLAPDataArea sourceDataType = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
		                                                 OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                 sourceTime,
		                                                 sourceCycle,
		                                                 sourceVersion,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 OlapDataAreaBCells,
		                                                 ""TYPE"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataType) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""TYPE"";

			double value = OLAPCellReadNumber(sourceConnection, sourceCube,1.0, sourceTime, sourceCycle, sourceVersion, detail, account, cashflow, cashflowConfig);

			// convert some values
			if (account == cashflowAccountElement ) {
				account = ""Cashflow"";
			}
			if (detail == NA) {
				detail = ""-"";
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to Year='"" + targetYear + ""', Period='"" + targetPeriod + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteNumber(targetConnection, targetCube, value, targetYear, targetPeriod, targetVersion, account, detail, cashflow, cashflowConfig);
			counter = counter + 1;
		}

		OLAPDataArea sourceDataWeight = OLAPCreateDataArea(sourceConnection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
		                                                   OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
		                                                   sourceTime,
		                                                   sourceCycle,
		                                                   sourceVersion,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaAllCells,
		                                                   OlapDataAreaBCells,
		                                                   ""WEIGHT"");

		// Loop through the source data area and write to the destination data area
		foreach (OLAPCell cell in sourceDataWeight) {
			string detail = OLAPCellGetElement(cell, detailDimension);
			string account = OLAPCellGetElement(cell, accountDimension);
			string cashflow = OLAPCellGetElement(cell, cashflowDimension);
			string cashflowConfig = ""WEIGHT"";

			string value = OLAPCellReadString(sourceConnection, sourceCube, sourceTime, sourceCycle, sourceVersion, detail, account, cashflow, cashflowConfig);

			// convert some values
			if (account == cashflowAccountElement ) {
				account = ""Cashflow"";
			}
			if (detail == NA) {
				detail = ""-"";
			}

			// LogDebug(functionName + "" writing value '"" + value + ""' to Year='"" + targetYear + ""', Period='"" + targetPeriod + ""', detail='"" + detail + ""', account='"" + account + ""', cashflow='"" + cashflow + ""', cashflowConfig='"" + cashflowConfig + ""'"");
			OLAPCellWriteString(targetConnection, targetCube, value, targetYear, targetPeriod, targetVersion, account, detail, cashflow, cashflowConfig);
			counter = counter + 1;
		}
		LogInformation(functionName + "" Copied "" + counter + "" values"");

		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogDebug(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	083EA1B5-6625-4A96-A567-407E6AF7BE22	This function is used to copy Cash Flow configuration from the Global Cash Flow component to the Consolidation component.	1	1	1	1639	NULL	0	45708.67502	0	0
CB32D94C-E4B0-4C50-A67F-06190915D3F1	CD491758-D9DF-4002-94C8-8006E1855F86	CF_DeleteAccountConfiguration	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""Database"" parameter-type=""string"" parameter-description=""The OLAP database to use in form Servername/Databasename."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""Ticket"" parameter-type=""string"" parameter-description=""The ticket to connect with."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""CycleUN"" parameter-type=""string"" parameter-description=""The Configuration set element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""VersionUN"" parameter-type=""string"" parameter-description=""The version element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""CFAccountUN"" parameter-type=""string"" parameter-description=""The Cash Flow account element to be used."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CF_DeleteAccountConfiguration(string Database, string Ticket, string CycleUN, string VersionUN, string CFAccountUN)
@Description: ""Delete version setting for Configuration set"";
@Category: ""Cash Flow Functions"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration set element to be used."";
@Parameter[VersionUN]: ""The version element to be used."";
@Parameter[CFAccountUN]: ""The Cash Flow account element to be used."";
@Returns: ""True, if successful."";

{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string Version = ResolveUniqueName(connection, VersionUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string CFAccount = ResolveUniqueName(connection, CFAccountUN);

	string CFConfigCube = ""CFCCONFIG_CASHFLOW"";

	OLAPDataArea TargetData = OLAPCreateDataArea(connection, CFConfigCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             ""N.A."", Cycle, Version, OlapDataAreaAllCells, OlapDataAreaAllCells, CFAccount, ""WEIGHT"");


	OLAPDeleteDataArea(TargetData);
	
return true;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CF_DeleteAccountConfiguration(string Database, string Ticket, string CycleUN, string VersionUN, string CFAccountUN)
@Description: ""Delete version setting for Configuration set"";
@Category: ""Cash Flow Functions"";
@Parameter[Database]: ""The OLAP database to use in form Servername/Databasename."";
@Parameter[Ticket]: ""The ticket to connect with."";
@Parameter[CycleUN]: ""The Configuration set element to be used."";
@Parameter[VersionUN]: ""The version element to be used."";
@Parameter[CFAccountUN]: ""The Cash Flow account element to be used."";
@Returns: ""True, if successful."";

{

	OLAPConnection connection = OLAPCreatePooledNamedConnection(Database);

	string Version = ResolveUniqueName(connection, VersionUN);
	string Cycle = ResolveUniqueName(connection, CycleUN);
	string CFAccount = ResolveUniqueName(connection, CFAccountUN);

	string CFConfigCube = ""CFCCONFIG_CASHFLOW"";

	OLAPDataArea TargetData = OLAPCreateDataArea(connection, CFConfigCube,
	                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
	                                             OlapDataAreaOperatorNone, 0.0,
	                                             ""N.A."", Cycle, Version, OlapDataAreaAllCells, OlapDataAreaAllCells, CFAccount, ""WEIGHT"");


	OLAPDeleteDataArea(TargetData);
	
return true;
}"	1	E0342A68-1816-4411-9732-6C373A88CA2A	Delete version setting for Configuration set	1	1	1	1640	NULL	0	45708.67508	0	0
2F434414-F824-4E5D-BC77-B2B15AFA6CB1	CD491758-D9DF-4002-94C8-8006E1855F86	CF_ElementStringSplit	Cash Flow Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""StringArray"" return-value-description=""A StringArray containing the elements found in the provided stringList"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""stringList"" parameter-type=""string"" parameter-description=""A comma-separated list of dimension elements"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray CF_ElementStringSplit(string stringList)
@Description: ""This function is used to split a list of comma separated dimension elements."";
@Category: ""Cash Flow Utilities"";
@Returns: ""A StringArray containing the elements found in the provided stringList"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringArray elementArray = CreateStringArray();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos &lt; 0) {

			Append(elementArray, stringList);
		} else {

			while (pos &gt;= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				Append(elementArray, element);
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			Append(elementArray, stringList);
		}
	}

	return elementArray;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringArray CF_ElementStringSplit(string stringList)
@Description: ""This function is used to split a list of comma separated dimension elements."";
@Category: ""Cash Flow Utilities"";
@Returns: ""A StringArray containing the elements found in the provided stringList"";
@Parameter[stringList]: ""A comma-separated list of dimension elements"";
{
	// Parse the elements into a string array
	StringArray elementArray = CreateStringArray();

	if (stringList != """") {
		int pos = StringFind(stringList, ""],["", 0);
		if (pos < 0) {

			Append(elementArray, stringList);
		} else {

			while (pos >= 0) {
				string element = StringSubstring(stringList, 0, pos + 1);
				Append(elementArray, element);
				stringList = StringSubstring(stringList, pos + 2, StringLength(stringList) - (pos + 2));
				pos = StringFind(stringList, ""],["", 0);
			}

			// Add the last element
			Append(elementArray, stringList);
		}
	}

	return elementArray;
}"	1	A5781A74-9994-44BF-B110-B80F810AB287	This function is used to split a list of comma separated dimension elements.	1	1	1	1641	NULL	0	45708.67502	0	0
6532072A-B1BC-4586-89A7-483435F10AF8	CD491758-D9DF-4002-94C8-8006E1855F86	CF_TransferOpeningBalances	Cash Flow Functions	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""OLAP connection for the transfer"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceCube"" parameter-type=""string"" parameter-description=""OLAP cube containing the source data"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""targetCube"" parameter-type=""string"" parameter-description=""OLAP cube where data is to be written"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTimelist"" parameter-type=""StringListList"" parameter-description=""List of Time elements to be processed"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceCycle"" parameter-type=""string"" parameter-description=""Configuration set element"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""versions"" parameter-type=""StringArray"" parameter-description=""Version element"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""entities"" parameter-type=""OLAPElementList"" parameter-description=""List of entity elements"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""BP_GetTopElement"" process-version=""*"" process-id="""" />
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string CF_TransferOpeningBalances(
	OLAPConnection connection,
	string sourceCube,
	string targetCube,
	StringListList sourceTimelist,
	string sourceCycle,
	StringArray versions,
	OLAPElementList entities
)
@Description: ""Transfer Cash Flow opening balances from BPCMAIN to CFCCASHFLOW."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""OLAP connection for the transfer"";
@Parameter[sourceCube]: ""OLAP cube containing the source data"";
@Parameter[targetCube]: ""OLAP cube where data is to be written"";
@Parameter[sourceTimelist]: ""List of Time elements to be processed"";
@Parameter[sourceCycle]: ""Configuration set element"";
@Parameter[versions]: ""Version element"";
@Parameter[entities]: ""List of entity elements"";
{
	/*
		Opening balance for cash account
		The process should also transfer the opening balance from cash account for each year
			BPDTIME: source and target: ""01""
			BPDLEVEL: source - ""TOTAL_OB"", target: ""IMPORT_OB""
			BPDACCOUNT: source: defined account for ""Cash and Cash Equivalents"" , target: defined account for ""Opening Balance Cash""
	 */

	string functionName = ""CF_TransferOpeningBalances:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		// Define dimension and element names
		string accountDimension = ""BPDACCOUNT"";
		string cfAccountDimension = ""CFDCASHFLOW"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";

		string NA = ""N.A."";
		string cashflowDetailElement = NA;
		string stepElement = ""BASE_STEP""; // One day may be passed in
		string topStepElement = ""TOTAL_STEP"";
		string topDetailElement = ""TOTAL_DETAIL"";
		string topLevelElement = ""TOTAL_CHANGE"";
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));

		LogDebug(functionName + "" Transferring Opening Balances"");
		NotifyInformation(""Transfer of opening balance data to cashflow started."");
		// Define some elements
		string sourceLevel = ""TOTAL_OB"";
		string targetLevel = ""IMPORT_OB"";
		string sourceAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CASH"", ""Value"");
		string targetAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_OB_CASH"", ""Value"");
		int y = 0;
		bool proceed = true;
		if(sourceAccount == """")
		{
			NotifyInformation(""Cash and Cash Equivalent account is not defined. Please check Cashflow configuration."");
			proceed = false;
		}
		if(targetAccount == """")
		{
			NotifyInformation(""Opening Balance Cash account is not defined. Please check Cashflow configuration."");
			proceed = false;
		}
		if(proceed)
		{
			foreach(string sourceVersion in versions)
			{
				StringList sourceTime = sourceTimelist[y];
				// Build opening balance time element list from sourceTime element list (which has year elements)
				LogDebug(functionName + ""creating openingBalanceTimeList for version "" + sourceVersion);
				OLAPElementList openingBalanceTimeList = CreateOLAPElementList();
				int x = 1; // Above initialization created an empty item in the list
				string period01String = """";

				while (x &lt; Count(sourceTime)) {
					period01String = OLAPGetStringAttribute(connection, timeDimension, sourceTime[x], ""CURRENT_YEAR_START_MONTH"");
					OLAPElementListAddElement(openingBalanceTimeList, OLAPGetDimensionElement(connection, timeDimension, ResolveUniqueName(connection, period01String)));
					x = x + 1;
				}

				// Need a target DataArea to be cleared
				LogDebug(functionName + ""creating and clearing the target data area for version "" + sourceVersion);
				OLAPDataArea targetData = OLAPCreateDataArea(connection, targetCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             openingBalanceTimeList,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             targetLevel,
				                                             OlapDataAreaBCells,
				                                             entities,
				                                             OlapDataAreaBCells, // BPDINTERCOMPANY
				                                             OlapDataAreaBCells, // BPDORGANIZATION
				                                             OlapDataAreaBCells, // BPDCURRENCY
				                                             OlapDataAreaBCells, // BPDPSEGMENT
				                                             OlapDataAreaBCells, // BPDSSEGMENT
				                                             OlapDataAreaBCells, // BPDTSEGMENT
				                                             targetAccount, // CASHFLOW
				                                             OlapDataAreaBCells, // BPDANALYSIS_01
				                                             OlapDataAreaBCells, // BPDANALYSIS_02
				                                             OlapDataAreaBCells, // BPDANALYSIS_03
				                                             OlapDataAreaBCells, // BPDANALYSIS_04
				                                             OlapDataAreaBCells, // BPDANALYSIS_05
				                                             OlapDataAreaBCells, // BPDANALYSIS_06
				                                             OlapDataAreaBCells, // BPDANALYSIS_07
				                                             OlapDataAreaBCells, // BPDANALYSIS_08
				                                             OlapDataAreaBCells, // BPDANALYSIS_09
				                                             OlapDataAreaBCells, // BPDANALYSIS_10
				                                             OlapDataAreaBCells, // BPDANALYSIS_11
				                                             OlapDataAreaBCells // BPDANALYSIS_12
				                                            );
				OLAPDeleteDataArea(targetData);

				OLAPDataArea sourceData = OLAPCreateDataArea(connection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             openingBalanceTimeList,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             sourceLevel,
				                                             topStepElement,
				                                             entities,
				                                             OlapDataAreaBCells, // BPDINTERCOMPANY
				                                             OlapDataAreaBCells, // BPDORGANIZATION
				                                             sourceAccount, // BPDACCOUNT
				                                             OlapDataAreaBCells, // BPDCURRENCY
				                                             topDetailElement,
				                                             OlapDataAreaBCells, // BPDPSEGMENT
				                                             OlapDataAreaBCells, // BPDSSEGMENT
				                                             OlapDataAreaBCells, // BPDTSEGMENT
				                                             OlapDataAreaBCells, // BPDANALYSIS_01
				                                             OlapDataAreaBCells, // BPDANALYSIS_02
				                                             OlapDataAreaBCells, // BPDANALYSIS_03
				                                             OlapDataAreaBCells, // BPDANALYSIS_04
				                                             OlapDataAreaBCells, // BPDANALYSIS_05
				                                             OlapDataAreaBCells, // BPDANALYSIS_06
				                                             OlapDataAreaBCells, // BPDANALYSIS_07
				                                             OlapDataAreaBCells, // BPDANALYSIS_08
				                                             OlapDataAreaBCells, // BPDANALYSIS_09
				                                             OlapDataAreaBCells, // BPDANALYSIS_10
				                                             OlapDataAreaBCells, // BPDANALYSIS_11
				                                             OlapDataAreaBCells // BPDANALYSIS_12
				                                            );

				LogDebug(functionName + ""processing the source data area cells for version "" + sourceVersion);
				foreach (OLAPCell cell in sourceData) {
					string account = OLAPCellGetElement(cell, accountDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string currency = OLAPCellGetElement(cell, currencyDimension);

					// only process local currencies
					if (StringEndsWith(currency, ""_LC"")) {
						string cycle = OLAPCellGetElement(cell, cycleDimension);
						string organization = OLAPCellGetElement(cell, organizationDimension);
						string entity = OLAPCellGetElement(cell, entityDimension);
						string time = OLAPCellGetElement(cell, timeDimension);
						string version = OLAPCellGetElement(cell, versionDimension);
						string level = OLAPCellGetElement(cell, levelDimension);
						string step = OLAPCellGetElement(cell, stepDimension);
						string interCompany = OLAPCellGetElement(cell, intercompanyDimension);
						string psegment = OLAPCellGetElement(cell, primarySegmentDimension);
						string ssegment = OLAPCellGetElement(cell, secondarySegmentDimension);
						string tsegment = OLAPCellGetElement(cell, tertiarySegmentDimension);
						string analysis01 = OLAPCellGetElement(cell, analysis01Dimension);
						string analysis02 = OLAPCellGetElement(cell, analysis02Dimension);
						string analysis03 = OLAPCellGetElement(cell, analysis03Dimension);
						string analysis04 = OLAPCellGetElement(cell, analysis04Dimension);
						string analysis05 = OLAPCellGetElement(cell, analysis05Dimension);
						string analysis06 = OLAPCellGetElement(cell, analysis06Dimension);
						string analysis07 = OLAPCellGetElement(cell, analysis07Dimension);
						string analysis08 = OLAPCellGetElement(cell, analysis08Dimension);
						string analysis09 = OLAPCellGetElement(cell, analysis09Dimension);
						string analysis10 = OLAPCellGetElement(cell, analysis10Dimension);
						string analysis11 = OLAPCellGetElement(cell, analysis11Dimension);
						string analysis12 = OLAPCellGetElement(cell, analysis12Dimension);

						double sourceValue = cell;
						OLAPCellWriteNumber(connection, targetCube, sourceValue, time, cycle, version, targetLevel, stepElement, entity, interCompany, organization, currency,
						                    psegment, ssegment, tsegment,
						                    targetAccount,
						                    analysis01, analysis02, analysis03, analysis04, analysis05, analysis06, analysis07, analysis08, analysis09, analysis10, analysis11, analysis12
						                   );
					}
				}
				y=y+1;
			}
		}
		LogDebug(functionName + "" finished transferring Opening Balances"");
		NotifyInformation(""Transfer of opening balance data to cashflow finished."");
		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_GetTopElement"", ""*""
#include ""CF_ElementStringSplit"", ""*""

string CF_TransferOpeningBalances(
	OLAPConnection connection,
	string sourceCube,
	string targetCube,
	StringListList sourceTimelist,
	string sourceCycle,
	StringArray versions,
	OLAPElementList entities
)
@Description: ""Transfer Cash Flow opening balances from BPCMAIN to CFCCASHFLOW."";
@Category: ""Cash Flow Functions"";
@Returns: ""TRUE for success, FALSE for failure, or ERROR if an unexpected error occurs"";
@Parameter[connection]: ""OLAP connection for the transfer"";
@Parameter[sourceCube]: ""OLAP cube containing the source data"";
@Parameter[targetCube]: ""OLAP cube where data is to be written"";
@Parameter[sourceTimelist]: ""List of Time elements to be processed"";
@Parameter[sourceCycle]: ""Configuration set element"";
@Parameter[versions]: ""Version element"";
@Parameter[entities]: ""List of entity elements"";
{
	/*
		Opening balance for cash account
		The process should also transfer the opening balance from cash account for each year
			BPDTIME: source and target: ""01""
			BPDLEVEL: source - ""TOTAL_OB"", target: ""IMPORT_OB""
			BPDACCOUNT: source: defined account for ""Cash and Cash Equivalents"" , target: defined account for ""Opening Balance Cash""
	 */

	string functionName = ""CF_TransferOpeningBalances:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		// Define dimension and element names
		string accountDimension = ""BPDACCOUNT"";
		string cfAccountDimension = ""CFDCASHFLOW"";
		string analysis01Dimension = ""BPDANALYSIS_01"";
		string analysis02Dimension = ""BPDANALYSIS_02"";
		string analysis03Dimension = ""BPDANALYSIS_03"";
		string analysis04Dimension = ""BPDANALYSIS_04"";
		string analysis05Dimension = ""BPDANALYSIS_05"";
		string analysis06Dimension = ""BPDANALYSIS_06"";
		string analysis07Dimension = ""BPDANALYSIS_07"";
		string analysis08Dimension = ""BPDANALYSIS_08"";
		string analysis09Dimension = ""BPDANALYSIS_09"";
		string analysis10Dimension = ""BPDANALYSIS_10"";
		string analysis11Dimension = ""BPDANALYSIS_11"";
		string analysis12Dimension = ""BPDANALYSIS_12"";
		string configurationDimension = ""BPDCONFIGURATION"";
		string currencyDimension = ""BPDCURRENCY"";
		string cycleDimension = ""BPDCYCLE"";
		string detailDimension = ""BPDDETAIL"";
		string entityDimension = ""BPDENTITY"";
		string intercompanyDimension = ""BPDINTERCOMPANY"";
		string levelDimension = ""BPDLEVEL"";
		string organizationDimension = ""BPDORGANIZATION"";
		string primarySegmentDimension = ""BPDPSEGMENT"";
		string secondarySegmentDimension = ""BPDSSEGMENT"";
		string stepDimension = ""BPDSTEP"";
		string tertiarySegmentDimension = ""BPDTSEGMENT"";
		string timeDimension = ""BPDTIME"";
		string versionDimension = ""BPDVERSION"";

		string NA = ""N.A."";
		string cashflowDetailElement = NA;
		string stepElement = ""BASE_STEP""; // One day may be passed in
		string topStepElement = ""TOTAL_STEP"";
		string topDetailElement = ""TOTAL_DETAIL"";
		string topLevelElement = ""TOTAL_CHANGE"";
		string topPSegmentElement = ToString(BP_GetTopElement(connection, primarySegmentDimension));
		string topSSegmentElement = ToString(BP_GetTopElement(connection, secondarySegmentDimension));
		string topTSegmentElement = ToString(BP_GetTopElement(connection, tertiarySegmentDimension));

		LogDebug(functionName + "" Transferring Opening Balances"");
		NotifyInformation(""Transfer of opening balance data to cashflow started."");
		// Define some elements
		string sourceLevel = ""TOTAL_OB"";
		string targetLevel = ""IMPORT_OB"";
		string sourceAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_CASH"", ""Value"");
		string targetAccount = OLAPGetStringAttribute(connection, configurationDimension, ""CF_OB_CASH"", ""Value"");
		int y = 0;
		bool proceed = true;
		if(sourceAccount == """")
		{
			NotifyInformation(""Cash and Cash Equivalent account is not defined. Please check Cashflow configuration."");
			proceed = false;
		}
		if(targetAccount == """")
		{
			NotifyInformation(""Opening Balance Cash account is not defined. Please check Cashflow configuration."");
			proceed = false;
		}
		if(proceed)
		{
			foreach(string sourceVersion in versions)
			{
				StringList sourceTime = sourceTimelist[y];
				// Build opening balance time element list from sourceTime element list (which has year elements)
				LogDebug(functionName + ""creating openingBalanceTimeList for version "" + sourceVersion);
				OLAPElementList openingBalanceTimeList = CreateOLAPElementList();
				int x = 1; // Above initialization created an empty item in the list
				string period01String = """";

				while (x < Count(sourceTime)) {
					period01String = OLAPGetStringAttribute(connection, timeDimension, sourceTime[x], ""CURRENT_YEAR_START_MONTH"");
					OLAPElementListAddElement(openingBalanceTimeList, OLAPGetDimensionElement(connection, timeDimension, ResolveUniqueName(connection, period01String)));
					x = x + 1;
				}

				// Need a target DataArea to be cleared
				LogDebug(functionName + ""creating and clearing the target data area for version "" + sourceVersion);
				OLAPDataArea targetData = OLAPCreateDataArea(connection, targetCube, OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             openingBalanceTimeList,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             targetLevel,
				                                             OlapDataAreaBCells,
				                                             entities,
				                                             OlapDataAreaBCells, // BPDINTERCOMPANY
				                                             OlapDataAreaBCells, // BPDORGANIZATION
				                                             OlapDataAreaBCells, // BPDCURRENCY
				                                             OlapDataAreaBCells, // BPDPSEGMENT
				                                             OlapDataAreaBCells, // BPDSSEGMENT
				                                             OlapDataAreaBCells, // BPDTSEGMENT
				                                             targetAccount, // CASHFLOW
				                                             OlapDataAreaBCells, // BPDANALYSIS_01
				                                             OlapDataAreaBCells, // BPDANALYSIS_02
				                                             OlapDataAreaBCells, // BPDANALYSIS_03
				                                             OlapDataAreaBCells, // BPDANALYSIS_04
				                                             OlapDataAreaBCells, // BPDANALYSIS_05
				                                             OlapDataAreaBCells, // BPDANALYSIS_06
				                                             OlapDataAreaBCells, // BPDANALYSIS_07
				                                             OlapDataAreaBCells, // BPDANALYSIS_08
				                                             OlapDataAreaBCells, // BPDANALYSIS_09
				                                             OlapDataAreaBCells, // BPDANALYSIS_10
				                                             OlapDataAreaBCells, // BPDANALYSIS_11
				                                             OlapDataAreaBCells // BPDANALYSIS_12
				                                            );
				OLAPDeleteDataArea(targetData);

				OLAPDataArea sourceData = OLAPCreateDataArea(connection, sourceCube, OlapDataAreaIncludeB |OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				                                             OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
				                                             openingBalanceTimeList,
				                                             sourceCycle,
				                                             sourceVersion,
				                                             sourceLevel,
				                                             topStepElement,
				                                             entities,
				                                             OlapDataAreaBCells, // BPDINTERCOMPANY
				                                             OlapDataAreaBCells, // BPDORGANIZATION
				                                             sourceAccount, // BPDACCOUNT
				                                             OlapDataAreaBCells, // BPDCURRENCY
				                                             topDetailElement,
				                                             OlapDataAreaBCells, // BPDPSEGMENT
				                                             OlapDataAreaBCells, // BPDSSEGMENT
				                                             OlapDataAreaBCells, // BPDTSEGMENT
				                                             OlapDataAreaBCells, // BPDANALYSIS_01
				                                             OlapDataAreaBCells, // BPDANALYSIS_02
				                                             OlapDataAreaBCells, // BPDANALYSIS_03
				                                             OlapDataAreaBCells, // BPDANALYSIS_04
				                                             OlapDataAreaBCells, // BPDANALYSIS_05
				                                             OlapDataAreaBCells, // BPDANALYSIS_06
				                                             OlapDataAreaBCells, // BPDANALYSIS_07
				                                             OlapDataAreaBCells, // BPDANALYSIS_08
				                                             OlapDataAreaBCells, // BPDANALYSIS_09
				                                             OlapDataAreaBCells, // BPDANALYSIS_10
				                                             OlapDataAreaBCells, // BPDANALYSIS_11
				                                             OlapDataAreaBCells // BPDANALYSIS_12
				                                            );

				LogDebug(functionName + ""processing the source data area cells for version "" + sourceVersion);
				foreach (OLAPCell cell in sourceData) {
					string account = OLAPCellGetElement(cell, accountDimension);
					string detail = OLAPCellGetElement(cell, detailDimension);
					string currency = OLAPCellGetElement(cell, currencyDimension);

					// only process local currencies
					if (StringEndsWith(currency, ""_LC"")) {
						string cycle = OLAPCellGetElement(cell, cycleDimension);
						string organization = OLAPCellGetElement(cell, organizationDimension);
						string entity = OLAPCellGetElement(cell, entityDimension);
						string time = OLAPCellGetElement(cell, timeDimension);
						string version = OLAPCellGetElement(cell, versionDimension);
						string level = OLAPCellGetElement(cell, levelDimension);
						string step = OLAPCellGetElement(cell, stepDimension);
						string interCompany = OLAPCellGetElement(cell, intercompanyDimension);
						string psegment = OLAPCellGetElement(cell, primarySegmentDimension);
						string ssegment = OLAPCellGetElement(cell, secondarySegmentDimension);
						string tsegment = OLAPCellGetElement(cell, tertiarySegmentDimension);
						string analysis01 = OLAPCellGetElement(cell, analysis01Dimension);
						string analysis02 = OLAPCellGetElement(cell, analysis02Dimension);
						string analysis03 = OLAPCellGetElement(cell, analysis03Dimension);
						string analysis04 = OLAPCellGetElement(cell, analysis04Dimension);
						string analysis05 = OLAPCellGetElement(cell, analysis05Dimension);
						string analysis06 = OLAPCellGetElement(cell, analysis06Dimension);
						string analysis07 = OLAPCellGetElement(cell, analysis07Dimension);
						string analysis08 = OLAPCellGetElement(cell, analysis08Dimension);
						string analysis09 = OLAPCellGetElement(cell, analysis09Dimension);
						string analysis10 = OLAPCellGetElement(cell, analysis10Dimension);
						string analysis11 = OLAPCellGetElement(cell, analysis11Dimension);
						string analysis12 = OLAPCellGetElement(cell, analysis12Dimension);

						double sourceValue = cell;
						OLAPCellWriteNumber(connection, targetCube, sourceValue, time, cycle, version, targetLevel, stepElement, entity, interCompany, organization, currency,
						                    psegment, ssegment, tsegment,
						                    targetAccount,
						                    analysis01, analysis02, analysis03, analysis04, analysis05, analysis06, analysis07, analysis08, analysis09, analysis10, analysis11, analysis12
						                   );
					}
				}
				y=y+1;
			}
		}
		LogDebug(functionName + "" finished transferring Opening Balances"");
		NotifyInformation(""Transfer of opening balance data to cashflow finished."");
		return ""TRUE"";
	} catch(errorMessage, errorCode) {
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return ""ERROR: ("" + errorCode + ""): "" + errorMessage;
	}
	
	// This is only here because AppEngine won't compile unless it is.
	return ""FALSE"";
}"	1	A01F2F0D-B59F-4DEC-A669-F2B1DFF76A9F	Transfer Cash Flow opening balances from BPCMAIN to CFCCASHFLOW.	1	1	1	1642	NULL	0	45708.67503	0	0
C34D9833-DF7F-459E-B13B-C5D2D6C4EA6E	CD491758-D9DF-4002-94C8-8006E1855F86	CO_AccountHasSegment	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if the segment is used."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""segmentNumber"" parameter-type=""int"" parameter-description=""The number of the segment (1,2, or 3)."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool CO_AccountHasSegment(OLAPConnection connection, string configurationSet, string account, int segmentNumber)
@Category: ""Consolidation Base Process"";
@Description: ""Gets whether the specified segment is used for given account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[segmentNumber]: ""The number of the segment (1,2, or 3)."";
@Returns: ""True, if the segment is used."";
{
	// VL - get P&amp;L top account and read its segment attributes
	OLAPElement totalPaLElement = OLAPGetDimensionElement(connection, ""DACOUNT"", account);
	string attName = """";
	if (segmentNumber == 1)
	{
		attName = ""Seg1"";
	}
	else if (segmentNumber == 2)
	{
		attName = ""Seg2"";
	}
	else if (segmentNumber == 3)
	{
		attName = ""Seg3"";
	}
	else
	{
		LogError(""Invalid segment number requested in CO_HasSegment."");
		return false;
	}
	string attValue = cached OLAPGetStringAttribute(connection, totalPaLElement, attName);
	return attValue == ""Y"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0


bool CO_AccountHasSegment(OLAPConnection connection, string configurationSet, string account, int segmentNumber)
@Category: ""Consolidation Base Process"";
@Description: ""Gets whether the specified segment is used for given account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[segmentNumber]: ""The number of the segment (1,2, or 3)."";
@Returns: ""True, if the segment is used."";
{
	// VL - get P&L top account and read its segment attributes
	OLAPElement totalPaLElement = OLAPGetDimensionElement(connection, ""DACOUNT"", account);
	string attName = """";
	if (segmentNumber == 1)
	{
		attName = ""Seg1"";
	}
	else if (segmentNumber == 2)
	{
		attName = ""Seg2"";
	}
	else if (segmentNumber == 3)
	{
		attName = ""Seg3"";
	}
	else
	{
		LogError(""Invalid segment number requested in CO_HasSegment."");
		return false;
	}
	string attValue = cached OLAPGetStringAttribute(connection, totalPaLElement, attName);
	return attValue == ""Y"";
}"	1	F0AAE4C4-C777-49F3-AB01-5574307441D1	Gets whether the specified segment is used for given account.	1	1	1	1643	NULL	0	45708.67503	0	0
7B3F03AD-8CF0-4AF0-A0E4-8B65637503F5	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Accounts	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of accounts."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Accounts(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of accounts, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of accounts."";
{
	return cached OLAPGetElementList(connection, ""DACOUNT"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Accounts(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of accounts, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of accounts."";
{
	return cached OLAPGetElementList(connection, ""DACOUNT"", true);
}"	1	9EB140F3-00D6-453B-B32C-B9BA5E66191F	Gets the list of accounts, only base elements.	1	1	1	1644	NULL	0	45708.67508	0	0
7DC54E81-51A7-4855-BA4D-9718E59C038D	CD491758-D9DF-4002-94C8-8006E1855F86	CO_AccountSchedule	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The schedule of the account."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""OLAPElement"" parameter-description=""The account to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_AccountSchedule(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the schedule of a consolidation account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The schedule of the account."";
{
	return cached OLAPGetStringAttribute(connection, account, ""DETAIL"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_AccountSchedule(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the schedule of a consolidation account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The schedule of the account."";
{
	return cached OLAPGetStringAttribute(connection, account, ""DETAIL"");
}"	1	3A936B80-4315-4871-98FE-E787AFB886A1	Gets the schedule of a consolidation account.	1	1	1	2197	NULL	0	45708.67508	0	0
5973044F-5C6E-4462-BA17-855BA79EB5E3	CD491758-D9DF-4002-94C8-8006E1855F86	CO_AccountType	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The type of the account."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""OLAPElement"" parameter-description=""The account to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_AccountType(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the type (Asset, Liability, Revenue, or Expenditure) of a consolidation account for the specified account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The type of the account."";
{
	string result = cached OLAPGetStringAttribute(connection, account, ""ALRE"");
	if (result == ""A"")
	{
		return ""Asset"";
	}

	if (result == ""L"")
	{
		return ""Liability"";
	}
	
	if (result == ""R"")
	{
		return ""Revenue"";
	}

	if (result == ""E"")
	{
		return ""Expenditure"";
	}

	return """";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_AccountType(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the type (Asset, Liability, Revenue, or Expenditure) of a consolidation account for the specified account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The type of the account."";
{
	string result = cached OLAPGetStringAttribute(connection, account, ""ALRE"");
	if (result == ""A"")
	{
		return ""Asset"";
	}

	if (result == ""L"")
	{
		return ""Liability"";
	}
	
	if (result == ""R"")
	{
		return ""Revenue"";
	}

	if (result == ""E"")
	{
		return ""Expenditure"";
	}

	return """";
}"	1	7AC1DBD2-0B4B-4BD9-A1D0-E1DBD44A1004	Gets the type (Asset, Liability, Revenue, or Expenditure) of a consolidation account for the specified account.	1	1	1	1646	NULL	0	45708.67502	0	0
AF0E6029-63FD-4B85-8713-0C20E6139851	CD491758-D9DF-4002-94C8-8006E1855F86	CO_BasePeriod	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The base period configured for the specified period."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to get the base period for."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_BasePeriod(OLAPConnection connection, string period)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the base period for specified period."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[period]: ""The period to get the base period for."";
@Returns: ""The base period configured for the specified period."";
{
	OLAPElementList periodList = cached OLAPGetElementList(connection, ""DPERIOD"", false);
	OLAPElement periodElement = OLAPGetDimensionElement(connection, ""DPERIOD"", period);
	string baseperiod = cached OLAPGetStringAttribute(connection, periodElement, ""BasePeriod"");
    return baseperiod;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_BasePeriod(OLAPConnection connection, string period)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the base period for specified period."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[period]: ""The period to get the base period for."";
@Returns: ""The base period configured for the specified period."";
{
	OLAPElementList periodList = cached OLAPGetElementList(connection, ""DPERIOD"", false);
	OLAPElement periodElement = OLAPGetDimensionElement(connection, ""DPERIOD"", period);
	string baseperiod = cached OLAPGetStringAttribute(connection, periodElement, ""BasePeriod"");
    return baseperiod;
}"	1	B985107F-A3BF-412E-88B5-1CF2BA9A98E9	Gets the base period for specified period.	1	1	1	1647	NULL	0	45708.67507	0	0
E7BDA5E8-9502-4F41-8295-2EDC833BF141	CD491758-D9DF-4002-94C8-8006E1855F86	CO_BaseYear	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The base year configured for the specified period."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to get the base year for."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to get the base year for."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_BaseYear(OLAPConnection connection, string year, string period)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the base year for the specified year."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[year]: ""The year to get the base year for."";
@Parameter[period]: ""The period to get the base year for."";
@Returns: ""The base year configured for the specified period."";
{
	OLAPElementList periodList = cached OLAPGetElementList(connection, ""DPERIOD"", false);
	OLAPElement periodElement =  OLAPGetDimensionElement(connection, ""DPERIOD"", period);
    string baseyear = cached OLAPGetStringAttribute(connection, periodElement, ""BaseYear"");
    int previous = ToInt(year) + ToInt(baseyear);
	return ToString(previous);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_BaseYear(OLAPConnection connection, string year, string period)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the base year for the specified year."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[year]: ""The year to get the base year for."";
@Parameter[period]: ""The period to get the base year for."";
@Returns: ""The base year configured for the specified period."";
{
	OLAPElementList periodList = cached OLAPGetElementList(connection, ""DPERIOD"", false);
	OLAPElement periodElement =  OLAPGetDimensionElement(connection, ""DPERIOD"", period);
    string baseyear = cached OLAPGetStringAttribute(connection, periodElement, ""BaseYear"");
    int previous = ToInt(year) + ToInt(baseyear);
	return ToString(previous);
}"	1	EA8D2E48-AB69-46B1-AC7E-3A08A36A0A4A	Gets the base year for the specified year.	1	1	1	1648	NULL	0	45708.67503	0	0
8C98D3CE-3937-4499-AFF5-AE647407F50F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_BookingType	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""1 or 2."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be process."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration Set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""process"" parameter-type=""OLAPElement"" parameter-description=""The process to query."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

int CO_BookingType(OLAPConnection connection, string configurationSet, OLAPElement process)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the journal type (1 or 2 journals per rule) for the specified rule."";
@Parameter[connection]: ""A connection to the OLAP database to be process."";
@Parameter[configurationSet]: ""The configuration Set to query."";
@Parameter[process]: ""The process to query."";
@Returns: ""1 or 2."";
{
	// VL - find a parent element in the DCONSRL dimension (should be Cons. Debts or Cons. Expenditure/Revenues) and read its BookingType property
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	OLAPElement parent = parentElements[0];
	return cached OLAPGetIntAttribute(connection, parent, ""BookingType"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

int CO_BookingType(OLAPConnection connection, string configurationSet, OLAPElement process)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the journal type (1 or 2 journals per rule) for the specified rule."";
@Parameter[connection]: ""A connection to the OLAP database to be process."";
@Parameter[configurationSet]: ""The configuration Set to query."";
@Parameter[process]: ""The process to query."";
@Returns: ""1 or 2."";
{
	// VL - find a parent element in the DCONSRL dimension (should be Cons. Debts or Cons. Expenditure/Revenues) and read its BookingType property
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	OLAPElement parent = parentElements[0];
	return cached OLAPGetIntAttribute(connection, parent, ""BookingType"");
}"	1	5F5EB9EA-9685-470C-A22E-9EFF4FEAA23E	Gets the journal type (1 or 2 journals per rule) for the specified rule.	1	1	1	1649	NULL	0	45708.67508	0	0
76F60275-ABB0-45D8-9765-3E71D41E2303	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CalculatedShares	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The calculated shared for the specified company on intercompany in group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""An element that specifies the intercompany to query."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_CalculatedShares(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the calculated shares of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The calculated shared for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""calculated shares"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_CalculatedShares(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the calculated shares of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The calculated shared for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""calculated shares"");
}"	1	042B5EEC-559C-452F-9E75-3BCD0C2E7A4B	Gets the calculated shares of a company on an intercompany in a group for a specified context.	1	1	1	1650	NULL	0	45708.67507	0	0
1E18E2C8-8189-494D-B529-E2B7F93FE70E	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CashflowCompany	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""the company to run the rule for - C/N-Element"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BaseYear"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BasePeriod"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""

#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""

bool CO_CashflowCompany(string server, string cycle, string year, string period, string scenario, string company, bool cancel)
@Description: ""Former FCCashflowCompany process. Adaptation/Extension of the CF1 Cash Flow Company rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[company]: ""the company to run the rule for - C/N-Element"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//handle account types 1-4, type 99 is only deleted

	//TSTDCASH_CO
	//handle all base elements for segment dimensions
	//if at least one segment is active the segment cubes (TSEGMC, TSEGMOVC) are used instead of the normal detail cubes (TFINANC, TDETAIC)
	//if there is no active segment, ""-"" is used as target for all segment dimensions

	//Partnersegments are missing from cube?

	//wo ist config vorhanden


	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	company = ""RU0001"";
	cancel = false;*/
		
	string processName = ""CO_CashflowCompany"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; company&lt;"" + company + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);

		string cubeCashflow = ""TSTDCASHSEGM"";
		string cubeCashflowConfig = ""TSTDCASHCFG"";
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDACOUNT = OLAPGetElementList(olapConnection, ""DACOUNT"", false);
		OLAPElementList sourceDDETAIL = OLAPGetElementList(olapConnection, ""DDETAIL"", false);
		OLAPElementList sourceDSTDCASHACC = CreateOLAPElementList();
		OLAPElementList deleteDSTDCASHACC = CreateOLAPElementList();
		string sourceDSTDCASHCFG = ""Weight"";
		//all childs under supplied company
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);

		double totalValue = 0;
		double value = 0;
		double counter = 0;
		
		OLAPElementList levels = OLAPGetChildElementList(olapConnection, ""DCLEVEL"", ""HB III"", true);
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		OLAPElementList yearFilter = CreateOLAPElementList();
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",year));
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",baseYear));
		OLAPElementList periodFilter = CreateOLAPElementList();
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",period));
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",basePeriod));
		
		//collect relevant Cashflow-Accounts
		foreach (OLAPElement cashflowAccount in OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true))
		{
			double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4) {
				OLAPElementListAddElement(sourceDSTDCASHACC, cashflowAccount);
			}
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4 or AccountType == 99) {
				OLAPElementListAddElement(deleteDSTDCASHACC, cashflowAccount);
			}
		}

		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		// we do not use segments for now
		/*
		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
			WriteLine(""using segments"");
		}
		*/
		
		WriteLine(""deleting old data in &lt;"" + cubeCashflow + ""&gt;"");
		
		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", ""HB III"", ""global"", sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,
			deleteDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);
		
		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflowWeight = OLAPCreateDataArea(
				olapConnection, cubeCashflowConfig, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDACOUNT, sourceDDETAIL, sourceDSTDCASHACC, sourceDSTDCASHCFG
			);
			
			foreach (OLAPCell cell in dataAreaCashflowWeight)
			{
				string cashflowAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				//read already cached AccountType
				double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
				
				//check if we have a relevant value
				if (AccountType == 1 or
				    ((AccountType == 2 or AccountType == 3) and detail == ""-"") or
				    AccountType == 4) {
					
					string accountWeightText = cell;
					
					if (StringTrim(accountWeightText) != """") {
						double accountWeight = ToInt(accountWeightText);
						if (accountWeight != 0) {

							if (AccountType == 1) {
								//Schedule (Spiegeldetail)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMOVC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TDETAIC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 2) {
								//Closing Balance (Endbestand)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue,cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 3) {
								//Previous Year

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 4) {
								//special Account handling
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}
							}
						}
					}
				}
			}
			
			WriteLine(""processed &lt;"" + counter + ""&gt; value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}

		result = true;
	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""

#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""

bool CO_CashflowCompany(string server, string cycle, string year, string period, string scenario, string company, bool cancel)
@Description: ""Former FCCashflowCompany process. Adaptation/Extension of the CF1 Cash Flow Company rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[company]: ""the company to run the rule for - C/N-Element"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//handle account types 1-4, type 99 is only deleted

	//TSTDCASH_CO
	//handle all base elements for segment dimensions
	//if at least one segment is active the segment cubes (TSEGMC, TSEGMOVC) are used instead of the normal detail cubes (TFINANC, TDETAIC)
	//if there is no active segment, ""-"" is used as target for all segment dimensions

	//Partnersegments are missing from cube?

	//wo ist config vorhanden


	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	company = ""RU0001"";
	cancel = false;*/
		
	string processName = ""CO_CashflowCompany"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> company<"" + company + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);

		string cubeCashflow = ""TSTDCASHSEGM"";
		string cubeCashflowConfig = ""TSTDCASHCFG"";
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDACOUNT = OLAPGetElementList(olapConnection, ""DACOUNT"", false);
		OLAPElementList sourceDDETAIL = OLAPGetElementList(olapConnection, ""DDETAIL"", false);
		OLAPElementList sourceDSTDCASHACC = CreateOLAPElementList();
		OLAPElementList deleteDSTDCASHACC = CreateOLAPElementList();
		string sourceDSTDCASHCFG = ""Weight"";
		//all childs under supplied company
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);

		double totalValue = 0;
		double value = 0;
		double counter = 0;
		
		OLAPElementList levels = OLAPGetChildElementList(olapConnection, ""DCLEVEL"", ""HB III"", true);
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		OLAPElementList yearFilter = CreateOLAPElementList();
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",year));
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",baseYear));
		OLAPElementList periodFilter = CreateOLAPElementList();
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",period));
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",basePeriod));
		
		//collect relevant Cashflow-Accounts
		foreach (OLAPElement cashflowAccount in OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true))
		{
			double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4) {
				OLAPElementListAddElement(sourceDSTDCASHACC, cashflowAccount);
			}
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4 or AccountType == 99) {
				OLAPElementListAddElement(deleteDSTDCASHACC, cashflowAccount);
			}
		}

		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		// we do not use segments for now
		/*
		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
			WriteLine(""using segments"");
		}
		*/
		
		WriteLine(""deleting old data in <"" + cubeCashflow + "">"");
		
		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", ""HB III"", ""global"", sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,
			deleteDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);
		
		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflowWeight = OLAPCreateDataArea(
				olapConnection, cubeCashflowConfig, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDACOUNT, sourceDDETAIL, sourceDSTDCASHACC, sourceDSTDCASHCFG
			);
			
			foreach (OLAPCell cell in dataAreaCashflowWeight)
			{
				string cashflowAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				//read already cached AccountType
				double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
				
				//check if we have a relevant value
				if (AccountType == 1 or
				    ((AccountType == 2 or AccountType == 3) and detail == ""-"") or
				    AccountType == 4) {
					
					string accountWeightText = cell;
					
					if (StringTrim(accountWeightText) != """") {
						double accountWeight = ToInt(accountWeightText);
						if (accountWeight != 0) {

							if (AccountType == 1) {
								//Schedule (Spiegeldetail)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMOVC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TDETAIC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 2) {
								//Closing Balance (Endbestand)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue,cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 3) {
								//Previous Year

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 4) {
								//special Account handling
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""), //OLAPCellGetElement(cell2, ""DPRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""), //OLAPCellGetElement(cell2, ""DSRSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""), //OLAPCellGetElement(cell2, ""DTRSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANC"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, ""LC (scaled)"", levels, ""Balance Sheet"", sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   ""LC (scaled)"", ""HB III"", ""global"", OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget, //inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}
							}
						}
					}
				}
			}
			
			WriteLine(""processed <"" + counter + ""> value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}

		result = true;
	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	E5FA02F6-9358-4269-B305-8503241FAA04	Former FCCashflowCompany process. Adaptation/Extension of the CF1 Cash Flow Company rule	1	1	1	1651	NULL	0	45708.67503	0	0
56537263-A0BC-49F1-B790-177136D7CA0A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CashflowCurrencyDifferences	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BaseYear"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BasePeriod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
    <process process-name=""GetCashFlowConfigAccountWeight"" process-version=""*"" process-id="""" />
    <process process-name=""GetCashFlowDifferenceByEntity"" process-version=""*"" process-id="""" />
    <process process-name=""GetCashFlowValueSumByEntity"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""GetCashFlowConfigAccountWeight"", ""*""
#include ""GetCashFlowDifferenceByEntity"", ""*""
#include ""GetCashFlowValueSumByEntity"", ""*""

bool CO_CashflowCurrencyDifferences(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowCurrencyDifferences process. Adaptation/Extension of the CF4 Cash Flow Currency Differences rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//exchangeRateEffects (rate current year vs previous year) are disclosed on a separate account (TopAccount XXX)

	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/

	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowCurrencyDifferences"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; company&lt;"" + company + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		
		string cubeCashflow = ""TSTDCASHSEGM"";
		
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string levelCashflow = ""HB III"";
		
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

		string account43 = CO_TopAccount(olapConnection,cycle, 43);
		string account44 = CO_TopAccount(olapConnection,cycle, 44);
		string cashAccount = CO_TopAccount(olapConnection, cycle, 45);
		
		string totalSegments = ""Total"";
		string inactiveSegments = ""-"";

		WriteLine(""deleting old data in &lt;"" + cubeCashflow + ""&gt;"");

		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, year, period, scenario, groupcurrency, levelCashflow, ""global"", sourceDCOMPC, intco, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account44
		);
		
		OLAPDeleteDataArea(deleteArea);
		WriteLine(""deleted data"");
		
		if (!cancel) {
			string localCurrency = ""LC"";

			// get account weights per period
			DoubleDictionary currentPeriodAccountWeights = GetCashFlowConfigAccountWeight(olapConnection, cycle, year, period, scenario, cashAccount);
			DoubleDictionary basePeriodAccountWeights = GetCashFlowConfigAccountWeight(olapConnection, cycle, baseYear, basePeriod, scenario, cashAccount);
			
			// get Cashflow values
			DoubleDictionary currentPeriodLocalCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, year, period, scenario, localCurrency, sourceDCOMPC, currentPeriodAccountWeights);
			DoubleDictionary basePeriodLocalCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, baseYear, basePeriod, scenario, localCurrency, sourceDCOMPC, basePeriodAccountWeights);
			DoubleDictionary currentPeriodGroupCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, year, period, scenario, groupcurrency, sourceDCOMPC, currentPeriodAccountWeights);
			DoubleDictionary basePeriodGroupCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, baseYear, basePeriod, scenario, groupcurrency, sourceDCOMPC, basePeriodAccountWeights);

			// get cashflowDifferences of companies
			DoubleDictionary LocalCurrCashFlowDifferenceList = GetCashFlowDifferenceByEntity(olapConnection, cycle, year, period, scenario, localCurrency, account43);
			DoubleDictionary GroupCurrCashFlowDifferenceList = GetCashFlowDifferenceByEntity(olapConnection, cycle, year, period, scenario, groupcurrency, account43);

			OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection);
			OLAPSetAutoCommit(buffer, true);
			OLAPSetMaxUncommittedValues(buffer, 100);
			double LocalCurrCashFlowDifference = 0;
			double GroupCurrCashFlowDifference = 0;

			foreach (OLAPElement companyElement in sourceDCOMPC) {
				// we use ""Total"" segment just in case; currently all data should be on '-' segments but future may change this
				LocalCurrCashFlowDifference = 0;
				if (ContainsKey(LocalCurrCashFlowDifferenceList, companyElement))
				{
					LocalCurrCashFlowDifference = LocalCurrCashFlowDifferenceList[companyElement];
				}

				double CashCurrentLocal = currentPeriodLocalCurrencyValues[companyElement];
				double CashPreviousLocal = basePeriodLocalCurrencyValues[companyElement];
				
				double LocalDifference = CashCurrentLocal - CashPreviousLocal - LocalCurrCashFlowDifference;
				
				if (RoundDecimals(LocalDifference, 0) != 0)
				{
					WriteLine(""Warning: The cash flow reconciliation in local currency for company "" + companyElement + "" has not been done."");
					WriteLine(""The difference in local currency was: "" + LocalDifference);
				}
				else
				{
					GroupCurrCashFlowDifference = 0;
					if (ContainsKey(GroupCurrCashFlowDifferenceList, companyElement))
					{
						GroupCurrCashFlowDifference = GroupCurrCashFlowDifferenceList[companyElement];
					}

					double CashCurr = currentPeriodGroupCurrencyValues[companyElement];
					double CashPY = basePeriodGroupCurrencyValues[companyElement];

					double CurrencyDiff = ((CashCurr - CashPY) - GroupCurrCashFlowDifference);

					if (RoundDecimals(CurrencyDiff, 2) != 0)
					{
						OLAPCellWriteBufferWriteNumber(buffer, cubeCashflow, CurrencyDiff, cycle, year, period, scenario, groupcurrency, levelCashflow, ""global"", companyElement, ""External"", inactiveSegments, inactiveSegments, inactiveSegments, account44);
					}
				}
			}
			OLAPCommitCellWriteBuffer(buffer);
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""GetCashFlowConfigAccountWeight"", ""*""
#include ""GetCashFlowDifferenceByEntity"", ""*""
#include ""GetCashFlowValueSumByEntity"", ""*""

bool CO_CashflowCurrencyDifferences(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowCurrencyDifferences process. Adaptation/Extension of the CF4 Cash Flow Currency Differences rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//exchangeRateEffects (rate current year vs previous year) are disclosed on a separate account (TopAccount XXX)

	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/

	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowCurrencyDifferences"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> company<"" + company + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		
		string cubeCashflow = ""TSTDCASHSEGM"";
		
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string levelCashflow = ""HB III"";
		
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

		string account43 = CO_TopAccount(olapConnection,cycle, 43);
		string account44 = CO_TopAccount(olapConnection,cycle, 44);
		string cashAccount = CO_TopAccount(olapConnection, cycle, 45);
		
		string totalSegments = ""Total"";
		string inactiveSegments = ""-"";

		WriteLine(""deleting old data in <"" + cubeCashflow + "">"");

		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, year, period, scenario, groupcurrency, levelCashflow, ""global"", sourceDCOMPC, intco, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account44
		);
		
		OLAPDeleteDataArea(deleteArea);
		WriteLine(""deleted data"");
		
		if (!cancel) {
			string localCurrency = ""LC"";

			// get account weights per period
			DoubleDictionary currentPeriodAccountWeights = GetCashFlowConfigAccountWeight(olapConnection, cycle, year, period, scenario, cashAccount);
			DoubleDictionary basePeriodAccountWeights = GetCashFlowConfigAccountWeight(olapConnection, cycle, baseYear, basePeriod, scenario, cashAccount);
			
			// get Cashflow values
			DoubleDictionary currentPeriodLocalCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, year, period, scenario, localCurrency, sourceDCOMPC, currentPeriodAccountWeights);
			DoubleDictionary basePeriodLocalCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, baseYear, basePeriod, scenario, localCurrency, sourceDCOMPC, basePeriodAccountWeights);
			DoubleDictionary currentPeriodGroupCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, year, period, scenario, groupcurrency, sourceDCOMPC, currentPeriodAccountWeights);
			DoubleDictionary basePeriodGroupCurrencyValues = GetCashFlowValueSumByEntity(olapConnection, cycle, baseYear, basePeriod, scenario, groupcurrency, sourceDCOMPC, basePeriodAccountWeights);

			// get cashflowDifferences of companies
			DoubleDictionary LocalCurrCashFlowDifferenceList = GetCashFlowDifferenceByEntity(olapConnection, cycle, year, period, scenario, localCurrency, account43);
			DoubleDictionary GroupCurrCashFlowDifferenceList = GetCashFlowDifferenceByEntity(olapConnection, cycle, year, period, scenario, groupcurrency, account43);

			OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection);
			OLAPSetAutoCommit(buffer, true);
			OLAPSetMaxUncommittedValues(buffer, 100);
			double LocalCurrCashFlowDifference = 0;
			double GroupCurrCashFlowDifference = 0;

			foreach (OLAPElement companyElement in sourceDCOMPC) {
				// we use ""Total"" segment just in case; currently all data should be on '-' segments but future may change this
				LocalCurrCashFlowDifference = 0;
				if (ContainsKey(LocalCurrCashFlowDifferenceList, companyElement))
				{
					LocalCurrCashFlowDifference = LocalCurrCashFlowDifferenceList[companyElement];
				}

				double CashCurrentLocal = currentPeriodLocalCurrencyValues[companyElement];
				double CashPreviousLocal = basePeriodLocalCurrencyValues[companyElement];
				
				double LocalDifference = CashCurrentLocal - CashPreviousLocal - LocalCurrCashFlowDifference;
				
				if (RoundDecimals(LocalDifference, 0) != 0)
				{
					WriteLine(""Warning: The cash flow reconciliation in local currency for company "" + companyElement + "" has not been done."");
					WriteLine(""The difference in local currency was: "" + LocalDifference);
				}
				else
				{
					GroupCurrCashFlowDifference = 0;
					if (ContainsKey(GroupCurrCashFlowDifferenceList, companyElement))
					{
						GroupCurrCashFlowDifference = GroupCurrCashFlowDifferenceList[companyElement];
					}

					double CashCurr = currentPeriodGroupCurrencyValues[companyElement];
					double CashPY = basePeriodGroupCurrencyValues[companyElement];

					double CurrencyDiff = ((CashCurr - CashPY) - GroupCurrCashFlowDifference);

					if (RoundDecimals(CurrencyDiff, 2) != 0)
					{
						OLAPCellWriteBufferWriteNumber(buffer, cubeCashflow, CurrencyDiff, cycle, year, period, scenario, groupcurrency, levelCashflow, ""global"", companyElement, ""External"", inactiveSegments, inactiveSegments, inactiveSegments, account44);
					}
				}
			}
			OLAPCommitCellWriteBuffer(buffer);
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	2E1D0DE7-EFCE-49BE-9197-F8ECF22DA3BF	Former FCCashflowCurrencyDifferences process. Adaptation/Extension of the CF4 Cash Flow Currency Differences rule	1	1	1	1652	NULL	0	45708.67501	0	0
DC75F166-9ACB-46F1-A4C1-CCF9D87A5392	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CashflowGroup	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BaseYear"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BasePeriod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""

#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_GroupCurrency"", ""*""

bool CO_CashflowGroup(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowGroup process. Adaptation/Extension of the CF3 Cash Flow Group rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2014"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/
	
	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowGroup"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; company&lt;"" + company + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);

		string cubeCashflow = ""TSTDCASHSEGM"";
		string cubeCashflowConfig = ""TSTDCASHCFG"";
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDACOUNT = OLAPGetElementList(olapConnection, ""DACOUNT"", false);
		OLAPElementList sourceDDETAIL = OLAPGetElementList(olapConnection, ""DDETAIL"", false);
		OLAPElementList sourceDSTDCASHACC = CreateOLAPElementList();
		OLAPElementList deleteDSTDCASHACC = CreateOLAPElementList();
		string sourceDSTDCASHCFG = ""Weight"";
		//all childs under supplied company
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);

		double totalValue = 0;
		double value = 0;
		double counter = 0;
		
		OLAPElementList levels = CreateOLAPElementList();
		OLAPElementList levelsWithRollover = CreateOLAPElementList();
		foreach (OLAPElement level in OLAPGetChildElementList(olapConnection, ""DGLEVEL"", ""Consolidation"", true))
		{
			OLAPElementListAddElement(levels, level);
			OLAPElementListAddElement(levelsWithRollover, level);
		}
		foreach (OLAPElement level in OLAPGetChildElementList(olapConnection, ""DGLEVEL"", ""Rollover Total"", true))
		{
			OLAPElementListAddElement(levelsWithRollover, level);
		}
		
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		OLAPElementList yearFilter = CreateOLAPElementList();
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",year));
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",baseYear));
		OLAPElementList periodFilter = CreateOLAPElementList();
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",period));
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",basePeriod));

		//collect relevant Cashflow-Accounts
		foreach (OLAPElement cashflowAccount in OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true))
		{
			double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4) {
				OLAPElementListAddElement(sourceDSTDCASHACC, cashflowAccount);
			}
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4 or AccountType == 99) {
				OLAPElementListAddElement(deleteDSTDCASHACC, cashflowAccount);
			}
		}

		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		// we do not use segments for now
		/*
		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
			WriteLine(""using segments"");
		}
		*/
		
		WriteLine(""deleting old data in &lt;"" + cubeCashflow + ""&gt;"");
		
		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, ""Group Adjustment"", group, sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,
			deleteDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);
		
		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflowWeight = OLAPCreateDataArea(
				olapConnection, cubeCashflowConfig, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDACOUNT, sourceDDETAIL, sourceDSTDCASHACC, sourceDSTDCASHCFG
			);
			
			foreach (OLAPCell cell in dataAreaCashflowWeight)
			{
				string cashflowAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				//read already cached AccountType
				double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
				
				//check if we have a relevant value
				if (AccountType == 1 or
				    ((AccountType == 2 or AccountType == 3) and detail == ""-"") or
				    AccountType == 4) {
					
					string accountWeightText = cell;
					
					if (StringTrim(accountWeightText) != """") {
						double accountWeight = ToInt(accountWeightText);
						if (accountWeight != 0) {

							if (AccountType == 1) {
								//Schedule (Spiegeldetail)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMOVG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TDETAIG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, sourceDCOMPC, intco, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 2) {
								//Closing Balance (Endbestand)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue,cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 3) {
								//Previous Year

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, groupcurrency, levelsWithRollover, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, groupcurrency, levelsWithRollover, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 4) {
								//special Account handling

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, groupcurrency, levelsWithRollover, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, groupcurrency, levelsWithRollover, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}
							}
						}
					}
				}
			}
			
			WriteLine(""processed &lt;"" + counter + ""&gt; value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}

		result = true;
	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""

#include ""CO_BaseYear"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_GroupCurrency"", ""*""

bool CO_CashflowGroup(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowGroup process. Adaptation/Extension of the CF3 Cash Flow Group rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2014"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/
	
	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowGroup"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> company<"" + company + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);

		string cubeCashflow = ""TSTDCASHSEGM"";
		string cubeCashflowConfig = ""TSTDCASHCFG"";
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDACOUNT = OLAPGetElementList(olapConnection, ""DACOUNT"", false);
		OLAPElementList sourceDDETAIL = OLAPGetElementList(olapConnection, ""DDETAIL"", false);
		OLAPElementList sourceDSTDCASHACC = CreateOLAPElementList();
		OLAPElementList deleteDSTDCASHACC = CreateOLAPElementList();
		string sourceDSTDCASHCFG = ""Weight"";
		//all childs under supplied company
		OLAPElementList sourceDCOMPC = OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true);

		double totalValue = 0;
		double value = 0;
		double counter = 0;
		
		OLAPElementList levels = CreateOLAPElementList();
		OLAPElementList levelsWithRollover = CreateOLAPElementList();
		foreach (OLAPElement level in OLAPGetChildElementList(olapConnection, ""DGLEVEL"", ""Consolidation"", true))
		{
			OLAPElementListAddElement(levels, level);
			OLAPElementListAddElement(levelsWithRollover, level);
		}
		foreach (OLAPElement level in OLAPGetChildElementList(olapConnection, ""DGLEVEL"", ""Rollover Total"", true))
		{
			OLAPElementListAddElement(levelsWithRollover, level);
		}
		
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		string baseYear = CO_BaseYear(olapConnection, year, period);
		string basePeriod = CO_BasePeriod(olapConnection, period);
		
		OLAPElementList yearFilter = CreateOLAPElementList();
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",year));
		OLAPElementListAddElement(yearFilter, OLAPGetDimensionElement(olapConnection,""DYEAR"",baseYear));
		OLAPElementList periodFilter = CreateOLAPElementList();
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",period));
		OLAPElementListAddElement(periodFilter, OLAPGetDimensionElement(olapConnection,""DPERIOD"",basePeriod));

		//collect relevant Cashflow-Accounts
		foreach (OLAPElement cashflowAccount in OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true))
		{
			double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4) {
				OLAPElementListAddElement(sourceDSTDCASHACC, cashflowAccount);
			}
			if (AccountType == 1 or AccountType == 2 or AccountType == 3 or AccountType == 4 or AccountType == 99) {
				OLAPElementListAddElement(deleteDSTDCASHACC, cashflowAccount);
			}
		}

		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		// we do not use segments for now
		/*
		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
			WriteLine(""using segments"");
		}
		*/
		
		WriteLine(""deleting old data in <"" + cubeCashflow + "">"");
		
		//deletearea
		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, ""Group Adjustment"", group, sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells,
			deleteDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);
		
		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflowWeight = OLAPCreateDataArea(
				olapConnection, cubeCashflowConfig, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDACOUNT, sourceDDETAIL, sourceDSTDCASHACC, sourceDSTDCASHCFG
			);
			
			foreach (OLAPCell cell in dataAreaCashflowWeight)
			{
				string cashflowAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				//read already cached AccountType
				double AccountType = cached OLAPCellReadNumber(olapConnection, cubeCashflowConfig, 1, cycle, year, period, scenario, ""Cashflow"", ""-"", cashflowAccount, ""Type"");
				
				//check if we have a relevant value
				if (AccountType == 1 or
				    ((AccountType == 2 or AccountType == 3) and detail == ""-"") or
				    AccountType == 4) {
					
					string accountWeightText = cell;
					
					if (StringTrim(accountWeightText) != """") {
						double accountWeight = ToInt(accountWeightText);
						if (accountWeight != 0) {

							if (AccountType == 1) {
								//Schedule (Spiegeldetail)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMOVG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TDETAIG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, sourceDCOMPC, intco, detail, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 2) {
								//Closing Balance (Endbestand)
								
								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue,cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, groupcurrency, levels, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 3) {
								//Previous Year

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, groupcurrency, levelsWithRollover, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, yearFilter, periodFilter, sourceDVERSIO, groupcurrency, levelsWithRollover, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										totalValue = 0;
										if (OLAPCellGetElement(cell2, ""DYEAR"") == baseYear and OLAPCellGetElement(cell2, ""DPERIOD"") == basePeriod) {
											//DataPreviousYear
											value = cell2;
											totalValue = (value * accountWeight) * -1;
										} else if (OLAPCellGetElement(cell2, ""DYEAR"") == year and OLAPCellGetElement(cell2, ""DPERIOD"") == period) {
											//DataCurrentYear
											value = cell2;
											totalValue = (value * accountWeight);
										}
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}

							} else if (AccountType == 4) {
								//special Account handling

								if(useSegments) {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, groupcurrency, levelsWithRollover, group, OlapDataAreaBCells, sourceDCOMPC, intco,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   OLAPCellGetElement(cell2, ""DPSEGM""),
											                                   OLAPCellGetElement(cell2, ""DSSEGM""),
											                                   OLAPCellGetElement(cell2, ""DTSEGM""),
											                                   cashflowAccount);
										}
									}
								} else {
									//use 2nd connection since we have already openend a dataarea
									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection2, ""TFINANG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, baseYear, basePeriod, sourceDVERSIO, groupcurrency, levelsWithRollover, group, sourceDCOMPC, intco, account
									);
									
									foreach (OLAPCell cell2 in sourceArea)
									{
										value = cell2;
										totalValue = (value * accountWeight);
										
										if (RoundDecimals(totalValue, 2) != 0) {
											counter = counter + 1;
											
											OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, totalValue, cycle, year, period, scenario,
											                                   groupcurrency, ""Group Adjustment"", group, OLAPCellGetElement(cell2, ""DCOMPC""), OLAPCellGetElement(cell2, ""DINTCO""),
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   inactiveSegmentsTarget,
											                                   cashflowAccount);
										}
									}
								}
							}
						}
					}
				}
			}
			
			WriteLine(""processed <"" + counter + ""> value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}

		result = true;
	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	B3BA2DDE-C463-48D9-B65C-BFA4A09C344B	Former FCCashflowGroup process. Adaptation/Extension of the CF3 Cash Flow Group rule	1	1	1	1653	NULL	0	45708.67509	0	0
558B536A-63AD-4461-A36C-D496CD8A3DFB	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CashflowSumOfAllCompanies	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""6"" />
  <dependencies>
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HoldingCompany"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CalculatedShares"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HasSegment"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_HasSegment"", ""*""

bool CO_CashflowSumOfAllCompanies(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowSumOfAllCompanies process. Adaptation/Extension of the CF2 Cash Flow Sum of all Companies rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/
	
	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowSumOfAllCompanies"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; company&lt;"" + company + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);
		
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDSTDCASHACC = OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true);
		string sourceDLCURR = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		OLAPElementList sourceDSTDCASHLEV = OLAPGetChildElementListOrItself(olapConnection, ""DSTDCASHLEV"", ""HB III"", true);
		string sourceDGROUP = ""global"";
		string cubeCashflow = ""TSTDCASHSEGM"";
		//all childs under supplied company with Method Full/Quotal
		OLAPElementList sourceDCOMPC = CreateOLAPElementList();
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		double value = 0;
		double counter = 0;
		double percentofConsolidation = 0;
		
		foreach (OLAPElement comp in OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true) where
		         ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Full"") or
		          (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Quotal""))) {
			OLAPElementListAddElement(sourceDCOMPC, comp);
		}
		
		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
		}

		WriteLine(""deleting old data in &lt;"" + cubeCashflow + ""&gt;"");

		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDLCURR, ""HB III"", group, sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, sourceDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);

		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflow = OLAPCreateDataArea(
				olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDLCURR, sourceDSTDCASHLEV, sourceDGROUP, sourceDCOMPC, intco,
				OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, sourceDSTDCASHACC
			);
			
			foreach (OLAPCell cell in dataAreaCashflow)
			{
				string comp = OLAPCellGetElement(cell, ""DCOMPC"");
				value = cell;
				
				if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Quotal"") {
					percentofConsolidation = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), comp);
					value = value * percentofConsolidation;
				}
				
				if (RoundDecimals(value, 2) != 0) {
					OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, value, cycle, year, period, scenario, sourceDLCURR,
					                                   ""HB III"", group, comp, OLAPCellGetElement(cell, ""DINTCO""),
					                                   OLAPCellGetElement(cell, ""DPSEGM""),
					                                   OLAPCellGetElement(cell, ""DSSEGM""),
					                                   OLAPCellGetElement(cell, ""DTSEGM""),
					                                   OLAPCellGetElement(cell, ""DSTDCASHACC""));
					counter = counter + 1;
				}
			}

			WriteLine(""processed &lt;"" + counter + ""&gt; value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_HasSegment"", ""*""

bool CO_CashflowSumOfAllCompanies(string server, string cycle, string year, string period, string scenario, string group, bool cancel)
@Description: ""Former FCCashflowSumOfAllCompanies process. Adaptation/Extension of the CF2 Cash Flow Sum of all Companies rule"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	company = ""RU0001"";
	cancel = false;*/
	
	// always consider all companies
	string company = ""Group Companies"";

	string processName = ""CO_CashflowSumOfAllCompanies"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> company<"" + company + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(olapConnection, true, 100000);
		
		string sourceDYEAR = year;
		string sourceDPERIOD = period;
		string sourceDVERSIO = scenario;
		OLAPElementList sourceDSTDCASHACC = OLAPGetElementList(olapConnection, ""DSTDCASHACC"", true);
		string sourceDLCURR = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		OLAPElementList sourceDSTDCASHLEV = OLAPGetChildElementListOrItself(olapConnection, ""DSTDCASHLEV"", ""HB III"", true);
		string sourceDGROUP = ""global"";
		string cubeCashflow = ""TSTDCASHSEGM"";
		//all childs under supplied company with Method Full/Quotal
		OLAPElementList sourceDCOMPC = CreateOLAPElementList();
		OLAPElementList intco = OLAPGetChildElementList(olapConnection, ""DINTCO"", ""Sum"", true);
		double value = 0;
		double counter = 0;
		double percentofConsolidation = 0;
		
		foreach (OLAPElement comp in OLAPGetChildElementListOrItself(olapConnection, ""DCOMPC"", company, true) where
		         ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Full"") or
		          (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Quotal""))) {
			OLAPElementListAddElement(sourceDCOMPC, comp);
		}
		
		//segments
		string inactiveSegmentsTarget = ""-"";
		bool useSegments = false;

		if(CO_HasSegment(olapConnection, cycle, 1) or CO_HasSegment(olapConnection, cycle, 2) or CO_HasSegment(olapConnection, cycle, 3)) {
			useSegments = true;
		}

		WriteLine(""deleting old data in <"" + cubeCashflow + "">"");

		OLAPDataArea deleteArea = OLAPCreateDataArea(
			olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
			OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
			cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDLCURR, ""HB III"", group, sourceDCOMPC, intco,
			OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, sourceDSTDCASHACC
		);
		
		OLAPDeleteDataArea(deleteArea);

		WriteLine(""deleted data"");
		
		if (!cancel) {
			OLAPDataArea dataAreaCashflow = OLAPCreateDataArea(
				olapConnection, cubeCashflow, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDLCURR, sourceDSTDCASHLEV, sourceDGROUP, sourceDCOMPC, intco,
				OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, sourceDSTDCASHACC
			);
			
			foreach (OLAPCell cell in dataAreaCashflow)
			{
				string comp = OLAPCellGetElement(cell, ""DCOMPC"");
				value = cell;
				
				if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, comp) == ""Quotal"") {
					percentofConsolidation = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), comp);
					value = value * percentofConsolidation;
				}
				
				if (RoundDecimals(value, 2) != 0) {
					OLAPCellWriteBufferIncrementNumber(buffer, cubeCashflow, value, cycle, year, period, scenario, sourceDLCURR,
					                                   ""HB III"", group, comp, OLAPCellGetElement(cell, ""DINTCO""),
					                                   OLAPCellGetElement(cell, ""DPSEGM""),
					                                   OLAPCellGetElement(cell, ""DSSEGM""),
					                                   OLAPCellGetElement(cell, ""DTSEGM""),
					                                   OLAPCellGetElement(cell, ""DSTDCASHACC""));
					counter = counter + 1;
				}
			}

			WriteLine(""processed <"" + counter + ""> value(s)"");
			
			//flush buffer
			WriteLine(""committing values"");
			OLAPCommitCellWriteBuffer(buffer);
			WriteLine(""committed values"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	3E8B11FF-9CDD-4122-BC04-2CF1483BD083	Former FCCashflowSumOfAllCompanies process. Adaptation/Extension of the CF2 Cash Flow Sum of all Companies rule	1	1	1	1654	NULL	0	45708.67502	0	0
9C877B7C-CAFE-439D-862D-F085BD134560	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Companies	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of companies."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Companies(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of companies, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of companies."";
{
	return cached OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Companies(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of companies, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of companies."";
{
	return cached OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
}"	1	E427F4D4-D58C-4089-BF05-D79A64750585	Gets the list of companies, only base elements.	1	1	1	1655	NULL	0	45708.67505	0	0
39DDC6FC-AF1A-40D7-9ECC-E459625302EF	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CompanyCurrency	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The currency of the given group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_CompanyCurrency(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company)
@Description: ""Returns the currency of the given group."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""The currency of the given group."";
{
	return cached OLAPCellReadString(connection, ""TCOMPPA"", configurationSet, year, period, scenario, company, ""Currency"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_CompanyCurrency(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company)
@Description: ""Returns the currency of the given group."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""The currency of the given group."";
{
	return cached OLAPCellReadString(connection, ""TCOMPPA"", configurationSet, year, period, scenario, company, ""Currency"");
}"	1	4E05B02F-506C-4546-9EE8-B16305C34112	Returns the currency of the given group.	1	1	1	1656	NULL	0	45708.67501	0	0
4584BF8E-3FC8-495C-9659-23F062AE852E	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CompanyTaxRate	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The tax rate for the company."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The connection to read from."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to read from."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to read from."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The scenario to read from."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""The company to read from."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_CompanyTaxRate(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the tax rate for a company in a specific context."";
@Parameter[connection]: ""The connection to read from."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""The year to read from."";
@Parameter[period]: ""The period to read from."";
@Parameter[scenario]: ""The scenario to read from."";
@Parameter[company]: ""The company to read from."";
@Returns: ""The tax rate for the company."";
{
	double result = cached OLAPCellReadNumber(connection, ""TCOMPPA"", 1.0, configurationSet, year, period, scenario, company, ""Tax Rate"");
	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_CompanyTaxRate(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the tax rate for a company in a specific context."";
@Parameter[connection]: ""The connection to read from."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""The year to read from."";
@Parameter[period]: ""The period to read from."";
@Parameter[scenario]: ""The scenario to read from."";
@Parameter[company]: ""The company to read from."";
@Returns: ""The tax rate for the company."";
{
	double result = cached OLAPCellReadNumber(connection, ""TCOMPPA"", 1.0, configurationSet, year, period, scenario, company, ""Tax Rate"");
	return result;
}"	1	15E6BFD0-DD66-462C-A141-36C73528E9BD	Gets the tax rate for a company in a specific context.	1	1	1	1657	NULL	0	45708.67503	0	0
EA85DDBF-E1C4-4FC3-AFFA-EA9EE23B6780	CD491758-D9DF-4002-94C8-8006E1855F86	CO_ConsolidationBasis	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The consolidation base setting for the process category."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""processCategory"" parameter-type=""string"" parameter-description=""The process category to query."" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_ConsolidationBasis(OLAPConnection connection, string configurationSet, string processCategory)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the consolidation base setting for the specified process category."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[processCategory]: ""The process category to query."";
@Returns: ""The consolidation base setting for the process category."";
{
	// VL - find the element in the DCONSRL dimension and read its ConsolidationBasis property
	OLAPElementList processes = cached OLAPGetElementList(connection, ""DCONSRL"", false);
	OLAPElement processElement = processes[processCategory];
	int value = cached OLAPGetIntAttribute(connection, processElement, ""ConsolidationBasis"");
	if (value == 0) {
		return ""HB III"";
	} else if (value == 1) {
		return ""HB III adjust"";
	} else if (value == 2) {
		return ""Consolidated Balance Sheet"";
	} else {
		// fallback
		return ""HB III"";
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_ConsolidationBasis(OLAPConnection connection, string configurationSet, string processCategory)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the consolidation base setting for the specified process category."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[processCategory]: ""The process category to query."";
@Returns: ""The consolidation base setting for the process category."";
{
	// VL - find the element in the DCONSRL dimension and read its ConsolidationBasis property
	OLAPElementList processes = cached OLAPGetElementList(connection, ""DCONSRL"", false);
	OLAPElement processElement = processes[processCategory];
	int value = cached OLAPGetIntAttribute(connection, processElement, ""ConsolidationBasis"");
	if (value == 0) {
		return ""HB III"";
	} else if (value == 1) {
		return ""HB III adjust"";
	} else if (value == 2) {
		return ""Consolidated Balance Sheet"";
	} else {
		// fallback
		return ""HB III"";
	}
}"	1	227946CC-23D2-4967-AE6A-E079B19703DD	Gets the consolidation base setting for the specified process category.	1	1	1	1658	NULL	0	45708.67501	0	0
E8A3818D-443B-4EE1-9764-603D428555CD	CD491758-D9DF-4002-94C8-8006E1855F86	CO_ConsolidationMethod	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The consolidation method for the specified company."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_ConsolidationMethod(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company)
@Category: ""Consolidation Base Process"";
@Description: ""GeGts the consolidation method for a company in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""The consolidation method for the specified company."";
{
	return cached OLAPCellReadString(connection, ""TCONSPA"", configurationSet, year, period, scenario, group, company, ""global"", ""way of consolidation"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_ConsolidationMethod(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company)
@Category: ""Consolidation Base Process"";
@Description: ""GeGts the consolidation method for a company in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""The consolidation method for the specified company."";
{
	return cached OLAPCellReadString(connection, ""TCONSPA"", configurationSet, year, period, scenario, group, company, ""global"", ""way of consolidation"");
}"	1	2D72E5E2-AAD3-4CA3-8718-843E6CBAD359	GeGts the consolidation method for a company in a group for a specified context.	1	1	1	1659	NULL	0	45708.67502	0	0
7683E745-018B-4E02-850D-38043CDEA470	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyCashFlowConfiguration	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process cought some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""GetLanguageOrCaptionOrElementItself"" process-version=""*"" process-id="""" />
    <process process-name=""GetStatusString"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyCashFlowConfiguration(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy cashflow Configuration from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCashFlowConfiguration:"";
	string statusGCube = ""TSTATUSG"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying cash flow configuration data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		StringArray toBeCopied = CreateStringArray();
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);

			double cfParameter = OLAPCellReadNumber(connection, statusGCube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,""global"",""Cash Flow Parameter"");
			if (cfParameter == 10)
			{
				Append(toBeCopied, pStat + yStat);
			}
			else
			{
				if(!cannotProcess)
				{
					NotifyInformation(""Cannot process:"");
					NotifyInformation("""");
					cannotProcess = true;
				}
				NotifyInformation(""- For period "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(cfParameter));
			}
			Append(targetPeriods,per);
		}

		Cube = ""TSTDCASHCFG"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSTDCASHCFGWeight = OLAPCreateDataArea(connection, Cube,
			                                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                              OlapDataAreaOperatorNone, 0.0,
			                                                              targetConfigurationSet, targetYear,targetMonth, targetVersion, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells,""Weight"");

			foreach (OLAPCell cell in TargetDataTSTDCASHCFGWeight)
			{

				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");

				if(Contains(toBeCopied,targetMonth + targetYear))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet, targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Weight"");
				}
			}
		}

		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTSTDCASHCFGWeight = OLAPCreateDataArea(connection, Cube,
			                                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                              OlapDataAreaOperatorNone, 0.0,
			                                                              sourceConfigurationSet,  sourceY,sourceM, sourceVersion,OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells,""Weight"");

			foreach (OLAPCell cell in SourceDataTSTDCASHCFGWeight)
			{
				
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear))
					{
						CopiedValues = CopiedValues + 1;
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Weight"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet, targetYear,targetMonth,targetVersion,account, detail,cashAccount,""Weight"");
						}
					}
				}

			}
		}

		OLAPCommitCellWriteBuffer(buffer);

		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSTDCASHCFGType = OLAPCreateDataArea(connection, Cube,
			                                                            OlapDataAreaIncludeB| OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                            OlapDataAreaOperatorNone, 0.0,
			                                                            targetConfigurationSet, targetYear,targetMonth, targetVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,""Type"");

			foreach (OLAPCell cell in TargetDataTSTDCASHCFGType)
			{

				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");

				if(Contains(toBeCopied,targetMonth + targetYear))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet, targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Type"");
				}
			}

		}
		OLAPCommitCellWriteBuffer(buffer);

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTSTDCASHCFGType = OLAPCreateDataArea(connection, Cube,
			                                                            OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                            OlapDataAreaOperatorNone, 0.0,
			                                                            sourceConfigurationSet,  sourceY,sourceM, sourceVersion,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,""Type"");

			foreach (OLAPCell cell in SourceDataTSTDCASHCFGType)
			{
				
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");


				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear))
					{
						CopiedValues = CopiedValues + 1;
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Type"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet, targetYear,targetMonth,targetVersion,account, detail,cashAccount,""Type"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of Cashflow configuration data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}

		LogDebug(CopiedValues + "" of TSTDCASHCFG values of cashFlow configuration were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyCashFlowConfiguration(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy cashflow Configuration from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCashFlowConfiguration:"";
	string statusGCube = ""TSTATUSG"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying cash flow configuration data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		StringArray toBeCopied = CreateStringArray();
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);

			double cfParameter = OLAPCellReadNumber(connection, statusGCube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,""global"",""Cash Flow Parameter"");
			if (cfParameter == 10)
			{
				Append(toBeCopied, pStat + yStat);
			}
			else
			{
				if(!cannotProcess)
				{
					NotifyInformation(""Cannot process:"");
					NotifyInformation("""");
					cannotProcess = true;
				}
				NotifyInformation(""- For period "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(cfParameter));
			}
			Append(targetPeriods,per);
		}

		Cube = ""TSTDCASHCFG"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSTDCASHCFGWeight = OLAPCreateDataArea(connection, Cube,
			                                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                              OlapDataAreaOperatorNone, 0.0,
			                                                              targetConfigurationSet, targetYear,targetMonth, targetVersion, OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells,""Weight"");

			foreach (OLAPCell cell in TargetDataTSTDCASHCFGWeight)
			{

				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");

				if(Contains(toBeCopied,targetMonth + targetYear))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet, targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Weight"");
				}
			}
		}

		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTSTDCASHCFGWeight = OLAPCreateDataArea(connection, Cube,
			                                                              OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                              OlapDataAreaOperatorNone, 0.0,
			                                                              sourceConfigurationSet,  sourceY,sourceM, sourceVersion,OlapDataAreaAllCells, OlapDataAreaAllCells,OlapDataAreaBCells,""Weight"");

			foreach (OLAPCell cell in SourceDataTSTDCASHCFGWeight)
			{
				
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear))
					{
						CopiedValues = CopiedValues + 1;
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Weight"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet, targetYear,targetMonth,targetVersion,account, detail,cashAccount,""Weight"");
						}
					}
				}

			}
		}

		OLAPCommitCellWriteBuffer(buffer);

		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSTDCASHCFGType = OLAPCreateDataArea(connection, Cube,
			                                                            OlapDataAreaIncludeB| OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                            OlapDataAreaOperatorNone, 0.0,
			                                                            targetConfigurationSet, targetYear,targetMonth, targetVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,""Type"");

			foreach (OLAPCell cell in TargetDataTSTDCASHCFGType)
			{

				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");

				if(Contains(toBeCopied,targetMonth + targetYear))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet, targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Type"");
				}
			}

		}
		OLAPCommitCellWriteBuffer(buffer);

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTSTDCASHCFGType = OLAPCreateDataArea(connection, Cube,
			                                                            OlapDataAreaIncludeB | OlapDataAreaIncludeC |OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                            OlapDataAreaOperatorNone, 0.0,
			                                                            sourceConfigurationSet,  sourceY,sourceM, sourceVersion,OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells,""Type"");

			foreach (OLAPCell cell in SourceDataTSTDCASHCFGType)
			{
				
				string account = OLAPCellGetElement(cell, ""DACOUNT"");
				string detail = OLAPCellGetElement(cell, ""DDETAIL"");
				string cashAccount = OLAPCellGetElement(cell, ""DSTDCASHACC"");


				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear))
					{
						CopiedValues = CopiedValues + 1;
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth, targetVersion,account, detail,cashAccount,""Type"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet, targetYear,targetMonth,targetVersion,account, detail,cashAccount,""Type"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of Cashflow configuration data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}

		LogDebug(CopiedValues + "" of TSTDCASHCFG values of cashFlow configuration were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	9EA3F2EA-EA1D-4314-8ADE-97BCA45E6F0A	Copy cashflow Configuration from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1660	NULL	0	45708.67503	0	0
F801F446-B75C-49A8-9868-EF94D6F042F0	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyConsMethods	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process cought some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceGroup"" parameter-type=""string"" parameter-description=""The source group element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetGroup"" parameter-type=""string"" parameter-description=""The source group element to be used."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyConsMethods(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceGroup, string targetConfigurationSet, string targetVersion, string targetTime, string targetGroup)
@Description: ""Copy consolidation methods from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetGroup]: ""The source group element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		StringList sourceGroupSL = CreateStringList();
		if(StringLength(sourceGroup)==0)
		{
			sourceGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}

		StringList targetGroupSL = CreateStringList();
		if(StringLength(targetGroup)==0)
		{
			targetGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);

		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, targetGroupSL, OlapDataAreaBCells,""global"",""way of consolidation"");

			OLAPDeleteDataArea(TargetDataTCONSPA);
		}

		OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion,sourceGroupSL, OlapDataAreaBCells,""global"",""way of consolidation"");



		foreach (OLAPCell cell in SourceDataTCONSPA)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string group = OLAPCellGetElement(cell, ""DGROUP"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,""global"",""way of consolidation"");
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,""global"",""way of consolidation"");
				}
			}
		}
		LogDebug(CopiedValues + "" of TCONSPA values of consolidation methods were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyConsMethods(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceGroup, string targetConfigurationSet, string targetVersion, string targetTime, string targetGroup)
@Description: ""Copy consolidation methods from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetGroup]: ""The source group element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		StringList sourceGroupSL = CreateStringList();
		if(StringLength(sourceGroup)==0)
		{
			sourceGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}

		StringList targetGroupSL = CreateStringList();
		if(StringLength(targetGroup)==0)
		{
			targetGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);

		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, targetGroupSL, OlapDataAreaBCells,""global"",""way of consolidation"");

			OLAPDeleteDataArea(TargetDataTCONSPA);
		}

		OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion,sourceGroupSL, OlapDataAreaBCells,""global"",""way of consolidation"");



		foreach (OLAPCell cell in SourceDataTCONSPA)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string group = OLAPCellGetElement(cell, ""DGROUP"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,""global"",""way of consolidation"");
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,""global"",""way of consolidation"");
				}
			}
		}
		LogDebug(CopiedValues + "" of TCONSPA values of consolidation methods were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	54BDC420-EF4E-4464-AF46-6D39F4EFE806	Copy consolidation methods from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1661	NULL	0	45708.67507	0	0
40E70CFA-0660-490F-862B-4028F80EB02F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyConsMethodsIC	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process cought some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceGroup"" parameter-type=""string"" parameter-description=""The source group element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetGroup"" parameter-type=""string"" parameter-description=""The source group element to be used."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyConsMethodsIC(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceGroup, string targetConfigurationSet, string targetVersion, string targetTime, string targetGroup)
@Description: ""Copy consolidation methods(I/C relations) from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetGroup]: ""The source group element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		StringList sourceGroupSL = CreateStringList();
		if(StringLength(sourceGroup)==0)
		{
			sourceGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}


		StringList targetGroupSL = CreateStringList();
		if(StringLength(targetGroup)==0)
		{
			targetGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);


		
		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, targetGroupSL, OlapDataAreaBCells,OlapDataAreaBCells,""f. cons. intercompany"");

			OLAPDeleteDataArea(TargetDataTCONSPA);
		}

		
		OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion,sourceGroupSL, OlapDataAreaBCells,OlapDataAreaBCells,""f. cons. intercompany"");



		foreach (OLAPCell cell in SourceDataTCONSPA)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string intercompany = OLAPCellGetElement(cell, ""DINTCO"");
			string group = OLAPCellGetElement(cell, ""DGROUP"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,intercompany,""way of consolidation"");
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,intercompany,""way of consolidation"");
				}
			}
		}

		LogDebug(CopiedValues + "" of TCONSPA values of consolidation methods (I/C relations) were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyConsMethodsIC(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceGroup, string targetConfigurationSet, string targetVersion, string targetTime, string targetGroup)
@Description: ""Copy consolidation methods(I/C relations) from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetGroup]: ""The source group element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;

	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		StringList sourceGroupSL = CreateStringList();
		if(StringLength(sourceGroup)==0)
		{
			sourceGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}


		StringList targetGroupSL = CreateStringList();
		if(StringLength(targetGroup)==0)
		{
			targetGroupSL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);


		
		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, targetGroupSL, OlapDataAreaBCells,OlapDataAreaBCells,""f. cons. intercompany"");

			OLAPDeleteDataArea(TargetDataTCONSPA);
		}

		
		OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion,sourceGroupSL, OlapDataAreaBCells,OlapDataAreaBCells,""f. cons. intercompany"");



		foreach (OLAPCell cell in SourceDataTCONSPA)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string intercompany = OLAPCellGetElement(cell, ""DINTCO"");
			string group = OLAPCellGetElement(cell, ""DGROUP"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,intercompany,""way of consolidation"");
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, entity,intercompany,""way of consolidation"");
				}
			}
		}

		LogDebug(CopiedValues + "" of TCONSPA values of consolidation methods (I/C relations) were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	A3E02952-D90D-4BAE-94A2-CFDDCF8F47F6	Copy consolidation methods(I/C relations) from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1662	NULL	0	45708.67506	0	0
FCE3B036-71D6-4A42-9521-AE084E367AE7	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyCurrencyChangesEntities	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process cought some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceEntity"" parameter-type=""string"" parameter-description=""The source entity element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetEntity"" parameter-type=""string"" parameter-description=""The target entity  element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyCurrencyChangesEntities(string server, string sourceConfigurationSet, string sourceVersion, string sourceEntity,string targetConfigurationSet, string targetVersion,string targetEntity)
@Description: ""Copy entity currency changes from given source configuration set/version to target configuration set/version"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetEntity]: ""The target entity  element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCurrencyChangesEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceEntity = ""[DCOMPC].[RU0001].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetEntity = ""[DCOMPC].[RU0002].[1],[DCOMPC].[RU0003].[1]"";//,[DTIME].[12.2015].[1],[DTIME].[12.2015].[1]*/
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringList sourceEntitySL = CreateStringList();
		bool multiLoop = false;

		if(StringLength(sourceEntity)==0)
		{
			OLAPElementList compsInEntityDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
			sourceEntitySL = ToStringList(compsInEntityDimT);
			Prepend(sourceEntitySL,"""");
		}
		else
		{
			sourceEntity = ResolveUniqueName(connection, sourceEntity);
			Append(sourceEntitySL,"""");
			Append(sourceEntitySL,sourceEntity);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringList targetEntitySL = CreateStringList();
		StringList targetEntityLoop = CreateStringList();

		if(StringLength(targetEntity)==0)
		{
			OLAPElementList compsInEntityDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
			targetEntitySL = ToStringList(compsInEntityDimT);
			Prepend(targetEntitySL,"""");

		}
		else if(StringContains(targetEntity,"",""))
		{
			StringArray targetE = CF_ElementStringSplit(targetEntity);
			foreach(string e in targetE)
			{
				string en = ResolveUniqueName(connection, e);
				Append(targetEntitySL,en);
				Append(targetEntityLoop,en);
			}
			Prepend(targetEntitySL,"""");
			multiLoop = true;
		}

		else
		{
			targetEntity = ResolveUniqueName(connection, targetEntity);
			Append(targetEntitySL,"""");
			Append(targetEntitySL,targetEntity);
			Append(targetEntityLoop,targetEntity);
			multiLoop = true;

		}

		Cube = ""TCURRCH"";
		StringList targetinLoop = CreateStringList();
		OLAPDataArea TargetDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    targetConfigurationSet, targetVersion, targetEntitySL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataTCURRCH);
		
		OLAPDataArea SourceDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet, sourceVersion, sourceEntitySL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTCURRCH)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string DCCURR = OLAPCellGetElement(cell, ""DCCURR"");
			string DCCURRCH = OLAPCellGetElement(cell, ""DCCURRCH"");
			string DCURRCH = OLAPCellGetElement(cell, ""DCURRCH"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			if(!multiLoop)
			{
				AppendDistinct(targetinLoop,entity);

			}
			else
			{
				targetinLoop = targetEntityLoop;
			}


			foreach(string tent in targetinLoop)
			{
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
			}
		}
		LogDebug(CopiedValues + "" of TCURRCH values of entity currency changes were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyCurrencyChangesEntities(string server, string sourceConfigurationSet, string sourceVersion, string sourceEntity,string targetConfigurationSet, string targetVersion,string targetEntity)
@Description: ""Copy entity currency changes from given source configuration set/version to target configuration set/version"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetEntity]: ""The target entity  element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCurrencyChangesEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceEntity = ""[DCOMPC].[RU0001].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetEntity = ""[DCOMPC].[RU0002].[1],[DCOMPC].[RU0003].[1]"";//,[DTIME].[12.2015].[1],[DTIME].[12.2015].[1]*/
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringList sourceEntitySL = CreateStringList();
		bool multiLoop = false;

		if(StringLength(sourceEntity)==0)
		{
			OLAPElementList compsInEntityDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
			sourceEntitySL = ToStringList(compsInEntityDimT);
			Prepend(sourceEntitySL,"""");
		}
		else
		{
			sourceEntity = ResolveUniqueName(connection, sourceEntity);
			Append(sourceEntitySL,"""");
			Append(sourceEntitySL,sourceEntity);

		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringList targetEntitySL = CreateStringList();
		StringList targetEntityLoop = CreateStringList();

		if(StringLength(targetEntity)==0)
		{
			OLAPElementList compsInEntityDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Group Companies"", true);
			targetEntitySL = ToStringList(compsInEntityDimT);
			Prepend(targetEntitySL,"""");

		}
		else if(StringContains(targetEntity,"",""))
		{
			StringArray targetE = CF_ElementStringSplit(targetEntity);
			foreach(string e in targetE)
			{
				string en = ResolveUniqueName(connection, e);
				Append(targetEntitySL,en);
				Append(targetEntityLoop,en);
			}
			Prepend(targetEntitySL,"""");
			multiLoop = true;
		}

		else
		{
			targetEntity = ResolveUniqueName(connection, targetEntity);
			Append(targetEntitySL,"""");
			Append(targetEntitySL,targetEntity);
			Append(targetEntityLoop,targetEntity);
			multiLoop = true;

		}

		Cube = ""TCURRCH"";
		StringList targetinLoop = CreateStringList();
		OLAPDataArea TargetDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    targetConfigurationSet, targetVersion, targetEntitySL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataTCURRCH);
		
		OLAPDataArea SourceDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet, sourceVersion, sourceEntitySL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTCURRCH)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string DCCURR = OLAPCellGetElement(cell, ""DCCURR"");
			string DCCURRCH = OLAPCellGetElement(cell, ""DCCURRCH"");
			string DCURRCH = OLAPCellGetElement(cell, ""DCURRCH"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			if(!multiLoop)
			{
				AppendDistinct(targetinLoop,entity);

			}
			else
			{
				targetinLoop = targetEntityLoop;
			}


			foreach(string tent in targetinLoop)
			{
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
			}
		}
		LogDebug(CopiedValues + "" of TCURRCH values of entity currency changes were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	042B4747-7190-4031-BEF2-7C7570ED1D79	Copy entity currency changes from given source configuration set/version to target configuration set/version	1	1	1	1663	NULL	0	45708.67509	0	0
579961CE-637C-425B-BDBD-3AA606798E6B	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyCurrencyChangesGroup	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process cought some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceGroup"" parameter-type=""string"" parameter-description=""The source group element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetGroup"" parameter-type=""string"" parameter-description=""The target group  element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyCurrencyChangesGroup(string server, string sourceConfigurationSet, string sourceVersion, string sourceGroup, string targetConfigurationSet, string targetVersion,string targetGroup)
@Description: ""Copy group currency changes from given source configuration set/version to target configuration set/version"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetGroup]: ""The target group  element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCurrencyChangesGroup:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceGroup = ""[DCOMPC].[GR0001].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetGroup= ""[DCOMPC].[GR0002].[1],[DCOMPC].[GR0003].[1]"";//,[DTIME].[12.2015].[1],[DTIME].[12.2015].[1]*/
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringList sourceGroupSL = CreateStringList();
		bool multiLoop = false;
		if(StringLength(sourceGroup)==0)
		{
			OLAPElementList compsInGroupDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);

			sourceGroupSL = ToStringList(compsInGroupDimT);
			Prepend(sourceGroupSL,"""");
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}
		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringList targetGroupSL = CreateStringList();
		StringList targetGroupLoop = CreateStringList();

		if(StringLength(targetGroup)==0)
		{
			OLAPElementList compsInGroupDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
			targetGroupSL = ToStringList(compsInGroupDimT);
			Prepend(targetGroupSL,"""");

		}
		else if(StringContains(targetGroup,"",""))
		{
			StringArray targetG = CF_ElementStringSplit(targetGroup);
			foreach(string g in targetG)
			{
				string gr = ResolveUniqueName(connection, g);
				Append(targetGroupSL,gr);
				Append(targetGroupLoop,gr);
			}
			Prepend(targetGroupSL,"""");
			multiLoop = true;
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);
			Append(targetGroupLoop,targetGroup);
			multiLoop = true;

		}

		Cube = ""TCURRCH"";
		StringList targetinLoop = CreateStringList();
		OLAPDataArea TargetDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    targetConfigurationSet, targetVersion, targetGroupSL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataTCURRCH);
		
		OLAPDataArea SourceDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet, sourceVersion, sourceGroupSL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTCURRCH)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string DCCURR = OLAPCellGetElement(cell, ""DCCURR"");
			string DCCURRCH = OLAPCellGetElement(cell, ""DCCURRCH"");
			string DCURRCH = OLAPCellGetElement(cell, ""DCURRCH"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			if(!multiLoop)
			{
				AppendDistinct(targetinLoop,entity);

			}
			else
			{
				targetinLoop = targetGroupLoop;
			}
			foreach(string tent in targetinLoop)
			{
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
			}
		}
		LogInformation(CopiedValues + "" of TCURRCH values of group currency changes were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyCurrencyChangesGroup(string server, string sourceConfigurationSet, string sourceVersion, string sourceGroup, string targetConfigurationSet, string targetVersion,string targetGroup)
@Description: ""Copy group currency changes from given source configuration set/version to target configuration set/version"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceGroup]: ""The source group element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetGroup]: ""The target group  element to be used."";
@Returns: ""true if process was succesfull, false if process cought some error"";
{
	string functionName = ""CO_CopyCurrencyChangesGroup:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceGroup = ""[DCOMPC].[GR0001].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetGroup= ""[DCOMPC].[GR0002].[1],[DCOMPC].[GR0003].[1]"";//,[DTIME].[12.2015].[1],[DTIME].[12.2015].[1]*/
		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringList sourceGroupSL = CreateStringList();
		bool multiLoop = false;
		if(StringLength(sourceGroup)==0)
		{
			OLAPElementList compsInGroupDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);

			sourceGroupSL = ToStringList(compsInGroupDimT);
			Prepend(sourceGroupSL,"""");
		}
		else
		{
			sourceGroup = ResolveUniqueName(connection, sourceGroup);
			Append(sourceGroupSL,"""");
			Append(sourceGroupSL,sourceGroup);

		}
		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringList targetGroupSL = CreateStringList();
		StringList targetGroupLoop = CreateStringList();

		if(StringLength(targetGroup)==0)
		{
			OLAPElementList compsInGroupDimT = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
			targetGroupSL = ToStringList(compsInGroupDimT);
			Prepend(targetGroupSL,"""");

		}
		else if(StringContains(targetGroup,"",""))
		{
			StringArray targetG = CF_ElementStringSplit(targetGroup);
			foreach(string g in targetG)
			{
				string gr = ResolveUniqueName(connection, g);
				Append(targetGroupSL,gr);
				Append(targetGroupLoop,gr);
			}
			Prepend(targetGroupSL,"""");
			multiLoop = true;
		}
		else
		{
			targetGroup = ResolveUniqueName(connection, targetGroup);
			Append(targetGroupSL,"""");
			Append(targetGroupSL,targetGroup);
			Append(targetGroupLoop,targetGroup);
			multiLoop = true;

		}

		Cube = ""TCURRCH"";
		StringList targetinLoop = CreateStringList();
		OLAPDataArea TargetDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    targetConfigurationSet, targetVersion, targetGroupSL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);

		OLAPDeleteDataArea(TargetDataTCURRCH);
		
		OLAPDataArea SourceDataTCURRCH = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet, sourceVersion, sourceGroupSL,OlapDataAreaBCells,OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTCURRCH)
		{
			
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string DCCURR = OLAPCellGetElement(cell, ""DCCURR"");
			string DCCURRCH = OLAPCellGetElement(cell, ""DCCURRCH"");
			string DCURRCH = OLAPCellGetElement(cell, ""DCURRCH"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";
			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}
			if(!multiLoop)
			{
				AppendDistinct(targetinLoop,entity);

			}
			else
			{
				targetinLoop = targetGroupLoop;
			}
			foreach(string tent in targetinLoop)
			{
				CopiedValues = CopiedValues + 1;
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetVersion,tent,DCCURR,DCCURRCH,DCURRCH);
				}
			}
		}
		LogInformation(CopiedValues + "" of TCURRCH values of group currency changes were copied"");
		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	C836A4E2-8FC1-4F10-AFF2-9567041FC965	Copy group currency changes from given source configuration set/version to target configuration set/version	1	1	1	1664	NULL	0	45708.67502	0	0
DB94D53D-7886-44D2-9373-13870EAEC127	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyEntitySettings	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""GetLanguageOrCaptionOrElementItself"" process-version=""*"" process-id="""" />
    <process process-name=""GetStatusString"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyEntitySettings(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy entity settings from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyEntitySettings:"";
	string statusECube = ""TSTATUSC"";
	string entityDimension = ""DCOMPC"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;



	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}


		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		StringArray toBeCopied = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying Entity settings data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList entityDimOList = OLAPGetChildElementList(connection, entityDimension, ""Group Companies"", true);
			StringList entityDimStringList = ToStringList(entityDimOList);
			foreach(string en in entityDimStringList)
			{
				double entityParameter = OLAPCellReadNumber(connection, statusECube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,en,""Entity Parameter"");
				if (entityParameter == 10)
				{
					Append(toBeCopied, pStat + yStat + en);
				}
				else
				{
					if(!cannotProcess)
					{
						NotifyInformation(""Cannot process:"");
						NotifyInformation("""");
						cannotProcess = true;
					}
					NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,entityDimension,en, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(entityParameter));
				}
			}
			Append(targetPeriods,per);
		}
		string targetMonth = StringSubstring(targetTime, 0, 2);
		string targetYear= StringSubstring(targetTime, 3, 4);

		Cube = ""TCOMPPA"";
		foreach(string t in targetPeriods)
		{
			targetMonth = StringSubstring(t, 0, 2);
			targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells,OlapDataAreaBCells);
			foreach (OLAPCell cell in TargetDataTCOMMPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;

		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion, OlapDataAreaBCells,OlapDataAreaBCells);



			foreach (OLAPCell cell in SourceDataTCOMMPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;
				
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					targetMonth = StringSubstring(t, 0, 2);
					targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
					}

				}
			}
			counter = counter + 1 ;
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCOMPPA values of entity settings were copied"");

		Cube = ""TCONSPA"";

		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			targetMonth = StringSubstring(t, 0, 2);
			targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, ""global"", OlapDataAreaBCells,""global"",""currency conversion method"");
			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion,""global"", OlapDataAreaBCells,""global"",""currency conversion method"");



			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriods)
				{
					targetMonth = StringSubstring(t, 0, 2);
					targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of entity settings data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}


		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCONSPA values of entity settings were copied"");
		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyEntitySettings(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy entity settings from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyEntitySettings:"";
	string statusECube = ""TSTATUSC"";
	string entityDimension = ""DCOMPC"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;



	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);
		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}


		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		StringArray toBeCopied = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying Entity settings data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList entityDimOList = OLAPGetChildElementList(connection, entityDimension, ""Group Companies"", true);
			StringList entityDimStringList = ToStringList(entityDimOList);
			foreach(string en in entityDimStringList)
			{
				double entityParameter = OLAPCellReadNumber(connection, statusECube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,en,""Entity Parameter"");
				if (entityParameter == 10)
				{
					Append(toBeCopied, pStat + yStat + en);
				}
				else
				{
					if(!cannotProcess)
					{
						NotifyInformation(""Cannot process:"");
						NotifyInformation("""");
						cannotProcess = true;
					}
					NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,entityDimension,en, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(entityParameter));
				}
			}
			Append(targetPeriods,per);
		}
		string targetMonth = StringSubstring(targetTime, 0, 2);
		string targetYear= StringSubstring(targetTime, 3, 4);

		Cube = ""TCOMPPA"";
		foreach(string t in targetPeriods)
		{
			targetMonth = StringSubstring(t, 0, 2);
			targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells,OlapDataAreaBCells);
			foreach (OLAPCell cell in TargetDataTCOMMPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;

		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion, OlapDataAreaBCells,OlapDataAreaBCells);



			foreach (OLAPCell cell in SourceDataTCOMMPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;
				
				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					targetMonth = StringSubstring(t, 0, 2);
					targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
					}

				}
			}
			counter = counter + 1 ;
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCOMPPA values of entity settings were copied"");

		Cube = ""TCONSPA"";

		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			targetMonth = StringSubstring(t, 0, 2);
			targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, ""global"", OlapDataAreaBCells,""global"",""currency conversion method"");
			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion,""global"", OlapDataAreaBCells,""global"",""currency conversion method"");



			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}

				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriods)
				{
					targetMonth = StringSubstring(t, 0, 2);
					targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,""global"", entity,""global"",""currency conversion method"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of entity settings data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}


		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCONSPA values of entity settings were copied"");
		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	905767B4-84DF-45C7-BB44-36A6DCEB273F	Copy entity settings from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1665	NULL	0	45708.67502	0	0
E774BA54-EC75-4ED7-881D-FC45DC20E053	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyExchangeRates	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyExchangeRates(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy exchange rates from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyExchangeRates:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;

	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";*/

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}


		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);


		Cube = ""TRATES"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTRATES = OLAPCreateDataArea(connection, Cube,
			                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                   OlapDataAreaOperatorNone, 0.0,
			                                                   targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTRATES);
		}

		OLAPDataArea SourceDataTRATES = OLAPCreateDataArea(connection, Cube,
		                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                   OlapDataAreaOperatorNone, 0.0,
		                                                   sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTRATES)
		{
			
			string groupCurr = OLAPCellGetElement(cell, ""DGCURR"");
			string eRate = OLAPCellGetElement(cell, ""DEXRATE"");
			string compCurr = OLAPCellGetElement(cell, ""DCCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion, groupCurr, eRate, compCurr);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, groupCurr, eRate, compCurr);
				}
			}
		}
		LogDebug(CopiedValues + "" of TRATES values were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""

bool CO_CopyExchangeRates(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy exchange rates from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyExchangeRates:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;

	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";*/

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);
		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}


		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);


		Cube = ""TRATES"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTRATES = OLAPCreateDataArea(connection, Cube,
			                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                   OlapDataAreaOperatorNone, 0.0,
			                                                   targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTRATES);
		}

		OLAPDataArea SourceDataTRATES = OLAPCreateDataArea(connection, Cube,
		                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                   OlapDataAreaOperatorNone, 0.0,
		                                                   sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, OlapDataAreaBCells,OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTRATES)
		{
			
			string groupCurr = OLAPCellGetElement(cell, ""DGCURR"");
			string eRate = OLAPCellGetElement(cell, ""DEXRATE"");
			string compCurr = OLAPCellGetElement(cell, ""DCCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion, groupCurr, eRate, compCurr);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, groupCurr, eRate, compCurr);
				}
			}
		}
		LogDebug(CopiedValues + "" of TRATES values were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	CB6952BB-4735-451A-AAF9-3E2EB37A4EB8	Copy exchange rates from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1666	NULL	0	45708.67501	0	0
1A1F0F15-6046-4E78-B035-0B48621A6316	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyGroupSettings	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""GetLanguageOrCaptionOrElementItself"" process-version=""*"" process-id="""" />
    <process process-name=""GetStatusString"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyGroupSettings(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy group settings from given source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyGroupSettings:"";
	string statusGCube = ""TSTATUSG"";
	string groupDimension = ""DGROUP"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		StringArray toBeCopied = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying Group settings data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList groupDimOList = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
			StringList groupDimStringList = ToStringList(groupDimOList);
			foreach(string gr in groupDimStringList)
			{
				if(gr != ""global"")
				{
					double groupParameter = OLAPCellReadNumber(connection, statusGCube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,gr,""Group Parameter"");
					if (groupParameter == 10)
					{
						Append(toBeCopied, pStat + yStat + gr);
					}
					else
					{
						if(!cannotProcess)
						{
							NotifyInformation(""Cannot process:"");
							NotifyInformation("""");
							cannotProcess = true;
						}
						NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,groupDimension,gr, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(groupParameter));
					}
				}
			}
			Append(targetPeriods,per);
		}

		Cube = ""TCOMPPA"";

		OLAPElementList groupsInEntityDim = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, groupsInEntityDim,OlapDataAreaBCells);
			
			foreach (OLAPCell cell in TargetDataTCOMMPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;
		
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion, groupsInEntityDim,OlapDataAreaBCells);



			foreach (OLAPCell cell in SourceDataTCOMMPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
					}
				}
			}
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCOMPPA values of group settings were copied"");

		Cube = ""TCONSPA"";
		CopiedValues = 0;

		OLAPElementList groups = OLAPGetElementList(connection, ""DGROUP"", true);
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, groups, ""global"",""global"",""holding company"");

			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string group = OLAPCellGetElement(cell, ""DGROUP"");

				if(Contains(toBeCopied,targetMonth + targetYear + group))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, ""global"",""global"",""holding company"");
				}
			}

		}

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion,groups, ""global"",""global"",""holding company"");



			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string group = OLAPCellGetElement(cell, ""DGROUP"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriods)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + group))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group,  ""global"",""global"",""holding company"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group,  ""global"",""global"",""holding company"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of group settings data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCONSPA values of group settings were copied"");
		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyGroupSettings(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy group settings from given source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyGroupSettings:"";
	string statusGCube = ""TSTATUSG"";
	string groupDimension = ""DGROUP"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[01.2012].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[02.2012].[1],[DTIME].[03.2012].[1]"";*/

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP = CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string pe in sourceP)
		{
			string peri = ResolveUniqueName(connection, pe);
			Append(sourcePeriods,peri);
		}

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		StringArray toBeCopied = CreateStringArray();
		int index = 1;
		bool cannotProcess = false;
		NotifyInformation(""Copying Group settings data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList groupDimOList = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
			StringList groupDimStringList = ToStringList(groupDimOList);
			foreach(string gr in groupDimStringList)
			{
				if(gr != ""global"")
				{
					double groupParameter = OLAPCellReadNumber(connection, statusGCube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,gr,""Group Parameter"");
					if (groupParameter == 10)
					{
						Append(toBeCopied, pStat + yStat + gr);
					}
					else
					{
						if(!cannotProcess)
						{
							NotifyInformation(""Cannot process:"");
							NotifyInformation("""");
							cannotProcess = true;
						}
						NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,groupDimension,gr, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(groupParameter));
					}
				}
			}
			Append(targetPeriods,per);
		}

		Cube = ""TCOMPPA"";

		OLAPElementList groupsInEntityDim = OLAPGetChildElementList(connection, ""DCOMPC"", ""Fict. Companies"", true);
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, groupsInEntityDim,OlapDataAreaBCells);
			
			foreach (OLAPCell cell in TargetDataTCOMMPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
				}
			}
		}
		OLAPCommitCellWriteBuffer(buffer);

		int counter  = 0;
		
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}
			OLAPDataArea SourceDataTCOMMPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion, groupsInEntityDim,OlapDataAreaBCells);



			foreach (OLAPCell cell in SourceDataTCOMMPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string Dcompc = OLAPCellGetElement(cell, ""DCOMPPA"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriodsInLoop)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + entity))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,entity,Dcompc);
						}
					}
				}
			}
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCOMPPA values of group settings were copied"");

		Cube = ""TCONSPA"";
		CopiedValues = 0;

		OLAPElementList groups = OLAPGetElementList(connection, ""DGROUP"", true);
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, groups, ""global"",""global"",""holding company"");

			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string group = OLAPCellGetElement(cell, ""DGROUP"");

				if(Contains(toBeCopied,targetMonth + targetYear + group))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion,group, ""global"",""global"",""holding company"");
				}
			}

		}

		counter  = 0;
		foreach(string sourcep in sourcePeriods)
		{

			string sourceM = StringSubstring(sourcep, 0, 2);
			string sourceY= StringSubstring(sourcep, 3, 4);
			StringArray targetPeriodsInLoop = CreateStringArray();
			if(Count(sourcePeriods) == Count(targetPeriods))
			{
				Append(targetPeriodsInLoop,targetPeriods[counter]);
			}
			else
			{
				targetPeriodsInLoop = targetPeriods;

			}

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceY,sourceM,sourceVersion,groups, ""global"",""global"",""holding company"");



			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string group = OLAPCellGetElement(cell, ""DGROUP"");
				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				CopiedValues = CopiedValues + 1;
				foreach(string t in targetPeriods)
				{
					string targetMonth = StringSubstring(t, 0, 2);
					string targetYear= StringSubstring(t, 3, 4);
					if(Contains(toBeCopied,targetMonth + targetYear + group))
					{
						if(isCellText)
						{
							OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,group,  ""global"",""global"",""holding company"");
						}
						else
						{
							OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,group,  ""global"",""global"",""holding company"");
						}
					}

				}
			}
		}
		if(!cannotProcess)
		{
			NotifyInformation("""");
			NotifyInformation(""Copy of group settings data was succesful"");
		}
		else
		{
			NotifyInformation("""");
			NotifyInformation(""Other combinations were copied succesfuly"");
		}

		OLAPCommitCellWriteBuffer(buffer);
		LogDebug(CopiedValues + "" of TCONSPA values of group settings were copied"");
		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	F8ECC51E-2828-4616-BDA0-61CC752B64D5	Copy group settings from given source configuration set/version/time to target configuration set/version/time	1	1	1	1667	NULL	0	45708.67504	0	0
2E8EE1E4-6BFD-4C42-99BF-E9D03E123C5B	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyHistoricalRates	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""sourceEntity"" parameter-type=""string"" parameter-description=""The source entity element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""targetEntity"" parameter-type=""string"" parameter-description=""The target entity element to be used."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""
bool CO_CopyHistoricalRates(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceEntity, string targetConfigurationSet, string targetVersion, string targetTime,string targetEntity)
@Description: ""Copy historical exrates from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetEntity]: ""The target entity element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyHistoricalRates:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		sourceEntity = ""[DCOMPC].[RU0001].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";
		targetEntity = ""[DCOMPC].[RU0002].[1]"";*/

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);

		StringList sourceEntitySL = CreateStringList();
		if(StringLength(sourceEntity)==0)
		{
			sourceEntitySL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceEntity = ResolveUniqueName(connection, sourceEntity);
			Append(sourceEntitySL,"""");
			Append(sourceEntitySL,sourceEntity);

		}



		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}

		StringList targetEntitySL = CreateStringList();
		if(StringLength(targetEntity)==0)
		{
			targetEntitySL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetEntity = ResolveUniqueName(connection, targetEntity);
			Append(targetEntitySL,"""");
			Append(targetEntitySL,targetEntity);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);



		Cube = ""TFINANC"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTFINANC = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",targetEntitySL,""External"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTFINANC);
		}

		OLAPDataArea SourceDataTFINANC = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, ""HB I"",""Historical Exchange Rate"",sourceEntitySL,""External"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTFINANC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TFINANC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		Cube = ""TDETAIC"";
		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTDETAIC = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion,OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",targetEntitySL,""External"", ""98"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTDETAIC);
		}

		
		OLAPDataArea SourceDataTDETAIC = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",sourceEntitySL,""External"",""98"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTDETAIC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", ""98"",account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", ""98"",account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TDETAIC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		Cube = ""TSEGMC"";
		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSEGMC = OLAPCreateDataArea(connection, Cube,
			                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                   OlapDataAreaOperatorNone, 0.0,
			                                                   targetConfigurationSet,  targetYear,targetMonth,targetVersion,OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",""Segment"",targetEntitySL,""External"", ""-"",""-"",""-"",""-"",""-"",""-"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTSEGMC);
		}

		OLAPDataArea SourceDataTSEGMC = OLAPCreateDataArea(connection, Cube,
		                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                   OlapDataAreaOperatorNone, 0.0,
		                                                   sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, ""HB I"",""Historical Exchange Rate"",""Segment"",sourceEntitySL,""External"",""-"",""-"",""-"",""-"",""-"",""-"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTSEGMC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",""Segment"",entity,""External"", ""-"",""-"",""-"",""-"",""-"",""-"",account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr,""HB I"",""Historical Exchange Rate"",""Segment"",entity,""External"", ""-"",""-"",""-"",""-"",""-"",""-"",account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TSEGMC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CF_ElementStringSplit"", ""*""
bool CO_CopyHistoricalRates(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string sourceEntity, string targetConfigurationSet, string targetVersion, string targetTime,string targetEntity)
@Description: ""Copy historical exrates from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[sourceEntity]: ""The source entity element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[targetEntity]: ""The target entity element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyHistoricalRates:"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;


	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		sourceEntity = ""[DCOMPC].[RU0001].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";
		targetEntity = ""[DCOMPC].[RU0002].[1]"";*/

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		sourceTime = ResolveUniqueName(connection, sourceTime);

		StringList sourceEntitySL = CreateStringList();
		if(StringLength(sourceEntity)==0)
		{
			sourceEntitySL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			sourceEntity = ResolveUniqueName(connection, sourceEntity);
			Append(sourceEntitySL,"""");
			Append(sourceEntitySL,sourceEntity);

		}



		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();

		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}

		StringList targetEntitySL = CreateStringList();
		if(StringLength(targetEntity)==0)
		{
			targetEntitySL = ConvertToStringList(OlapDataAreaBCells);
		}
		else
		{
			targetEntity = ResolveUniqueName(connection, targetEntity);
			Append(targetEntitySL,"""");
			Append(targetEntitySL,targetEntity);

		}

		string sourceMonth = StringSubstring(sourceTime, 0, 2);
		string sourceYear= StringSubstring(sourceTime, 3, 4);



		Cube = ""TFINANC"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTFINANC = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",targetEntitySL,""External"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTFINANC);
		}

		OLAPDataArea SourceDataTFINANC = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, ""HB I"",""Historical Exchange Rate"",sourceEntitySL,""External"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTFINANC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TFINANC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		Cube = ""TDETAIC"";
		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTDETAIC = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion,OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",targetEntitySL,""External"", ""98"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTDETAIC);
		}

		
		OLAPDataArea SourceDataTDETAIC = OLAPCreateDataArea(connection, Cube,
		                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                    OlapDataAreaOperatorNone, 0.0,
		                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",sourceEntitySL,""External"",""98"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTDETAIC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");

			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", ""98"",account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, localCurr, ""HB I"",""Historical Exchange Rate"",entity,""External"", ""98"",account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TDETAIC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		Cube = ""TSEGMC"";
		CopiedValues = 0;
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);
			OLAPDataArea TargetDataTSEGMC = OLAPCreateDataArea(connection, Cube,
			                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,

			                                                   OlapDataAreaOperatorNone, 0.0,
			                                                   targetConfigurationSet,  targetYear,targetMonth,targetVersion,OlapDataAreaBCells,""HB I"",""Historical Exchange Rate"",""Segment"",targetEntitySL,""External"", ""-"",""-"",""-"",""-"",""-"",""-"", OlapDataAreaBCells);

			OLAPDeleteDataArea(TargetDataTSEGMC);
		}

		OLAPDataArea SourceDataTSEGMC = OLAPCreateDataArea(connection, Cube,
		                                                   OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                                   OlapDataAreaOperatorNone, 0.0,
		                                                   sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, OlapDataAreaBCells, ""HB I"",""Historical Exchange Rate"",""Segment"",sourceEntitySL,""External"",""-"",""-"",""-"",""-"",""-"",""-"", OlapDataAreaBCells);



		foreach (OLAPCell cell in SourceDataTSEGMC)
		{
			
			string account = OLAPCellGetElement(cell, ""DACOUNT"");
			string entity = OLAPCellGetElement(cell, ""DCOMPC"");
			string localCurr = OLAPCellGetElement(cell, ""DLCURR"");
			bool isCellText =  OLAPCellIsTextCell(cell);
			string valueStr = """";

			double valueDou = 0;

			if(isCellText)
			{
				valueStr  = cell;
			}
			else
			{
				valueDou = cell;
			}

			CopiedValues = CopiedValues + 1;
			foreach(string t in targetPeriods)
			{
				string targetMonth = StringSubstring(t, 0, 2);
				string targetYear= StringSubstring(t, 3, 4);
				if(isCellText)
				{
					OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr, ""HB I"",""Historical Exchange Rate"",""Segment"",entity,""External"", ""-"",""-"",""-"",""-"",""-"",""-"",account);
				}
				else
				{
					OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion,localCurr,""HB I"",""Historical Exchange Rate"",""Segment"",entity,""External"", ""-"",""-"",""-"",""-"",""-"",""-"",account);
				}
			}
		}
		LogDebug(CopiedValues + "" of TSEGMC values of historical rates were copied"");

		OLAPCommitCellWriteBuffer(buffer);

		return true;
	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	F530E399-039D-4C40-AA9B-1187C4905ECF	Copy historical exrates from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1668	NULL	0	45708.67501	0	0
B0A66749-7B08-48DC-8C5B-3BC202B582C7	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyParameters	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""entitySettings"" parameter-type=""bool"" parameter-description=""flag if entity settings should be copied."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""groupSettings"" parameter-type=""bool"" parameter-description=""flag if group settings should be copied."" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""profitMargin"" parameter-type=""bool"" parameter-description=""flag if profit margin should be copied."" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""exRates"" parameter-type=""bool"" parameter-description=""flag if exchange rates should be copied."" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""histRates"" parameter-type=""bool"" parameter-description=""flag if historical exchange rates should be copied."" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""entityChurrChange"" parameter-type=""bool"" parameter-description=""flag if entity currency changes should be copied."" parameter-order=""12"" />
  <parameter-descriptor parameter-name=""groupChurrChange"" parameter-type=""bool"" parameter-description=""flag if group currency changes should be copied."" parameter-order=""13"" />
  <parameter-descriptor parameter-name=""consMethods"" parameter-type=""bool"" parameter-description=""flag if consolidation methods should be copied."" parameter-order=""14"" />
  <parameter-descriptor parameter-name=""consMethodsIC"" parameter-type=""bool"" parameter-description=""flag if consolidation methods (I/C relations) should be copied."" parameter-order=""15"" />
  <parameter-descriptor parameter-name=""casfFlowConfig"" parameter-type=""bool"" parameter-description=""flag if cashflow Configuration should be copied."" parameter-order=""16"" />
  <dependencies>
    <process process-name=""CO_CopyEntitySettings"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyGroupSettings"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyProfitMargin"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyExchangeRates"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyHistoricalRates"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyCurrencyChangesEntities"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyCurrencyChangesGroup"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyConsMethods"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyConsMethodsIC"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CopyCashFlowConfiguration"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CO_CopyEntitySettings"", ""*""
#include ""CO_CopyGroupSettings"", ""*""
#include ""CO_CopyProfitMargin"", ""*""
#include ""CO_CopyExchangeRates"", ""*""
#include ""CO_CopyHistoricalRates"", ""*""
#include ""CO_CopyCurrencyChangesEntities"", ""*""
#include ""CO_CopyCurrencyChangesGroup"", ""*""
#include ""CO_CopyConsMethods"", ""*""
#include ""CO_CopyConsMethodsIC"", ""*""
#include ""CO_CopyCashFlowConfiguration"", ""*""


bool CO_CopyParameters(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime, bool entitySettings,
                       bool groupSettings, bool profitMargin, bool exRates, bool histRates, bool entityChurrChange, bool groupChurrChange,bool consMethods,bool consMethodsIC,bool casfFlowConfig)
@Description: ""Copy Configuration Set settings within the listed cubes."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[entitySettings]: ""flag if entity settings should be copied."";
@Parameter[groupSettings]: ""flag if group settings should be copied."";
@Parameter[profitMargin]: ""flag if profit margin should be copied."";
@Parameter[exRates]: ""flag if exchange rates should be copied."";
@Parameter[histRates]: ""flag if historical exchange rates should be copied."";
@Parameter[entityChurrChange]: ""flag if entity currency changes should be copied."";
@Parameter[groupChurrChange]: ""flag if group currency changes should be copied."";
@Parameter[consMethods]: ""flag if consolidation methods should be copied."";
@Parameter[consMethodsIC]: ""flag if consolidation methods (I/C relations) should be copied."";
@Parameter[casfFlowConfig]: ""flag if cashflow Configuration should be copied."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyParameters:"";
	string errorMessage = """";
	int errorCode = 0;
	string sourceEntity = """";
	string targetEntity = """";
	string sourceGroup = """";
	string targetGroup = """";

	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";*/

		if(entitySettings)
		{
			bool eset  = CO_CopyEntitySettings(server, sourceConfigurationSet, sourceVersion, sourceTime,targetConfigurationSet, targetVersion, targetTime);
		}

		if(groupSettings)
		{
			bool gSet = CO_CopyGroupSettings(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(profitMargin)
		{
			bool pmargin = CO_CopyProfitMargin(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(exRates)
		{
			bool eRates = CO_CopyExchangeRates(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(histRates)
		{
			bool histR = CO_CopyHistoricalRates(server, sourceConfigurationSet, sourceVersion, sourceTime, sourceEntity, targetConfigurationSet, targetVersion, targetTime,targetEntity);
		}

		if(entityChurrChange)
		{
			bool ECurrChan = CO_CopyCurrencyChangesEntities(server, sourceConfigurationSet, sourceVersion,sourceEntity, targetConfigurationSet, targetVersion, targetEntity);
		}

		if(groupChurrChange)
		{
			bool GCurrChan = CO_CopyCurrencyChangesGroup(server, sourceConfigurationSet, sourceVersion,sourceGroup, targetConfigurationSet, targetVersion,targetGroup);
		}

		if(consMethods)
		{
			bool cMethods = CO_CopyConsMethods(server, sourceConfigurationSet, sourceVersion, sourceTime,sourceGroup, targetConfigurationSet, targetVersion, targetTime, targetGroup);
		}

		if(consMethodsIC)
		{
			bool cMethodsIC = CO_CopyConsMethodsIC(server, sourceConfigurationSet, sourceVersion, sourceTime,sourceGroup, targetConfigurationSet, targetVersion, targetTime, targetGroup);
		}

		if(casfFlowConfig)
		{
			bool casConf =  CO_CopyCashFlowConfiguration(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		return true;

	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0
#include ""CO_CopyEntitySettings"", ""*""
#include ""CO_CopyGroupSettings"", ""*""
#include ""CO_CopyProfitMargin"", ""*""
#include ""CO_CopyExchangeRates"", ""*""
#include ""CO_CopyHistoricalRates"", ""*""
#include ""CO_CopyCurrencyChangesEntities"", ""*""
#include ""CO_CopyCurrencyChangesGroup"", ""*""
#include ""CO_CopyConsMethods"", ""*""
#include ""CO_CopyConsMethodsIC"", ""*""
#include ""CO_CopyCashFlowConfiguration"", ""*""


bool CO_CopyParameters(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime, bool entitySettings,
                       bool groupSettings, bool profitMargin, bool exRates, bool histRates, bool entityChurrChange, bool groupChurrChange,bool consMethods,bool consMethodsIC,bool casfFlowConfig)
@Description: ""Copy Configuration Set settings within the listed cubes."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Parameter[entitySettings]: ""flag if entity settings should be copied."";
@Parameter[groupSettings]: ""flag if group settings should be copied."";
@Parameter[profitMargin]: ""flag if profit margin should be copied."";
@Parameter[exRates]: ""flag if exchange rates should be copied."";
@Parameter[histRates]: ""flag if historical exchange rates should be copied."";
@Parameter[entityChurrChange]: ""flag if entity currency changes should be copied."";
@Parameter[groupChurrChange]: ""flag if group currency changes should be copied."";
@Parameter[consMethods]: ""flag if consolidation methods should be copied."";
@Parameter[consMethodsIC]: ""flag if consolidation methods (I/C relations) should be copied."";
@Parameter[casfFlowConfig]: ""flag if cashflow Configuration should be copied."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyParameters:"";
	string errorMessage = """";
	int errorCode = 0;
	string sourceEntity = """";
	string targetEntity = """";
	string sourceGroup = """";
	string targetGroup = """";

	try
	{
		/*server = ""DEPM"";
		sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2015].[1]"";
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[12.2020].[1]"";*/

		if(entitySettings)
		{
			bool eset  = CO_CopyEntitySettings(server, sourceConfigurationSet, sourceVersion, sourceTime,targetConfigurationSet, targetVersion, targetTime);
		}

		if(groupSettings)
		{
			bool gSet = CO_CopyGroupSettings(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(profitMargin)
		{
			bool pmargin = CO_CopyProfitMargin(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(exRates)
		{
			bool eRates = CO_CopyExchangeRates(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		if(histRates)
		{
			bool histR = CO_CopyHistoricalRates(server, sourceConfigurationSet, sourceVersion, sourceTime, sourceEntity, targetConfigurationSet, targetVersion, targetTime,targetEntity);
		}

		if(entityChurrChange)
		{
			bool ECurrChan = CO_CopyCurrencyChangesEntities(server, sourceConfigurationSet, sourceVersion,sourceEntity, targetConfigurationSet, targetVersion, targetEntity);
		}

		if(groupChurrChange)
		{
			bool GCurrChan = CO_CopyCurrencyChangesGroup(server, sourceConfigurationSet, sourceVersion,sourceGroup, targetConfigurationSet, targetVersion,targetGroup);
		}

		if(consMethods)
		{
			bool cMethods = CO_CopyConsMethods(server, sourceConfigurationSet, sourceVersion, sourceTime,sourceGroup, targetConfigurationSet, targetVersion, targetTime, targetGroup);
		}

		if(consMethodsIC)
		{
			bool cMethodsIC = CO_CopyConsMethodsIC(server, sourceConfigurationSet, sourceVersion, sourceTime,sourceGroup, targetConfigurationSet, targetVersion, targetTime, targetGroup);
		}

		if(casfFlowConfig)
		{
			bool casConf =  CO_CopyCashFlowConfiguration(server, sourceConfigurationSet, sourceVersion, sourceTime, targetConfigurationSet, targetVersion, targetTime);
		}

		return true;

	}

	catch(errorMessage, errorCode)

	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	45921F6C-D8BB-4865-BA24-B92447DB9C1B	Copy Configuration Set settings within the listed cubes.	1	1	1	1669	NULL	0	45708.67502	0	0
16244E5B-8B03-478E-989E-FF64E8480CFB	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CopyProfitMargin	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if process was succesfull, false if process caught some error"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""sourceConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""sourceVersion"" parameter-type=""string"" parameter-description=""The source version/scenario  element to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""sourceTime"" parameter-type=""string"" parameter-description=""The source time element to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""targetConfigurationSet"" parameter-type=""string"" parameter-description=""The source Configuration set  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""targetVersion"" parameter-type=""string"" parameter-description=""The target version/scenario  element to be used."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""targetTime"" parameter-type=""string"" parameter-description=""The target time element to be used."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CF_ElementStringSplit"" process-version=""*"" process-id="""" />
    <process process-name=""GetLanguageOrCaptionOrElementItself"" process-version=""*"" process-id="""" />
    <process process-name=""GetStatusString"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyProfitMargin(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy profit margin from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string statusECube = ""TSTATUSC"";
	string entityDimension = ""DCOMPC"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2020].[1],[DTIME].[01.2021].[1],[DTIME].[02.2021].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[11.2020].[1]"";//[DTIME].[03.2022].[1]*/


		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP =CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string p in sourceP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(sourcePeriods,per);
		}

		int numberOfSourcePeriods = Count(sourcePeriods);

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		if(targetTime == """")
		{
			NotifyInformation(""Target Period was not filled. Aborting process."");
			return false;
		}

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}
		int numberOfTargetPeriods = Count(targetPeriods);
		if(numberOfSourcePeriods &gt; numberOfTargetPeriods)
		{
			int index = 0;
			while(index &lt;= numberOfSourcePeriods - 2)
			{
				string p = targetPeriods[index];
				OLAPElement pOElement = OLAPGetDimensionElement(connection, ""DTIME"", p);
				string nextTime = OLAPGetStringAttribute(connection, pOElement, ""NextPeriod"");
				string next = ResolveUniqueName(connection, nextTime);
				Append(targetPeriods,next);
				index = index + 1;

			}
		}

		numberOfTargetPeriods = Count(targetPeriods);

		string sourceCVCheck = sourceConfigurationSet + sourceVersion;
		string targetCVCheck = targetConfigurationSet + targetVersion;

		bool periodsOverLap = false;
		foreach(string t in targetPeriods)
		{
			if(t != """")
			{
				if(Contains(sourcePeriods,t))
				{
					periodsOverLap = true;
				}
			}
		}

		if(sourceCVCheck == targetCVCheck and periodsOverLap)
		{
			NotifyInformation(""The source and target for configuration set and version are the same and there are overlaping periods. No data transfered. Aborting Process."");
			return false;
		}

		bool cannotProcess = false;
		NotifyInformation(""Copying profit margin data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");


		foreach(string per in targetPeriods)
		{
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");

		StringArray toBeCopied = CreateStringArray();
		foreach(string per in targetPeriods)
		{
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList entityDimOList = OLAPGetChildElementList(connection, entityDimension, ""Group Companies"", true);
			StringList entityDimStringList = ToStringList(entityDimOList);
			foreach(string en in entityDimStringList)
			{
				double entityProfitMargin = OLAPCellReadNumber(connection, statusECube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,en,""Entity Profit Margin"");
				if (entityProfitMargin == 10)
				{
					Append(toBeCopied, pStat + yStat + en);
				}
				else
				{
					if(!cannotProcess)
					{
						NotifyInformation(""Cannot process:"");
						NotifyInformation("""");
						cannotProcess = true;
					}
					NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,entityDimension,en, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(entityProfitMargin));
				}
			}
		}

		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, ""global"", OlapDataAreaBCells,OlapDataAreaBCells,""profit margin"");
			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string intercompany = OLAPCellGetElement(cell, ""DINTCO"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
				}
			}
		}
		int indexsource = 0;
		int indextarget = 0;

		while(indextarget &lt;= numberOfTargetPeriods - 1)
		{
			string targetMonth = StringSubstring(targetPeriods[indextarget], 0, 2);
			string targetYear= StringSubstring(targetPeriods[indextarget], 3, 4);
			string sourceMonth = StringSubstring(sourcePeriods[indexsource], 0, 2);
			string sourceYear= StringSubstring(sourcePeriods[indexsource], 3, 4);

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, ""global"", OlapDataAreaBCells,OlapDataAreaBCells,""profit margin"");

			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string intercompany = OLAPCellGetElement(cell, ""DINTCO"");

				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				
				CopiedValues = CopiedValues + 1;
				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
					}
					else
					{
						OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
					}
				}
			}
			if(numberOfSourcePeriods != 1)
			{
				indexsource = indexsource + 1;
			}
			indextarget = indextarget + 1;
		}

		LogDebug(CopiedValues + "" of TCONSPA values of profit margin were copied"");
		OLAPCommitCellWriteBuffer(buffer);
		return true;
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CF_ElementStringSplit"", ""*""
#include ""GetLanguageOrCaptionOrElementItself"", ""*""
#include ""GetStatusString"", ""*""

bool CO_CopyProfitMargin(string server, string sourceConfigurationSet, string sourceVersion, string sourceTime,string targetConfigurationSet, string targetVersion, string targetTime)
@Description: ""Copy profit margin from given  source configuration set/version/time to target configuration set/version/time"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[sourceConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[sourceVersion]: ""The source version/scenario  element to be used."";
@Parameter[sourceTime]: ""The source time element to be used."";
@Parameter[targetConfigurationSet]: ""The source Configuration set  element to be used."";
@Parameter[targetVersion]: ""The target version/scenario  element to be used."";
@Parameter[targetTime]: ""The target time element to be used."";
@Returns: ""true if process was succesfull, false if process caught some error"";
{
	string functionName = ""CO_CopyProfitMargin:"";
	string statusECube = ""TSTATUSC"";
	string entityDimension = ""DCOMPC"";
	string errorMessage = """";
	int errorCode = 0;
	string Cube = """";
	int CopiedValues = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*sourceConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		sourceVersion = ""[DVERSIO].[V01].[1]"";
		sourceTime = ""[DTIME].[12.2020].[1],[DTIME].[01.2021].[1],[DTIME].[02.2021].[1]"";//
		targetConfigurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		targetVersion = ""[DVERSIO].[V01].[1]"";
		targetTime = ""[DTIME].[11.2020].[1]"";//[DTIME].[03.2022].[1]*/


		OLAPCellWriteBuffer buffer = OLAPCreateCellWriteBuffer(connection);
		OLAPSetMaxUncommittedValues(buffer, 500);

		sourceConfigurationSet = ResolveUniqueName(connection, sourceConfigurationSet);
		sourceVersion = ResolveUniqueName(connection, sourceVersion);
		StringArray sourceP =CF_ElementStringSplit(sourceTime);
		StringArray sourcePeriods = CreateStringArray();

		foreach(string p in sourceP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(sourcePeriods,per);
		}

		int numberOfSourcePeriods = Count(sourcePeriods);

		targetConfigurationSet = ResolveUniqueName(connection, targetConfigurationSet);
		targetVersion = ResolveUniqueName(connection, targetVersion);
		if(targetTime == """")
		{
			NotifyInformation(""Target Period was not filled. Aborting process."");
			return false;
		}

		StringArray targetP = CF_ElementStringSplit(targetTime);
		StringArray targetPeriods = CreateStringArray();
		foreach(string p in targetP)
		{
			string per = ResolveUniqueName(connection, p);
			Append(targetPeriods,per);
		}
		int numberOfTargetPeriods = Count(targetPeriods);
		if(numberOfSourcePeriods > numberOfTargetPeriods)
		{
			int index = 0;
			while(index <= numberOfSourcePeriods - 2)
			{
				string p = targetPeriods[index];
				OLAPElement pOElement = OLAPGetDimensionElement(connection, ""DTIME"", p);
				string nextTime = OLAPGetStringAttribute(connection, pOElement, ""NextPeriod"");
				string next = ResolveUniqueName(connection, nextTime);
				Append(targetPeriods,next);
				index = index + 1;

			}
		}

		numberOfTargetPeriods = Count(targetPeriods);

		string sourceCVCheck = sourceConfigurationSet + sourceVersion;
		string targetCVCheck = targetConfigurationSet + targetVersion;

		bool periodsOverLap = false;
		foreach(string t in targetPeriods)
		{
			if(t != """")
			{
				if(Contains(sourcePeriods,t))
				{
					periodsOverLap = true;
				}
			}
		}

		if(sourceCVCheck == targetCVCheck and periodsOverLap)
		{
			NotifyInformation(""The source and target for configuration set and version are the same and there are overlaping periods. No data transfered. Aborting Process."");
			return false;
		}

		bool cannotProcess = false;
		NotifyInformation(""Copying profit margin data"");
		foreach(string p in sourcePeriods)
		{
			NotifyInformation(""From Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", sourceVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",p, ""English"") );

		}
		NotifyInformation("""");


		foreach(string per in targetPeriods)
		{
			NotifyInformation(""To Version: "" + GetLanguageOrCaptionOrElementItself(connection,""DVERSIO"", targetVersion, ""English"") + "", Period: ""  + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"") );

		}
		NotifyInformation("""");

		StringArray toBeCopied = CreateStringArray();
		foreach(string per in targetPeriods)
		{
			string pStat= StringSubstring(per, 0, 2);
			string yStat= StringSubstring(per, 3, 4);
			OLAPElementList entityDimOList = OLAPGetChildElementList(connection, entityDimension, ""Group Companies"", true);
			StringList entityDimStringList = ToStringList(entityDimOList);
			foreach(string en in entityDimStringList)
			{
				double entityProfitMargin = OLAPCellReadNumber(connection, statusECube, 1.0, targetConfigurationSet, yStat,pStat, targetVersion,en,""Entity Profit Margin"");
				if (entityProfitMargin == 10)
				{
					Append(toBeCopied, pStat + yStat + en);
				}
				else
				{
					if(!cannotProcess)
					{
						NotifyInformation(""Cannot process:"");
						NotifyInformation("""");
						cannotProcess = true;
					}
					NotifyInformation(""- "" + GetLanguageOrCaptionOrElementItself(connection,entityDimension,en, ""English"") + "", "" + GetLanguageOrCaptionOrElementItself(connection,""DTIME"",per, ""English"")  + "", as it has a status "" +  GetStatusString(entityProfitMargin));
				}
			}
		}

		Cube = ""TCONSPA"";
		foreach(string t in targetPeriods)
		{
			string targetMonth = StringSubstring(t, 0, 2);
			string targetYear= StringSubstring(t, 3, 4);

			OLAPDataArea TargetDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    targetConfigurationSet,  targetYear,targetMonth,targetVersion, ""global"", OlapDataAreaBCells,OlapDataAreaBCells,""profit margin"");
			foreach (OLAPCell cell in TargetDataTCONSPA)
			{
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string intercompany = OLAPCellGetElement(cell, ""DINTCO"");

				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					OLAPCellWriteBufferDeleteCell(buffer, Cube, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
				}
			}
		}
		int indexsource = 0;
		int indextarget = 0;

		while(indextarget <= numberOfTargetPeriods - 1)
		{
			string targetMonth = StringSubstring(targetPeriods[indextarget], 0, 2);
			string targetYear= StringSubstring(targetPeriods[indextarget], 3, 4);
			string sourceMonth = StringSubstring(sourcePeriods[indexsource], 0, 2);
			string sourceYear= StringSubstring(sourcePeriods[indexsource], 3, 4);

			OLAPDataArea SourceDataTCONSPA = OLAPCreateDataArea(connection, Cube,
			                                                    OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
			                                                    OlapDataAreaOperatorNone, 0.0,
			                                                    sourceConfigurationSet,  sourceYear,sourceMonth,sourceVersion, ""global"", OlapDataAreaBCells,OlapDataAreaBCells,""profit margin"");

			foreach (OLAPCell cell in SourceDataTCONSPA)
			{
				
				string entity = OLAPCellGetElement(cell, ""DCOMPC"");
				string intercompany = OLAPCellGetElement(cell, ""DINTCO"");

				bool isCellText =  OLAPCellIsTextCell(cell);
				string valueStr = """";
				double valueDou = 0;

				if(isCellText)
				{
					valueStr  = cell;
				}
				else
				{
					valueDou = cell;
				}
				
				CopiedValues = CopiedValues + 1;
				if(Contains(toBeCopied,targetMonth + targetYear + entity))
				{
					if(isCellText)
					{
						OLAPCellWriteBufferWriteString(buffer, Cube, valueStr, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
					}
					else
					{
						OLAPCellWriteBufferWriteNumber(buffer, Cube, valueDou, targetConfigurationSet,targetYear,targetMonth,targetVersion, ""global"", entity, intercompany,""profit margin"");
					}
				}
			}
			if(numberOfSourcePeriods != 1)
			{
				indexsource = indexsource + 1;
			}
			indextarget = indextarget + 1;
		}

		LogDebug(CopiedValues + "" of TCONSPA values of profit margin were copied"");
		OLAPCommitCellWriteBuffer(buffer);
		return true;
	}

	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	9FA87E73-FB96-4338-8E30-6776B2C4E0E7	Copy profit margin from given  source configuration set/version/time to target configuration set/version/time	1	1	1	1670	NULL	0	45708.67509	0	0
C3857DD3-AE9D-4EC0-AA25-0FBB35F3B99A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CreateGenericElementWithName	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""elementID"" parameter-type=""string"" parameter-description=""Element name to be created  ."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""description"" parameter-type=""string"" parameter-description=""Nama attribute to be filed."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension where elements to be created ."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""parent"" parameter-type=""string"" parameter-description=""parent Element below new element should be created, second parent is Rollover Total."" parameter-order=""4"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateGenericElementWithName(string server, string elementID, string description, string dimension, string parent)
@Description: ""Create level element and its coresponding rollover element and fill attributes."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[elementID]: ""Element name to be created  ."";
@Parameter[description]: ""Nama attribute to be filed."";
@Parameter[dimension]: ""Dimension where elements to be created ."";
@Parameter[parent]: ""parent Element below new element should be created, second parent is Rollover Total."";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""CO_CreateGenericElementWithName: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*elementID = ""testChecks"";
		description = ""Test Checks"";
		dimension = ""DCHECKS"";
		parent = ""[DCHECKS].[TC].[1]"";*/
		
		string newElement = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", parent,elementID, 0,"""",  ""N"", 1, false);
		newElement = ResolveUniqueName(connection, newElement);
		
		bool setNameAttributeNewElement = OLAPSetStringAttribute(connection, dimension, newElement, ""Name"", description);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateGenericElementWithName(string server, string elementID, string description, string dimension, string parent)
@Description: ""Create level element and its coresponding rollover element and fill attributes."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[elementID]: ""Element name to be created  ."";
@Parameter[description]: ""Nama attribute to be filed."";
@Parameter[dimension]: ""Dimension where elements to be created ."";
@Parameter[parent]: ""parent Element below new element should be created, second parent is Rollover Total."";
@Returns: ""Created element UN or empty string if not successful."";
{
	string functionName = ""CO_CreateGenericElementWithName: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*elementID = ""testChecks"";
		description = ""Test Checks"";
		dimension = ""DCHECKS"";
		parent = ""[DCHECKS].[TC].[1]"";*/
		
		string newElement = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", parent,elementID, 0,"""",  ""N"", 1, false);
		newElement = ResolveUniqueName(connection, newElement);
		
		bool setNameAttributeNewElement = OLAPSetStringAttribute(connection, dimension, newElement, ""Name"", description);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}"	1	7E557511-6B08-4538-A6A9-969F1B52D7C4	Create level element and its coresponding rollover element and fill attributes.	1	1	1	1671	NULL	0	45708.67507	0	0
0DD4305C-B463-43B5-96E7-C9D0CF4A01DB	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CreateLevelAndRolloverLevelElements	Budgeting and Planning Utilities	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True if successful, otherwise false."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""elementID"" parameter-type=""string"" parameter-description=""Element name to be created ."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""description"" parameter-type=""string"" parameter-description=""Nama attribute to be filed."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""Dimension where elements to be created ."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""parent"" parameter-type=""string"" parameter-description=""parent Element below new element should be created, second parent is Rollover Total."" parameter-order=""4"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateLevelAndRolloverLevelElements(string server, string elementID, string description, string dimension, string parent)
@Description: ""Create level element and its coresponding rollover element and fill attributes."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[elementID]: ""Element name to be created ."";
@Parameter[description]: ""Nama attribute to be filed."";
@Parameter[dimension]: ""Dimension where elements to be created ."";
@Parameter[parent]: ""parent Element below new element should be created, second parent is Rollover Total."";
@Returns: ""True if successful, otherwise false."";
{
	string functionName = ""CO_CreateLevelAndRolloverLevelElements: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*elementID = ""testMichal2"";
		description = ""Test Michal 2"";
		dimension = ""DCLEVEL"";
		parent = ""[DCLEVEL].[Journal Total].[1]"";*/

		string newElement = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", parent,elementID, 0,"""",  ""N"", 1, false);
		string newElementRolover = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", ""[""+dimension+""].[Rollover total].[1]"",""Rollover ""+ elementID, 0,"""",  ""N"", 1, false);

		newElement = ResolveUniqueName(connection, newElement);
		newElementRolover = ResolveUniqueName(connection, newElementRolover);

		bool setReportAttributeNewElement = OLAPSetBoolAttribute(connection, dimension, newElement, ""Report"", true);
		bool setBookerAttributeNewElement = OLAPSetBoolAttribute(connection, dimension, newElement, ""Booker"", true);
		bool setNameAttributeNewElement = OLAPSetStringAttribute(connection, dimension, newElement, ""Name"", description);

		bool setReportAttributeNewElementRollover = OLAPSetBoolAttribute(connection, dimension, newElementRolover, ""Report"", true);
		bool setBookerAttributeNewElementRollover = OLAPSetBoolAttribute(connection, dimension, newElementRolover, ""Booker"", false);
		bool setNameAttributeNewElementRollover = OLAPSetStringAttribute(connection, dimension, newElementRolover, ""Name"", ""Rollover ""+ description);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateLevelAndRolloverLevelElements(string server, string elementID, string description, string dimension, string parent)
@Description: ""Create level element and its coresponding rollover element and fill attributes."";
@Category: ""Budgeting and Planning Utilities"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[elementID]: ""Element name to be created ."";
@Parameter[description]: ""Nama attribute to be filed."";
@Parameter[dimension]: ""Dimension where elements to be created ."";
@Parameter[parent]: ""parent Element below new element should be created, second parent is Rollover Total."";
@Returns: ""True if successful, otherwise false."";
{
	string functionName = ""CO_CreateLevelAndRolloverLevelElements: "";
	string errorMessage = """";
	int errorCode = 0;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*elementID = ""testMichal2"";
		description = ""Test Michal 2"";
		dimension = ""DCLEVEL"";
		parent = ""[DCLEVEL].[Journal Total].[1]"";*/

		string newElement = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", parent,elementID, 0,"""",  ""N"", 1, false);
		string newElementRolover = BP_CreateGenericElement(server,""[""+dimension+""]"",""[""+dimension+""].[""+dimension+""]"", ""[""+dimension+""].[Rollover total].[1]"",""Rollover ""+ elementID, 0,"""",  ""N"", 1, false);

		newElement = ResolveUniqueName(connection, newElement);
		newElementRolover = ResolveUniqueName(connection, newElementRolover);

		bool setReportAttributeNewElement = OLAPSetBoolAttribute(connection, dimension, newElement, ""Report"", true);
		bool setBookerAttributeNewElement = OLAPSetBoolAttribute(connection, dimension, newElement, ""Booker"", true);
		bool setNameAttributeNewElement = OLAPSetStringAttribute(connection, dimension, newElement, ""Name"", description);

		bool setReportAttributeNewElementRollover = OLAPSetBoolAttribute(connection, dimension, newElementRolover, ""Report"", true);
		bool setBookerAttributeNewElementRollover = OLAPSetBoolAttribute(connection, dimension, newElementRolover, ""Booker"", false);
		bool setNameAttributeNewElementRollover = OLAPSetStringAttribute(connection, dimension, newElementRolover, ""Name"", ""Rollover ""+ description);
		
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}"	1	6E799397-1C20-415C-B54A-804160E13B9E	Create level element and its coresponding rollover element and fill attributes.	1	1	1	1672	NULL	0	45708.67508	0	0
1B6A97E9-5548-4E1F-8805-6EA89A9E7C2C	CD491758-D9DF-4002-94C8-8006E1855F86	CO_CreateUGElement	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Created DUSERGUIDANCE element UN or empty string if not successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""parentName"" parameter-type=""string"" parameter-description=""Element below new element should be created"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""caption"" parameter-type=""string"" parameter-description=""Caption is filled in case that parent with UG is sent to process"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""BP_CreateGenericElement"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateUGElement(string server, string parentName,string caption)
@Description: ""Create New element for DUSERGUIDANCE dimension, if parent contain UG, than swimlane element, if parent contain SWIMLANE, than card element, if parent contain CARD, than link element."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[parentName]: ""Element below new element should be created"";
@Parameter[caption]: ""Caption is filled in case that parent with UG is sent to process"";
@Returns: ""Created DUSERGUIDANCE element UN or empty string if not successful."";
{
	string functionName = ""CO_CreateUGElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	string ugDimension = ""DUSERGUIDANCE"";
	try
	{
		/*parentName =""[DUSERGUIDANCE].[CST_SWIMLANE_001].[1]"";
		caption=""testMichaL"";*/
		if(parentName.Contains(""UG""))
		{
			OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
			newElement =  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_SWIMLANE"", 3,""_"", ""N"", 1, true);
			string resolvedElement = ResolveUniqueName(olapconnection , newElement);
			OLAPSetStringAttribute(olapconnection,ugDimension,resolvedElement,""Name"",caption);			
		}
		if(parentName.Contains(""SWIMLANE""))
		{
			newElement=  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_CARD"", 3,""_"", ""N"", 1, true);
		}
		if(parentName.Contains(""CARD""))
		{
			newElement =  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_LINK"", 3,""_"", ""N"", 1, true);
		}
		return newElement;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}</bisharp-code>
</process-descriptor>"	1	"/************************************************************** 
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 **************************************************************/

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""BP_CreateGenericElement"", ""*""

string CO_CreateUGElement(string server, string parentName,string caption)
@Description: ""Create New element for DUSERGUIDANCE dimension, if parent contain UG, than swimlane element, if parent contain SWIMLANE, than card element, if parent contain CARD, than link element."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[parentName]: ""Element below new element should be created"";
@Parameter[caption]: ""Caption is filled in case that parent with UG is sent to process"";
@Returns: ""Created DUSERGUIDANCE element UN or empty string if not successful."";
{
	string functionName = ""CO_CreateUGElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	string ugDimension = ""DUSERGUIDANCE"";
	try
	{
		/*parentName =""[DUSERGUIDANCE].[CST_SWIMLANE_001].[1]"";
		caption=""testMichaL"";*/
		if(parentName.Contains(""UG""))
		{
			OLAPConnection olapconnection = OLAPCreatePooledNamedConnection(server);
			newElement =  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_SWIMLANE"", 3,""_"", ""N"", 1, true);
			string resolvedElement = ResolveUniqueName(olapconnection , newElement);
			OLAPSetStringAttribute(olapconnection,ugDimension,resolvedElement,""Name"",caption);			
		}
		if(parentName.Contains(""SWIMLANE""))
		{
			newElement=  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_CARD"", 3,""_"", ""N"", 1, true);
		}
		if(parentName.Contains(""CARD""))
		{
			newElement =  BP_CreateGenericElement(server,""[""+ugDimension+""]"",""[""+ugDimension+""].[""+ugDimension+""]"",parentName,""CST_LINK"", 3,""_"", ""N"", 1, true);
		}
		return newElement;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}"	1	18491B08-FCCF-42CF-B380-0B92E0248AFC	Create New element for DUSERGUIDANCE dimension, if parent contain UG, than swimlane element, if parent contain SWIMLANE, than card element, if parent contain CARD, than link element.	1	1	1	1673	NULL	0	45708.67506	0	0
F51D6FE4-04D8-42C8-A0CE-63C3B8DB272D	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Debts	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BookingType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Schedules"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""DetermineElementDimensionOrder"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_BookingType"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Schedules"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""DetermineElementDimensionOrder"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_Debts(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebts process. Consolidation of debts for finance and detail data."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""D"";
	cancel = false;*/
	
	string processName = ""CO_Debts"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			// Constants
			string cubeDetailG  = ""TDETAIG"";
			string cubeFinanceG = ""TFINANG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimDetail       = ""DDETAIL"";
			string dimConsRule     = ""DCONSRL"";
			string consolidationType     = ""Cons. Debts"";
			string OwnershipQuotal  = ""Quotal"";
			string OwnershipFull    = ""Full"";
			string AssetAccountType = ""Asset"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			
			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string stdRule = """";
			string helpKey1 = """";
			string helpKey2 = """";
			double value = 0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isAsset = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, dimGroupLevel, consolidationBasis, true);
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList details = CreateOLAPElementList();          //only TDETAIG
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			foreach (OLAPElement sourceDetail in CO_Schedules(olapConnection)) {
				OLAPElementListAddElement(details, sourceDetail);
			}
			
			//stores all processed values of cubeDetailG, so we can check in the loop for cubeFinanceG
			//if a matching cubeDetailG value was found
			LegacyLookupMapInitialize(""processedValues"" + cubeDetailG);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeDetailG);
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeFinanceG);
			
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeDetailG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, details, accounts
			);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				detail = OLAPCellGetElement(cell, dimDetail);
				
				lookupKey = company + ""|"" + interCompany + ""|"" + account + ""|"" + detail;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection, cubeDetailG, 1.0,
					                           cycle,
					                           year,
					                           period,
					                           scenario,
					                           groupCurrency,
					                           consolidationBasis,
					                           group,
					                           company,
					                           interCompany,
					                           detail,
					                           account);
					
					if (value != 0) {
						counter = counter + 1;

						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
						
						//use lookup to remember processed values for 2nd DataArea
						lookupKey = company + ""|"" + interCompany + ""|"" + account;
						LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", true);
						
						//store all opened journals by company/interCompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						if (ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination
							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						//add the journal lines
						transformedValue = transformedValue * value;

						if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", 0.0, Abs(transformedValue));
						}
					}
				}
			}
			
			NotifyInformation(""&lt;"" + cubeDetailG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			//create DataArea over second cube
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeFinanceG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, accounts
			);
			
			counter = 0;
			foreach (OLAPCell cell in sourceArea) {
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);

				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + account;
				
				if (!LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", false)) {
					//no value found - go on processing this cell
					
					if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", false) == false) {
						LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", true);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);

						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									//switch companies
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						value = OLAPCellReadNumber(olapConnection, cubeFinanceG, 1.0,
						                           cycle,
						                           year,
						                           period,
						                           scenario,
						                           groupCurrency,
						                           consolidationBasis,
						                           group,
						                           company,
						                           interCompany,
						                           account);
						
						if (value != 0) {
							counter = counter + 1;
							
							transformedValue = transformedValue * value;
							
							if (ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								
								//remember entries in a StringArray
								Append(dictionaryEntries,lookupKey);
							}

							//add the journal lines
							if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", 0.0, Abs(transformedValue));
							}
						}  // end if value != 0.0
					}  // end if already processed finance cube cell
				}  // end if already processed detail cube cell
			}  // end foreach cell in 2nd data area
			
			NotifyInformation(""&lt;"" + cubeFinanceG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary,entry);
				//retrieve elements from key
				keyElements = StringSplit(entry, ""|"");
				company = GetElementByIndex(keyElements, 0);
				interCompany = GetElementByIndex(keyElements, 1);
				stdRule = GetElementByIndex(keyElements, 2);
				OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, stdRule);
				
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				double difference = ConsolidationJournalDifference(openJournal);

				//is there any difference?
				if (RoundDecimals(difference, 4) != 0.0) {
					
					int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					string stdDiffRule = """";
					if (bookingType == 1)
					{
						stdDiffRule = stdRule;
					} else
					{
						stdDiffRule = ""100"" + stdRule;
					}

					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario,
						                                                     stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule);
						double stdDiffFx = difference - transactionsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal,  entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", 0.0, -difference);
						}
					}
				}

				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for &lt;"" + entry + ""&gt; was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_BookingType"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Schedules"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""DetermineElementDimensionOrder"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_Debts(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebts process. Consolidation of debts for finance and detail data."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""D"";
	cancel = false;*/
	
	string processName = ""CO_Debts"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			// Constants
			string cubeDetailG  = ""TDETAIG"";
			string cubeFinanceG = ""TFINANG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimDetail       = ""DDETAIL"";
			string dimConsRule     = ""DCONSRL"";
			string consolidationType     = ""Cons. Debts"";
			string OwnershipQuotal  = ""Quotal"";
			string OwnershipFull    = ""Full"";
			string AssetAccountType = ""Asset"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			
			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string stdRule = """";
			string helpKey1 = """";
			string helpKey2 = """";
			double value = 0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isAsset = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, dimGroupLevel, consolidationBasis, true);
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList details = CreateOLAPElementList();          //only TDETAIG
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			foreach (OLAPElement sourceDetail in CO_Schedules(olapConnection)) {
				OLAPElementListAddElement(details, sourceDetail);
			}
			
			//stores all processed values of cubeDetailG, so we can check in the loop for cubeFinanceG
			//if a matching cubeDetailG value was found
			LegacyLookupMapInitialize(""processedValues"" + cubeDetailG);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeDetailG);
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeFinanceG);
			
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeDetailG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, details, accounts
			);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				detail = OLAPCellGetElement(cell, dimDetail);
				
				lookupKey = company + ""|"" + interCompany + ""|"" + account + ""|"" + detail;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection, cubeDetailG, 1.0,
					                           cycle,
					                           year,
					                           period,
					                           scenario,
					                           groupCurrency,
					                           consolidationBasis,
					                           group,
					                           company,
					                           interCompany,
					                           detail,
					                           account);
					
					if (value != 0) {
						counter = counter + 1;

						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
						
						//use lookup to remember processed values for 2nd DataArea
						lookupKey = company + ""|"" + interCompany + ""|"" + account;
						LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", true);
						
						//store all opened journals by company/interCompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						if (ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination
							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						//add the journal lines
						transformedValue = transformedValue * value;

						if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", 0.0, Abs(transformedValue));
						}
					}
				}
			}
			
			NotifyInformation(""<"" + cubeDetailG + ""> processed <"" + counter + ""> value(s)"");
			
			//create DataArea over second cube
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeFinanceG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, accounts
			);
			
			counter = 0;
			foreach (OLAPCell cell in sourceArea) {
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);

				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + account;
				
				if (!LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", false)) {
					//no value found - go on processing this cell
					
					if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", false) == false) {
						LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", true);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);

						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									//switch companies
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						value = OLAPCellReadNumber(olapConnection, cubeFinanceG, 1.0,
						                           cycle,
						                           year,
						                           period,
						                           scenario,
						                           groupCurrency,
						                           consolidationBasis,
						                           group,
						                           company,
						                           interCompany,
						                           account);
						
						if (value != 0) {
							counter = counter + 1;
							
							transformedValue = transformedValue * value;
							
							if (ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								
								//remember entries in a StringArray
								Append(dictionaryEntries,lookupKey);
							}

							//add the journal lines
							if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", 0.0, Abs(transformedValue));
							}
						}  // end if value != 0.0
					}  // end if already processed finance cube cell
				}  // end if already processed detail cube cell
			}  // end foreach cell in 2nd data area
			
			NotifyInformation(""<"" + cubeFinanceG + ""> processed <"" + counter + ""> value(s)"");
			
			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary,entry);
				//retrieve elements from key
				keyElements = StringSplit(entry, ""|"");
				company = GetElementByIndex(keyElements, 0);
				interCompany = GetElementByIndex(keyElements, 1);
				stdRule = GetElementByIndex(keyElements, 2);
				OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, stdRule);
				
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				double difference = ConsolidationJournalDifference(openJournal);

				//is there any difference?
				if (RoundDecimals(difference, 4) != 0.0) {
					
					int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					string stdDiffRule = """";
					if (bookingType == 1)
					{
						stdDiffRule = stdRule;
					} else
					{
						stdDiffRule = ""100"" + stdRule;
					}

					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario,
						                                                     stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule);
						double stdDiffFx = difference - transactionsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal,  entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", 0.0, -difference);
						}
					}
				}

				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for <"" + entry + ""> was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	405B7B4F-A88E-4995-B865-937A76ED1C03	Former FCDebts process. Consolidation of debts for finance and detail data.	1	1	1	1674	NULL	0	45708.67509	0	0
C69CDFE4-626D-4049-ABF8-9914E5FED17F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DebtsSegment	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_PrimarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_SecondarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_TertiarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_PrimarySegments"", ""*""
#include ""CO_SecondarySegments"", ""*""
#include ""CO_TertiarySegments"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_DebtsSegment(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebtsSegment process.Consolidation of debts for hierarchical segments."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_002"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HD"";
	cancel = false;*/
	
	string processName = ""CO_DebtsSegment"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if(!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");
		
		if(!cancel) {
			// Constants
			string psegm1Read = ""Sum"";
			string psegm2Read = ""Sum"";
			string psegm3Read = ""Sum"";
			string cubeTSegmG  = ""TSEGMG"";
			string cubeTSegmovG  = ""TSEGMOVG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimConsRule     = ""DCONSRL"";
			string dimPrimarySegment           = ""DPSEGM"";
			string dimPrimaryPartnerSegment    = ""DPRSEGM"";
			string dimSecondarySegment         = ""DSSEGM"";
			string dimSecondaryPartnerSegment  = ""DSRSEGM"";
			string dimTertiarySegment          = ""DTSEGM"";
			string dimTertiaryPartnerSegment   = ""DTRSEGM"";
			string consStage              = ""Consolidated Segments"";
			string consolidationType      = ""Cons. Debts"";
			string OwnershipQuotal        = ""Quotal"";
			string OwnershipFull          = ""Full"";
			string AssetAccountType  	  = ""Asset"";
			string noSegment              = ""-"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";

			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string detail = """";
			string company = """";
			string interCompany = """";
			string primarySegment = """";
			string primaryPartnerSegment = """";
			string secondarySegment = """";
			string secondaryPartnerSegment = """";
			string tertiarySegment = """";
			string tertiaryPartnerSegment = """";
			string helpKey = """";
			double valueAcc = 0.0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isAsset = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList primarySegments = CreateOLAPElementList();
			OLAPElementList primaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimPrimaryPartnerSegment, psegm1Read, true);
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimSecondaryPartnerSegment, psegm2Read, true);
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimTertiaryPartnerSegment, psegm3Read, true);
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement aSegment in CO_PrimarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
				OLAPElementListAddElement(primarySegments, aSegment);
			}

			if (CO_HasSegment(olapConnection, cycle, 2)) {
				foreach (OLAPElement aSegment in CO_SecondarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(secondarySegments, aSegment);
				}
				NotifyInformation(""Using segment2"");
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, dimSecondarySegment, noSegment));
				secondaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(secondaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimSecondaryPartnerSegment, noSegment));
			}

			if (CO_HasSegment(olapConnection, cycle, 3)) {
				foreach (OLAPElement aSegment in CO_TertiarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(tertiarySegments, aSegment);
				}
				NotifyInformation(""Using segment3"");
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, dimTertiarySegment, noSegment));
				tertiaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(tertiaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimTertiaryPartnerSegment, noSegment));
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					   (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//stores all processed values of cubeSegmovG, so we can check in the loop for cubeSegmG
			//if a matching detail value was found
			LegacyLookupMapInitialize(""processedValues"");

			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmovG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				OlapDataAreaBCells, accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
				detail = OLAPCellGetElement(cell, ""DDETAIL"");

				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				valueAcc = cell;
				
				counter = counter + 1;
				
				//use lookup to remember processed values for 2nd DataArea
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;

				LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", true);

				factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
				factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
				
				//get consolidationRule linked to the account
				foreach (OLAPElement consolidationRule in rules) {
					transformedValue = 0.0;
					if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorAccount;
						lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
							""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

					} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorContraAccount;
						lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
							""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
					}
					
					if (transformedValue != 0.0) {
						if(ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination

							string targetSegment = ""Intersegment"";
							if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
								targetSegment = ""Intrasegment"";
							}

							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}

						if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", 0.0, Abs(transformedValue));
						}
					}
				}  // end foreach consolidationRule
			}
			
			NotifyInformation(""&lt;"" + cubeTSegmovG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
				
				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;
				
				if(!LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", false)) {
					//no value found - go on processing this cell

					valueAcc = cell;
					
					counter = counter + 1;
					
					factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
					factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
					
					//get consolidationRule linked to the account
					foreach (OLAPElement consolidationRule in rules) {
						transformedValue = 0.0;
						if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorAccount;
							lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
								""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

						} else if(CO_IsContraAccount(olapConnection,cycle,  account, consolidationRule)) {
							transformedValue = valueAcc * factorContraAccount;
							lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
								""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
						}
						
						if (transformedValue != 0.0) {
							if(ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination

								string targetSegment = ""Intersegment"";
								if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
									targetSegment = ""Intrasegment"";
								}

								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								//remember entries in a StringArray
								Append(dictionaryEntries, lookupKey);
							}

							if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", 0.0, Abs(transformedValue));
							}
						}
					}  // end foreach consolidationRule
				}
			}
			
			NotifyInformation(""&lt;"" + cubeTSegmG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			

			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary, entry);
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0.0) {
					//retrieve elements from key
					keyElements = StringSplit(entry, ""|"");
					company = GetElementByIndex(keyElements, 0);
					interCompany = GetElementByIndex(keyElements, 1);
					helpKey = GetElementByIndex(keyElements, 2);
					primarySegment = GetElementByIndex(keyElements, 3);
					primaryPartnerSegment = GetElementByIndex(keyElements, 4);
					secondarySegment = GetElementByIndex(keyElements, 5);
					secondaryPartnerSegment = GetElementByIndex(keyElements, 6);
					tertiarySegment = GetElementByIndex(keyElements, 7);
					tertiaryPartnerSegment = GetElementByIndex(keyElements, 8);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, helpKey);
					
					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					// check if value from TSTDTRANSACTSEGM is not null
					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    primarySegment, primaryPartnerSegment,
					                    secondarySegment, secondaryPartnerSegment,
					                    tertiarySegment, tertiaryPartnerSegment,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     primarySegment, primaryPartnerSegment,
						                                                     secondarySegment, secondaryPartnerSegment,
						                                                     tertiarySegment, tertiaryPartnerSegment,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = difference - transactionsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -difference);
						}
					}
				}
				
				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for &lt;"" + entry + ""&gt; was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_PrimarySegments"", ""*""
#include ""CO_SecondarySegments"", ""*""
#include ""CO_TertiarySegments"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_DebtsSegment(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebtsSegment process.Consolidation of debts for hierarchical segments."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_002"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HD"";
	cancel = false;*/
	
	string processName = ""CO_DebtsSegment"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if(!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");
		
		if(!cancel) {
			// Constants
			string psegm1Read = ""Sum"";
			string psegm2Read = ""Sum"";
			string psegm3Read = ""Sum"";
			string cubeTSegmG  = ""TSEGMG"";
			string cubeTSegmovG  = ""TSEGMOVG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimConsRule     = ""DCONSRL"";
			string dimPrimarySegment           = ""DPSEGM"";
			string dimPrimaryPartnerSegment    = ""DPRSEGM"";
			string dimSecondarySegment         = ""DSSEGM"";
			string dimSecondaryPartnerSegment  = ""DSRSEGM"";
			string dimTertiarySegment          = ""DTSEGM"";
			string dimTertiaryPartnerSegment   = ""DTRSEGM"";
			string consStage              = ""Consolidated Segments"";
			string consolidationType      = ""Cons. Debts"";
			string OwnershipQuotal        = ""Quotal"";
			string OwnershipFull          = ""Full"";
			string AssetAccountType  	  = ""Asset"";
			string noSegment              = ""-"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";

			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string detail = """";
			string company = """";
			string interCompany = """";
			string primarySegment = """";
			string primaryPartnerSegment = """";
			string secondarySegment = """";
			string secondaryPartnerSegment = """";
			string tertiarySegment = """";
			string tertiaryPartnerSegment = """";
			string helpKey = """";
			double valueAcc = 0.0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isAsset = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList primarySegments = CreateOLAPElementList();
			OLAPElementList primaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimPrimaryPartnerSegment, psegm1Read, true);
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimSecondaryPartnerSegment, psegm2Read, true);
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimTertiaryPartnerSegment, psegm3Read, true);
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement aSegment in CO_PrimarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
				OLAPElementListAddElement(primarySegments, aSegment);
			}

			if (CO_HasSegment(olapConnection, cycle, 2)) {
				foreach (OLAPElement aSegment in CO_SecondarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(secondarySegments, aSegment);
				}
				NotifyInformation(""Using segment2"");
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, dimSecondarySegment, noSegment));
				secondaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(secondaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimSecondaryPartnerSegment, noSegment));
			}

			if (CO_HasSegment(olapConnection, cycle, 3)) {
				foreach (OLAPElement aSegment in CO_TertiarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(tertiarySegments, aSegment);
				}
				NotifyInformation(""Using segment3"");
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, dimTertiarySegment, noSegment));
				tertiaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(tertiaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimTertiaryPartnerSegment, noSegment));
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					   (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//stores all processed values of cubeSegmovG, so we can check in the loop for cubeSegmG
			//if a matching detail value was found
			LegacyLookupMapInitialize(""processedValues"");

			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmovG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				OlapDataAreaBCells, accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
				detail = OLAPCellGetElement(cell, ""DDETAIL"");

				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				valueAcc = cell;
				
				counter = counter + 1;
				
				//use lookup to remember processed values for 2nd DataArea
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;

				LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", true);

				factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
				factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
				
				//get consolidationRule linked to the account
				foreach (OLAPElement consolidationRule in rules) {
					transformedValue = 0.0;
					if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorAccount;
						lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
							""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

					} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorContraAccount;
						lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
							""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
					}
					
					if (transformedValue != 0.0) {
						if(ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination

							string targetSegment = ""Intersegment"";
							if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
								targetSegment = ""Intrasegment"";
							}

							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}

						if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", 0.0, Abs(transformedValue));
						}
					}
				}  // end foreach consolidationRule
			}
			
			NotifyInformation(""<"" + cubeTSegmovG + ""> processed <"" + counter + ""> value(s)"");
			
			
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isAsset = CO_AccountType(olapConnection, acc) == AssetAccountType;
				
				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;
				
				if(!LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", false)) {
					//no value found - go on processing this cell

					valueAcc = cell;
					
					counter = counter + 1;
					
					factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
					factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
					
					//get consolidationRule linked to the account
					foreach (OLAPElement consolidationRule in rules) {
						transformedValue = 0.0;
						if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorAccount;
							lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
								""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

						} else if(CO_IsContraAccount(olapConnection,cycle,  account, consolidationRule)) {
							transformedValue = valueAcc * factorContraAccount;
							lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
								""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
						}
						
						if (transformedValue != 0.0) {
							if(ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination

								string targetSegment = ""Intersegment"";
								if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
									targetSegment = ""Intrasegment"";
								}

								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								//remember entries in a StringArray
								Append(dictionaryEntries, lookupKey);
							}

							if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", 0.0, Abs(transformedValue));
							}
						}
					}  // end foreach consolidationRule
				}
			}
			
			NotifyInformation(""<"" + cubeTSegmG + ""> processed <"" + counter + ""> value(s)"");
			

			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary, entry);
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0.0) {
					//retrieve elements from key
					keyElements = StringSplit(entry, ""|"");
					company = GetElementByIndex(keyElements, 0);
					interCompany = GetElementByIndex(keyElements, 1);
					helpKey = GetElementByIndex(keyElements, 2);
					primarySegment = GetElementByIndex(keyElements, 3);
					primaryPartnerSegment = GetElementByIndex(keyElements, 4);
					secondarySegment = GetElementByIndex(keyElements, 5);
					secondaryPartnerSegment = GetElementByIndex(keyElements, 6);
					tertiarySegment = GetElementByIndex(keyElements, 7);
					tertiaryPartnerSegment = GetElementByIndex(keyElements, 8);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, helpKey);
					
					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					// check if value from TSTDTRANSACTSEGM is not null
					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    primarySegment, primaryPartnerSegment,
					                    secondarySegment, secondaryPartnerSegment,
					                    tertiarySegment, tertiaryPartnerSegment,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     primarySegment, primaryPartnerSegment,
						                                                     secondarySegment, secondaryPartnerSegment,
						                                                     tertiarySegment, tertiaryPartnerSegment,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = difference - transactionsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -difference);
						}
					}
				}
				
				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for <"" + entry + ""> was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	13ED7155-26C8-4659-A0E3-621D15340D2F	Former FCDebtsSegment process.Consolidation of debts for hierarchical segments.	1	1	1	1675	NULL	0	45708.67508	0	0
441189D2-040E-4A5A-B60E-BFCCEDE487B8	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DebtsSegmentElim	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEliminationElement"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ScheduleDetails"" process-version=""*"" process-id="""" />
    <process process-name=""SortStringArray"" process-version=""*"" process-id="""" />
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetEliminationElement"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""SortStringArray"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_DebtsSegmentElim(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebtsSegmentElim process. Hierarchical Consolidation of Debts with hierarchical segmentation."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HD"";
	cancel = false;*/

	string processName = ""CO_DebtsSegmentElim"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 =  OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore( olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			GroupJournalDictionary groupSegmentJournalDictionary = CreateGroupJournalDictionary();
			GroupJournal groupSegmentJournal = null;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double counter2 = 0;
			double value = 0;
			double transformedValue = 0;
			double factor = 0;
			string lookupKey = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string unassigned = ""Unassigned"";
			string segment = """";
			string segmentPartner = """";
			string secondarySegment = """";
			string secondarySegmentPartner = """";
			string tertiarySegment = """";
			string tertiarySegmentPartner = """";
			string segmentRoot = ""TOTAL"";
			string secondarySegmentRoot = ""TOTAL"";
			string tertiarySegmentRoot = ""TOTAL"";
			string account = """";
			string help = """";
			bool isAsset = false;
			double factorAccount = 0;
			double factorContraAccount = 0;
			string segmentLevel = ""Intersegment"";
			string eliminationSuffix = ""_Elim"";
			string segmentElimination = """";
			string secondarySegmentElimination = """";
			string tertiarySegmentElimination = """";
			string consolidationType = ""Cons. Debts"";
			
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, ""DGLEVEL"", consolidationBasis, true);
			
			//Companies
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList interCompanies = CreateOLAPElementList();
			
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle) where (
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Full"") or
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Quotal"")))
			{
				OLAPElementListAddElement(companies, sourceCompany);
				OLAPElementListAddElement(interCompanies, sourceCompany);
			}
			
			//segments (primary, secondary, tertiary)
			OLAPElementList segments = OLAPGetChildElementList(olapConnection, ""DPSEGM"", segmentRoot, true);
			OLAPElementList segmentsPartner = OLAPGetChildElementList(olapConnection, ""DPRSEGM"", segmentRoot, true);
			
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 2)) {
				secondarySegments = OLAPGetChildElementList(olapConnection, ""DSSEGM"", secondarySegmentRoot, true);
				secondarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DSRSEGM"", secondarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, ""DSSEGM"", ""-""));
				OLAPElementListAddElement(secondarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DSRSEGM"", ""-""));
			}
			
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 3)) {
				tertiarySegments = OLAPGetChildElementList(olapConnection, ""DTSEGM"", tertiarySegmentRoot, true);
				tertiarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DTRSEGM"", tertiarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, ""DTSEGM"", ""-""));
				OLAPElementListAddElement(tertiarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DTRSEGM"", ""-""));
			}

			//Accounts
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rulesList = CreateOLAPElementList();

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rulesList, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle))
			{
				foreach (OLAPElement consolidationRule in rulesList)
				{
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//Source Definition for TSEGMG
			string cube1 = ""TSEGMG"";
			string cube2 = ""TSEGMOVG"";
			string sourceDYEAR = year; 			  					 //DYEAR
			string sourceDPERIOD = period; 		  					 //DPERIOD
			string sourceDVERSIO = scenario; 							 //DVERSIO
			string sourceDGCURR = groupCurrency; 						 //DGCURR
			OLAPElementList sourceDGLEVEL = levels; 		  			//DGLEVEL
			string sourceDGROUP = group; 								 //DGROUP
			string sourceDSTAGE = ""Consolidated Segments"";				 //DSTAGE
			OLAPElementList sourceDCOMPC = companies; 					//DCOMPC
			OLAPElementList sourceDINTCO = interCompanies;				//DINTCO
			OLAPElementList sourceDPSEGM = segments; 		 			//DPSEGM
			OLAPElementList sourceDPRSEGM = segmentsPartner; 			 //DPRSEGM
			OLAPElementList sourceDSSEGM = secondarySegments; 			//DSSEGM
			OLAPElementList sourceDSRSEGM = secondarySegmentsPartner; 	//DSRSEGM
			OLAPElementList sourceDTSEGM = tertiarySegments;  			//DTSEGM
			OLAPElementList sourceDTRSEGM = tertiarySegmentsPartner; 	 //DTRSEGM
			OLAPElementList sourceDACOUNT = accounts; 					//DACOUNT
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cube1, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDGCURR, sourceDGLEVEL, sourceDGROUP, sourceDSTAGE, sourceDCOMPC, sourceDINTCO,
				sourceDPSEGM, sourceDPRSEGM, sourceDSSEGM, sourceDSRSEGM, sourceDTSEGM, sourceDTRSEGM, sourceDACOUNT
			);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cube1);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, ""DCOMPC"");
				interCompany = OLAPCellGetElement(cell, ""DINTCO"");
				segment = OLAPCellGetElement(cell, ""DPSEGM"");
				segmentPartner = OLAPCellGetElement(cell, ""DPRSEGM"");
				secondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
				secondarySegmentPartner = OLAPCellGetElement(cell, ""DSRSEGM"");
				tertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
				tertiarySegmentPartner = OLAPCellGetElement(cell, ""DTRSEGM"");
				account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				lookupKey = company + ""|"" + interCompany + ""|"" + segment + ""|"" + segmentPartner + ""|"" +
					secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + account;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection,cube1,1,
					                           OLAPCellGetElement(cell, ""BPDCYCLE""),
					                           OLAPCellGetElement(cell, ""DYEAR""),
					                           OLAPCellGetElement(cell, ""DPERIOD""),
					                           OLAPCellGetElement(cell, ""DVERSIO""),
					                           OLAPCellGetElement(cell, ""DGCURR""),
					                           consolidationBasis,
					                           OLAPCellGetElement(cell, ""DGROUP""),
					                           OLAPCellGetElement(cell, ""DSTAGE""),
					                           OLAPCellGetElement(cell, ""DCOMPC""),
					                           OLAPCellGetElement(cell, ""DINTCO""),
					                           OLAPCellGetElement(cell, ""DPSEGM""),
					                           OLAPCellGetElement(cell, ""DPRSEGM""),
					                           OLAPCellGetElement(cell, ""DSSEGM""),
					                           OLAPCellGetElement(cell, ""DSRSEGM""),
					                           OLAPCellGetElement(cell, ""DTSEGM""),
					                           OLAPCellGetElement(cell, ""DTRSEGM""),
					                           OLAPCellGetElement(cell, ""DACOUNT""));
					
					if (value != 0) {
						counter = counter + 1;
						
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						isAsset = CO_AccountType(olapConnection, acc) == ""Asset"";
						
						//store all opened journals by company/intercompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rulesList)
						{
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true or
							    CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								
								/*
								determine Elimination Element through dimension hierarchy
									
								direct elimination elements (under _CONSOL elements) are created without the _CONSOL part
								all other elimination elements are C-Element + _CONSOL
								
								-Germany
								  -Germany_ELIM
								  -MUC_CONSOL
								    -MUC_ELIM
								    -MUC
								  -HAN_CONSOL
								    -HAN_ELIM
								    -HAN
								 */
								
								//segment
								segmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DPSEGM"",
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segment),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentPartner),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentRoot));
								
								segmentElimination = segmentElimination + eliminationSuffix;
								
								//secondarySegment
								if (CO_HasSegment(olapConnection, cycle, 2)) {
									secondarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DSSEGM"",
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegment),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentPartner),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentRoot));
									
									secondarySegmentElimination = secondarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									secondarySegmentElimination = secondarySegment;
								}
								
								//tertiarySegment
								if (CO_HasSegment(olapConnection, cycle, 3)) {
									tertiarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DTSEGM"",
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegment),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentPartner),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentRoot));
									
									tertiarySegmentElimination = tertiarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									tertiarySegmentElimination = tertiarySegment;
								}
							}
							
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								lookupKey = company + ""|"" + interCompany + ""|"" +
									segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
									secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorAccount;
							}
							if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								//switch company/intercompany and segment/partnersegment for all 3 dims
								lookupKey = interCompany + ""|"" + company + ""|"" +
									segmentPartner + ""|"" + segment + ""|"" + segmentElimination + ""|"" +
									secondarySegmentPartner + ""|"" + secondarySegment + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorContraAccount;
							}
						}
						
						if (ContainsKey(groupSegmentJournalDictionary, lookupKey)) {
							//groupSegmentJournal for this combination exists already
							groupSegmentJournal = GetEntry(groupSegmentJournalDictionary, lookupKey);
						} else {
							//open a new groupSegmentJournal for this combination
							groupSegmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, segmentLevel, ruleid, ""ID &lt;"" + counter + ""&gt;"", true);
							AddEntry(groupSegmentJournalDictionary, lookupKey, groupSegmentJournal);
							
							
							//remember entries in a StringArray
							Append(dictionaryEntries,lookupKey);
						}
						
						/*  DACOUNT(DETAIL) -&gt; DDETPA
							DDETPA(TOP_ACC) -&gt; DDETAIL -&gt; all N Childs
							-&gt;DataArea TSEGMOVG */
						
						//determine if TSEGMOVG holds the values split up by DDETAIL - use them instead
						string accountDetail = cached OLAPGetStringAttribute(olapConnection, acc, ""DETAIL"");
						if (accountDetail != """") {
							//read values from TSEGMOVG
							//with Detail
							OLAPElement accDetail = OLAPGetDimensionElement(olapConnection, ""DDETPA"", accountDetail);
							
							OLAPElementList details = CO_ScheduleDetails(olapConnection, accDetail);//A1_CB
							
							OLAPDataArea sourceArea2 = OLAPCreateDataArea(
								olapConnection2, cube2, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
								OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
								OLAPCellGetElement(cell, ""BPDCYCLE""), OLAPCellGetElement(cell, ""DYEAR""), OLAPCellGetElement(cell, ""DPERIOD""), OLAPCellGetElement(cell, ""DVERSIO""),
								OLAPCellGetElement(cell, ""DGCURR""), consolidationBasis, OLAPCellGetElement(cell, ""DGROUP""),
								OLAPCellGetElement(cell, ""DSTAGE""), OLAPCellGetElement(cell, ""DCOMPC""), OLAPCellGetElement(cell, ""DINTCO""),
								OLAPCellGetElement(cell, ""DPSEGM""), OLAPCellGetElement(cell, ""DPRSEGM""),
								OLAPCellGetElement(cell, ""DSSEGM""), OLAPCellGetElement(cell, ""DSRSEGM""), OLAPCellGetElement(cell, ""DTSEGM""),
								OLAPCellGetElement(cell, ""DTRSEGM""), details, OLAPCellGetElement(cell, ""DACOUNT"")
							);
							
							foreach (OLAPCell cell2 in sourceArea2)
							{
								counter2 = counter2 + 1;
								
								detail = OLAPCellGetElement(cell2, ""DDETAIL"");
								value = cell2;
								
								transformedValue = value * factor;

								//add the groupSegmentJournal lines
								if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", Abs(transformedValue), 0.0);
									
									
								} else {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", 0.0, Abs(transformedValue));
									
								}
							}
						} else {
							//handle the value coming from TSEGMG
							//no Detail
							
							transformedValue = value * factor;

							//add the groupSegmentJournal lines
							if ((isAsset and transformedValue &lt; 0) or (!isAsset and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", Abs(transformedValue), 0.0);
								
								
							} else {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", 0.0, Abs(transformedValue));
								
								
							}
						}
					}
				}
			}
			
			NotifyInformation(""&lt;"" + cube1 + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			NotifyInformation(""&lt;"" + cube2 + ""&gt; processed &lt;"" + counter2 + ""&gt; value(s)"");
			
			//sort entries
			SortStringArray(dictionaryEntries);
			
			NotifyInformation(""sorted entries"");
			
			//loop all journals and post them
			counter = 0;
			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(groupSegmentJournalDictionary,entry);
				
				
				/*lookupKey = company + ""|"" + interCompany + ""|"" +
								segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
								secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
								tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
								consolidationRule;*/
				
				keyElements = StringSplit(entry,""|"");
				company = GetElementByIndex(keyElements,0);
				interCompany = GetElementByIndex(keyElements,1);
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0) {
					segment = GetElementByIndex(keyElements,2);
					segmentPartner = GetElementByIndex(keyElements,3);
					segmentElimination = GetElementByIndex(keyElements,4);
					
					secondarySegment = GetElementByIndex(keyElements,5);
					secondarySegmentPartner = GetElementByIndex(keyElements,6);
					secondarySegmentElimination = GetElementByIndex(keyElements,7);
					
					tertiarySegment = GetElementByIndex(keyElements,8);
					tertiarySegmentPartner = GetElementByIndex(keyElements,9);
					tertiarySegmentElimination = GetElementByIndex(keyElements,10);
					
					help = GetElementByIndex(keyElements,11);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, ""DCONSRL"", help);

					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					// check if value from TSTDTRANSACTSEGM is not null
					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    segment, segmentPartner,
					                    secondarySegment, secondarySegmentPartner,
					                    tertiarySegment, tertiarySegmentPartner,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     segment, segmentPartner,
						                                                     secondarySegment, secondarySegmentPartner,
						                                                     tertiarySegment, tertiarySegmentPartner,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						
						double stdDiffFx = difference - transactionsValue;

						string differenceAccountFX = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
						string differenceAccountFXDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccountOther = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceAccountOtherDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);
						
						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", difference, 0.0);

						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", 0.0, -difference);

						}
					}
				}
				
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					if (CO_ValidateGroupJournal(openJournal, true)) {
						ConsolidationPostJournal(journalStore, openJournal);
						counter = counter + 1;
					}
				}

			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}


		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetEliminationElement"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""SortStringArray"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_DebtsSegmentElim(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDebtsSegmentElim process. Hierarchical Consolidation of Debts with hierarchical segmentation."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HD"";
	cancel = false;*/

	string processName = ""CO_DebtsSegmentElim"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 =  OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore( olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			GroupJournalDictionary groupSegmentJournalDictionary = CreateGroupJournalDictionary();
			GroupJournal groupSegmentJournal = null;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double counter2 = 0;
			double value = 0;
			double transformedValue = 0;
			double factor = 0;
			string lookupKey = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string unassigned = ""Unassigned"";
			string segment = """";
			string segmentPartner = """";
			string secondarySegment = """";
			string secondarySegmentPartner = """";
			string tertiarySegment = """";
			string tertiarySegmentPartner = """";
			string segmentRoot = ""TOTAL"";
			string secondarySegmentRoot = ""TOTAL"";
			string tertiarySegmentRoot = ""TOTAL"";
			string account = """";
			string help = """";
			bool isAsset = false;
			double factorAccount = 0;
			double factorContraAccount = 0;
			string segmentLevel = ""Intersegment"";
			string eliminationSuffix = ""_Elim"";
			string segmentElimination = """";
			string secondarySegmentElimination = """";
			string tertiarySegmentElimination = """";
			string consolidationType = ""Cons. Debts"";
			
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, ""DGLEVEL"", consolidationBasis, true);
			
			//Companies
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList interCompanies = CreateOLAPElementList();
			
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle) where (
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Full"") or
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Quotal"")))
			{
				OLAPElementListAddElement(companies, sourceCompany);
				OLAPElementListAddElement(interCompanies, sourceCompany);
			}
			
			//segments (primary, secondary, tertiary)
			OLAPElementList segments = OLAPGetChildElementList(olapConnection, ""DPSEGM"", segmentRoot, true);
			OLAPElementList segmentsPartner = OLAPGetChildElementList(olapConnection, ""DPRSEGM"", segmentRoot, true);
			
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 2)) {
				secondarySegments = OLAPGetChildElementList(olapConnection, ""DSSEGM"", secondarySegmentRoot, true);
				secondarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DSRSEGM"", secondarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, ""DSSEGM"", ""-""));
				OLAPElementListAddElement(secondarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DSRSEGM"", ""-""));
			}
			
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 3)) {
				tertiarySegments = OLAPGetChildElementList(olapConnection, ""DTSEGM"", tertiarySegmentRoot, true);
				tertiarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DTRSEGM"", tertiarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, ""DTSEGM"", ""-""));
				OLAPElementListAddElement(tertiarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DTRSEGM"", ""-""));
			}

			//Accounts
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rulesList = CreateOLAPElementList();

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rulesList, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle))
			{
				foreach (OLAPElement consolidationRule in rulesList)
				{
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//Source Definition for TSEGMG
			string cube1 = ""TSEGMG"";
			string cube2 = ""TSEGMOVG"";
			string sourceDYEAR = year; 			  					 //DYEAR
			string sourceDPERIOD = period; 		  					 //DPERIOD
			string sourceDVERSIO = scenario; 							 //DVERSIO
			string sourceDGCURR = groupCurrency; 						 //DGCURR
			OLAPElementList sourceDGLEVEL = levels; 		  			//DGLEVEL
			string sourceDGROUP = group; 								 //DGROUP
			string sourceDSTAGE = ""Consolidated Segments"";				 //DSTAGE
			OLAPElementList sourceDCOMPC = companies; 					//DCOMPC
			OLAPElementList sourceDINTCO = interCompanies;				//DINTCO
			OLAPElementList sourceDPSEGM = segments; 		 			//DPSEGM
			OLAPElementList sourceDPRSEGM = segmentsPartner; 			 //DPRSEGM
			OLAPElementList sourceDSSEGM = secondarySegments; 			//DSSEGM
			OLAPElementList sourceDSRSEGM = secondarySegmentsPartner; 	//DSRSEGM
			OLAPElementList sourceDTSEGM = tertiarySegments;  			//DTSEGM
			OLAPElementList sourceDTRSEGM = tertiarySegmentsPartner; 	 //DTRSEGM
			OLAPElementList sourceDACOUNT = accounts; 					//DACOUNT
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cube1, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDGCURR, sourceDGLEVEL, sourceDGROUP, sourceDSTAGE, sourceDCOMPC, sourceDINTCO,
				sourceDPSEGM, sourceDPRSEGM, sourceDSSEGM, sourceDSRSEGM, sourceDTSEGM, sourceDTRSEGM, sourceDACOUNT
			);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cube1);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, ""DCOMPC"");
				interCompany = OLAPCellGetElement(cell, ""DINTCO"");
				segment = OLAPCellGetElement(cell, ""DPSEGM"");
				segmentPartner = OLAPCellGetElement(cell, ""DPRSEGM"");
				secondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
				secondarySegmentPartner = OLAPCellGetElement(cell, ""DSRSEGM"");
				tertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
				tertiarySegmentPartner = OLAPCellGetElement(cell, ""DTRSEGM"");
				account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				lookupKey = company + ""|"" + interCompany + ""|"" + segment + ""|"" + segmentPartner + ""|"" +
					secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + account;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection,cube1,1,
					                           OLAPCellGetElement(cell, ""BPDCYCLE""),
					                           OLAPCellGetElement(cell, ""DYEAR""),
					                           OLAPCellGetElement(cell, ""DPERIOD""),
					                           OLAPCellGetElement(cell, ""DVERSIO""),
					                           OLAPCellGetElement(cell, ""DGCURR""),
					                           consolidationBasis,
					                           OLAPCellGetElement(cell, ""DGROUP""),
					                           OLAPCellGetElement(cell, ""DSTAGE""),
					                           OLAPCellGetElement(cell, ""DCOMPC""),
					                           OLAPCellGetElement(cell, ""DINTCO""),
					                           OLAPCellGetElement(cell, ""DPSEGM""),
					                           OLAPCellGetElement(cell, ""DPRSEGM""),
					                           OLAPCellGetElement(cell, ""DSSEGM""),
					                           OLAPCellGetElement(cell, ""DSRSEGM""),
					                           OLAPCellGetElement(cell, ""DTSEGM""),
					                           OLAPCellGetElement(cell, ""DTRSEGM""),
					                           OLAPCellGetElement(cell, ""DACOUNT""));
					
					if (value != 0) {
						counter = counter + 1;
						
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						isAsset = CO_AccountType(olapConnection, acc) == ""Asset"";
						
						//store all opened journals by company/intercompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rulesList)
						{
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true or
							    CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								
								/*
								determine Elimination Element through dimension hierarchy
									
								direct elimination elements (under _CONSOL elements) are created without the _CONSOL part
								all other elimination elements are C-Element + _CONSOL
								
								-Germany
								  -Germany_ELIM
								  -MUC_CONSOL
								    -MUC_ELIM
								    -MUC
								  -HAN_CONSOL
								    -HAN_ELIM
								    -HAN
								 */
								
								//segment
								segmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DPSEGM"",
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segment),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentPartner),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentRoot));
								
								segmentElimination = segmentElimination + eliminationSuffix;
								
								//secondarySegment
								if (CO_HasSegment(olapConnection, cycle, 2)) {
									secondarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DSSEGM"",
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegment),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentPartner),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentRoot));
									
									secondarySegmentElimination = secondarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									secondarySegmentElimination = secondarySegment;
								}
								
								//tertiarySegment
								if (CO_HasSegment(olapConnection, cycle, 3)) {
									tertiarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DTSEGM"",
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegment),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentPartner),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentRoot));
									
									tertiarySegmentElimination = tertiarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									tertiarySegmentElimination = tertiarySegment;
								}
							}
							
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								lookupKey = company + ""|"" + interCompany + ""|"" +
									segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
									secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorAccount;
							}
							if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								//switch company/intercompany and segment/partnersegment for all 3 dims
								lookupKey = interCompany + ""|"" + company + ""|"" +
									segmentPartner + ""|"" + segment + ""|"" + segmentElimination + ""|"" +
									secondarySegmentPartner + ""|"" + secondarySegment + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorContraAccount;
							}
						}
						
						if (ContainsKey(groupSegmentJournalDictionary, lookupKey)) {
							//groupSegmentJournal for this combination exists already
							groupSegmentJournal = GetEntry(groupSegmentJournalDictionary, lookupKey);
						} else {
							//open a new groupSegmentJournal for this combination
							groupSegmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, segmentLevel, ruleid, ""ID <"" + counter + "">"", true);
							AddEntry(groupSegmentJournalDictionary, lookupKey, groupSegmentJournal);
							
							
							//remember entries in a StringArray
							Append(dictionaryEntries,lookupKey);
						}
						
						/*  DACOUNT(DETAIL) -> DDETPA
							DDETPA(TOP_ACC) -> DDETAIL -> all N Childs
							->DataArea TSEGMOVG */
						
						//determine if TSEGMOVG holds the values split up by DDETAIL - use them instead
						string accountDetail = cached OLAPGetStringAttribute(olapConnection, acc, ""DETAIL"");
						if (accountDetail != """") {
							//read values from TSEGMOVG
							//with Detail
							OLAPElement accDetail = OLAPGetDimensionElement(olapConnection, ""DDETPA"", accountDetail);
							
							OLAPElementList details = CO_ScheduleDetails(olapConnection, accDetail);//A1_CB
							
							OLAPDataArea sourceArea2 = OLAPCreateDataArea(
								olapConnection2, cube2, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
								OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
								OLAPCellGetElement(cell, ""BPDCYCLE""), OLAPCellGetElement(cell, ""DYEAR""), OLAPCellGetElement(cell, ""DPERIOD""), OLAPCellGetElement(cell, ""DVERSIO""),
								OLAPCellGetElement(cell, ""DGCURR""), consolidationBasis, OLAPCellGetElement(cell, ""DGROUP""),
								OLAPCellGetElement(cell, ""DSTAGE""), OLAPCellGetElement(cell, ""DCOMPC""), OLAPCellGetElement(cell, ""DINTCO""),
								OLAPCellGetElement(cell, ""DPSEGM""), OLAPCellGetElement(cell, ""DPRSEGM""),
								OLAPCellGetElement(cell, ""DSSEGM""), OLAPCellGetElement(cell, ""DSRSEGM""), OLAPCellGetElement(cell, ""DTSEGM""),
								OLAPCellGetElement(cell, ""DTRSEGM""), details, OLAPCellGetElement(cell, ""DACOUNT"")
							);
							
							foreach (OLAPCell cell2 in sourceArea2)
							{
								counter2 = counter2 + 1;
								
								detail = OLAPCellGetElement(cell2, ""DDETAIL"");
								value = cell2;
								
								transformedValue = value * factor;

								//add the groupSegmentJournal lines
								if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", Abs(transformedValue), 0.0);
									
									
								} else {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", 0.0, Abs(transformedValue));
									
								}
							}
						} else {
							//handle the value coming from TSEGMG
							//no Detail
							
							transformedValue = value * factor;

							//add the groupSegmentJournal lines
							if ((isAsset and transformedValue < 0) or (!isAsset and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", Abs(transformedValue), 0.0);
								
								
							} else {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", 0.0, Abs(transformedValue));
								
								
							}
						}
					}
				}
			}
			
			NotifyInformation(""<"" + cube1 + ""> processed <"" + counter + ""> value(s)"");
			NotifyInformation(""<"" + cube2 + ""> processed <"" + counter2 + ""> value(s)"");
			
			//sort entries
			SortStringArray(dictionaryEntries);
			
			NotifyInformation(""sorted entries"");
			
			//loop all journals and post them
			counter = 0;
			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(groupSegmentJournalDictionary,entry);
				
				
				/*lookupKey = company + ""|"" + interCompany + ""|"" +
								segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
								secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
								tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
								consolidationRule;*/
				
				keyElements = StringSplit(entry,""|"");
				company = GetElementByIndex(keyElements,0);
				interCompany = GetElementByIndex(keyElements,1);
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0) {
					segment = GetElementByIndex(keyElements,2);
					segmentPartner = GetElementByIndex(keyElements,3);
					segmentElimination = GetElementByIndex(keyElements,4);
					
					secondarySegment = GetElementByIndex(keyElements,5);
					secondarySegmentPartner = GetElementByIndex(keyElements,6);
					secondarySegmentElimination = GetElementByIndex(keyElements,7);
					
					tertiarySegment = GetElementByIndex(keyElements,8);
					tertiarySegmentPartner = GetElementByIndex(keyElements,9);
					tertiarySegmentElimination = GetElementByIndex(keyElements,10);
					
					help = GetElementByIndex(keyElements,11);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, ""DCONSRL"", help);

					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					// check if value from TSTDTRANSACTSEGM is not null
					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    segment, segmentPartner,
					                    secondarySegment, secondarySegmentPartner,
					                    tertiarySegment, tertiarySegmentPartner,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						
						double transactionsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     segment, segmentPartner,
						                                                     secondarySegment, secondarySegmentPartner,
						                                                     tertiarySegment, tertiarySegmentPartner,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						
						double stdDiffFx = difference - transactionsValue;

						string differenceAccountFX = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
						string differenceAccountFXDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", stdDiffFx, 0.0);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", 0.0, -stdDiffFx);
							}
							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccountOther = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceAccountOtherDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);
						
						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", difference, 0.0);

						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", 0.0, -difference);

						}
					}
				}
				
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					if (CO_ValidateGroupJournal(openJournal, true)) {
						ConsolidationPostJournal(journalStore, openJournal);
						counter = counter + 1;
					}
				}

			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}


		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	C3DD1BED-A3AF-40CC-B7FA-AF542DE6FF6B	Former FCDebtsSegmentElim process. Hierarchical Consolidation of Debts with hierarchical segmentation.	1	1	1	1676	NULL	0	45708.67507	0	0
7E66708E-37ED-42C9-BD0D-3A6E6E7D065B	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DeleteCFParameterConfiguration	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful. Othevise error Code"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycleUN"" parameter-type=""string"" parameter-description=""The configuration set element UN to be used."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""yearUN"" parameter-type=""string"" parameter-description=""The year element UN to be used."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""monthUN"" parameter-type=""string"" parameter-description=""The month element UN to be used."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenarioUN"" parameter-type=""string"" parameter-description=""The  element to be used."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""CFAccountUN"" parameter-type=""string"" parameter-description=""The Cash Flow account element to be used."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_DeleteCFParameterConfiguration(string server, string cycleUN, string yearUN,string monthUN, string scenarioUN, string CFAccountUN)
@Description: ""Delete setting for given CFAccount in given context cycle/year/month/scenario"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycleUN]: ""The configuration set element UN to be used."";
@Parameter[yearUN]: ""The year element UN to be used."";
@Parameter[monthUN]: ""The month element UN to be used."";
@Parameter[scenarioUN]: ""The  element to be used."";
@Parameter[CFAccountUN]: ""The Cash Flow account element to be used."";
@Returns: ""True, if successful. Othevise error Code"";
{
	string functionName = ""CO_DeleteCFParameterConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;
	string CFConfigCube = ""TSTDCASHCFG"";
	string result="""";
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		
		string cycle = ResolveUniqueName(connection, cycleUN);
		string year = ResolveUniqueName(connection, yearUN);
		string month = ResolveUniqueName(connection, monthUN);
		string scenario = ResolveUniqueName(connection, scenarioUN);
		string CFAccount = ResolveUniqueName(connection, CFAccountUN);


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, CFConfigCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             cycle, year, month, scenario, OlapDataAreaAllCells, OlapDataAreaAllCells, CFAccount, OlapDataAreaAllCells);

		OLAPDeleteDataArea(TargetData);

		result=""true"";
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_DeleteCFParameterConfiguration(string server, string cycleUN, string yearUN,string monthUN, string scenarioUN, string CFAccountUN)
@Description: ""Delete setting for given CFAccount in given context cycle/year/month/scenario"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycleUN]: ""The configuration set element UN to be used."";
@Parameter[yearUN]: ""The year element UN to be used."";
@Parameter[monthUN]: ""The month element UN to be used."";
@Parameter[scenarioUN]: ""The  element to be used."";
@Parameter[CFAccountUN]: ""The Cash Flow account element to be used."";
@Returns: ""True, if successful. Othevise error Code"";
{
	string functionName = ""CO_DeleteCFParameterConfiguration:"";
	string errorMessage = """";
	int errorCode = 0;
	string CFConfigCube = ""TSTDCASHCFG"";
	string result="""";
	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		
		string cycle = ResolveUniqueName(connection, cycleUN);
		string year = ResolveUniqueName(connection, yearUN);
		string month = ResolveUniqueName(connection, monthUN);
		string scenario = ResolveUniqueName(connection, scenarioUN);
		string CFAccount = ResolveUniqueName(connection, CFAccountUN);


		OLAPDataArea TargetData = OLAPCreateDataArea(connection, CFConfigCube,
		                                             OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0,
		                                             OlapDataAreaOperatorNone, 0.0,
		                                             cycle, year, month, scenario, OlapDataAreaAllCells, OlapDataAreaAllCells, CFAccount, OlapDataAreaAllCells);

		OLAPDeleteDataArea(TargetData);

		result=""true"";
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	78EA14EA-6F0D-4D4C-89E5-8F418180850C	Delete setting for given CFAccount in given context cycle/year/month/scenario	1	1	1	1677	NULL	0	45708.67503	0	0
5F1E9A4E-B6CF-43E9-9D95-E1DADEEE5D49	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DeleteUGElement	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""True, if successful."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP database to interact with in the form database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""element"" parameter-type=""string"" parameter-description=""The dimension where element should be deleted."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_DeleteUGElement(string server, string element)
@Description: ""Delete given custom UG element or all custom elements below in case of C element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[element]: ""The dimension where element should be deleted."";
@Returns: ""True, if successful."";
{
	string functionName = ""CO_DeleteUGElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	string ugDimension = ""DUSERGUIDANCE"";
	bool deleteElement = false;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//element =""[DUSERGUIDANCE].[CST_LINK_002].[1]"";
		element = ResolveUniqueName(connection , element);

		OLAPElement UGTElement = OLAPGetDimensionElement(connection, ugDimension, element);
		bool isBaseElement = OLAPIsBaseElement(connection, UGTElement);
		if(isBaseElement)
		{
			if(element.Contains(""CST_""))
			{
				deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, element);
			}
		}
		else
		{
			OLAPElementList ugElementList = OLAPGetChildElementList(connection, ugDimension, element, false);
			StringList ugStringList = ToStringList(ugElementList);
			bool delete =true;
			foreach(string el in ugStringList)
			{
				if(!el.Contains(""CST_""))
				{
					delete =false;
				}
			}
			if(delete)
			{
				foreach(string el in ugStringList)
				{
					deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, el);
				}
				deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, element);
			}
		}
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_DeleteUGElement(string server, string element)
@Description: ""Delete given custom UG element or all custom elements below in case of C element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP database to interact with in the form database"";
@Parameter[element]: ""The dimension where element should be deleted."";
@Returns: ""True, if successful."";
{
	string functionName = ""CO_DeleteUGElement: "";
	string errorMessage = """";
	int errorCode = 0;
	string newElement = """";
	string ugDimension = ""DUSERGUIDANCE"";
	bool deleteElement = false;
	try
	{
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//element =""[DUSERGUIDANCE].[CST_LINK_002].[1]"";
		element = ResolveUniqueName(connection , element);

		OLAPElement UGTElement = OLAPGetDimensionElement(connection, ugDimension, element);
		bool isBaseElement = OLAPIsBaseElement(connection, UGTElement);
		if(isBaseElement)
		{
			if(element.Contains(""CST_""))
			{
				deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, element);
			}
		}
		else
		{
			OLAPElementList ugElementList = OLAPGetChildElementList(connection, ugDimension, element, false);
			StringList ugStringList = ToStringList(ugElementList);
			bool delete =true;
			foreach(string el in ugStringList)
			{
				if(!el.Contains(""CST_""))
				{
					delete =false;
				}
			}
			if(delete)
			{
				foreach(string el in ugStringList)
				{
					deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, el);
				}
				deleteElement = OLAPDeleteDimensionElement(connection,ugDimension, element);
			}
		}
		return ""true"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		string result = """";
		return result;
	}
}"	1	19846741-5C45-4292-B5B5-2BB314BAFC33	Delete given custom UG element or all custom elements below in case of C element	1	1	1	1678	NULL	0	45708.67503	0	0
A760425D-800B-4BC2-8D7A-2E16B2F2576A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DifferenceSide	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""int"" return-value-description=""The Difference Side setting of the process."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""process"" parameter-type=""OLAPElement"" parameter-description=""The process to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""bookingType"" parameter-type=""int"" parameter-description=""The booking type of the process."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

int CO_DifferenceSide(OLAPConnection connection, string configurationSet, OLAPElement process, int bookingType)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the consolidation difference side setting of the specified process."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[process]: ""The process to query."";
@Parameter[bookingType]: ""The booking type of the process."";
@Returns: ""The Difference Side setting of the process."";
{
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	OLAPElement parent = parentElements[0];

	int differenceSide = cached OLAPGetIntAttribute(connection, parent, ""DifferenceSide"");

	bool isValid =
		(bookingType == 1 and (differenceSide == 2 or differenceSide == 3)) or
		(bookingType == 2 and (differenceSide == 0 or differenceSide == 1 or differenceSide == 2 or differenceSide == 3));

	if (isValid)
	{
		return differenceSide;
	}
	else
	{
		RaiseError(""Invalid setting for Target for Differences"", 0);
		return -1;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

int CO_DifferenceSide(OLAPConnection connection, string configurationSet, OLAPElement process, int bookingType)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the consolidation difference side setting of the specified process."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[process]: ""The process to query."";
@Parameter[bookingType]: ""The booking type of the process."";
@Returns: ""The Difference Side setting of the process."";
{
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	OLAPElement parent = parentElements[0];

	int differenceSide = cached OLAPGetIntAttribute(connection, parent, ""DifferenceSide"");

	bool isValid =
		(bookingType == 1 and (differenceSide == 2 or differenceSide == 3)) or
		(bookingType == 2 and (differenceSide == 0 or differenceSide == 1 or differenceSide == 2 or differenceSide == 3));

	if (isValid)
	{
		return differenceSide;
	}
	else
	{
		RaiseError(""Invalid setting for Target for Differences"", 0);
		return -1;
	}
}"	1	7E7E7CBA-F4D6-4BDE-80C6-AA995DBCF199	Gets the consolidation difference side setting of the specified process.	1	1	1	1679	NULL	0	45708.67506	0	0
8602E6C7-2957-4E1A-A049-3421D06C0EC3	CD491758-D9DF-4002-94C8-8006E1855F86	CO_DirectAndIndirectMinorities	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ScheduleDetails"" process-version=""*"" process-id="""" />
    <process process-name=""CO_MinoritiesAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_MinorityDirect"" process-version=""*"" process-id="""" />
    <process process-name=""CO_MinorityIndirect"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Accounts"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""CO_MinoritiesAccount"", ""*""
#include ""CO_MinorityDirect"", ""*""
#include ""CO_MinorityIndirect"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""CO_GetProcessProperty"", ""*""

bool CO_DirectAndIndirectMinorities(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDirectMinorities and FCIndirectMinorities process. This process defines the capital consolidation process to post the direct and indirect minorities."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""C2"";
	cancel = false;*/
	
	string processName = ""CO_DirectAndIndirectMinorities"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for cycle&lt;"" + cycle + ""&gt; year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			double counter1 = 0;
			double counter2 = 0;
			string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationType = ""Cons. Capital"";

			OLAPElementList accountsWithSegmentation = CreateOLAPElementList();
			string ACCTYPE_ASSET_VALUE = ""A"";
			string CONSMETHOD_FULL = ""Full"";
			string TDETAIG = ""TDETAIG"";
			string TFINANG = ""TFINANG"";
			string TSEGMOVG = ""TSEGMOVG"";
			string TSEGMG = ""TSEGMG"";
			string ELEM_SUM = ""Sum"";
			string DDETPA = ""DDETPA"";
			string DACOUNT = ""DACOUNT"";
			string DCOMPC = ""DCOMPC"";
			string DDETAIL = ""DDETAIL"";
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournalDictionary segmentJournalDictionary = CreateGroupJournalDictionary();

			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);

			string balanceSheetProfitLoss = CO_TopAccount(olapConnection, cycle, 4);	// BS Profit/Loss

			string generateSegmentJournalsString = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Generate Segment Journals"");
			bool generateSegmentLines = generateSegmentJournalsString == ""0"";

			OLAPElementList companies = CreateOLAPElementList();
			DoubleDictionary minorityDirectDictionary = CreateDoubleDictionary();
			DoubleDictionary minorityIndirectDictionary = CreateDoubleDictionary();

			foreach(OLAPElement company in CO_Companies(olapConnection, cycle)
			        where (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == CONSMETHOD_FULL))
			{
				double minDirect = CO_MinorityDirect(olapConnection, cycle, year, period, scenario, group, company, company);
				double minIndirect = CO_MinorityIndirect(olapConnection,cycle, year, period, scenario, group, company, company);

				if (minDirect + minIndirect &gt; 0)
				{
					OLAPElementListAddElement(companies, company);
					minorityDirectDictionary[company] = minDirect;
					minorityIndirectDictionary[company] = minIndirect;
				}
			}

			OLAPElementList accounts = CreateOLAPElementList();
			foreach(OLAPElement account in CO_Accounts(olapConnection, cycle) where (account != balanceSheetProfitLoss) and (CO_MinoritiesAccount(olapConnection, account) != """"))
			{
				OLAPElementListAddElement(accounts, account);
			}

			StringList attributes = CreateStringList();
			attributes.Append(""DETAIL"");
			attributes.Append(""ALRE"");
			attributes.Append(""Seg1"");
			attributes.Append(""Seg2"");
			attributes.Append(""Seg3"");

			StringListList accountAttributes = OLAPGetElementsAttributesValues(olapConnection, DACOUNT, DACOUNT, accounts, attributes);
			StringDictionary accountTypes = CreateStringDictionary();
			StringDictionary accountDetailsAttr = CreateStringDictionary();
			StringArray accountsWithDetailsWithoutSegments = CreateStringArray();		// TDETAIG
			StringArray accountsWithDetailsWithSegments = CreateStringArray(); 		// TSEGMOVG
			StringArray accountsWithoutDetailsWithoutSegments = CreateStringArray();	// TFINANG
			StringArray accountsWithoutDetailsWithSegments = CreateStringArray(); 	// TSEGMG

			int index = 0;
			foreach(OLAPElement account in accounts)
			{
				string accountStr = account.ToString();
				string detail = accountAttributes[index].GetElementByIndex(0);
				string acctType = accountAttributes[index].GetElementByIndex(1);
				string seg1 = accountAttributes[index].GetElementByIndex(2);
				string seg2 = accountAttributes[index].GetElementByIndex(3);
				string seg3 = accountAttributes[index].GetElementByIndex(4);
				bool hasSegment = seg1 == ""Y"" or seg2 == ""Y"" or seg3 == ""Y"";

				accountDetailsAttr[accountStr] = detail;
				accountTypes[accountStr] = acctType;

				if(detail == """")
				{
					if (hasSegment) {
						accountsWithoutDetailsWithSegments.Append(accountStr);	// TSEGMG
					}
					else {
						accountsWithoutDetailsWithoutSegments.Append(accountStr); // TFINANG
					}
				}
				else
				{
					if (hasSegment) {
						accountsWithDetailsWithSegments.Append(accountStr); // TSEGMOVG
					}
					else {
						accountsWithDetailsWithoutSegments.Append(accountStr); // TDETAIG
					}
				}
				index = index + 1;
			}

			if (Count(companies) &gt; 0)
			{
				if(accountsWithDetailsWithoutSegments.Count() &gt; 0)
				{
					// check cells from TDETAIG
					OLAPDataArea detailData = OLAPCreateDataArea(
						olapConnection, TDETAIG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						cycle, year, period, scenario, groupcurrency, consolidationBasis,
						group, companies, ELEM_SUM, OlapDataAreaBCells, accountsWithDetailsWithoutSegments.ConvertToStringList()
					);

					foreach (OLAPCell detailCell in detailData)
					{
						double cellValue = detailCell;
						
						if (cellValue != 0)
						{
							GroupJournal journal = null;
							string account = OLAPCellGetElement(detailCell, DACOUNT);
							string company = OLAPCellGetElement(detailCell, DCOMPC);
							string detail = OLAPCellGetElement(detailCell, DDETAIL);
							OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

							string accountDetailStr = accountDetailsAttr[account];
							OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
							OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

							if (accountScheduleDetails.ElementListContainsElement(detail))
							{
								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								string journalKey = company;
								if (ContainsKey(journalDictionary, company))
								{
									journal = GetEntry(journalDictionary, journalKey);
								}
								else
								{
									journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
									AddEntry(journalDictionary, journalKey, journal);
								}

								double minDirect = minorityDirectDictionary[company];
								double minIndirect = minorityIndirectDictionary[company];

								// handle direct minorities
								double calcValue = cellValue * minDirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0))
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", account, detail, """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", 0.0, Abs(calcValue));
									}
									else
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", account, detail, """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", Abs(calcValue), 0.0);
									}
								}

								// handle indirect minorities
								calcValue = cellValue * minIndirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
										ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, detail, """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", 0.0, Abs(calcValue));
									}
									else
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, detail, """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", Abs(calcValue), 0.0);
									}
								}
							}
						}
					}
				}

				if(accountsWithoutDetailsWithoutSegments.Count() &gt; 0)
				{
					// check cells from TFINANG
					OLAPDataArea finData = OLAPCreateDataArea(
						olapConnection, TFINANG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						cycle, year, period, scenario, groupcurrency, consolidationBasis,
						group, companies, ELEM_SUM, accountsWithoutDetailsWithoutSegments.ConvertToStringList()
					);

					foreach (OLAPCell finCell in finData)
					{
						double cellValue = finCell;
						
						if (cellValue != 0)
						{
							GroupJournal journal = null;
							string account = OLAPCellGetElement(finCell, DACOUNT);
							string company = OLAPCellGetElement(finCell, DCOMPC);

							OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);
							
							bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

							string journalKey = company;
							if (ContainsKey(journalDictionary, company))
							{
								journal = GetEntry(journalDictionary, journalKey);
							}
							else
							{
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, journalKey, journal);
							}

							double minDirect = minorityDirectDictionary[company];
							double minIndirect = minorityIndirectDictionary[company];

							// handle direct minorities
							double calcValue = cellValue * minDirect;
							if (calcValue != 0)
							{

								if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0))
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", Abs(calcValue), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", 0.0, Abs(calcValue));
								}
								else
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", 0.0, Abs(calcValue));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", Abs(calcValue), 0.0);
								}
							}

							// handle indirect minorities
							calcValue = cellValue * minIndirect;
							if (calcValue != 0)
							{
								if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", Abs(calcValue), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", 0.0, Abs(calcValue));
								}
								else
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", 0.0, Abs(calcValue));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", Abs(calcValue), 0.0);
								}
							}
						}
					}
				}

				foreach(string journalKey in journalDictionary.Keys())
				{
					GroupJournal journal = journalDictionary.GetEntry(journalKey);
					if (!ConsolidationJournalIsEmpty(journal)) {
						if (ConsolidationJournalIsBalanced(journal)) {
							ConsolidationPostJournal(journalStore, journal);
							counter1 = counter1 + 1;
						} else {
							WriteLine(""The journal was not posted as it was unbalanced."");
						}
					}
				}

				if (generateSegmentLines)
				{
					if (accountsWithDetailsWithSegments.Count() &gt; 0)
					{
						// check cells from TSEGMOVG
						OLAPDataArea segmentDetailData = OLAPCreateDataArea(
							olapConnection, TSEGMOVG, OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBasis,
							group, ""Consolidated Segments"", companies, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, accountsWithDetailsWithSegments.ConvertToStringList()
						);

						foreach (OLAPCell segDetailCell in segmentDetailData)
						{
							double cellValue = segDetailCell;

							if (cellValue != 0)
							{
								GroupJournal segmentJournal = null;
								string account = OLAPCellGetElement(segDetailCell, DACOUNT);
								string company = OLAPCellGetElement(segDetailCell, DCOMPC);
								string detail = OLAPCellGetElement(segDetailCell, DDETAIL);

								string accountDetailStr = accountDetailsAttr[account];
								OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
								OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

								if (accountScheduleDetails.ElementListContainsElement(detail))
								{
									string pPrimarySegment = OLAPCellGetElement(segDetailCell, ""DPSEGM"");
									string pSecondarySegment = OLAPCellGetElement(segDetailCell, ""DSSEGM"");
									string pTertiarySegment = OLAPCellGetElement(segDetailCell, ""DTSEGM"");

									bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

									string journalKey = company;
									if (ContainsKey(segmentJournalDictionary, company))
									{
										segmentJournal = GetEntry(segmentJournalDictionary, journalKey);
									}
									else
									{
										segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
										AddEntry(segmentJournalDictionary, journalKey, segmentJournal);
									}

									OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

									double minDirect = minorityDirectDictionary[company];
									double minIndirect = minorityIndirectDictionary[company];

									// handle direct minorities
									double calcValue = cellValue * minDirect;
									if (calcValue != 0)
									{

										if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										} else {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										}
									}

									// handle indirect minorities
									calcValue = cellValue * minIndirect;
									if (calcValue != 0)
									{
										if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										} else {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										}
									}

								}
							}
						}
					}
					if(accountsWithoutDetailsWithSegments.Count() &gt; 0)
					{
						// check cells from TSEGMG
						OLAPDataArea segmentData = OLAPCreateDataArea(
							olapConnection, TSEGMG, OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBasis,
							group, ""Consolidated Segments"", companies, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", accountsWithoutDetailsWithSegments.ConvertToStringList()
						);

						foreach (OLAPCell segmentCell in segmentData)
						{
							double cellValue = segmentCell;

							if (cellValue != 0)
							{
								GroupJournal segmentJournal = null;
								string account = OLAPCellGetElement(segmentCell, DACOUNT);
								string company = OLAPCellGetElement(segmentCell, DCOMPC);

								string pPrimarySegment = OLAPCellGetElement(segmentCell, ""DPSEGM"");
								string pSecondarySegment = OLAPCellGetElement(segmentCell, ""DSSEGM"");
								string pTertiarySegment = OLAPCellGetElement(segmentCell, ""DTSEGM"");

								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								string journalKey = company;
								if (ContainsKey(segmentJournalDictionary, company))
								{
									segmentJournal = GetEntry(segmentJournalDictionary, journalKey);
								}
								else
								{
									segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
									AddEntry(segmentJournalDictionary, journalKey, segmentJournal);
								}

								OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

								double minDirect = minorityDirectDictionary[company];
								double minIndirect = minorityIndirectDictionary[company];

								// handle direct minorities
								double calcValue = cellValue * minDirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
									} else {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
									}
								}

								// handle indirect minorities
								calcValue = cellValue * minIndirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue &lt; 0) or (!isAsset and calcValue &gt; 0)) {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
									} else {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
									}
								}
							}
						}
					}

					foreach(string journalKey in segmentJournalDictionary.Keys())
					{
						GroupJournal journal = segmentJournalDictionary.GetEntry(journalKey);
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter2 = counter2 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
			}

			WriteLine(""posted &lt;"" + counter1 + ""&gt; group journal(s)"");
			WriteLine(""posted &lt;"" + counter2 + ""&gt; group segment journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Accounts"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""CO_MinoritiesAccount"", ""*""
#include ""CO_MinorityDirect"", ""*""
#include ""CO_MinorityIndirect"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""CO_GetProcessProperty"", ""*""

bool CO_DirectAndIndirectMinorities(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCDirectMinorities and FCIndirectMinorities process. This process defines the capital consolidation process to post the direct and indirect minorities."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""C2"";
	cancel = false;*/
	
	string processName = ""CO_DirectAndIndirectMinorities"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for cycle<"" + cycle + ""> year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			double counter1 = 0;
			double counter2 = 0;
			string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationType = ""Cons. Capital"";

			OLAPElementList accountsWithSegmentation = CreateOLAPElementList();
			string ACCTYPE_ASSET_VALUE = ""A"";
			string CONSMETHOD_FULL = ""Full"";
			string TDETAIG = ""TDETAIG"";
			string TFINANG = ""TFINANG"";
			string TSEGMOVG = ""TSEGMOVG"";
			string TSEGMG = ""TSEGMG"";
			string ELEM_SUM = ""Sum"";
			string DDETPA = ""DDETPA"";
			string DACOUNT = ""DACOUNT"";
			string DCOMPC = ""DCOMPC"";
			string DDETAIL = ""DDETAIL"";
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournalDictionary segmentJournalDictionary = CreateGroupJournalDictionary();

			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);

			string balanceSheetProfitLoss = CO_TopAccount(olapConnection, cycle, 4);	// BS Profit/Loss

			string generateSegmentJournalsString = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Generate Segment Journals"");
			bool generateSegmentLines = generateSegmentJournalsString == ""0"";

			OLAPElementList companies = CreateOLAPElementList();
			DoubleDictionary minorityDirectDictionary = CreateDoubleDictionary();
			DoubleDictionary minorityIndirectDictionary = CreateDoubleDictionary();

			foreach(OLAPElement company in CO_Companies(olapConnection, cycle)
			        where (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == CONSMETHOD_FULL))
			{
				double minDirect = CO_MinorityDirect(olapConnection, cycle, year, period, scenario, group, company, company);
				double minIndirect = CO_MinorityIndirect(olapConnection,cycle, year, period, scenario, group, company, company);

				if (minDirect + minIndirect > 0)
				{
					OLAPElementListAddElement(companies, company);
					minorityDirectDictionary[company] = minDirect;
					minorityIndirectDictionary[company] = minIndirect;
				}
			}

			OLAPElementList accounts = CreateOLAPElementList();
			foreach(OLAPElement account in CO_Accounts(olapConnection, cycle) where (account != balanceSheetProfitLoss) and (CO_MinoritiesAccount(olapConnection, account) != """"))
			{
				OLAPElementListAddElement(accounts, account);
			}

			StringList attributes = CreateStringList();
			attributes.Append(""DETAIL"");
			attributes.Append(""ALRE"");
			attributes.Append(""Seg1"");
			attributes.Append(""Seg2"");
			attributes.Append(""Seg3"");

			StringListList accountAttributes = OLAPGetElementsAttributesValues(olapConnection, DACOUNT, DACOUNT, accounts, attributes);
			StringDictionary accountTypes = CreateStringDictionary();
			StringDictionary accountDetailsAttr = CreateStringDictionary();
			StringArray accountsWithDetailsWithoutSegments = CreateStringArray();		// TDETAIG
			StringArray accountsWithDetailsWithSegments = CreateStringArray(); 		// TSEGMOVG
			StringArray accountsWithoutDetailsWithoutSegments = CreateStringArray();	// TFINANG
			StringArray accountsWithoutDetailsWithSegments = CreateStringArray(); 	// TSEGMG

			int index = 0;
			foreach(OLAPElement account in accounts)
			{
				string accountStr = account.ToString();
				string detail = accountAttributes[index].GetElementByIndex(0);
				string acctType = accountAttributes[index].GetElementByIndex(1);
				string seg1 = accountAttributes[index].GetElementByIndex(2);
				string seg2 = accountAttributes[index].GetElementByIndex(3);
				string seg3 = accountAttributes[index].GetElementByIndex(4);
				bool hasSegment = seg1 == ""Y"" or seg2 == ""Y"" or seg3 == ""Y"";

				accountDetailsAttr[accountStr] = detail;
				accountTypes[accountStr] = acctType;

				if(detail == """")
				{
					if (hasSegment) {
						accountsWithoutDetailsWithSegments.Append(accountStr);	// TSEGMG
					}
					else {
						accountsWithoutDetailsWithoutSegments.Append(accountStr); // TFINANG
					}
				}
				else
				{
					if (hasSegment) {
						accountsWithDetailsWithSegments.Append(accountStr); // TSEGMOVG
					}
					else {
						accountsWithDetailsWithoutSegments.Append(accountStr); // TDETAIG
					}
				}
				index = index + 1;
			}

			if (Count(companies) > 0)
			{
				if(accountsWithDetailsWithoutSegments.Count() > 0)
				{
					// check cells from TDETAIG
					OLAPDataArea detailData = OLAPCreateDataArea(
						olapConnection, TDETAIG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						cycle, year, period, scenario, groupcurrency, consolidationBasis,
						group, companies, ELEM_SUM, OlapDataAreaBCells, accountsWithDetailsWithoutSegments.ConvertToStringList()
					);

					foreach (OLAPCell detailCell in detailData)
					{
						double cellValue = detailCell;
						
						if (cellValue != 0)
						{
							GroupJournal journal = null;
							string account = OLAPCellGetElement(detailCell, DACOUNT);
							string company = OLAPCellGetElement(detailCell, DCOMPC);
							string detail = OLAPCellGetElement(detailCell, DDETAIL);
							OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

							string accountDetailStr = accountDetailsAttr[account];
							OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
							OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

							if (accountScheduleDetails.ElementListContainsElement(detail))
							{
								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								string journalKey = company;
								if (ContainsKey(journalDictionary, company))
								{
									journal = GetEntry(journalDictionary, journalKey);
								}
								else
								{
									journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
									AddEntry(journalDictionary, journalKey, journal);
								}

								double minDirect = minorityDirectDictionary[company];
								double minIndirect = minorityIndirectDictionary[company];

								// handle direct minorities
								double calcValue = cellValue * minDirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0))
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", account, detail, """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", 0.0, Abs(calcValue));
									}
									else
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", account, detail, """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", Abs(calcValue), 0.0);
									}
								}

								// handle indirect minorities
								calcValue = cellValue * minIndirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
										ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, detail, """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", 0.0, Abs(calcValue));
									}
									else
									{
										ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, detail, """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail, """", Abs(calcValue), 0.0);
									}
								}
							}
						}
					}
				}

				if(accountsWithoutDetailsWithoutSegments.Count() > 0)
				{
					// check cells from TFINANG
					OLAPDataArea finData = OLAPCreateDataArea(
						olapConnection, TFINANG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						cycle, year, period, scenario, groupcurrency, consolidationBasis,
						group, companies, ELEM_SUM, accountsWithoutDetailsWithoutSegments.ConvertToStringList()
					);

					foreach (OLAPCell finCell in finData)
					{
						double cellValue = finCell;
						
						if (cellValue != 0)
						{
							GroupJournal journal = null;
							string account = OLAPCellGetElement(finCell, DACOUNT);
							string company = OLAPCellGetElement(finCell, DCOMPC);

							OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);
							
							bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

							string journalKey = company;
							if (ContainsKey(journalDictionary, company))
							{
								journal = GetEntry(journalDictionary, journalKey);
							}
							else
							{
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, journalKey, journal);
							}

							double minDirect = minorityDirectDictionary[company];
							double minIndirect = minorityIndirectDictionary[company];

							// handle direct minorities
							double calcValue = cellValue * minDirect;
							if (calcValue != 0)
							{

								if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0))
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", Abs(calcValue), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", 0.0, Abs(calcValue));
								}
								else
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", 0.0, Abs(calcValue));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", Abs(calcValue), 0.0);
								}
							}

							// handle indirect minorities
							calcValue = cellValue * minIndirect;
							if (calcValue != 0)
							{
								if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", Abs(calcValue), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", 0.0, Abs(calcValue));
								}
								else
								{
									ConsolidationAddGroupJournalLine(journal, company, ""External"", accountEl, """", """", 0.0, Abs(calcValue));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """", """", Abs(calcValue), 0.0);
								}
							}
						}
					}
				}

				foreach(string journalKey in journalDictionary.Keys())
				{
					GroupJournal journal = journalDictionary.GetEntry(journalKey);
					if (!ConsolidationJournalIsEmpty(journal)) {
						if (ConsolidationJournalIsBalanced(journal)) {
							ConsolidationPostJournal(journalStore, journal);
							counter1 = counter1 + 1;
						} else {
							WriteLine(""The journal was not posted as it was unbalanced."");
						}
					}
				}

				if (generateSegmentLines)
				{
					if (accountsWithDetailsWithSegments.Count() > 0)
					{
						// check cells from TSEGMOVG
						OLAPDataArea segmentDetailData = OLAPCreateDataArea(
							olapConnection, TSEGMOVG, OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBasis,
							group, ""Consolidated Segments"", companies, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, accountsWithDetailsWithSegments.ConvertToStringList()
						);

						foreach (OLAPCell segDetailCell in segmentDetailData)
						{
							double cellValue = segDetailCell;

							if (cellValue != 0)
							{
								GroupJournal segmentJournal = null;
								string account = OLAPCellGetElement(segDetailCell, DACOUNT);
								string company = OLAPCellGetElement(segDetailCell, DCOMPC);
								string detail = OLAPCellGetElement(segDetailCell, DDETAIL);

								string accountDetailStr = accountDetailsAttr[account];
								OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
								OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

								if (accountScheduleDetails.ElementListContainsElement(detail))
								{
									string pPrimarySegment = OLAPCellGetElement(segDetailCell, ""DPSEGM"");
									string pSecondarySegment = OLAPCellGetElement(segDetailCell, ""DSSEGM"");
									string pTertiarySegment = OLAPCellGetElement(segDetailCell, ""DTSEGM"");

									bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

									string journalKey = company;
									if (ContainsKey(segmentJournalDictionary, company))
									{
										segmentJournal = GetEntry(segmentJournalDictionary, journalKey);
									}
									else
									{
										segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
										AddEntry(segmentJournalDictionary, journalKey, segmentJournal);
									}

									OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

									double minDirect = minorityDirectDictionary[company];
									double minIndirect = minorityIndirectDictionary[company];

									// handle direct minorities
									double calcValue = cellValue * minDirect;
									if (calcValue != 0)
									{

										if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										} else {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										}
									}

									// handle indirect minorities
									calcValue = cellValue * minIndirect;
									if (calcValue != 0)
									{
										if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										} else {
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
											ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), detail,
											                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										}
									}

								}
							}
						}
					}
					if(accountsWithoutDetailsWithSegments.Count() > 0)
					{
						// check cells from TSEGMG
						OLAPDataArea segmentData = OLAPCreateDataArea(
							olapConnection, TSEGMG, OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBasis,
							group, ""Consolidated Segments"", companies, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", accountsWithoutDetailsWithSegments.ConvertToStringList()
						);

						foreach (OLAPCell segmentCell in segmentData)
						{
							double cellValue = segmentCell;

							if (cellValue != 0)
							{
								GroupJournal segmentJournal = null;
								string account = OLAPCellGetElement(segmentCell, DACOUNT);
								string company = OLAPCellGetElement(segmentCell, DCOMPC);

								string pPrimarySegment = OLAPCellGetElement(segmentCell, ""DPSEGM"");
								string pSecondarySegment = OLAPCellGetElement(segmentCell, ""DSSEGM"");
								string pTertiarySegment = OLAPCellGetElement(segmentCell, ""DTSEGM"");

								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								string journalKey = company;
								if (ContainsKey(segmentJournalDictionary, company))
								{
									segmentJournal = GetEntry(segmentJournalDictionary, journalKey);
								}
								else
								{
									segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
									AddEntry(segmentJournalDictionary, journalKey, segmentJournal);
								}

								OLAPElement accountEl = OLAPGetDimensionElement(olapConnection, DACOUNT, account);

								double minDirect = minorityDirectDictionary[company];
								double minIndirect = minorityIndirectDictionary[company];

								// handle direct minorities
								double calcValue = cellValue * minDirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
									} else {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
									}
								}

								// handle indirect minorities
								calcValue = cellValue * minIndirect;
								if (calcValue != 0)
								{
									if ((isAsset and calcValue < 0) or (!isAsset and calcValue > 0)) {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
									} else {
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", accountEl, """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(calcValue));
										ConsolidationAddGroupJournalLine(segmentJournal, company, ""External"", CO_MinoritiesAccount(olapConnection, accountEl), """",
										                                 pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(calcValue), 0.0);
									}
								}
							}
						}
					}

					foreach(string journalKey in segmentJournalDictionary.Keys())
					{
						GroupJournal journal = segmentJournalDictionary.GetEntry(journalKey);
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter2 = counter2 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
			}

			WriteLine(""posted <"" + counter1 + ""> group journal(s)"");
			WriteLine(""posted <"" + counter2 + ""> group segment journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	2F7323F4-E5A7-4F1C-A8F6-318326220BD2	Former FCDirectMinorities and FCIndirectMinorities process. This process defines the capital consolidation process to post the direct and indirect minorities.	1	1	1	1680	NULL	0	45708.67503	0	0
A95A269A-6EF1-4466-8EDB-8EFD148B72C2	CD491758-D9DF-4002-94C8-8006E1855F86	CO_EliminateInvestments	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""the configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleId"" parameter-type=""string"" parameter-description=""the rule id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetAccountElementList"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HoldingCompany"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ScheduleDetails"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetAccountElementList"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""

bool CO_EliminateInvestments(string server, string configurationSet, string year, string period, string scenario, string group, string ruleId, bool cancel)
@Description: ""Former FCCapitalConsolidation process. This process defines the capital consolidation process to eliminate the shared capital."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[configurationSet]: ""the configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleId]: ""the rule id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	/* DEBUG
	server = ""DEPM"";
	configurationSet = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleId = ""C1"";
	cancel = false;
	 */
	string processName = ""CO_EliminateInvestments"";
	string errorMessage = """";
	int errorCode = 0;
	bool result = false;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for configurationSet&lt;"" + configurationSet + ""&gt; year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleId&lt;"" + ruleId + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		
		NotifyInformation(""cancelling journals"");
		if (!ConsolidationCancelGroupJournals(journalStore, configurationSet, year, period, scenario, group, ruleId, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}
		NotifyInformation(""cancelled journals"");

		if(!cancel)
		{
			string consolidationBase = CO_ConsolidationBasis(olapConnection, configurationSet, ""Cons. Capital"");
			string ACCTYPE_ASSET_VALUE = ""A"";
			string CONSMETHOD_FULL = ""Full"";
			string CONSMETHOD_QUOTAL = ""Quotal"";
			string DDETPA = ""DDETPA"";
			string DACOUNT = ""DACOUNT"";
			string ELEM_CONSCAPITAL = ""Cons. Capital"";
			string ELEM_EXTERNAL = ""EXTERNAL"";
			string ELEM_SUM = ""Sum"";
			string TDETAIG = ""TDETAIG"";
			string TFINANG = ""TFINANG"";
			string ATTR_DETAIL = ""DETAIL"";
			string holdingCompany = CO_HoldingCompany(olapConnection, configurationSet, year, period, scenario, group);
			string groupCurrency = CO_GroupCurrency(olapConnection, configurationSet, year, period, scenario, group);
			string differenceDebitAccount = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Debit Differences Account"");
			string differenceCreditAccount =  CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Credit Differences Account"");
			string accountDifferenceDebitDetail = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Debit Differences Account Detail"");
			string accountDifferenceCreditDetail = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Credit Differences Account Detail"");
			string accountsPropVal = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Investment Accounts"");
			string contraAccountsPropVal = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Equity Accounts of the Subsidiaries"");
			
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			int postCtr = 0;

			OLAPElementList accounts = CO_GetAccountElementList(olapConnection, accountsPropVal);
			OLAPElementList contraAccounts = CO_GetAccountElementList(olapConnection, contraAccountsPropVal);
			OLAPElementList allAccounts = accounts.MergeDistinct(contraAccounts);
			
			StringList attributes = CreateStringList();
			attributes.Append(""DETAIL"");
			attributes.Append(""ALRE"");

			StringListList accountAttributes = OLAPGetElementsAttributesValues(olapConnection, DACOUNT, DACOUNT, allAccounts, attributes);
			StringDictionary accountTypes = CreateStringDictionary();
			StringDictionary accountDetailsAttr = CreateStringDictionary();
			StringArray accountsWithDetails = CreateStringArray();
			StringArray accountsWithoutDetails = CreateStringArray();

			int index = 0;
			foreach(OLAPElement account in allAccounts)
			{
				string accountStr = account.ToString();
				string detail = accountAttributes[index].GetElementByIndex(0);
				string acctType = accountAttributes[index].GetElementByIndex(1);

				accountDetailsAttr[accountStr] = detail;
				accountTypes[accountStr] = acctType;

				if(detail == """")
				{
					accountsWithoutDetails.Append(accountStr); // TFINANG
				}
				else
				{
					accountsWithDetails.Append(accountStr); // TDETAIG
				}
				index = index + 1;
			}

			// prepare companies and intercompanies and their calculated shares and ownership data
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			DoubleDictionary csharesRef = CreateDoubleDictionary();
			DoubleDictionary ctrlRef = CreateDoubleDictionary();
			foreach(OLAPElement company in CO_Companies(olapConnection, configurationSet) where (
				CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, company) == CONSMETHOD_FULL or
				CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, company) == CONSMETHOD_QUOTAL))
			{
				OLAPElementListAddElement(companies, company);
				OLAPElementListAddElement(intercompanies, company);
			}
			if (Count(companies) &gt; 0)
			{
				OLAPDataArea sharesData = OLAPCreateDataArea(
					olapConnection, ""TCONSPA"", OlapDataAreaIncludeB,
					OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
					configurationSet, year, period, scenario, group, holdingCompany, companies, ""calculated shares""
				);
				foreach (OLAPCell cshares in sharesData)
				{
					string company = OLAPCellGetElement(cshares, ""DINTCO"");
					csharesRef[company] = cshares;
				}

				if(Count(intercompanies) &gt; 0)
				{
					OLAPDataArea controlData = OLAPCreateDataArea(
						olapConnection, ""TCONSPA"", OlapDataAreaIncludeB,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, group, companies, intercompanies, ""equity participation""
					);
					foreach (OLAPCell ctrl in controlData)
					{
						string intercompany = OLAPCellGetElement(ctrl, ""DINTCO"");
						string company = OLAPCellGetElement(ctrl, ""DCOMPC"");
						ctrlRef[company + ""]"" + intercompany] = ctrl;
					}
				}
				
				// include Sum to Intercompanies
				StringList intercompaniesWithSum = intercompanies.ConvertToStringList();
				intercompaniesWithSum.Append(ELEM_SUM);

				if (accountsWithDetails.Count() &gt; 0)
				{
					// check cells from TDETAIG - accounts with schedule attr
					OLAPDataArea detailData = OLAPCreateDataArea(
						olapConnection, TDETAIG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, groupCurrency, consolidationBase,
						group, companies, intercompaniesWithSum, OlapDataAreaBCells, accountsWithDetails.ConvertToStringList()
					);

					foreach (OLAPCell detailCell in detailData)
					{
						double value = detailCell;

						if (value != 0)
						{
							GroupJournal groupJournal = null;
							string account = OLAPCellGetElement(detailCell, ""DACOUNT"");
							string company = OLAPCellGetElement(detailCell, ""DCOMPC"");
							string intercompany = OLAPCellGetElement(detailCell, ""DINTCO"");
							string detail = OLAPCellGetElement(detailCell, ""DDETAIL"");

							string accountDetailStr =  accountDetailsAttr[account];
							OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
							OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

							if (accountScheduleDetails.ElementListContainsElement(detail))
							{
								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								if (accounts.ElementListContainsElement(account) and intercompany.ToLower() != ELEM_SUM.ToLower())
								{
									string journalKey = company + ""]"" + intercompany;
									if (ContainsKey(journalDictionary, journalKey))
									{
										groupJournal = GetEntry(journalDictionary, journalKey);
									}
									else
									{
										groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
										AddEntry(journalDictionary, journalKey, groupJournal);
									}

									if ((isAsset and value &lt; 0) or (!isAsset and value &gt; 0))
									{
										ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, detail, """", Abs(value), 0.0);
									}
									else
									{
										ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, detail, """", 0.0, Abs(value));
									}
								}
								else if (contraAccounts.ElementListContainsElement(account) and intercompany.ToLower() == ELEM_SUM.ToLower())
								{
									foreach(string ctrlKey in ctrlRef.Keys())
									{
										double sumValue = detailCell;

										StringArray info = StringSplit(ctrlKey, ""]"");
										string ctrlCompany = info[0];
										string ctrlIntercompany = info[1];
										string journalKey =  ctrlCompany + ""]"" + ctrlIntercompany;

										double ctrl = 0;
										if (ctrlRef.ContainsKey(ctrlKey))
										{
											ctrl = ctrlRef[ctrlKey];
										}
										if (company == ctrlIntercompany and ctrl != 0)
										{
											if (ContainsKey(journalDictionary, journalKey))
											{
												groupJournal = GetEntry(journalDictionary, journalKey);
											}
											else
											{
												groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
												AddEntry(journalDictionary, journalKey, groupJournal);
											}

											double cShares = 0;
											if (csharesRef.ContainsKey(ctrlCompany))
											{
												cShares = csharesRef[ctrlCompany];
											}
											if ((CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, ctrlIntercompany) == CONSMETHOD_FULL))
											{
												sumValue = sumValue * ctrl * cShares;
											}
											else
											{
												sumValue = sumValue * cShares;
											}

											if ((isAsset and sumValue &lt; 0) or (!isAsset and sumValue &gt; 0))
											{
												ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, detail, """", Abs(sumValue), 0.0);
											}
											else
											{
												ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, detail, """", 0.0, Abs(sumValue));
											}
										}

									}
								}
							}
						}
					}
				}

				if (accountsWithoutDetails.Count() &gt; 0)
				{
					// check cells from TFINANG - accounts with no schedule attr
					OLAPDataArea financeData = OLAPCreateDataArea(
						olapConnection, TFINANG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, groupCurrency, consolidationBase,
						group, companies, intercompaniesWithSum, accountsWithoutDetails.ConvertToStringList()
					);

					foreach (OLAPCell finCell in financeData)
					{
						double value = finCell;

						if (value != 0)
						{
							GroupJournal groupJournal = null;
							string account = OLAPCellGetElement(finCell, ""DACOUNT"");
							string company = OLAPCellGetElement(finCell, ""DCOMPC"");
							string intercompany = OLAPCellGetElement(finCell, ""DINTCO"");

							bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

							if (accounts.ElementListContainsElement(account) and intercompany.ToLower() != ELEM_SUM.ToLower())
							{
								string journalKey = company + ""]"" + intercompany;
								if (ContainsKey(journalDictionary, journalKey))
								{
									groupJournal = GetEntry(journalDictionary, journalKey);
								}
								else
								{
									groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
									AddEntry(journalDictionary, journalKey, groupJournal);
								}

								if ((isAsset and value &lt; 0) or (!isAsset and value &gt; 0))
								{
									ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, """", """", Abs(value), 0.0);
								}
								else
								{
									ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, """", """", 0.0, Abs(value));
								}
							}
							else if (contraAccounts.ElementListContainsElement(account) and intercompany.ToLower() == ELEM_SUM.ToLower())
							{
								foreach(string ctrlKey in ctrlRef.Keys())
								{
									double sumValue = finCell;

									StringArray info = StringSplit(ctrlKey, ""]"");
									string ctrlCompany = info[0];
									string ctrlIntercompany = info[1];
									string journalKey =  ctrlCompany + ""]"" + ctrlIntercompany;

									double ctrl = 0;
									if (ctrlRef.ContainsKey(ctrlKey))
									{
										ctrl = ctrlRef[ctrlKey];
									}
									if (company == ctrlIntercompany and ctrl != 0)
									{
										if (ContainsKey(journalDictionary, journalKey))
										{
											groupJournal = GetEntry(journalDictionary, journalKey);
										}
										else
										{
											groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
											AddEntry(journalDictionary, journalKey, groupJournal);
										}

										double cShares = 0;
										if (csharesRef.ContainsKey(ctrlCompany))
										{
											cShares = csharesRef[ctrlCompany];
										}
										if ((CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, ctrlIntercompany) == CONSMETHOD_FULL))
										{
											sumValue = sumValue * ctrl * cShares;
										}
										else
										{
											sumValue = sumValue * cShares;
										}

										if ((isAsset and sumValue &lt; 0) or (!isAsset and sumValue &gt; 0))
										{
											ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, """", """", Abs(sumValue), 0.0);
										}
										else
										{
											ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, """", """", 0.0, Abs(sumValue));
										}
									}

								}
							}
						}
					}
				}

				// loop thru all the journals created and check if difference exists
				foreach(string journalKey in journalDictionary.Keys())
				{
					GroupJournal journal = GetEntry(journalDictionary, journalKey);
					StringArray info = StringSplit(journalKey, ""]"");
					string company = info[0];
					string intercompany = info[1];

					double difference = ConsolidationJournalDifference(journal);
					if (RoundDecimals(difference, 4) != 0)
					{
						if (difference &gt; 0)
						{
							ConsolidationAddGroupJournalLine(journal, company, intercompany, differenceDebitAccount, accountDifferenceDebitDetail, """", Abs(difference), 0.0);
						}
						else
						{
							ConsolidationAddGroupJournalLine(journal, company, intercompany, differenceCreditAccount, accountDifferenceCreditDetail, """", 0.0, Abs(difference));
						}
					}

					if (!ConsolidationJournalIsEmpty(journal))
					{
						if (ConsolidationJournalIsBalanced(journal))
						{
							if (CO_ValidateGroupJournal(journal, true)) {
								ConsolidationPostJournal(journalStore, journal);
								postCtr = postCtr + 1;
							}
						}
						else
						{
							NotifyError(""The journal was not posted as it was unbalanced."");
						}
					}
				}
			}

			NotifyInformation(""posted &lt;"" + postCtr + ""&gt; journal(s)"");
		}
		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetAccountElementList"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_ScheduleDetails"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""

bool CO_EliminateInvestments(string server, string configurationSet, string year, string period, string scenario, string group, string ruleId, bool cancel)
@Description: ""Former FCCapitalConsolidation process. This process defines the capital consolidation process to eliminate the shared capital."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[configurationSet]: ""the configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleId]: ""the rule id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	/* DEBUG
	server = ""DEPM"";
	configurationSet = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleId = ""C1"";
	cancel = false;
	 */
	string processName = ""CO_EliminateInvestments"";
	string errorMessage = """";
	int errorCode = 0;
	bool result = false;

	try {
		WriteLine(""Starting process <"" + processName + ""> for configurationSet<"" + configurationSet + ""> year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleId<"" + ruleId + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		
		NotifyInformation(""cancelling journals"");
		if (!ConsolidationCancelGroupJournals(journalStore, configurationSet, year, period, scenario, group, ruleId, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}
		NotifyInformation(""cancelled journals"");

		if(!cancel)
		{
			string consolidationBase = CO_ConsolidationBasis(olapConnection, configurationSet, ""Cons. Capital"");
			string ACCTYPE_ASSET_VALUE = ""A"";
			string CONSMETHOD_FULL = ""Full"";
			string CONSMETHOD_QUOTAL = ""Quotal"";
			string DDETPA = ""DDETPA"";
			string DACOUNT = ""DACOUNT"";
			string ELEM_CONSCAPITAL = ""Cons. Capital"";
			string ELEM_EXTERNAL = ""EXTERNAL"";
			string ELEM_SUM = ""Sum"";
			string TDETAIG = ""TDETAIG"";
			string TFINANG = ""TFINANG"";
			string ATTR_DETAIL = ""DETAIL"";
			string holdingCompany = CO_HoldingCompany(olapConnection, configurationSet, year, period, scenario, group);
			string groupCurrency = CO_GroupCurrency(olapConnection, configurationSet, year, period, scenario, group);
			string differenceDebitAccount = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Debit Differences Account"");
			string differenceCreditAccount =  CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Credit Differences Account"");
			string accountDifferenceDebitDetail = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Debit Differences Account Detail"");
			string accountDifferenceCreditDetail = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Credit Differences Account Detail"");
			string accountsPropVal = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Investment Accounts"");
			string contraAccountsPropVal = CO_GetProcessProperty(olapConnection, configurationSet, ruleId, ""Equity Accounts of the Subsidiaries"");
			
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			int postCtr = 0;

			OLAPElementList accounts = CO_GetAccountElementList(olapConnection, accountsPropVal);
			OLAPElementList contraAccounts = CO_GetAccountElementList(olapConnection, contraAccountsPropVal);
			OLAPElementList allAccounts = accounts.MergeDistinct(contraAccounts);
			
			StringList attributes = CreateStringList();
			attributes.Append(""DETAIL"");
			attributes.Append(""ALRE"");

			StringListList accountAttributes = OLAPGetElementsAttributesValues(olapConnection, DACOUNT, DACOUNT, allAccounts, attributes);
			StringDictionary accountTypes = CreateStringDictionary();
			StringDictionary accountDetailsAttr = CreateStringDictionary();
			StringArray accountsWithDetails = CreateStringArray();
			StringArray accountsWithoutDetails = CreateStringArray();

			int index = 0;
			foreach(OLAPElement account in allAccounts)
			{
				string accountStr = account.ToString();
				string detail = accountAttributes[index].GetElementByIndex(0);
				string acctType = accountAttributes[index].GetElementByIndex(1);

				accountDetailsAttr[accountStr] = detail;
				accountTypes[accountStr] = acctType;

				if(detail == """")
				{
					accountsWithoutDetails.Append(accountStr); // TFINANG
				}
				else
				{
					accountsWithDetails.Append(accountStr); // TDETAIG
				}
				index = index + 1;
			}

			// prepare companies and intercompanies and their calculated shares and ownership data
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			DoubleDictionary csharesRef = CreateDoubleDictionary();
			DoubleDictionary ctrlRef = CreateDoubleDictionary();
			foreach(OLAPElement company in CO_Companies(olapConnection, configurationSet) where (
				CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, company) == CONSMETHOD_FULL or
				CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, company) == CONSMETHOD_QUOTAL))
			{
				OLAPElementListAddElement(companies, company);
				OLAPElementListAddElement(intercompanies, company);
			}
			if (Count(companies) > 0)
			{
				OLAPDataArea sharesData = OLAPCreateDataArea(
					olapConnection, ""TCONSPA"", OlapDataAreaIncludeB,
					OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
					configurationSet, year, period, scenario, group, holdingCompany, companies, ""calculated shares""
				);
				foreach (OLAPCell cshares in sharesData)
				{
					string company = OLAPCellGetElement(cshares, ""DINTCO"");
					csharesRef[company] = cshares;
				}

				if(Count(intercompanies) > 0)
				{
					OLAPDataArea controlData = OLAPCreateDataArea(
						olapConnection, ""TCONSPA"", OlapDataAreaIncludeB,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, group, companies, intercompanies, ""equity participation""
					);
					foreach (OLAPCell ctrl in controlData)
					{
						string intercompany = OLAPCellGetElement(ctrl, ""DINTCO"");
						string company = OLAPCellGetElement(ctrl, ""DCOMPC"");
						ctrlRef[company + ""]"" + intercompany] = ctrl;
					}
				}
				
				// include Sum to Intercompanies
				StringList intercompaniesWithSum = intercompanies.ConvertToStringList();
				intercompaniesWithSum.Append(ELEM_SUM);

				if (accountsWithDetails.Count() > 0)
				{
					// check cells from TDETAIG - accounts with schedule attr
					OLAPDataArea detailData = OLAPCreateDataArea(
						olapConnection, TDETAIG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, groupCurrency, consolidationBase,
						group, companies, intercompaniesWithSum, OlapDataAreaBCells, accountsWithDetails.ConvertToStringList()
					);

					foreach (OLAPCell detailCell in detailData)
					{
						double value = detailCell;

						if (value != 0)
						{
							GroupJournal groupJournal = null;
							string account = OLAPCellGetElement(detailCell, ""DACOUNT"");
							string company = OLAPCellGetElement(detailCell, ""DCOMPC"");
							string intercompany = OLAPCellGetElement(detailCell, ""DINTCO"");
							string detail = OLAPCellGetElement(detailCell, ""DDETAIL"");

							string accountDetailStr =  accountDetailsAttr[account];
							OLAPElement accountDetail = OLAPGetDimensionElement(olapConnection, DDETPA, accountDetailStr);
							OLAPElementList accountScheduleDetails = CO_ScheduleDetails(olapConnection, accountDetail);

							if (accountScheduleDetails.ElementListContainsElement(detail))
							{
								bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

								if (accounts.ElementListContainsElement(account) and intercompany.ToLower() != ELEM_SUM.ToLower())
								{
									string journalKey = company + ""]"" + intercompany;
									if (ContainsKey(journalDictionary, journalKey))
									{
										groupJournal = GetEntry(journalDictionary, journalKey);
									}
									else
									{
										groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
										AddEntry(journalDictionary, journalKey, groupJournal);
									}

									if ((isAsset and value < 0) or (!isAsset and value > 0))
									{
										ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, detail, """", Abs(value), 0.0);
									}
									else
									{
										ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, detail, """", 0.0, Abs(value));
									}
								}
								else if (contraAccounts.ElementListContainsElement(account) and intercompany.ToLower() == ELEM_SUM.ToLower())
								{
									foreach(string ctrlKey in ctrlRef.Keys())
									{
										double sumValue = detailCell;

										StringArray info = StringSplit(ctrlKey, ""]"");
										string ctrlCompany = info[0];
										string ctrlIntercompany = info[1];
										string journalKey =  ctrlCompany + ""]"" + ctrlIntercompany;

										double ctrl = 0;
										if (ctrlRef.ContainsKey(ctrlKey))
										{
											ctrl = ctrlRef[ctrlKey];
										}
										if (company == ctrlIntercompany and ctrl != 0)
										{
											if (ContainsKey(journalDictionary, journalKey))
											{
												groupJournal = GetEntry(journalDictionary, journalKey);
											}
											else
											{
												groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
												AddEntry(journalDictionary, journalKey, groupJournal);
											}

											double cShares = 0;
											if (csharesRef.ContainsKey(ctrlCompany))
											{
												cShares = csharesRef[ctrlCompany];
											}
											if ((CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, ctrlIntercompany) == CONSMETHOD_FULL))
											{
												sumValue = sumValue * ctrl * cShares;
											}
											else
											{
												sumValue = sumValue * cShares;
											}

											if ((isAsset and sumValue < 0) or (!isAsset and sumValue > 0))
											{
												ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, detail, """", Abs(sumValue), 0.0);
											}
											else
											{
												ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, detail, """", 0.0, Abs(sumValue));
											}
										}

									}
								}
							}
						}
					}
				}

				if (accountsWithoutDetails.Count() > 0)
				{
					// check cells from TFINANG - accounts with no schedule attr
					OLAPDataArea financeData = OLAPCreateDataArea(
						olapConnection, TFINANG, OlapDataAreaSuppressNull,
						OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
						configurationSet, year, period, scenario, groupCurrency, consolidationBase,
						group, companies, intercompaniesWithSum, accountsWithoutDetails.ConvertToStringList()
					);

					foreach (OLAPCell finCell in financeData)
					{
						double value = finCell;

						if (value != 0)
						{
							GroupJournal groupJournal = null;
							string account = OLAPCellGetElement(finCell, ""DACOUNT"");
							string company = OLAPCellGetElement(finCell, ""DCOMPC"");
							string intercompany = OLAPCellGetElement(finCell, ""DINTCO"");

							bool isAsset = accountTypes[account] == ACCTYPE_ASSET_VALUE;

							if (accounts.ElementListContainsElement(account) and intercompany.ToLower() != ELEM_SUM.ToLower())
							{
								string journalKey = company + ""]"" + intercompany;
								if (ContainsKey(journalDictionary, journalKey))
								{
									groupJournal = GetEntry(journalDictionary, journalKey);
								}
								else
								{
									groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
									AddEntry(journalDictionary, journalKey, groupJournal);
								}

								if ((isAsset and value < 0) or (!isAsset and value > 0))
								{
									ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, """", """", Abs(value), 0.0);
								}
								else
								{
									ConsolidationAddGroupJournalLine(groupJournal, company, intercompany, account, """", """", 0.0, Abs(value));
								}
							}
							else if (contraAccounts.ElementListContainsElement(account) and intercompany.ToLower() == ELEM_SUM.ToLower())
							{
								foreach(string ctrlKey in ctrlRef.Keys())
								{
									double sumValue = finCell;

									StringArray info = StringSplit(ctrlKey, ""]"");
									string ctrlCompany = info[0];
									string ctrlIntercompany = info[1];
									string journalKey =  ctrlCompany + ""]"" + ctrlIntercompany;

									double ctrl = 0;
									if (ctrlRef.ContainsKey(ctrlKey))
									{
										ctrl = ctrlRef[ctrlKey];
									}
									if (company == ctrlIntercompany and ctrl != 0)
									{
										if (ContainsKey(journalDictionary, journalKey))
										{
											groupJournal = GetEntry(journalDictionary, journalKey);
										}
										else
										{
											groupJournal = ConsolidationCreateGroupJournal(journalStore, configurationSet, year, period, scenario, group, ELEM_CONSCAPITAL, ruleId, """", true);
											AddEntry(journalDictionary, journalKey, groupJournal);
										}

										double cShares = 0;
										if (csharesRef.ContainsKey(ctrlCompany))
										{
											cShares = csharesRef[ctrlCompany];
										}
										if ((CO_ConsolidationMethod(olapConnection, configurationSet, year, period, scenario, group, ctrlIntercompany) == CONSMETHOD_FULL))
										{
											sumValue = sumValue * ctrl * cShares;
										}
										else
										{
											sumValue = sumValue * cShares;
										}

										if ((isAsset and sumValue < 0) or (!isAsset and sumValue > 0))
										{
											ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, """", """", Abs(sumValue), 0.0);
										}
										else
										{
											ConsolidationAddGroupJournalLine(groupJournal, ctrlIntercompany, ELEM_EXTERNAL, account, """", """", 0.0, Abs(sumValue));
										}
									}

								}
							}
						}
					}
				}

				// loop thru all the journals created and check if difference exists
				foreach(string journalKey in journalDictionary.Keys())
				{
					GroupJournal journal = GetEntry(journalDictionary, journalKey);
					StringArray info = StringSplit(journalKey, ""]"");
					string company = info[0];
					string intercompany = info[1];

					double difference = ConsolidationJournalDifference(journal);
					if (RoundDecimals(difference, 4) != 0)
					{
						if (difference > 0)
						{
							ConsolidationAddGroupJournalLine(journal, company, intercompany, differenceDebitAccount, accountDifferenceDebitDetail, """", Abs(difference), 0.0);
						}
						else
						{
							ConsolidationAddGroupJournalLine(journal, company, intercompany, differenceCreditAccount, accountDifferenceCreditDetail, """", 0.0, Abs(difference));
						}
					}

					if (!ConsolidationJournalIsEmpty(journal))
					{
						if (ConsolidationJournalIsBalanced(journal))
						{
							if (CO_ValidateGroupJournal(journal, true)) {
								ConsolidationPostJournal(journalStore, journal);
								postCtr = postCtr + 1;
							}
						}
						else
						{
							NotifyError(""The journal was not posted as it was unbalanced."");
						}
					}
				}
			}

			NotifyInformation(""posted <"" + postCtr + ""> journal(s)"");
		}
		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	5D290580-5B2A-4DA7-87E2-4380D3B2A9FE	Former FCCapitalConsolidation process. This process defines the capital consolidation process to eliminate the shared capital.	1	1	1	1681	NULL	0	45708.67506	0	0
6D87B57C-6417-49A4-8E99-01EE0B94B6B7	CD491758-D9DF-4002-94C8-8006E1855F86	CO_EliminationFactor	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The factor of elimination."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""interCompany"" parameter-type=""string"" parameter-description=""An element that specifies the intercompany to query."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""forAccount"" parameter-type=""bool"" parameter-description=""Indicated whether to calculate factor for account or contra-account."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CalculatedShares"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HoldingCompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_HoldingCompany"", ""*""

double CO_EliminationFactor(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string interCompany, bool forAccount)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the factor of elimination for given company and intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[interCompany]: ""An element that specifies the intercompany to query."";
@Parameter[forAccount]: ""Indicated whether to calculate factor for account or contra-account."";
@Returns: ""The factor of elimination."";
{
	// 100% by default
	double factorAccount = 1;
	double factorContraAccount = 1;

	double percentOfConsolidation = 1;
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"") {
		percentOfConsolidation = CO_CalculatedShares(connection, configurationSet, year, period, scenario, group, CO_HoldingCompany(connection, configurationSet, year, period, scenario, group), company);
	}

	double percentOfConsolidationIntercompany = 1;
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, interCompany) == ""Quotal"") {
		percentOfConsolidationIntercompany = CO_CalculatedShares(connection, configurationSet, year, period, scenario, group, CO_HoldingCompany(connection, configurationSet, year, period, scenario, group), interCompany);

		// if IC has Quotal consolidation we use the same factor for both account and contra-account
		factorAccount = percentOfConsolidationIntercompany;
		factorContraAccount = factorAccount;
	}
	
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"" and
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, interCompany) == ""Quotal"") {
		if (percentOfConsolidation &lt;= percentOfConsolidationIntercompany) {
			factorAccount = 1.0;
			factorContraAccount = percentOfConsolidation / percentOfConsolidationIntercompany;
		} else {
			factorAccount = percentOfConsolidationIntercompany / percentOfConsolidation;
			factorContraAccount = 1.0;
		}
	}
	if (forAccount) {
		return factorAccount;
	} else {
		return factorContraAccount;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_HoldingCompany"", ""*""

double CO_EliminationFactor(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string interCompany, bool forAccount)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the factor of elimination for given company and intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[interCompany]: ""An element that specifies the intercompany to query."";
@Parameter[forAccount]: ""Indicated whether to calculate factor for account or contra-account."";
@Returns: ""The factor of elimination."";
{
	// 100% by default
	double factorAccount = 1;
	double factorContraAccount = 1;

	double percentOfConsolidation = 1;
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"") {
		percentOfConsolidation = CO_CalculatedShares(connection, configurationSet, year, period, scenario, group, CO_HoldingCompany(connection, configurationSet, year, period, scenario, group), company);
	}

	double percentOfConsolidationIntercompany = 1;
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, interCompany) == ""Quotal"") {
		percentOfConsolidationIntercompany = CO_CalculatedShares(connection, configurationSet, year, period, scenario, group, CO_HoldingCompany(connection, configurationSet, year, period, scenario, group), interCompany);

		// if IC has Quotal consolidation we use the same factor for both account and contra-account
		factorAccount = percentOfConsolidationIntercompany;
		factorContraAccount = factorAccount;
	}
	
	if (CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"" and
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, interCompany) == ""Quotal"") {
		if (percentOfConsolidation <= percentOfConsolidationIntercompany) {
			factorAccount = 1.0;
			factorContraAccount = percentOfConsolidation / percentOfConsolidationIntercompany;
		} else {
			factorAccount = percentOfConsolidationIntercompany / percentOfConsolidation;
			factorContraAccount = 1.0;
		}
	}
	if (forAccount) {
		return factorAccount;
	} else {
		return factorContraAccount;
	}
}"	1	532DED54-40C0-4749-A8AE-6051FC9AEA88	Gets the factor of elimination for given company and intercompany in a group for a specified context.	1	1	1	1682	NULL	0	45708.67507	0	0
E8E6E85F-FF32-4EEA-9CAA-8A2C45D03239	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Equity	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Ownership"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BasePeriod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BaseYear"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateProcessConfiguration"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_Ownership"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_BaseYear"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_ValidateProcessConfiguration"", ""*""

/*
	This process recognizes the share in the profit or loss of the associated company, which is consolidated using the at equity method.
	The share is booked to the investment account in the parent company and either increases (in case of a profit) or decreases (in case of a loss) the investment.
	In addition the equity consolidation also reduces the investment by the dividend income the parent company received from the associated company.

	Effects from silent reserves, depreciations of silent reserves or the recognition and/or impairment of a goodwill are not included yet.

	The relevant accounts and details are set up in the consolidation settings in the capital consolidation sections. It makes use of the configuration rule 'EQ'.
	The following settings are used from section 'Cons. Capital', consolidation rule 'EQ'. If there are missing some settings or are not configured, default values apply:
	- Account 'Profit (Loss) from Associated Entities (calculation basis)'
	- Account 'Shares in Associated Entities'
	- Detail  'Shares in Associated Entities Detail for Increases'
	- Detail  'Shares in Associated Entities Detail for Decreases'
	- Account 'Profit from Associated Entities'
	- Account 'Profit from Associated Entities Detail'
	- Account 'Loss from Associated Entities'
	- Account 'Loss from Associated Entities Detail'
	- Account 'Dividends received from Associated Entities'
	- Account 'Dividends received from Associated Entities Detail'

 */

bool CO_Equity(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""This process calculates the particiaption for associated companies."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	/* DEBUG
	cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""EQ"";
	cancel = false;*/

	string processName = ""CO_Equity"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		
		// Group Parametrization
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		OLAPElementList companiesEquity = CreateOLAPElementList();
		OLAPElementList companiesFullOrQuotal = CreateOLAPElementList();
		int ownershipCtr = 0;
		foreach (OLAPElement company in CO_Companies(olapConnection, cycle))
		{
			string consMethod = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company);
			if (consMethod != """")
			{
				ownershipCtr = ownershipCtr + 1;
				if (consMethod == ""Equity"")
				{
					companiesEquity.ElementListAddElement(company);
				}
				else if (consMethod == ""Quotal"" or consMethod == ""Full"")
				{
					companiesFullOrQuotal.ElementListAddElement(company);
				}
			}

		}

		// validate Group Parametrization
		StringList groupParamErrors = CreateStringList();
		if (groupcurrency == """")
		{
			groupParamErrors.Append(""Group Currency should be configured."");
		}
		if (ownershipCtr == 0)
		{
			groupParamErrors.Append(""Missing entity ownership configuration and/or group ownership calculation."");
		}
		if (groupParamErrors.Count() &gt; 0)
		{
			WriteLine(""Group Parametrization Issues:"");
			foreach (string error in groupParamErrors) {
				WriteLine(error);
			}
		}

		// Process Configuration property names
		string PROP_CALCULATION_BASE_ACCOUNT = ""Profit (Loss) from Associated Entities (calculation basis)"";
		string PROP_SHARES_ASSOC_ENTITIES_ACCOUNT = ""Shares in Associated Entities"";
		string PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL = ""Shares in Associated Entities Detail for Increases"";
		string PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL = ""Shares in Associated Entities Detail for Decreases"";
		string PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT = ""Profit from Associated Entities"";
		string PROP_PROFIT_ASSOC_ENTITIES_DETAIL = ""Profit from Associated Entities Detail"";
		string PROP_LOSS_ASSOC_ENTITIES_ACCOUNT = ""Loss from Associated Entities"";
		string PROP_LOSS_ASSOC_ENTITIES_DETAIL = ""Loss from Associated Entities Detail"";
		string PROP_DIVIDENDS_BASE_ACCOUNT = ""Dividends received from Associated Entities"";
		string PROP_DIVIDENDS_BASE_DETAIL = ""Dividends received from Associated Entities Detail"";

		// get and validate the Process Configuration
		StringDictionary accountsConfig = CreateStringDictionary();
		accountsConfig[PROP_CALCULATION_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_CALCULATION_BASE_ACCOUNT);
		accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_LOSS_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_LOSS_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_DIVIDENDS_BASE_ACCOUNT);

		StringDictionary detailsConfig = CreateStringDictionary();
		detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL);
		detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL);
		detailsConfig[PROP_PROFIT_ASSOC_ENTITIES_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_PROFIT_ASSOC_ENTITIES_DETAIL);
		detailsConfig[PROP_LOSS_ASSOC_ENTITIES_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_LOSS_ASSOC_ENTITIES_DETAIL);
		detailsConfig[PROP_DIVIDENDS_BASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_DIVIDENDS_BASE_DETAIL);

		StringDictionary detailToAccount = CreateStringDictionary();
		detailToAccount[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL] = PROP_SHARES_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL] = PROP_SHARES_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_PROFIT_ASSOC_ENTITIES_DETAIL] = PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_LOSS_ASSOC_ENTITIES_DETAIL] = PROP_LOSS_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_DIVIDENDS_BASE_DETAIL] = PROP_DIVIDENDS_BASE_ACCOUNT;

		bool isValidConfig = CO_ValidateProcessConfiguration(olapConnection, accountsConfig, detailsConfig, detailToAccount);

		// stop the process if there are Process Config or Group Parametrization issues
		if (!isValidConfig or groupParamErrors.Count() &gt; 0) {
			ExitProcess(""Cannot execute the process"");
		}
		// end of validation

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			
			string baseYear = CO_BaseYear(olapConnection, year, period);
			string basePeriod = CO_BasePeriod(olapConnection, period);

			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, ruleid);

			// Get OLAP elements
			OLAPElement calculationBaseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", accountsConfig[PROP_CALCULATION_BASE_ACCOUNT]);
			OLAPElement dividendsBaseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"",  accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);

			// Check if base accounts are expenditure accounts
			bool calculationBaseAccountIsExpenditure = CO_AccountType(olapConnection, calculationBaseAccountElement) == ""Expenditure"";
			bool dividendsBaseAccountIsExpenditure = CO_AccountType(olapConnection, dividendsBaseAccountElement) == ""Expenditure"";

			int counter = 0;

			// Go over all 'equity' companies for equity processing
			foreach (OLAPElement company in companiesEquity)
			{
				// loop over all parent companies which have full or quotal shares
				foreach (OLAPElement parentCompany in companiesFullOrQuotal)
				{
					double ownership = CO_Ownership(olapConnection, cycle, year, period, scenario, group, parentCompany, company);

					if (ownership &gt; 0.0)
					{
						LogDebug(""Processing equity company: "" + company);

						double value = OLAPCellReadNumber(olapConnection, ""TFINANC"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBasis, ""Balance Sheet"", company, ""sum"", accountsConfig[PROP_CALCULATION_BASE_ACCOUNT]);
						double totalValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Consolidated Balance Sheet"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double previousPeriodValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, baseYear, basePeriod, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double currentEquity = 0.0;

						LogDebug(""Current Value  : "" + value);
						LogDebug(""Total Value    : "" + totalValue);
						LogDebug(""Previous Value : "" + previousPeriodValue);

						value = value * ownership;

						if (Abs(totalValue) &lt; 0.0000001)
						{
							currentEquity = previousPeriodValue + value;

							if (currentEquity &lt;= 0.0)
							{
								value = 0.0;
							}
							else
							{
								value = currentEquity;
							}
						}
						else
						{
							if (value &lt; 0.0)
							{
								currentEquity = value + totalValue;
								if (Abs(value) &gt; Abs(totalValue))
								{
									value = -totalValue;
								}
							}
							else
							{
								currentEquity = value + totalValue;
							}
						}

						LogDebug(""Final Book Value   : "" + value);
						LogDebug(""Final Equity Value : "" + currentEquity);

						OLAPCellWriteNumber(olapConnection, ""TFINANG"", currentEquity, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						if (value != 0.0)
						{
							GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Capital"", ruleid, ""Recognition of current year's earnings"", true);

							if ((calculationBaseAccountIsExpenditure and value &lt; 0) or (!calculationBaseAccountIsExpenditure and value &gt; 0))
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL], """", Abs(value), 0.0);
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_PROFIT_ASSOC_ENTITIES_DETAIL], """", 0.0, Abs(value));
							}
							else
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL], """", 0.0, Abs(value));
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_LOSS_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_LOSS_ASSOC_ENTITIES_DETAIL], """", Abs(value), 0.0);
							}

							if (!ConsolidationJournalIsEmpty(journal))
							{
								if (ConsolidationJournalIsBalanced(journal))
								{
									ConsolidationPostJournal(journalStore, journal);
									counter++;
								}
								else
								{
									WriteLine(""The journal was not posted as it was unbalanced."");
								}
							}
						}
					}
				}
			}
			
			// Go over all 'equity' companies again for dividend processing
			foreach (OLAPElement company in companiesEquity)
			{
				// loop over all parent companies which have full or quotal shares
				foreach (OLAPElement parentCompany in companiesFullOrQuotal)
				{
					double ownership = CO_Ownership(olapConnection, cycle, year, period, scenario, group, parentCompany, company);
					if (ownership &gt; 0.0)
					{
						LogDebug(""Processing dividends for equity company: "" + company);
						LogDebug(""Base Account: "" + accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);

						double value = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBasis, group, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);
						double totalValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Consolidated Balance Sheet"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double currentEquityValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						double difference = 0;

						LogDebug(""Current Value        : "" + value);
						LogDebug(""Total Value          : "" + totalValue);
						LogDebug(""Current Equity Value : "" + currentEquityValue);

						if (Abs(totalValue) &lt; 0.0000001)
						{
							currentEquityValue = currentEquityValue - value;
							value = 0.0;
						}
						else
						{
							currentEquityValue = -value + totalValue;
							if (Abs(totalValue) - Abs(value) &gt; 0)
							{
								value = -Abs(value);
							}
							else
							{
								value= -Abs(totalValue);
							}
						}

						LogDebug(""Final Book Value   : "" + value);
						LogDebug(""Final Equity Value : "" + currentEquityValue);

						OLAPCellWriteNumber(olapConnection, ""TFINANG"", currentEquityValue, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						if (value != 0.0)
						{
							GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Capital"", ruleid, ""Recognition of dividends"", true);
							
							if ((dividendsBaseAccountIsExpenditure and value &lt; 0) or (!dividendsBaseAccountIsExpenditure and value &gt; 0))
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL], """", Abs(value), 0.0);
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT], detailsConfig[PROP_DIVIDENDS_BASE_DETAIL], """", 0.0, Abs(value));
							}
							else
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL], """", 0.0, Abs(value));
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT], detailsConfig[PROP_DIVIDENDS_BASE_DETAIL], """", Abs(value), 0.0);
							}

							if (!ConsolidationJournalIsEmpty(journal))
							{
								if (ConsolidationJournalIsBalanced(journal))
								{
									ConsolidationPostJournal(journalStore, journal);
									counter++;
								}
								else
								{
									WriteLine(""The journal was not posted as it was unbalanced."");
								}
							}
						}
					}
				}
			}
			WriteLine(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}

		result = true;
	}
	catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_Ownership"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_BasePeriod"", ""*""
#include ""CO_BaseYear"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_ValidateProcessConfiguration"", ""*""

/*
	This process recognizes the share in the profit or loss of the associated company, which is consolidated using the at equity method.
	The share is booked to the investment account in the parent company and either increases (in case of a profit) or decreases (in case of a loss) the investment.
	In addition the equity consolidation also reduces the investment by the dividend income the parent company received from the associated company.

	Effects from silent reserves, depreciations of silent reserves or the recognition and/or impairment of a goodwill are not included yet.

	The relevant accounts and details are set up in the consolidation settings in the capital consolidation sections. It makes use of the configuration rule 'EQ'.
	The following settings are used from section 'Cons. Capital', consolidation rule 'EQ'. If there are missing some settings or are not configured, default values apply:
	- Account 'Profit (Loss) from Associated Entities (calculation basis)'
	- Account 'Shares in Associated Entities'
	- Detail  'Shares in Associated Entities Detail for Increases'
	- Detail  'Shares in Associated Entities Detail for Decreases'
	- Account 'Profit from Associated Entities'
	- Account 'Profit from Associated Entities Detail'
	- Account 'Loss from Associated Entities'
	- Account 'Loss from Associated Entities Detail'
	- Account 'Dividends received from Associated Entities'
	- Account 'Dividends received from Associated Entities Detail'

 */

bool CO_Equity(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""This process calculates the particiaption for associated companies."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	/* DEBUG
	cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""EQ"";
	cancel = false;*/

	string processName = ""CO_Equity"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);
		
		// Group Parametrization
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
		OLAPElementList companiesEquity = CreateOLAPElementList();
		OLAPElementList companiesFullOrQuotal = CreateOLAPElementList();
		int ownershipCtr = 0;
		foreach (OLAPElement company in CO_Companies(olapConnection, cycle))
		{
			string consMethod = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company);
			if (consMethod != """")
			{
				ownershipCtr = ownershipCtr + 1;
				if (consMethod == ""Equity"")
				{
					companiesEquity.ElementListAddElement(company);
				}
				else if (consMethod == ""Quotal"" or consMethod == ""Full"")
				{
					companiesFullOrQuotal.ElementListAddElement(company);
				}
			}

		}

		// validate Group Parametrization
		StringList groupParamErrors = CreateStringList();
		if (groupcurrency == """")
		{
			groupParamErrors.Append(""Group Currency should be configured."");
		}
		if (ownershipCtr == 0)
		{
			groupParamErrors.Append(""Missing entity ownership configuration and/or group ownership calculation."");
		}
		if (groupParamErrors.Count() > 0)
		{
			WriteLine(""Group Parametrization Issues:"");
			foreach (string error in groupParamErrors) {
				WriteLine(error);
			}
		}

		// Process Configuration property names
		string PROP_CALCULATION_BASE_ACCOUNT = ""Profit (Loss) from Associated Entities (calculation basis)"";
		string PROP_SHARES_ASSOC_ENTITIES_ACCOUNT = ""Shares in Associated Entities"";
		string PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL = ""Shares in Associated Entities Detail for Increases"";
		string PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL = ""Shares in Associated Entities Detail for Decreases"";
		string PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT = ""Profit from Associated Entities"";
		string PROP_PROFIT_ASSOC_ENTITIES_DETAIL = ""Profit from Associated Entities Detail"";
		string PROP_LOSS_ASSOC_ENTITIES_ACCOUNT = ""Loss from Associated Entities"";
		string PROP_LOSS_ASSOC_ENTITIES_DETAIL = ""Loss from Associated Entities Detail"";
		string PROP_DIVIDENDS_BASE_ACCOUNT = ""Dividends received from Associated Entities"";
		string PROP_DIVIDENDS_BASE_DETAIL = ""Dividends received from Associated Entities Detail"";

		// get and validate the Process Configuration
		StringDictionary accountsConfig = CreateStringDictionary();
		accountsConfig[PROP_CALCULATION_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_CALCULATION_BASE_ACCOUNT);
		accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_LOSS_ASSOC_ENTITIES_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_LOSS_ASSOC_ENTITIES_ACCOUNT);
		accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_DIVIDENDS_BASE_ACCOUNT);

		StringDictionary detailsConfig = CreateStringDictionary();
		detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL);
		detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL);
		detailsConfig[PROP_PROFIT_ASSOC_ENTITIES_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_PROFIT_ASSOC_ENTITIES_DETAIL);
		detailsConfig[PROP_LOSS_ASSOC_ENTITIES_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_LOSS_ASSOC_ENTITIES_DETAIL);
		detailsConfig[PROP_DIVIDENDS_BASE_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, ruleid, PROP_DIVIDENDS_BASE_DETAIL);

		StringDictionary detailToAccount = CreateStringDictionary();
		detailToAccount[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL] = PROP_SHARES_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL] = PROP_SHARES_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_PROFIT_ASSOC_ENTITIES_DETAIL] = PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_LOSS_ASSOC_ENTITIES_DETAIL] = PROP_LOSS_ASSOC_ENTITIES_ACCOUNT;
		detailToAccount[PROP_DIVIDENDS_BASE_DETAIL] = PROP_DIVIDENDS_BASE_ACCOUNT;

		bool isValidConfig = CO_ValidateProcessConfiguration(olapConnection, accountsConfig, detailsConfig, detailToAccount);

		// stop the process if there are Process Config or Group Parametrization issues
		if (!isValidConfig or groupParamErrors.Count() > 0) {
			ExitProcess(""Cannot execute the process"");
		}
		// end of validation

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			
			string baseYear = CO_BaseYear(olapConnection, year, period);
			string basePeriod = CO_BasePeriod(olapConnection, period);

			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, ruleid);

			// Get OLAP elements
			OLAPElement calculationBaseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", accountsConfig[PROP_CALCULATION_BASE_ACCOUNT]);
			OLAPElement dividendsBaseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"",  accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);

			// Check if base accounts are expenditure accounts
			bool calculationBaseAccountIsExpenditure = CO_AccountType(olapConnection, calculationBaseAccountElement) == ""Expenditure"";
			bool dividendsBaseAccountIsExpenditure = CO_AccountType(olapConnection, dividendsBaseAccountElement) == ""Expenditure"";

			int counter = 0;

			// Go over all 'equity' companies for equity processing
			foreach (OLAPElement company in companiesEquity)
			{
				// loop over all parent companies which have full or quotal shares
				foreach (OLAPElement parentCompany in companiesFullOrQuotal)
				{
					double ownership = CO_Ownership(olapConnection, cycle, year, period, scenario, group, parentCompany, company);

					if (ownership > 0.0)
					{
						LogDebug(""Processing equity company: "" + company);

						double value = OLAPCellReadNumber(olapConnection, ""TFINANC"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBasis, ""Balance Sheet"", company, ""sum"", accountsConfig[PROP_CALCULATION_BASE_ACCOUNT]);
						double totalValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Consolidated Balance Sheet"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double previousPeriodValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, baseYear, basePeriod, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double currentEquity = 0.0;

						LogDebug(""Current Value  : "" + value);
						LogDebug(""Total Value    : "" + totalValue);
						LogDebug(""Previous Value : "" + previousPeriodValue);

						value = value * ownership;

						if (Abs(totalValue) < 0.0000001)
						{
							currentEquity = previousPeriodValue + value;

							if (currentEquity <= 0.0)
							{
								value = 0.0;
							}
							else
							{
								value = currentEquity;
							}
						}
						else
						{
							if (value < 0.0)
							{
								currentEquity = value + totalValue;
								if (Abs(value) > Abs(totalValue))
								{
									value = -totalValue;
								}
							}
							else
							{
								currentEquity = value + totalValue;
							}
						}

						LogDebug(""Final Book Value   : "" + value);
						LogDebug(""Final Equity Value : "" + currentEquity);

						OLAPCellWriteNumber(olapConnection, ""TFINANG"", currentEquity, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						if (value != 0.0)
						{
							GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Capital"", ruleid, ""Recognition of current year's earnings"", true);

							if ((calculationBaseAccountIsExpenditure and value < 0) or (!calculationBaseAccountIsExpenditure and value > 0))
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL], """", Abs(value), 0.0);
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_PROFIT_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_PROFIT_ASSOC_ENTITIES_DETAIL], """", 0.0, Abs(value));
							}
							else
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL], """", 0.0, Abs(value));
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_LOSS_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_LOSS_ASSOC_ENTITIES_DETAIL], """", Abs(value), 0.0);
							}

							if (!ConsolidationJournalIsEmpty(journal))
							{
								if (ConsolidationJournalIsBalanced(journal))
								{
									ConsolidationPostJournal(journalStore, journal);
									counter++;
								}
								else
								{
									WriteLine(""The journal was not posted as it was unbalanced."");
								}
							}
						}
					}
				}
			}
			
			// Go over all 'equity' companies again for dividend processing
			foreach (OLAPElement company in companiesEquity)
			{
				// loop over all parent companies which have full or quotal shares
				foreach (OLAPElement parentCompany in companiesFullOrQuotal)
				{
					double ownership = CO_Ownership(olapConnection, cycle, year, period, scenario, group, parentCompany, company);
					if (ownership > 0.0)
					{
						LogDebug(""Processing dividends for equity company: "" + company);
						LogDebug(""Base Account: "" + accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);

						double value = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBasis, group, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT]);
						double totalValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Consolidated Balance Sheet"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);
						double currentEquityValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						double difference = 0;

						LogDebug(""Current Value        : "" + value);
						LogDebug(""Total Value          : "" + totalValue);
						LogDebug(""Current Equity Value : "" + currentEquityValue);

						if (Abs(totalValue) < 0.0000001)
						{
							currentEquityValue = currentEquityValue - value;
							value = 0.0;
						}
						else
						{
							currentEquityValue = -value + totalValue;
							if (Abs(totalValue) - Abs(value) > 0)
							{
								value = -Abs(value);
							}
							else
							{
								value= -Abs(totalValue);
							}
						}

						LogDebug(""Final Book Value   : "" + value);
						LogDebug(""Final Equity Value : "" + currentEquityValue);

						OLAPCellWriteNumber(olapConnection, ""TFINANG"", currentEquityValue, cycle, year, period, scenario, groupcurrency, ""Equity Calculation"", group, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT]);

						if (value != 0.0)
						{
							GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Capital"", ruleid, ""Recognition of dividends"", true);
							
							if ((dividendsBaseAccountIsExpenditure and value < 0) or (!dividendsBaseAccountIsExpenditure and value > 0))
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_INCREASE_DETAIL], """", Abs(value), 0.0);
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT], detailsConfig[PROP_DIVIDENDS_BASE_DETAIL], """", 0.0, Abs(value));
							}
							else
							{
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_SHARES_ASSOC_ENTITIES_ACCOUNT], detailsConfig[PROP_SHARES_ASSOC_ENTITIES_DECREASE_DETAIL], """", 0.0, Abs(value));
								ConsolidationAddGroupJournalLine(journal, parentCompany, company, accountsConfig[PROP_DIVIDENDS_BASE_ACCOUNT], detailsConfig[PROP_DIVIDENDS_BASE_DETAIL], """", Abs(value), 0.0);
							}

							if (!ConsolidationJournalIsEmpty(journal))
							{
								if (ConsolidationJournalIsBalanced(journal))
								{
									ConsolidationPostJournal(journalStore, journal);
									counter++;
								}
								else
								{
									WriteLine(""The journal was not posted as it was unbalanced."");
								}
							}
						}
					}
				}
			}
			WriteLine(""posted <"" + counter + ""> journal(s)"");
		}

		result = true;
	}
	catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	A78EF5CC-8935-4EFC-9F8D-56606E0DBC92	This process calculates the particiaption for associated companies.	1	1	1	1683	NULL	0	45708.67502	0	0
6AAAFE27-C287-41B1-81DA-CAEA269A173C	CD491758-D9DF-4002-94C8-8006E1855F86	CO_ExpenditureRevenues	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_BookingType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Schedules"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""DetermineElementDimensionOrder"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_BookingType"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Schedules"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""DetermineElementDimensionOrder"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenues(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenues process.Consolidation of expenditures/revenues for finance and detail data."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_002"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""R"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenues"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			// Constants
			string cubeDetailG  = ""TDETAIG"";
			string cubeFinanceG = ""TFINANG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimDetail       = ""DDETAIL"";
			string dimConsRule     = ""DCONSRL"";
			string consolidationType     = ""Cons. Expenditures/Revenue"";
			string OwnershipQuotal  = ""Quotal"";
			string OwnershipFull    = ""Full"";
			string ExpenditureAccountType = ""Expenditure"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			
			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string stdRule = """";
			string helpKey1 = """";
			string helpKey2 = """";
			double value = 0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isExpenditure = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, dimGroupLevel, consolidationBasis, true);
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList details = CreateOLAPElementList();          //only TDETAIG
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}
			
			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			foreach (OLAPElement sourceDetail in CO_Schedules(olapConnection)) {
				OLAPElementListAddElement(details, sourceDetail);
			}
			
			//stores all processed values of cubeDetailG, so we can check in the loop for cubeFinanceG
			//if a matching cubeDetailG value was found
			LegacyLookupMapInitialize(""processedValues"" + cubeDetailG);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeDetailG);
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeFinanceG);
			
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeDetailG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, details, accounts
			);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				detail = OLAPCellGetElement(cell, dimDetail);
				
				lookupKey = company + ""|"" + interCompany + ""|"" + account + ""|"" + detail;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection, cubeDetailG, 1.0,
					                           cycle,
					                           year,
					                           period,
					                           scenario,
					                           groupCurrency,
					                           consolidationBasis,
					                           group,
					                           company,
					                           interCompany,
					                           detail,
					                           account);
					
					if (value != 0) {
						counter = counter + 1;
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
						
						//use lookup to remember processed values for 2nd DataArea
						lookupKey = company + ""|"" + interCompany + ""|"" + account;
						LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", true);
						
						//store all opened journals by company/interCompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						if (ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination
							journal = ConsolidationCreateGroupJournal(journalStore, cycle,year, period, scenario, group, consolidationType, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						//add the journal lines
						transformedValue = transformedValue * value;

						if (isExpenditure) {
							transformedValue = transformedValue * -1.0;
						}

						if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", 0.0, Abs(transformedValue));
						}
					}
				}
			}
			
			NotifyInformation(""&lt;"" + cubeDetailG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			//create DataArea over second cube
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeFinanceG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, accounts
			);
			
			counter = 0;
			foreach (OLAPCell cell in sourceArea) {
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);

				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + account;
				
				if (!LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", false)) {
					//no value found - go on processing this cell
					
					if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", false) == false) {
						LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", true);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);

						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									//switch companies
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						value = OLAPCellReadNumber(olapConnection, cubeFinanceG, 1.0,
						                           cycle,
						                           year,
						                           period,
						                           scenario,
						                           groupCurrency,
						                           consolidationBasis,
						                           group,
						                           company,
						                           interCompany,
						                           account);
						
						if (value != 0) {
							counter = counter + 1;
							
							if (ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								
								//remember entries in a StringArray
								Append(dictionaryEntries,lookupKey);
							}
							
							transformedValue = transformedValue * value;
							
							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}

							//add the journal lines
							if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", 0.0, Abs(transformedValue));
							}
						}  // end if value != 0.0
					}  // end if already processed finance cube cell
				}  // end if already processed detail cube cell
			}  // end foreach cell in 2nd data area
			
			NotifyInformation(""&lt;"" + cubeFinanceG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary,entry);
				//retrieve elements from key
				keyElements = StringSplit(entry, ""|"");
				company = GetElementByIndex(keyElements, 0);
				interCompany = GetElementByIndex(keyElements, 1);
				stdRule = GetElementByIndex(keyElements, 2);
				OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, stdRule);
				
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				double difference = ConsolidationJournalDifference(openJournal);

				//is there any difference?
				if (RoundDecimals(difference, 4) != 0.0) {
					
					int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);

					string stdDiffRule = """";
					if (bookingType == 1)
					{
						stdDiffRule = stdRule;
					} else
					{
						stdDiffRule = ""100"" + stdRule;
					}

					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);
							
							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", 0.0, -difference);
						}
					}
				}

				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for &lt;"" + entry + ""&gt; was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_BookingType"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Schedules"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""DetermineElementDimensionOrder"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenues(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenues process.Consolidation of expenditures/revenues for finance and detail data."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""CYCLE_002"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""R"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenues"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			// Constants
			string cubeDetailG  = ""TDETAIG"";
			string cubeFinanceG = ""TFINANG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimDetail       = ""DDETAIL"";
			string dimConsRule     = ""DCONSRL"";
			string consolidationType     = ""Cons. Expenditures/Revenue"";
			string OwnershipQuotal  = ""Quotal"";
			string OwnershipFull    = ""Full"";
			string ExpenditureAccountType = ""Expenditure"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			
			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string stdRule = """";
			string helpKey1 = """";
			string helpKey2 = """";
			double value = 0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isExpenditure = false;

			//source filter for TDETAIG / TFINANG
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, dimGroupLevel, consolidationBasis, true);
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList details = CreateOLAPElementList();          //only TDETAIG
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}
			
			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			foreach (OLAPElement sourceDetail in CO_Schedules(olapConnection)) {
				OLAPElementListAddElement(details, sourceDetail);
			}
			
			//stores all processed values of cubeDetailG, so we can check in the loop for cubeFinanceG
			//if a matching cubeDetailG value was found
			LegacyLookupMapInitialize(""processedValues"" + cubeDetailG);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeDetailG);
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cubeFinanceG);
			
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeDetailG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, details, accounts
			);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				detail = OLAPCellGetElement(cell, dimDetail);
				
				lookupKey = company + ""|"" + interCompany + ""|"" + account + ""|"" + detail;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeDetailG, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection, cubeDetailG, 1.0,
					                           cycle,
					                           year,
					                           period,
					                           scenario,
					                           groupCurrency,
					                           consolidationBasis,
					                           group,
					                           company,
					                           interCompany,
					                           detail,
					                           account);
					
					if (value != 0) {
						counter = counter + 1;
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
						
						//use lookup to remember processed values for 2nd DataArea
						lookupKey = company + ""|"" + interCompany + ""|"" + account;
						LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", true);
						
						//store all opened journals by company/interCompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										//no entry yet, find correct sequence of dimension elements
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						if (ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination
							journal = ConsolidationCreateGroupJournal(journalStore, cycle,year, period, scenario, group, consolidationType, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						//add the journal lines
						transformedValue = transformedValue * value;

						if (isExpenditure) {
							transformedValue = transformedValue * -1.0;
						}

						if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail, """", 0.0, Abs(transformedValue));
						}
					}
				}
			}
			
			NotifyInformation(""<"" + cubeDetailG + ""> processed <"" + counter + ""> value(s)"");
			
			//create DataArea over second cube
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeFinanceG, OlapDataAreaIncludeB | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNone, 0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, levels,
				group, companies, intercompanies, accounts
			);
			
			counter = 0;
			foreach (OLAPCell cell in sourceArea) {
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);

				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + account;
				
				if (!LegacyLookupMapLookupKey(""processedValues"" + cubeDetailG, lookupKey, """", false)) {
					//no value found - go on processing this cell
					
					if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", false) == false) {
						LegacyLookupMapLookupKey(""baseValueAccelerator"" + cubeFinanceG, lookupKey, """", true);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);

						OLAPElement elCompany = OLAPGetDimensionElement(olapConnection, dimCompany, company);
						OLAPElement elInterCompany = OLAPGetDimensionElement(olapConnection, dimIntercompany, interCompany);
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
						isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
						foreach (OLAPElement consolidationRule in rules) {
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorContraAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end IsAccount
							else if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								transformedValue = factorContraAccount;
								
								// Check whether one or two journals per company/intercompany should be created
								if (CO_BookingType(olapConnection, cycle, consolidationRule) == 2) {
									//switch companies
									lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule;
								} else {
									if (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == OwnershipQuotal and
									    CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, interCompany) == OwnershipQuotal) {
										transformedValue = factorAccount;
									}
									helpKey1 = company + ""|"" + interCompany + ""|"" + consolidationRule;
									helpKey2 = interCompany + ""|"" + company + ""|"" + consolidationRule;
									
									if (ContainsKey(journalDictionary, helpKey1)) {
										lookupKey = helpKey1;
									} else if (ContainsKey(journalDictionary, helpKey2)) {
										lookupKey = helpKey2;
									} else {
										if (DetermineElementDimensionOrder(companies, elCompany, elInterCompany)) {
											lookupKey = helpKey1;
										} else {
											lookupKey = helpKey2;
										}
									}
								}
							}  // end isContraAccount
						}  // end foreach consolidationRule
						
						value = OLAPCellReadNumber(olapConnection, cubeFinanceG, 1.0,
						                           cycle,
						                           year,
						                           period,
						                           scenario,
						                           groupCurrency,
						                           consolidationBasis,
						                           group,
						                           company,
						                           interCompany,
						                           account);
						
						if (value != 0) {
							counter = counter + 1;
							
							if (ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination
								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								
								//remember entries in a StringArray
								Append(dictionaryEntries,lookupKey);
							}
							
							transformedValue = transformedValue * value;
							
							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}

							//add the journal lines
							if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """", """", 0.0, Abs(transformedValue));
							}
						}  // end if value != 0.0
					}  // end if already processed finance cube cell
				}  // end if already processed detail cube cell
			}  // end foreach cell in 2nd data area
			
			NotifyInformation(""<"" + cubeFinanceG + ""> processed <"" + counter + ""> value(s)"");
			
			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary,entry);
				//retrieve elements from key
				keyElements = StringSplit(entry, ""|"");
				company = GetElementByIndex(keyElements, 0);
				interCompany = GetElementByIndex(keyElements, 1);
				stdRule = GetElementByIndex(keyElements, 2);
				OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, stdRule);
				
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				double difference = ConsolidationJournalDifference(openJournal);

				//is there any difference?
				if (RoundDecimals(difference, 4) != 0.0) {
					
					int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);

					string stdDiffRule = """";
					if (bookingType == 1)
					{
						stdDiffRule = stdRule;
					} else
					{
						stdDiffRule = ""100"" + stdRule;
					}

					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     ""-"", ""-"", ""-"", ""-"", ""-"", ""-"", strTransactDebit, stdDiffRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);
							
							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""],  differenceAccount, differenceDetail, """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, stdRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail, """", 0.0, -difference);
						}
					}
				}

				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for <"" + entry + ""> was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	FC7C9597-632E-479B-BBFA-F13D65D19901	Former FCExpenditureRevenues process.Consolidation of expenditures/revenues for finance and detail data.	1	1	1	1684	NULL	0	45708.67502	0	0
772F7D11-095C-45F7-A831-3DF17E1910D1	CD491758-D9DF-4002-94C8-8006E1855F86	CO_ExpenditureRevenuesSegment	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_PrimarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_SecondarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_TertiarySegments"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_PrimarySegments"", ""*""
#include ""CO_SecondarySegments"", ""*""
#include ""CO_TertiarySegments"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenuesSegment(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenuesSegment process. Consolidation of Expenditure/Revenues for hierarchical segments."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HR"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenuesSegment"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if(!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");
		
		if(!cancel) {
			// Constants
			string psegm1Read = ""Sum"";
			string psegm2Read = ""Sum"";
			string psegm3Read = ""Sum"";
			string cubeTSegmG  = ""TSEGMG"";
			string cubeTSegmovG  = ""TSEGMOVG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimConsRule     = ""DCONSRL"";
			string dimPrimarySegment           = ""DPSEGM"";
			string dimPrimaryPartnerSegment    = ""DPRSEGM"";
			string dimSecondarySegment         = ""DSSEGM"";
			string dimSecondaryPartnerSegment  = ""DSRSEGM"";
			string dimTertiarySegment          = ""DTSEGM"";
			string dimTertiaryPartnerSegment   = ""DTRSEGM"";
			string consStage              = ""Consolidated Segments"";
			string consolidationType      = ""Cons. Expenditures/Revenue"";
			string OwnershipQuotal        = ""Quotal"";
			string OwnershipFull          = ""Full"";
			string ExpenditureAccountType  	  = ""Expenditure"";
			string noSegment              = ""-"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";

			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string detail = """";
			string company = """";
			string interCompany = """";
			string primarySegment = """";
			string primaryPartnerSegment = """";
			string secondarySegment = """";
			string secondaryPartnerSegment = """";
			string tertiarySegment = """";
			string tertiaryPartnerSegment = """";
			string helpKey = """";
			double valueAcc = 0.0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isExpenditure = false;
			
			//source filter for TDETAIG / TFINANG
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList primarySegments = CreateOLAPElementList();
			OLAPElementList primaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimPrimaryPartnerSegment, psegm1Read, true);
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimSecondaryPartnerSegment, psegm2Read, true);
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimTertiaryPartnerSegment, psegm3Read, true);
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement aSegment in CO_PrimarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
				OLAPElementListAddElement(primarySegments, aSegment);
			}

			if (CO_HasSegment(olapConnection, cycle, 2)) {
				foreach (OLAPElement aSegment in CO_SecondarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(secondarySegments, aSegment);
				}
				NotifyInformation(""Using segment2"");
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, dimSecondarySegment, noSegment));
				secondaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(secondaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimSecondaryPartnerSegment, noSegment));
			}

			if (CO_HasSegment(olapConnection, cycle, 3)) {
				foreach (OLAPElement aSegment in CO_TertiarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(tertiarySegments, aSegment);
				}
				NotifyInformation(""Using segment3"");
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, dimTertiarySegment, noSegment));
				tertiaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(tertiaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimTertiaryPartnerSegment, noSegment));
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					   (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}

			//stores all processed values of cubeSegmovG, so we can check in the loop for cubeSegmG
			//if a matching detail value was found
			LegacyLookupMapInitialize(""processedValues"");

			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmovG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				OlapDataAreaBCells, accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
				detail = OLAPCellGetElement(cell, ""DDETAIL"");

				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				valueAcc = cell;
				
				counter = counter + 1;
				
				//use lookup to remember processed values for 2nd DataArea
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;

				LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", true);

				factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
				factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
				
				//get consolidationRule linked to the account
				foreach (OLAPElement consolidationRule in rules) {
					transformedValue = 0.0;
					if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorAccount;
						lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
							""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

					} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorContraAccount;
						lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
							""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
					}
					
					if (transformedValue != 0.0) {
						if(ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination

							string targetSegment = ""Intersegment"";
							if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
								targetSegment = ""Intrasegment"";
							}

							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						if (isExpenditure) {
							transformedValue = transformedValue * -1.0;
						}

						if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", 0.0, Abs(transformedValue));
						}
					}
				}  // end foreach consolidationRule
			}
			
			NotifyInformation(""&lt;"" + cubeTSegmovG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			
			
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
				
				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;
				
				if(!LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", false)) {
					//no value found - go on processing this cell

					valueAcc = cell;
					
					counter = counter + 1;
					
					factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
					factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
					
					//get consolidationRule linked to the account
					foreach (OLAPElement consolidationRule in rules) {
						transformedValue = 0.0;
						if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorAccount;
							lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
								""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

						} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorContraAccount;
							lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
								""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
						}
						
						if (transformedValue != 0.0) {
							if(ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination

								string targetSegment = ""Intersegment"";
								if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
									targetSegment = ""Intrasegment"";
								}

								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								//remember entries in a StringArray
								Append(dictionaryEntries, lookupKey);
							}
							
							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}
							
							if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", 0.0, Abs(transformedValue));
							}
						}
					}  // end foreach consolidationRule
				}
			}
			
			NotifyInformation(""&lt;"" + cubeTSegmG + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			

			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary, entry);
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0.0) {
					//retrieve elements from key
					keyElements = StringSplit(entry, ""|"");
					company = GetElementByIndex(keyElements, 0);
					interCompany = GetElementByIndex(keyElements, 1);
					helpKey = GetElementByIndex(keyElements, 2);
					primarySegment = GetElementByIndex(keyElements, 3);
					primaryPartnerSegment = GetElementByIndex(keyElements, 4);
					secondarySegment = GetElementByIndex(keyElements, 5);
					secondaryPartnerSegment = GetElementByIndex(keyElements, 6);
					tertiarySegment = GetElementByIndex(keyElements, 7);
					tertiaryPartnerSegment = GetElementByIndex(keyElements, 8);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, helpKey);
					
					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    primarySegment, primaryPartnerSegment,
					                    secondarySegment, secondaryPartnerSegment,
					                    tertiarySegment, tertiaryPartnerSegment,
					                    strTransactDebit, ""100"" + consolidationRule))
					{

						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     primarySegment, primaryPartnerSegment,
						                                                     secondarySegment, secondaryPartnerSegment,
						                                                     tertiarySegment, tertiaryPartnerSegment,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -difference);
						}
					}
				}
				
				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for &lt;"" + entry + ""&gt; was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountType"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_PrimarySegments"", ""*""
#include ""CO_SecondarySegments"", ""*""
#include ""CO_TertiarySegments"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenuesSegment(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenuesSegment process. Consolidation of Expenditure/Revenues for hierarchical segments."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""CYCLE_001"";
	year = ""2015"";
	period = ""01"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HR"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenuesSegment"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if(!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");
		
		if(!cancel) {
			// Constants
			string psegm1Read = ""Sum"";
			string psegm2Read = ""Sum"";
			string psegm3Read = ""Sum"";
			string cubeTSegmG  = ""TSEGMG"";
			string cubeTSegmovG  = ""TSEGMOVG"";
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string dimCompany      = ""DCOMPC"";
			string dimIntercompany = ""DINTCO"";
			string dimGroupLevel   = ""DGLEVEL"";
			string dimAccount      = ""DACOUNT"";
			string dimConsRule     = ""DCONSRL"";
			string dimPrimarySegment           = ""DPSEGM"";
			string dimPrimaryPartnerSegment    = ""DPRSEGM"";
			string dimSecondarySegment         = ""DSSEGM"";
			string dimSecondaryPartnerSegment  = ""DSRSEGM"";
			string dimTertiarySegment          = ""DTSEGM"";
			string dimTertiaryPartnerSegment   = ""DTRSEGM"";
			string consStage              = ""Consolidated Segments"";
			string consolidationType      = ""Cons. Expenditures/Revenue"";
			string OwnershipQuotal        = ""Quotal"";
			string OwnershipFull          = ""Full"";
			string ExpenditureAccountType  	  = ""Expenditure"";
			string noSegment              = ""-"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";

			// Variables
			GroupJournalDictionary journalDictionary = CreateGroupJournalDictionary();
			GroupJournal journal = null;
			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			string lookupKey = """";
			string account = """";
			string detail = """";
			string company = """";
			string interCompany = """";
			string primarySegment = """";
			string primaryPartnerSegment = """";
			string secondarySegment = """";
			string secondaryPartnerSegment = """";
			string tertiarySegment = """";
			string tertiaryPartnerSegment = """";
			string helpKey = """";
			double valueAcc = 0.0;
			double transformedValue = 0;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double factorAccount = 1.0;
			double factorContraAccount = 1.0;
			bool isExpenditure = false;
			
			//source filter for TDETAIG / TFINANG
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList intercompanies = CreateOLAPElementList();
			OLAPElementList primarySegments = CreateOLAPElementList();
			OLAPElementList primaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimPrimaryPartnerSegment, psegm1Read, true);
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimSecondaryPartnerSegment, psegm2Read, true);
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiaryPartnerSegments = OLAPGetChildElementList(olapConnection, dimTertiaryPartnerSegment, psegm3Read, true);
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rules = CreateOLAPElementList();
			
			string str = """";
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle)) {
				str = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany);
				if (str == OwnershipFull or str == OwnershipQuotal) {
					OLAPElementListAddElement(companies, sourceCompany);
					OLAPElementListAddElement(intercompanies, sourceCompany);
				}
			}

			foreach (OLAPElement aSegment in CO_PrimarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
				OLAPElementListAddElement(primarySegments, aSegment);
			}

			if (CO_HasSegment(olapConnection, cycle, 2)) {
				foreach (OLAPElement aSegment in CO_SecondarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(secondarySegments, aSegment);
				}
				NotifyInformation(""Using segment2"");
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, dimSecondarySegment, noSegment));
				secondaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(secondaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimSecondaryPartnerSegment, noSegment));
			}

			if (CO_HasSegment(olapConnection, cycle, 3)) {
				foreach (OLAPElement aSegment in CO_TertiarySegments(olapConnection, cycle) where (aSegment != noSegment)) {
					OLAPElementListAddElement(tertiarySegments, aSegment);
				}
				NotifyInformation(""Using segment3"");
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, dimTertiarySegment, noSegment));
				tertiaryPartnerSegments = CreateOLAPElementList();
				OLAPElementListAddElement(tertiaryPartnerSegments, OLAPGetDimensionElement(olapConnection, dimTertiaryPartnerSegment, noSegment));
			}

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rules, consolidationRule);
			}
			
			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle)) {
				foreach (OLAPElement consolidationRule in rules) {
					if((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					   (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}

			//stores all processed values of cubeSegmovG, so we can check in the loop for cubeSegmG
			//if a matching detail value was found
			LegacyLookupMapInitialize(""processedValues"");

			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmovG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				OlapDataAreaBCells, accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
				detail = OLAPCellGetElement(cell, ""DDETAIL"");

				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				valueAcc = cell;
				
				counter = counter + 1;
				
				//use lookup to remember processed values for 2nd DataArea
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;

				LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", true);

				factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
				factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
				
				//get consolidationRule linked to the account
				foreach (OLAPElement consolidationRule in rules) {
					transformedValue = 0.0;
					if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorAccount;
						lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
							""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

					} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
						transformedValue = valueAcc * factorContraAccount;
						lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
							""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
					}
					
					if (transformedValue != 0.0) {
						if(ContainsKey(journalDictionary, lookupKey)) {
							//journal for this combination exists already
							journal = GetEntry(journalDictionary, lookupKey);
						} else {
							//open a new journal for this combination

							string targetSegment = ""Intersegment"";
							if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
								targetSegment = ""Intrasegment"";
							}

							journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
							AddEntry(journalDictionary, lookupKey, journal);
							//remember entries in a StringArray
							Append(dictionaryEntries, lookupKey);
						}
						
						if (isExpenditure) {
							transformedValue = transformedValue * -1.0;
						}

						if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", Abs(transformedValue), 0.0);
						} else {
							ConsolidationAddGroupJournalLine(journal, company, interCompany, account, detail,
							                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
							                                        """", 0.0, Abs(transformedValue));
						}
					}
				}  // end foreach consolidationRule
			}
			
			NotifyInformation(""<"" + cubeTSegmovG + ""> processed <"" + counter + ""> value(s)"");
			
			
			sourceArea = OLAPCreateDataArea(
				olapConnection, cubeTSegmG, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, year, period, scenario, groupCurrency, consolidationBasis, group, consStage, companies, intercompanies,
				primarySegments, primaryPartnerSegments, secondarySegments, secondaryPartnerSegments, tertiarySegments, tertiaryPartnerSegments,
				accounts
			);

			counter = 0;
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, dimCompany);
				interCompany = OLAPCellGetElement(cell, dimIntercompany);
				account = OLAPCellGetElement(cell, dimAccount);
				OLAPElement acc = OLAPGetDimensionElement(olapConnection, dimAccount, account);
				isExpenditure = CO_AccountType(olapConnection, acc) == ExpenditureAccountType;
				
				primarySegment = OLAPCellGetElement(cell, dimPrimarySegment);
				primaryPartnerSegment = OLAPCellGetElement(cell, dimPrimaryPartnerSegment);
				secondarySegment = OLAPCellGetElement(cell, dimSecondarySegment);
				secondaryPartnerSegment = OLAPCellGetElement(cell, dimSecondaryPartnerSegment);
				tertiarySegment = OLAPCellGetElement(cell, dimTertiarySegment);
				tertiaryPartnerSegment = OLAPCellGetElement(cell, dimTertiaryPartnerSegment);
				
				//check if a value for this cell-coordinates exists in cubeDetailG
				lookupKey = company + ""|"" + interCompany + ""|"" + primarySegment + ""|"" + primaryPartnerSegment + ""|"" + secondarySegment + ""|"" + secondaryPartnerSegment
					+ ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + account;
				
				if(!LegacyLookupMapLookupKey(""processedValues"", lookupKey, """", false)) {
					//no value found - go on processing this cell

					valueAcc = cell;
					
					counter = counter + 1;
					
					factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
					factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
					
					//get consolidationRule linked to the account
					foreach (OLAPElement consolidationRule in rules) {
						transformedValue = 0.0;
						if(CO_IsAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorAccount;
							lookupKey = company + ""|"" + interCompany + ""|"" + consolidationRule + ""|"" + primarySegment + ""|"" + primaryPartnerSegment +
								""|"" + secondarySegment + ""|"" + secondaryPartnerSegment + ""|"" + tertiarySegment + ""|"" + tertiaryPartnerSegment;

						} else if(CO_IsContraAccount(olapConnection, cycle, account, consolidationRule)) {
							transformedValue = valueAcc * factorContraAccount;
							lookupKey = interCompany + ""|"" + company + ""|"" + consolidationRule + ""|"" + primaryPartnerSegment + ""|"" + primarySegment +
								""|"" + secondaryPartnerSegment + ""|"" + secondarySegment + ""|"" + tertiaryPartnerSegment + ""|"" + tertiarySegment;
						}
						
						if (transformedValue != 0.0) {
							if(ContainsKey(journalDictionary, lookupKey)) {
								//journal for this combination exists already
								journal = GetEntry(journalDictionary, lookupKey);
							} else {
								//open a new journal for this combination

								string targetSegment = ""Intersegment"";
								if (primarySegment == primaryPartnerSegment and secondarySegment == secondaryPartnerSegment and tertiarySegment == tertiaryPartnerSegment) {
									targetSegment = ""Intrasegment"";
								}

								journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, targetSegment, ruleid, """", true);
								AddEntry(journalDictionary, lookupKey, journal);
								//remember entries in a StringArray
								Append(dictionaryEntries, lookupKey);
							}
							
							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}
							
							if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(journal, company, interCompany, account, """",
								                                        primarySegment, primaryPartnerSegment, secondarySegment, secondaryPartnerSegment, tertiarySegment, tertiaryPartnerSegment,
								                                        """", 0.0, Abs(transformedValue));
							}
						}
					}  // end foreach consolidationRule
				}
			}
			
			NotifyInformation(""<"" + cubeTSegmG + ""> processed <"" + counter + ""> value(s)"");
			

			counter = 0;

			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(journalDictionary, entry);
				// after the journal was filled get the total debit/credit difference and add a line with the difference to balance the journal
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0.0) {
					//retrieve elements from key
					keyElements = StringSplit(entry, ""|"");
					company = GetElementByIndex(keyElements, 0);
					interCompany = GetElementByIndex(keyElements, 1);
					helpKey = GetElementByIndex(keyElements, 2);
					primarySegment = GetElementByIndex(keyElements, 3);
					primaryPartnerSegment = GetElementByIndex(keyElements, 4);
					secondarySegment = GetElementByIndex(keyElements, 5);
					secondaryPartnerSegment = GetElementByIndex(keyElements, 6);
					tertiarySegment = GetElementByIndex(keyElements, 7);
					tertiaryPartnerSegment = GetElementByIndex(keyElements, 8);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, dimConsRule, helpKey);
					
					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    primarySegment, primaryPartnerSegment,
					                    secondarySegment, secondaryPartnerSegment,
					                    tertiarySegment, tertiaryPartnerSegment,
					                    strTransactDebit, ""100"" + consolidationRule))
					{

						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     primarySegment, primaryPartnerSegment,
						                                                     secondarySegment, secondaryPartnerSegment,
						                                                     tertiarySegment, tertiaryPartnerSegment,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {
							string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
								                                 primarySegment, primaryPartnerSegment,
								                                 secondarySegment, secondaryPartnerSegment,
								                                 tertiarySegment, tertiaryPartnerSegment, """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}
					
					if (RoundDecimals(difference, 4) != 0.0) {
						string differenceAccount = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccount, differenceDetail,
							                                 primarySegment, primaryPartnerSegment,
							                                 secondarySegment, secondaryPartnerSegment,
							                                 tertiarySegment, tertiaryPartnerSegment, """", 0.0, -difference);
						}
					}
				}
				
				// if the journal has lines and is balanced it will be posted
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					difference = ConsolidationJournalDifference(openJournal);
					if (RoundDecimals(difference, 4) == 0) {
						if (CO_ValidateGroupJournal(openJournal, true)) {
							ConsolidationPostJournal(journalStore, openJournal);
							counter = counter + 1;
						}
					} else {
						NotifyError(""The journal for <"" + entry + ""> was not posted as it was unbalanced. Diff: "" + difference);
					}
				}
			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	93CAD5EF-3593-47D7-A590-2F175C56FBBF	Former FCExpenditureRevenuesSegment process. Consolidation of Expenditure/Revenues for hierarchical segments.	1	1	1	1685	NULL	0	45708.67501	0	0
4DDBC238-D794-4DED-A04C-8530916DA067	CD491758-D9DF-4002-94C8-8006E1855F86	CO_ExpenditureRevenuesSegmentElim	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsContraAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsRuleType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Processes"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Accounts"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEliminationElement"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_EliminationFactor"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateGroupJournal"" process-version=""*"" process-id="""" />
    <process process-name=""SortStringArray"" process-version=""*"" process-id="""" />
    <process process-name=""OLAPGetChildElementListOrItself"" process-version=""*"" process-id="""" />
    <process process-name=""CO_DifferenceSide"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetEntityIntercompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetEliminationElement"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""SortStringArray"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenuesSegmentElim(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenuesSegmentElim process., Hierarchical Consolidation of Expenditure/Revenues with hierarchical segmentation."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HR"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenuesSegmentElim"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			GroupJournalDictionary groupSegmentJournalDictionary = CreateGroupJournalDictionary();
			GroupJournal groupSegmentJournal = null;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double counter2 = 0;
			double value = 0;
			double transformedValue = 0;
			double factor = 0;
			string lookupKey = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string unassigned = ""Unassigned"";
			string segment = """";
			string segmentPartner = """";
			string secondarySegment = """";
			string secondarySegmentPartner = """";
			string tertiarySegment = """";
			string tertiarySegmentPartner = """";
			string segmentRoot = ""TOTAL"";
			string secondarySegmentRoot = ""TOTAL"";
			string tertiarySegmentRoot = ""TOTAL"";
			string account = """";
			string help = """";
			bool isExpenditure = false;
			double factorAccount = 0;
			double factorContraAccount = 0;
			string segmentLevel = ""Intersegment"";
			string eliminationSuffix = ""_Elim"";
			string segmentElimination = """";
			string secondarySegmentElimination = """";
			string tertiarySegmentElimination = """";
			string consolidationType = ""Cons. Expenditures/Revenue"";

			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, ""DGLEVEL"", consolidationBasis, true);
			
			//Companies
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList interCompanies = CreateOLAPElementList();
			
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle) where (
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Full"") or
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Quotal"")))
			{
				OLAPElementListAddElement(companies, sourceCompany);
				OLAPElementListAddElement(interCompanies, sourceCompany);
			}
			
			//segments (primary, secondary, tertiary)
			OLAPElementList segments = OLAPGetChildElementList(olapConnection, ""DPSEGM"", segmentRoot, true);
			OLAPElementList segmentsPartner = OLAPGetChildElementList(olapConnection, ""DPRSEGM"", segmentRoot, true);
			
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 2)) {
				secondarySegments = OLAPGetChildElementList(olapConnection, ""DSSEGM"", secondarySegmentRoot, true);
				secondarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DSRSEGM"", secondarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, ""DSSEGM"", ""-""));
				OLAPElementListAddElement(secondarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DSRSEGM"", ""-""));
			}
			
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 3)) {
				tertiarySegments = OLAPGetChildElementList(olapConnection, ""DTSEGM"", tertiarySegmentRoot, true);
				tertiarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DTRSEGM"", tertiarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, ""DTSEGM"", ""-""));
				OLAPElementListAddElement(tertiarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DTRSEGM"", ""-""));
			}

			//Accounts
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rulesList = CreateOLAPElementList();

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rulesList, consolidationRule);
			}

			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle))
			{
				foreach (OLAPElement consolidationRule in rulesList)
				{
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//Source Definition for TSEGMG
			string cube1 = ""TSEGMG"";
			string cube2 = ""TSEGMOVG"";
			string sourceDYEAR = year; 			  					 //DYEAR
			string sourceDPERIOD = period; 		  					 //DPERIOD
			string sourceDVERSIO = scenario; 							 //DVERSIO
			string sourceDGCURR = groupCurrency; 						 //DGCURR
			OLAPElementList sourceDGLEVEL = levels; 		  			//DGLEVEL
			string sourceDGROUP = group; 								 //DGROUP
			string sourceDSTAGE = ""Consolidated Segments"";				 //DSTAGE
			OLAPElementList sourceDCOMPC = companies; 					//DCOMPC
			OLAPElementList sourceDINTCO = interCompanies;				//DINTCO
			OLAPElementList sourceDPSEGM = segments; 		 			//DPSEGM
			OLAPElementList sourceDPRSEGM = segmentsPartner; 			 //DPRSEGM
			OLAPElementList sourceDSSEGM = secondarySegments; 			//DSSEGM
			OLAPElementList sourceDSRSEGM = secondarySegmentsPartner; 	//DSRSEGM
			OLAPElementList sourceDTSEGM = tertiarySegments;  			//DTSEGM
			OLAPElementList sourceDTRSEGM = tertiarySegmentsPartner; 	 //DTRSEGM
			OLAPElementList sourceDACOUNT = accounts; 					//DACOUNT
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cube1, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDGCURR, sourceDGLEVEL, sourceDGROUP, sourceDSTAGE, sourceDCOMPC, sourceDINTCO,
				sourceDPSEGM, sourceDPRSEGM, sourceDSSEGM, sourceDSRSEGM, sourceDTSEGM, sourceDTRSEGM, sourceDACOUNT
			);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cube1);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, ""DCOMPC"");
				interCompany = OLAPCellGetElement(cell, ""DINTCO"");
				segment = OLAPCellGetElement(cell, ""DPSEGM"");
				segmentPartner = OLAPCellGetElement(cell, ""DPRSEGM"");
				secondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
				secondarySegmentPartner = OLAPCellGetElement(cell, ""DSRSEGM"");
				tertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
				tertiarySegmentPartner = OLAPCellGetElement(cell, ""DTRSEGM"");
				account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				lookupKey = company + ""|"" + interCompany + ""|"" + segment + ""|"" + segmentPartner + ""|"" +
					secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + account;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection,cube1,1,
					                           OLAPCellGetElement(cell, ""BPDCYCLE""),
					                           OLAPCellGetElement(cell, ""DYEAR""),
					                           OLAPCellGetElement(cell, ""DPERIOD""),
					                           OLAPCellGetElement(cell, ""DVERSIO""),
					                           OLAPCellGetElement(cell, ""DGCURR""),
					                           consolidationBasis,
					                           OLAPCellGetElement(cell, ""DGROUP""),
					                           OLAPCellGetElement(cell, ""DSTAGE""),
					                           OLAPCellGetElement(cell, ""DCOMPC""),
					                           OLAPCellGetElement(cell, ""DINTCO""),
					                           OLAPCellGetElement(cell, ""DPSEGM""),
					                           OLAPCellGetElement(cell, ""DPRSEGM""),
					                           OLAPCellGetElement(cell, ""DSSEGM""),
					                           OLAPCellGetElement(cell, ""DSRSEGM""),
					                           OLAPCellGetElement(cell, ""DTSEGM""),
					                           OLAPCellGetElement(cell, ""DTRSEGM""),
					                           OLAPCellGetElement(cell, ""DACOUNT""));
					
					if (value != 0) {
						counter = counter + 1;
						
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						isExpenditure = CO_AccountType(olapConnection, acc) == ""Expenditure"";
						
						//store all opened journals by company/intercompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rulesList)
						{
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true or
							    CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								
								/*
								determine Elimination Element through dimension hierarchy
									
								direct elimination elements (under _CONSOL elements) are created without the _CONSOL part
								all other elimination elements are C-Element + _CONSOL
								
								-Germany
								  -Germany_ELIM
								  -MUC_CONSOL
								    -MUC_ELIM
								    -MUC
								  -HAN_CONSOL
								    -HAN_ELIM
								    -HAN
								 */
								
								//segment
								segmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DPSEGM"",
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segment),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentPartner),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentRoot));
								
								segmentElimination = segmentElimination + eliminationSuffix;
								
								//secondarySegment
								if (CO_HasSegment(olapConnection, cycle, 2)) {
									secondarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DSSEGM"",
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegment),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentPartner),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentRoot));
									
									secondarySegmentElimination = secondarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									secondarySegmentElimination = secondarySegment;
								}
								
								//tertiarySegment
								if (CO_HasSegment(olapConnection, cycle, 3)) {
									tertiarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DTSEGM"",
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegment),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentPartner),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentRoot));
									
									tertiarySegmentElimination = tertiarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									tertiarySegmentElimination = tertiarySegment;
								}
							}
							
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								lookupKey = company + ""|"" + interCompany + ""|"" +
									segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
									secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorAccount;
							}
							if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								//switch company/intercompany and segment/partnersegment for all 3 dims
								lookupKey = interCompany + ""|"" + company + ""|"" +
									segmentPartner + ""|"" + segment + ""|"" + segmentElimination + ""|"" +
									secondarySegmentPartner + ""|"" + secondarySegment + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorContraAccount;
							}
						}
						
						if (ContainsKey(groupSegmentJournalDictionary, lookupKey)) {
							//groupSegmentJournal for this combination exists already
							groupSegmentJournal = GetEntry(groupSegmentJournalDictionary, lookupKey);
						} else {
							//open a new groupSegmentJournal for this combination
							groupSegmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, segmentLevel, ruleid, ""ID &lt;"" + counter + ""&gt;"", true);
							AddEntry(groupSegmentJournalDictionary, lookupKey, groupSegmentJournal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries,lookupKey);
						}
						
						/*  DACOUNT(DETAIL) -&gt; DDETPA
							DDETPA(TOP_ACC) -&gt; DDETAIL -&gt; all N Childs
							-&gt;DataArea TSEGMOVG */
						
						//determine if TSEGMOVG holds the values split up by DDETAIL - use them instead
						string accountDetail = cached OLAPGetStringAttribute(olapConnection, acc, ""DETAIL"");
						if (accountDetail != """") {
							//read values from TSEGMOVG
							//with Detail
							
							string topAccount = cached OLAPGetStringAttribute(olapConnection, OLAPGetDimensionElement(olapConnection, ""DDETPA"", accountDetail), ""TOP_ACC"");
							OLAPElementList details = OLAPGetChildElementListOrItself(olapConnection, ""DDETAIL"", topAccount, true);
							
							OLAPDataArea sourceArea2 = OLAPCreateDataArea(
								olapConnection2, cube2, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
								OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
								OLAPCellGetElement(cell, ""BPDCYCLE""), OLAPCellGetElement(cell, ""DYEAR""), OLAPCellGetElement(cell, ""DPERIOD""), OLAPCellGetElement(cell, ""DVERSIO""),
								OLAPCellGetElement(cell, ""DGCURR""), consolidationBasis, OLAPCellGetElement(cell, ""DGROUP""),
								OLAPCellGetElement(cell, ""DSTAGE""), OLAPCellGetElement(cell, ""DCOMPC""), OLAPCellGetElement(cell, ""DINTCO""),
								OLAPCellGetElement(cell, ""DPSEGM""), OLAPCellGetElement(cell, ""DPRSEGM""),
								OLAPCellGetElement(cell, ""DSSEGM""), OLAPCellGetElement(cell, ""DSRSEGM""), OLAPCellGetElement(cell, ""DTSEGM""),
								OLAPCellGetElement(cell, ""DTRSEGM""), details, OLAPCellGetElement(cell, ""DACOUNT"")
							);
							
							foreach (OLAPCell cell2 in sourceArea2)
							{
								counter2 = counter2 + 1;
								
								detail = OLAPCellGetElement(cell2, ""DDETAIL"");
								value = cell2;
								
								transformedValue = value * factor;

								if (isExpenditure) {
									transformedValue = transformedValue * -1.0;
								}

								//add the groupSegmentJournal lines
								if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", Abs(transformedValue), 0.0);
								} else {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", 0.0, Abs(transformedValue));
								}
							}
						} else {
							//handle the value coming from TSEGMG
							//no Detail
							
							transformedValue = value * factor;

							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}

							//add the groupSegmentJournal lines
							if ((isExpenditure and transformedValue &lt; 0) or (!isExpenditure and transformedValue &gt; 0)) {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM &lt;"" + segment + ""&gt;"", 0.0, Abs(transformedValue));
							}
						}
					}
				}
			}
			
			NotifyInformation(""&lt;"" + cube1 + ""&gt; processed &lt;"" + counter + ""&gt; value(s)"");
			NotifyInformation(""&lt;"" + cube2 + ""&gt; processed &lt;"" + counter2 + ""&gt; value(s)"");
			
			//sort entries
			SortStringArray(dictionaryEntries);
			
			NotifyInformation(""sorted entries"");
			
			//loop all journals and post them
			counter = 0;
			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(groupSegmentJournalDictionary,entry);
				
				
				/*lookupKey = company + ""|"" + interCompany + ""|"" +
								segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
								secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
								tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
								consolidationRule;*/
				
				keyElements = StringSplit(entry,""|"");
				company = GetElementByIndex(keyElements,0);
				interCompany = GetElementByIndex(keyElements,1);
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0) {
					segment = GetElementByIndex(keyElements,2);
					segmentPartner = GetElementByIndex(keyElements,3);
					segmentElimination = GetElementByIndex(keyElements,4);
					
					secondarySegment = GetElementByIndex(keyElements,5);
					secondarySegmentPartner = GetElementByIndex(keyElements,6);
					secondarySegmentElimination = GetElementByIndex(keyElements,7);
					
					tertiarySegment = GetElementByIndex(keyElements,8);
					tertiarySegmentPartner = GetElementByIndex(keyElements,9);
					tertiarySegmentElimination = GetElementByIndex(keyElements,10);
					
					help = GetElementByIndex(keyElements,11);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, ""DCONSRL"", help);

					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    segment, segmentPartner,
					                    secondarySegment, secondarySegmentPartner,
					                    tertiarySegment, tertiarySegmentPartner,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     segment, segmentPartner,
						                                                     secondarySegment, secondarySegmentPartner,
						                                                     tertiarySegment, tertiarySegmentPartner,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							string differenceAccountFX = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceAccountFXDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx &gt; 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {

						string differenceAccountOther = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceAccountOtherDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference &gt; 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", 0.0, -difference);

						}
					}
				}
				
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					if (CO_ValidateGroupJournal(openJournal, true)) {
						ConsolidationPostJournal(journalStore, openJournal);
						counter = counter + 1;
					}
				}

			}
			
			NotifyInformation(""posted &lt;"" + counter + ""&gt; journal(s)"");
		}
		

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_HasSegment"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_IsAccount"", ""*""
#include ""CO_IsContraAccount"", ""*""
#include ""CO_IsRuleType"", ""*""
#include ""CO_Processes"", ""*""
#include ""CO_Accounts"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetEliminationElement"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_EliminationFactor"", ""*""
#include ""CO_ValidateGroupJournal"", ""*""
#include ""SortStringArray"", ""*""
#include ""OLAPGetChildElementListOrItself"", ""*""
#include ""CO_DifferenceSide"", ""*""
#include ""CO_GetEntityIntercompany"", ""*""

bool CO_ExpenditureRevenuesSegmentElim(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCExpenditureRevenuesSegmentElim process., Hierarchical Consolidation of Expenditure/Revenues with hierarchical segmentation."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""HR"";
	cancel = false;*/
	
	string processName = ""CO_ExpenditureRevenuesSegmentElim"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPConnection olapConnection2 = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		NotifyInformation(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		NotifyInformation(""cancelled journals"");

		if (!cancel) {
			string cubeTransact = ""TSTDTRANSACTSEGM"";
			string stdCurrency = ""Total"";
			string strTransactDebit = ""T1150"";
			//string strTransactCredit = ""T3000"";
			GroupJournalDictionary groupSegmentJournalDictionary = CreateGroupJournalDictionary();
			GroupJournal groupSegmentJournal = null;
			StringArray dictionaryEntries = CreateStringArray();
			StringArray keyElements = CreateStringArray();
			double counter = 0;
			double counter2 = 0;
			double value = 0;
			double transformedValue = 0;
			double factor = 0;
			string lookupKey = """";
			string company = """";
			string interCompany = """";
			string detail = """";
			string unassigned = ""Unassigned"";
			string segment = """";
			string segmentPartner = """";
			string secondarySegment = """";
			string secondarySegmentPartner = """";
			string tertiarySegment = """";
			string tertiarySegmentPartner = """";
			string segmentRoot = ""TOTAL"";
			string secondarySegmentRoot = ""TOTAL"";
			string tertiarySegmentRoot = ""TOTAL"";
			string account = """";
			string help = """";
			bool isExpenditure = false;
			double factorAccount = 0;
			double factorContraAccount = 0;
			string segmentLevel = ""Intersegment"";
			string eliminationSuffix = ""_Elim"";
			string segmentElimination = """";
			string secondarySegmentElimination = """";
			string tertiarySegmentElimination = """";
			string consolidationType = ""Cons. Expenditures/Revenue"";

			string groupCurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);
			string consolidationBasis = CO_ConsolidationBasis(olapConnection, cycle, consolidationType);
			OLAPElementList levels = OLAPGetChildElementListOrItself(olapConnection, ""DGLEVEL"", consolidationBasis, true);
			
			//Companies
			OLAPElementList companies = CreateOLAPElementList();
			OLAPElementList interCompanies = CreateOLAPElementList();
			
			foreach (OLAPElement sourceCompany in CO_Companies(olapConnection, cycle) where (
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Full"") or
				(CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, sourceCompany) == ""Quotal"")))
			{
				OLAPElementListAddElement(companies, sourceCompany);
				OLAPElementListAddElement(interCompanies, sourceCompany);
			}
			
			//segments (primary, secondary, tertiary)
			OLAPElementList segments = OLAPGetChildElementList(olapConnection, ""DPSEGM"", segmentRoot, true);
			OLAPElementList segmentsPartner = OLAPGetChildElementList(olapConnection, ""DPRSEGM"", segmentRoot, true);
			
			OLAPElementList secondarySegments = CreateOLAPElementList();
			OLAPElementList secondarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 2)) {
				secondarySegments = OLAPGetChildElementList(olapConnection, ""DSSEGM"", secondarySegmentRoot, true);
				secondarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DSRSEGM"", secondarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(secondarySegments, OLAPGetDimensionElement(olapConnection, ""DSSEGM"", ""-""));
				OLAPElementListAddElement(secondarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DSRSEGM"", ""-""));
			}
			
			OLAPElementList tertiarySegments = CreateOLAPElementList();
			OLAPElementList tertiarySegmentsPartner = CreateOLAPElementList();
			
			if (CO_HasSegment(olapConnection, cycle, 3)) {
				tertiarySegments = OLAPGetChildElementList(olapConnection, ""DTSEGM"", tertiarySegmentRoot, true);
				tertiarySegmentsPartner = OLAPGetChildElementList(olapConnection, ""DTRSEGM"", tertiarySegmentRoot, true);
			} else {
				OLAPElementListAddElement(tertiarySegments, OLAPGetDimensionElement(olapConnection, ""DTSEGM"", ""-""));
				OLAPElementListAddElement(tertiarySegmentsPartner, OLAPGetDimensionElement(olapConnection, ""DTRSEGM"", ""-""));
			}

			//Accounts
			OLAPElementList accounts = CreateOLAPElementList();
			OLAPElementList rulesList = CreateOLAPElementList();

			foreach (OLAPElement consolidationRule in CO_Processes(olapConnection, cycle) where (
				CO_IsRuleType(olapConnection, cycle, consolidationRule, consolidationType) == true)) {
				OLAPElementListAddElement(rulesList, consolidationRule);
			}

			foreach (OLAPElement sourceAccount in CO_Accounts(olapConnection, cycle))
			{
				foreach (OLAPElement consolidationRule in rulesList)
				{
					if ((CO_IsAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true) or
					    (CO_IsContraAccount(olapConnection, cycle, sourceAccount, consolidationRule) == true)) {
						OLAPElementListAddElement(accounts, sourceAccount);
					}
				}
			}
			
			//Source Definition for TSEGMG
			string cube1 = ""TSEGMG"";
			string cube2 = ""TSEGMOVG"";
			string sourceDYEAR = year; 			  					 //DYEAR
			string sourceDPERIOD = period; 		  					 //DPERIOD
			string sourceDVERSIO = scenario; 							 //DVERSIO
			string sourceDGCURR = groupCurrency; 						 //DGCURR
			OLAPElementList sourceDGLEVEL = levels; 		  			//DGLEVEL
			string sourceDGROUP = group; 								 //DGROUP
			string sourceDSTAGE = ""Consolidated Segments"";				 //DSTAGE
			OLAPElementList sourceDCOMPC = companies; 					//DCOMPC
			OLAPElementList sourceDINTCO = interCompanies;				//DINTCO
			OLAPElementList sourceDPSEGM = segments; 		 			//DPSEGM
			OLAPElementList sourceDPRSEGM = segmentsPartner; 			 //DPRSEGM
			OLAPElementList sourceDSSEGM = secondarySegments; 			//DSSEGM
			OLAPElementList sourceDSRSEGM = secondarySegmentsPartner; 	//DSRSEGM
			OLAPElementList sourceDTSEGM = tertiarySegments;  			//DTSEGM
			OLAPElementList sourceDTRSEGM = tertiarySegmentsPartner; 	 //DTRSEGM
			OLAPElementList sourceDACOUNT = accounts; 					//DACOUNT
			
			OLAPDataArea sourceArea = OLAPCreateDataArea(
				olapConnection, cube1, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
				OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
				cycle, sourceDYEAR, sourceDPERIOD, sourceDVERSIO, sourceDGCURR, sourceDGLEVEL, sourceDGROUP, sourceDSTAGE, sourceDCOMPC, sourceDINTCO,
				sourceDPSEGM, sourceDPRSEGM, sourceDSSEGM, sourceDSRSEGM, sourceDTSEGM, sourceDTRSEGM, sourceDACOUNT
			);
			
			//since we need the values in DGLEVEL on C-Level we open the DataArea on BaseValues and
			//fetch the C-Value manually - the processed combinations are remembered in a lookup
			LegacyLookupMapInitialize(""baseValueAccelerator"" + cube1);
			
			foreach (OLAPCell cell in sourceArea)
			{
				company = OLAPCellGetElement(cell, ""DCOMPC"");
				interCompany = OLAPCellGetElement(cell, ""DINTCO"");
				segment = OLAPCellGetElement(cell, ""DPSEGM"");
				segmentPartner = OLAPCellGetElement(cell, ""DPRSEGM"");
				secondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
				secondarySegmentPartner = OLAPCellGetElement(cell, ""DSRSEGM"");
				tertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
				tertiarySegmentPartner = OLAPCellGetElement(cell, ""DTRSEGM"");
				account = OLAPCellGetElement(cell, ""DACOUNT"");
				
				lookupKey = company + ""|"" + interCompany + ""|"" + segment + ""|"" + segmentPartner + ""|"" +
					secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + account;
				if (LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", false) == false) {
					LegacyLookupMapLookupKey(""baseValueAccelerator"" + cube1, lookupKey, """", true);
					
					//fetch Value on C-Level
					value = OLAPCellReadNumber(olapConnection,cube1,1,
					                           OLAPCellGetElement(cell, ""BPDCYCLE""),
					                           OLAPCellGetElement(cell, ""DYEAR""),
					                           OLAPCellGetElement(cell, ""DPERIOD""),
					                           OLAPCellGetElement(cell, ""DVERSIO""),
					                           OLAPCellGetElement(cell, ""DGCURR""),
					                           consolidationBasis,
					                           OLAPCellGetElement(cell, ""DGROUP""),
					                           OLAPCellGetElement(cell, ""DSTAGE""),
					                           OLAPCellGetElement(cell, ""DCOMPC""),
					                           OLAPCellGetElement(cell, ""DINTCO""),
					                           OLAPCellGetElement(cell, ""DPSEGM""),
					                           OLAPCellGetElement(cell, ""DPRSEGM""),
					                           OLAPCellGetElement(cell, ""DSSEGM""),
					                           OLAPCellGetElement(cell, ""DSRSEGM""),
					                           OLAPCellGetElement(cell, ""DTSEGM""),
					                           OLAPCellGetElement(cell, ""DTRSEGM""),
					                           OLAPCellGetElement(cell, ""DACOUNT""));
					
					if (value != 0) {
						counter = counter + 1;
						
						OLAPElement acc = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
						
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						factorContraAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, false);
						
						isExpenditure = CO_AccountType(olapConnection, acc) == ""Expenditure"";
						
						//store all opened journals by company/intercompany key
						//get consolidationRule linked to the account
						foreach (OLAPElement consolidationRule in rulesList)
						{
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true or
							    CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								
								/*
								determine Elimination Element through dimension hierarchy
									
								direct elimination elements (under _CONSOL elements) are created without the _CONSOL part
								all other elimination elements are C-Element + _CONSOL
								
								-Germany
								  -Germany_ELIM
								  -MUC_CONSOL
								    -MUC_ELIM
								    -MUC
								  -HAN_CONSOL
								    -HAN_ELIM
								    -HAN
								 */
								
								//segment
								segmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DPSEGM"",
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segment),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentPartner),
								                                              OLAPGetDimensionElement(olapConnection, ""DPSEGM"", segmentRoot));
								
								segmentElimination = segmentElimination + eliminationSuffix;
								
								//secondarySegment
								if (CO_HasSegment(olapConnection, cycle, 2)) {
									secondarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DSSEGM"",
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegment),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentPartner),
									                                                       OLAPGetDimensionElement(olapConnection, ""DSSEGM"", secondarySegmentRoot));
									
									secondarySegmentElimination = secondarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									secondarySegmentElimination = secondarySegment;
								}
								
								//tertiarySegment
								if (CO_HasSegment(olapConnection, cycle, 3)) {
									tertiarySegmentElimination = CO_GetEliminationElement(olapConnection, cycle, ""DTSEGM"",
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegment),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentPartner),
									                                                      OLAPGetDimensionElement(olapConnection, ""DTSEGM"", tertiarySegmentRoot));
									
									tertiarySegmentElimination = tertiarySegmentElimination + eliminationSuffix;
								} else {
									//no Elimination - just use Dimension Element itself
									tertiarySegmentElimination = tertiarySegment;
								}
							}
							
							if (CO_IsAccount(olapConnection, cycle, account, consolidationRule) == true) {
								lookupKey = company + ""|"" + interCompany + ""|"" +
									segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
									secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorAccount;
							}
							if (CO_IsContraAccount(olapConnection, cycle, account, consolidationRule) == true) {
								//switch company/intercompany and segment/partnersegment for all 3 dims
								lookupKey = interCompany + ""|"" + company + ""|"" +
									segmentPartner + ""|"" + segment + ""|"" + segmentElimination + ""|"" +
									secondarySegmentPartner + ""|"" + secondarySegment + ""|"" + secondarySegmentElimination + ""|"" +
									tertiarySegmentPartner + ""|"" + tertiarySegment + ""|"" + tertiarySegmentElimination + ""|"" +
									consolidationRule;
								
								factor = factorContraAccount;
							}
						}
						
						if (ContainsKey(groupSegmentJournalDictionary, lookupKey)) {
							//groupSegmentJournal for this combination exists already
							groupSegmentJournal = GetEntry(groupSegmentJournalDictionary, lookupKey);
						} else {
							//open a new groupSegmentJournal for this combination
							groupSegmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, consolidationType, segmentLevel, ruleid, ""ID <"" + counter + "">"", true);
							AddEntry(groupSegmentJournalDictionary, lookupKey, groupSegmentJournal);
							
							//remember entries in a StringArray
							Append(dictionaryEntries,lookupKey);
						}
						
						/*  DACOUNT(DETAIL) -> DDETPA
							DDETPA(TOP_ACC) -> DDETAIL -> all N Childs
							->DataArea TSEGMOVG */
						
						//determine if TSEGMOVG holds the values split up by DDETAIL - use them instead
						string accountDetail = cached OLAPGetStringAttribute(olapConnection, acc, ""DETAIL"");
						if (accountDetail != """") {
							//read values from TSEGMOVG
							//with Detail
							
							string topAccount = cached OLAPGetStringAttribute(olapConnection, OLAPGetDimensionElement(olapConnection, ""DDETPA"", accountDetail), ""TOP_ACC"");
							OLAPElementList details = OLAPGetChildElementListOrItself(olapConnection, ""DDETAIL"", topAccount, true);
							
							OLAPDataArea sourceArea2 = OLAPCreateDataArea(
								olapConnection2, cube2, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
								OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
								OLAPCellGetElement(cell, ""BPDCYCLE""), OLAPCellGetElement(cell, ""DYEAR""), OLAPCellGetElement(cell, ""DPERIOD""), OLAPCellGetElement(cell, ""DVERSIO""),
								OLAPCellGetElement(cell, ""DGCURR""), consolidationBasis, OLAPCellGetElement(cell, ""DGROUP""),
								OLAPCellGetElement(cell, ""DSTAGE""), OLAPCellGetElement(cell, ""DCOMPC""), OLAPCellGetElement(cell, ""DINTCO""),
								OLAPCellGetElement(cell, ""DPSEGM""), OLAPCellGetElement(cell, ""DPRSEGM""),
								OLAPCellGetElement(cell, ""DSSEGM""), OLAPCellGetElement(cell, ""DSRSEGM""), OLAPCellGetElement(cell, ""DTSEGM""),
								OLAPCellGetElement(cell, ""DTRSEGM""), details, OLAPCellGetElement(cell, ""DACOUNT"")
							);
							
							foreach (OLAPCell cell2 in sourceArea2)
							{
								counter2 = counter2 + 1;
								
								detail = OLAPCellGetElement(cell2, ""DDETAIL"");
								value = cell2;
								
								transformedValue = value * factor;

								if (isExpenditure) {
									transformedValue = transformedValue * -1.0;
								}

								//add the groupSegmentJournal lines
								if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", Abs(transformedValue), 0.0);
								} else {
									ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, detail, segmentElimination, segmentPartner,
									                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", 0.0, Abs(transformedValue));
								}
							}
						} else {
							//handle the value coming from TSEGMG
							//no Detail
							
							transformedValue = value * factor;

							if (isExpenditure) {
								transformedValue = transformedValue * -1.0;
							}

							//add the groupSegmentJournal lines
							if ((isExpenditure and transformedValue < 0) or (!isExpenditure and transformedValue > 0)) {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", Abs(transformedValue), 0.0);
							} else {
								ConsolidationAddGroupJournalLine(groupSegmentJournal, company, interCompany, account, """", segmentElimination, segmentPartner,
								                                        secondarySegmentElimination, secondarySegmentPartner, tertiarySegmentElimination, tertiarySegmentPartner, ""DPSEGM <"" + segment + "">"", 0.0, Abs(transformedValue));
							}
						}
					}
				}
			}
			
			NotifyInformation(""<"" + cube1 + ""> processed <"" + counter + ""> value(s)"");
			NotifyInformation(""<"" + cube2 + ""> processed <"" + counter2 + ""> value(s)"");
			
			//sort entries
			SortStringArray(dictionaryEntries);
			
			NotifyInformation(""sorted entries"");
			
			//loop all journals and post them
			counter = 0;
			foreach(string entry in dictionaryEntries) {
				GroupJournal openJournal = GetEntry(groupSegmentJournalDictionary,entry);
				
				
				/*lookupKey = company + ""|"" + interCompany + ""|"" +
								segment + ""|"" + segmentPartner + ""|"" + segmentElimination + ""|"" +
								secondarySegment + ""|"" + secondarySegmentPartner + ""|"" + secondarySegmentElimination + ""|"" +
								tertiarySegment + ""|"" + tertiarySegmentPartner + ""|"" + tertiarySegmentElimination + ""|"" +
								consolidationRule;*/
				
				keyElements = StringSplit(entry,""|"");
				company = GetElementByIndex(keyElements,0);
				interCompany = GetElementByIndex(keyElements,1);
				
				double difference = ConsolidationJournalDifference(openJournal);
				if (RoundDecimals(difference, 4) != 0) {
					segment = GetElementByIndex(keyElements,2);
					segmentPartner = GetElementByIndex(keyElements,3);
					segmentElimination = GetElementByIndex(keyElements,4);
					
					secondarySegment = GetElementByIndex(keyElements,5);
					secondarySegmentPartner = GetElementByIndex(keyElements,6);
					secondarySegmentElimination = GetElementByIndex(keyElements,7);
					
					tertiarySegment = GetElementByIndex(keyElements,8);
					tertiarySegmentPartner = GetElementByIndex(keyElements,9);
					tertiarySegmentElimination = GetElementByIndex(keyElements,10);
					
					help = GetElementByIndex(keyElements,11);
					OLAPElement consolidationRule = OLAPGetDimensionElement(olapConnection, ""DCONSRL"", help);

					// int bookingType = CO_BookingType(olapConnection, cycle, consolidationRule);
					int bookingType = 2; // default setting used in this variant
					int differenceSide = CO_DifferenceSide(olapConnection, cycle, consolidationRule, bookingType);

					if (!OLAPCellIsNull(olapConnection, cubeTransact, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
					                    segment, segmentPartner,
					                    secondarySegment, secondarySegmentPartner,
					                    tertiarySegment, tertiarySegmentPartner,
					                    strTransactDebit, ""100"" + consolidationRule))
					{
						// consider the ownership also for FX differences
						factorAccount = CO_EliminationFactor(olapConnection, cycle, year, period, scenario, group, company, interCompany, true);
						double translationsValue = cached OLAPCellReadNumber(olapConnection, cubeTransact, factorAccount, cycle, year, period, scenario, stdCurrency, groupCurrency, ""HB III"", company, interCompany,
						                                                     segment, segmentPartner,
						                                                     secondarySegment, secondarySegmentPartner,
						                                                     tertiarySegment, tertiarySegmentPartner,
						                                                     strTransactDebit, ""100"" + consolidationRule);
						double stdDiffFx = (difference * -1) - translationsValue;

						if (RoundDecimals(stdDiffFx, 4) != 0.0) {

							string differenceAccountFX = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Account"");
							string differenceAccountFXDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Currency Translation Differences Detail"");
							StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, stdDiffFx, company, interCompany);

							if (stdDiffFx > 0.0) {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", 0.0, stdDiffFx);
							} else {
								ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountFX, differenceAccountFXDetail,
								                                 segmentElimination, segmentPartner,
								                                 secondarySegmentElimination, secondarySegmentPartner,
								                                 tertiarySegmentElimination, tertiarySegmentPartner,
								                                 """", -stdDiffFx, 0.0);
							}

							// check the difference again after adding lines for currency translation diff
							difference = ConsolidationJournalDifference(openJournal);
						}
					}

					if (RoundDecimals(difference, 4) != 0.0) {

						string differenceAccountOther = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Account"");
						string differenceAccountOtherDetail = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Other Differences Detail"");
						StringDictionary entityIntercompany = CO_GetEntityIntercompany(differenceSide, difference, company, interCompany);

						if (difference > 0.0) {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", difference, 0.0);
						} else {
							ConsolidationAddGroupJournalLine(openJournal, entityIntercompany[""entity""], entityIntercompany[""intercompany""], differenceAccountOther, differenceAccountOtherDetail,
							                                 segmentElimination, segmentPartner,
							                                 secondarySegmentElimination, secondarySegmentPartner,
							                                 tertiarySegmentElimination, tertiarySegmentPartner,
							                                 """", 0.0, -difference);

						}
					}
				}
				
				if (!ConsolidationJournalIsEmpty(openJournal)) {
					if (CO_ValidateGroupJournal(openJournal, true)) {
						ConsolidationPostJournal(journalStore, openJournal);
						counter = counter + 1;
					}
				}

			}
			
			NotifyInformation(""posted <"" + counter + ""> journal(s)"");
		}
		

		result = true;

	} catch (errorMessage, errorCode) {
		NotifyError(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	94D27358-8B96-4DD7-887F-7B7E281346A4	Former FCExpenditureRevenuesSegmentElim process., Hierarchical Consolidation of Expenditure/Revenues with hierarchical segmentation.	1	1	1	1686	NULL	0	45708.67507	0	0
6D9D0336-22C9-44CF-A209-04D57B9AA521	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetAccountElementList	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of accounts."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""accountsString"" parameter-type=""string"" parameter-description=""The concatenated account element ids."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_GetAccountElementList(OLAPConnection connection, string accountsString)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of Account OLAP elements given the concatenated account ids."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[accountsString]: ""The concatenated account element ids."";
@Returns: ""The list of accounts."";
{
	string dAccountDim = ""DACOUNT"";
	OLAPElementList accounts = CreateOLAPElementList();
	if (accountsString != """")
	{
		StringArray accountsArray = StringSplit(accountsString, ""]"");

		foreach(string acc in accountsArray)
		{
			OLAPElement accountElement = OLAPGetDimensionElement(connection, dAccountDim, acc);
			OLAPElementListAddElement(accounts, accountElement);
		}
	}
	return accounts;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_GetAccountElementList(OLAPConnection connection, string accountsString)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of Account OLAP elements given the concatenated account ids."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[accountsString]: ""The concatenated account element ids."";
@Returns: ""The list of accounts."";
{
	string dAccountDim = ""DACOUNT"";
	OLAPElementList accounts = CreateOLAPElementList();
	if (accountsString != """")
	{
		StringArray accountsArray = StringSplit(accountsString, ""]"");

		foreach(string acc in accountsArray)
		{
			OLAPElement accountElement = OLAPGetDimensionElement(connection, dAccountDim, acc);
			OLAPElementListAddElement(accounts, accountElement);
		}
	}
	return accounts;
}"	1	9D75C202-354A-4451-A44F-B337C7273F6A	Gets the list of Account OLAP elements given the concatenated account ids.	1	1	1	1687	NULL	0	45708.67505	0	0
8871A2A2-4189-4812-BE50-9A2742E9690F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetCashAccountSum	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""Sum of all Cash Accounts."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""currency"" parameter-type=""string"" parameter-description=""An element that specifies the currency to query."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

double CO_GetCashAccountSum(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company, string currency)
@Category: ""Consolidation"";
@Description: ""Gets the sum of all Cash Accounts defined for given context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[currency]: ""An element that specifies the currency to query."";
@Returns: ""Sum of all Cash Accounts."";
{
    double result = 0;

	string cashConfigCube = ""TSTDCASHCFG"";
	string accountDimension = ""DACOUNT"";

	// get the one and only cash account from BM configuration (""Opening Balance Cashflow"" setting)
	string cashAccount = CO_TopAccount(connection, configurationSet, 45);

	OLAPDataArea cashConfigDataAreaWeight = OLAPCreateDataArea(connection, cashConfigCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
	                                                           configurationSet, year, period, scenario, OlapDataAreaAllCells, OlapDataAreaAllCells, cashAccount, ""Weight"");
	foreach(OLAPCell cell in cashConfigDataAreaWeight)
	{
        // get the weight
        double weight = cell;
        // get the account value
		string account = OLAPCellGetElement(cell, accountDimension);
        double value = cached OLAPCellReadNumber(connection, ""TFINANC"", 1, configurationSet, year, period, scenario, currency, ""HB III"", ""Balance Sheet"", company, ""Sum"", account);
        // add it to the result
        result += weight * value;
	}

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

double CO_GetCashAccountSum(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string company, string currency)
@Category: ""Consolidation"";
@Description: ""Gets the sum of all Cash Accounts defined for given context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[currency]: ""An element that specifies the currency to query."";
@Returns: ""Sum of all Cash Accounts."";
{
    double result = 0;

	string cashConfigCube = ""TSTDCASHCFG"";
	string accountDimension = ""DACOUNT"";

	// get the one and only cash account from BM configuration (""Opening Balance Cashflow"" setting)
	string cashAccount = CO_TopAccount(connection, configurationSet, 45);

	OLAPDataArea cashConfigDataAreaWeight = OLAPCreateDataArea(connection, cashConfigCube, OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0,
	                                                           configurationSet, year, period, scenario, OlapDataAreaAllCells, OlapDataAreaAllCells, cashAccount, ""Weight"");
	foreach(OLAPCell cell in cashConfigDataAreaWeight)
	{
        // get the weight
        double weight = cell;
        // get the account value
		string account = OLAPCellGetElement(cell, accountDimension);
        double value = cached OLAPCellReadNumber(connection, ""TFINANC"", 1, configurationSet, year, period, scenario, currency, ""HB III"", ""Balance Sheet"", company, ""Sum"", account);
        // add it to the result
        result += weight * value;
	}

	return result;
}"	1	EF710980-C838-4B99-8384-BF1F5AC2E439	Gets the sum of all Cash Accounts defined for given context.	1	1	1	1688	NULL	0	45708.67508	0	0
D4D5178A-60A5-4F24-91C8-D3F6FBE4909A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetCompanyCurrency	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Currency fo given time/scenario/company."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Un of element that specifies the cycle to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""time"" parameter-type=""string"" parameter-description=""Un of element that specifies the period to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""Un of element that specifies the scenario to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""Un of element that specifies the company to query."" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetCompanyCurrency(string server, string cycle, string time, string scenario,string company )
@Description: ""Get currency for given time/scenario/company"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Un of element that specifies the cycle to query."";
@Parameter[time]: ""Un of element that specifies the period to query."";
@Parameter[scenario]: ""Un of element that specifies the scenario to query."";
@Parameter[company]: ""Un of element that specifies the company to query."";
@Returns: ""Currency fo given time/scenario/company."";
{
	string functionName = ""CO_GetCompanyCurrency:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*time = ""[DTIME].[07.2015].[1]"";
		scenario = ""[DVERSIO].[V01].[1]"";
		company = ""[DCOMPC].[RU0001].[1]"";*/

		cycle = ResolveUniqueName(connection, cycle);
		time = ResolveUniqueName(connection, time);
		scenario = ResolveUniqueName(connection, scenario);
		company = ResolveUniqueName(connection, company);
		
		string period = StringSubstring(time, 0, 2);
		string year = StringSubstring(time, 3, 4);
		string currency = OLAPCellReadString(connection, ""TCOMPPA"", cycle, year, period, scenario, company, ""Currency"");


		return ""[DCCURR].["" +currency+ ""].[1]"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetCompanyCurrency(string server, string cycle, string time, string scenario,string company )
@Description: ""Get currency for given time/scenario/company"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Un of element that specifies the cycle to query."";
@Parameter[time]: ""Un of element that specifies the period to query."";
@Parameter[scenario]: ""Un of element that specifies the scenario to query."";
@Parameter[company]: ""Un of element that specifies the company to query."";
@Returns: ""Currency fo given time/scenario/company."";
{
	string functionName = ""CO_GetCompanyCurrency:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*time = ""[DTIME].[07.2015].[1]"";
		scenario = ""[DVERSIO].[V01].[1]"";
		company = ""[DCOMPC].[RU0001].[1]"";*/

		cycle = ResolveUniqueName(connection, cycle);
		time = ResolveUniqueName(connection, time);
		scenario = ResolveUniqueName(connection, scenario);
		company = ResolveUniqueName(connection, company);
		
		string period = StringSubstring(time, 0, 2);
		string year = StringSubstring(time, 3, 4);
		string currency = OLAPCellReadString(connection, ""TCOMPPA"", cycle, year, period, scenario, company, ""Currency"");


		return ""[DCCURR].["" +currency+ ""].[1]"";
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	E67F1B9F-4516-46A9-99D2-6DF0CDE0C2DD	Get currency for given time/scenario/company	1	1	1	1689	NULL	0	45708.67502	0	0
77954D5F-E556-4EE4-9B2F-21D7D3594E69	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetConfigurationSet	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of cycles used in consolidation"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetConfigurationSet(string server)
@Description: ""Get list of active configurationSets"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Comma separated list of cycles used in consolidation"";
{
	string functionName = ""CO_GetConfigurationSet:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		string confSet = ""[BPDCYCLE].[SET_001].[1]"";
		return confSet;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetConfigurationSet(string server)
@Description: ""Get list of active configurationSets"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Comma separated list of cycles used in consolidation"";
{
	string functionName = ""CO_GetConfigurationSet:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);

		string confSet = ""[BPDCYCLE].[SET_001].[1]"";
		return confSet;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	EAF65B05-DA82-4D63-8F06-3B07861555C9	Get list of active configurationSets	1	1	1	1690	NULL	0	45708.67503	0	0
CC624CF3-2A4E-4F6F-843C-8B7475996466	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetEliminationElement	Helper	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElement"" return-value-description=""the first parent for both elements inside of the supplied hierachy."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""The olap connection to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""dimension"" parameter-type=""string"" parameter-description=""The dimension the elements are belonging to."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""element"" parameter-type=""OLAPElement"" parameter-description=""The first element for which the parent shall be determined."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""element2"" parameter-type=""OLAPElement"" parameter-description=""The second element for which the parent shall be determined."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""hierarchyParent"" parameter-type=""OLAPElement"" parameter-description=""The root of the hierarchy to be searched for."" parameter-order=""5"" />
  <dependencies>
    <process process-name=""GetParentElementFromHierarchy"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetParentElementFromHierarchy"", ""*""

OLAPElement CO_GetEliminationElement(OLAPConnection connection, string configurationSet, string dimension, OLAPElement element, OLAPElement element2, OLAPElement hierarchyParent)
@Description: ""Finds the first parent both of the supplied elements share limited to a hierarchy."";
@Category: ""Helper"";
@Parameter[connection]: ""The olap connection to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[dimension]: ""The dimension the elements are belonging to."";
@Parameter[element]: ""The first element for which the parent shall be determined."";
@Parameter[element2]: ""The second element for which the parent shall be determined."";
@Parameter[hierarchyParent]: ""The root of the hierarchy to be searched for."";
@Returns: ""the first parent for both elements inside of the supplied hierachy."";
{
	OLAPElement elementParent = GetParentElementFromHierarchy(connection, dimension, element, hierarchyParent);
	OLAPElement element2Parent = GetParentElementFromHierarchy(connection, dimension, element2, hierarchyParent);
	string stringElementParent = elementParent;
	string stringElement2Parent = element2Parent;
	string stringHierarchyParent = hierarchyParent;
	
	while (stringElementParent != stringElement2Parent and stringElementParent != stringHierarchyParent) {
		while (stringElementParent != stringElement2Parent and stringElement2Parent != stringHierarchyParent) {
			element2Parent =GetParentElementFromHierarchy(connection, dimension, element2Parent, hierarchyParent);
			stringElement2Parent = element2Parent;
		}
		
		if (stringElementParent != stringElement2Parent) {
			elementParent = GetParentElementFromHierarchy(connection, dimension, elementParent, hierarchyParent);
			stringElementParent = elementParent;
			
			//reset element2Parent back to the direct parent
			element2Parent = GetParentElementFromHierarchy(connection, dimension, element2, hierarchyParent);
			stringElement2Parent = element2Parent;
		}
	}
	
	return elementParent;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetParentElementFromHierarchy"", ""*""

OLAPElement CO_GetEliminationElement(OLAPConnection connection, string configurationSet, string dimension, OLAPElement element, OLAPElement element2, OLAPElement hierarchyParent)
@Description: ""Finds the first parent both of the supplied elements share limited to a hierarchy."";
@Category: ""Helper"";
@Parameter[connection]: ""The olap connection to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[dimension]: ""The dimension the elements are belonging to."";
@Parameter[element]: ""The first element for which the parent shall be determined."";
@Parameter[element2]: ""The second element for which the parent shall be determined."";
@Parameter[hierarchyParent]: ""The root of the hierarchy to be searched for."";
@Returns: ""the first parent for both elements inside of the supplied hierachy."";
{
	OLAPElement elementParent = GetParentElementFromHierarchy(connection, dimension, element, hierarchyParent);
	OLAPElement element2Parent = GetParentElementFromHierarchy(connection, dimension, element2, hierarchyParent);
	string stringElementParent = elementParent;
	string stringElement2Parent = element2Parent;
	string stringHierarchyParent = hierarchyParent;
	
	while (stringElementParent != stringElement2Parent and stringElementParent != stringHierarchyParent) {
		while (stringElementParent != stringElement2Parent and stringElement2Parent != stringHierarchyParent) {
			element2Parent =GetParentElementFromHierarchy(connection, dimension, element2Parent, hierarchyParent);
			stringElement2Parent = element2Parent;
		}
		
		if (stringElementParent != stringElement2Parent) {
			elementParent = GetParentElementFromHierarchy(connection, dimension, elementParent, hierarchyParent);
			stringElementParent = elementParent;
			
			//reset element2Parent back to the direct parent
			element2Parent = GetParentElementFromHierarchy(connection, dimension, element2, hierarchyParent);
			stringElement2Parent = element2Parent;
		}
	}
	
	return elementParent;
}"	1	6C0D81FA-1A57-4FCD-BB32-DC13D6D11930	Finds the first parent both of the supplied elements share limited to a hierarchy.	1	1	1	1691	NULL	0	45708.67505	0	0
FAF36C58-A46B-4340-A786-67392F850531	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetEntityCurrency	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""List of entity currencies"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Configuration set to be used"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity  set to be used"" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetEntityCurrency(string server, string cycle, string entity)
@Description: ""Get assigned currency for given cycle/entity"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Configuration set to be used"";
@Parameter[entity]: ""Entity  set to be used"";
@Returns: ""List of entity currencies"";
{
	string functionName = ""CO_GetEntityCurrency:"";
	string errorMessage = """";
	string dimDLCURR = ""DLCURR"";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList currencies = OLAPGetElementList(olapConnection, dimDLCURR, true);
		StringList currenciesStringList =  ConvertToStringList(currencies);
		StringArray currenciesStringArray  = CreateStringArray();
		
		foreach(string curr  in currenciesStringList)
		{
			if(curr != """")
			{
				Append(currenciesStringArray, ""[""+dimDLCURR+""].[""+curr+""].[1]"");
			}

		}

		string currency  = StringJoin(currenciesStringArray, "","");

		return currency;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetEntityCurrency(string server, string cycle, string entity)
@Description: ""Get assigned currency for given cycle/entity"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Configuration set to be used"";
@Parameter[entity]: ""Entity  set to be used"";
@Returns: ""List of entity currencies"";
{
	string functionName = ""CO_GetEntityCurrency:"";
	string errorMessage = """";
	string dimDLCURR = ""DLCURR"";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList currencies = OLAPGetElementList(olapConnection, dimDLCURR, true);
		StringList currenciesStringList =  ConvertToStringList(currencies);
		StringArray currenciesStringArray  = CreateStringArray();
		
		foreach(string curr  in currenciesStringList)
		{
			if(curr != """")
			{
				Append(currenciesStringArray, ""[""+dimDLCURR+""].[""+curr+""].[1]"");
			}

		}

		string currency  = StringJoin(currenciesStringArray, "","");

		return currency;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	98580971-F9BD-4E06-9FB2-84EFE55A4C6B	Get assigned currency for given cycle/entity	1	1	1	1692	NULL	0	45708.67508	0	0
171BDB10-5E69-4DFC-95DF-A250E1E4BBFC	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetEntityIntercompany	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""StringDictionary"" return-value-description=""The Entity and Intercompany in a string dictionary."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""differenceSide"" parameter-type=""int"" parameter-description=""The difference side setting."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""differenceValue"" parameter-type=""double"" parameter-description=""The difference value."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""The entity id."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""The intercompany id."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringDictionary CO_GetEntityIntercompany(int differenceSide, double differenceValue,  string entity, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the entity and intercompany based on the given difference side setting and difference value.  "";
@Parameter[differenceSide]: ""The difference side setting."";
@Parameter[differenceValue]: ""The difference value."";
@Parameter[entity]: ""The entity id."";
@Parameter[intercompany]: ""The intercompany id."";
@Returns: ""The Entity and Intercompany in a string dictionary."";
{
	string tagetEntity = entity;
	string targetIntercompany = intercompany;

	// 0 - Company
	// 1 - Intercompany Relation
	// 2 -	According to account value
	// 3 - External

	if (differenceSide == 1 or
	    (differenceSide == 2 and differenceValue &lt; 0))
	{
		tagetEntity = intercompany;
		targetIntercompany = entity;
	}
	else if (differenceSide == 3)
	{
		targetIntercompany = ""External"";
		if (differenceValue  &lt; 0)
		{
			tagetEntity = intercompany;
		}
	}

	StringDictionary resultDictionary = CreateStringDictionary();
	resultDictionary[""entity""] = tagetEntity;
	resultDictionary[""intercompany""] = targetIntercompany;

	return resultDictionary;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

StringDictionary CO_GetEntityIntercompany(int differenceSide, double differenceValue,  string entity, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the entity and intercompany based on the given difference side setting and difference value.  "";
@Parameter[differenceSide]: ""The difference side setting."";
@Parameter[differenceValue]: ""The difference value."";
@Parameter[entity]: ""The entity id."";
@Parameter[intercompany]: ""The intercompany id."";
@Returns: ""The Entity and Intercompany in a string dictionary."";
{
	string tagetEntity = entity;
	string targetIntercompany = intercompany;

	// 0 - Company
	// 1 - Intercompany Relation
	// 2 -	According to account value
	// 3 - External

	if (differenceSide == 1 or
	    (differenceSide == 2 and differenceValue < 0))
	{
		tagetEntity = intercompany;
		targetIntercompany = entity;
	}
	else if (differenceSide == 3)
	{
		targetIntercompany = ""External"";
		if (differenceValue  < 0)
		{
			tagetEntity = intercompany;
		}
	}

	StringDictionary resultDictionary = CreateStringDictionary();
	resultDictionary[""entity""] = tagetEntity;
	resultDictionary[""intercompany""] = targetIntercompany;

	return resultDictionary;
}"	1	F794DE3D-3B5E-4602-A585-7F0FA4E0CAD0	Gets the entity and intercompany based on the given difference side setting and difference value.	1	1	1	1693	NULL	0	45708.67506	0	0
4E0D98FD-B853-4B17-BB83-122F8B47529E	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetEntityJournalLines	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with journal lines data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""uniqueBookingId"" parameter-type=""string"" parameter-description=""Unique indentificator of journal"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetEntityJournalLines(string server, string uniqueBookingId)
@Description: ""Get journal lines data for given journal ID"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[uniqueBookingId]: ""Unique indentificator of journal"";
@Returns: ""XML with journal lines data"";
{
	string functionName = ""CO_GetEntityJournalLines:"";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);
		
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		int i = 0;
		int j = 0;
		double debit = 0.0;
		double credit = 0.0;
		double numericProp = 0.0;
		string stringProp = """";

		CompanyJournal eJournal = journalStore.GetCompanyJournalById(uniqueBookingId);
		CompanyJournalLineList eJournalLineList = eJournal.GetCompanyJournalLines();

		StringArray journalLineProperties = [""Account"",""company"",""Intercompany"",""Debit"",""Credit""];
		StringArray journalLinePropertyTypes = [""string"",""string"",""string"",""numeric"",""numeric""];

		foreach(CompanyJournalLine eJournalLine in eJournalLineList )
		{

			row = XMLCreateElement(""Row"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId + ""_"" + ToString(i));
			j= 0;
			foreach(string journalLineProperty in journalLineProperties)
			{
				if(journalLinePropertyTypes[j] == ""string"")
				{
					property = XMLCreateElement(""Property"");
					stringProp = ConsolidationGetCompanyJournalLineProperty(eJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", stringProp);
					XMLAddElement(row, property);
				}
				else
				{
					property = XMLCreateElement(""Property"");
					numericProp = ConsolidationGetCompanyJournalLineNumericProperty(eJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", numericProp.ToString());
					XMLAddElement(row, property);
				}
				j++;
			}
			i++;
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetEntityJournalLines(string server, string uniqueBookingId)
@Description: ""Get journal lines data for given journal ID"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[uniqueBookingId]: ""Unique indentificator of journal"";
@Returns: ""XML with journal lines data"";
{
	string functionName = ""CO_GetEntityJournalLines:"";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);
		
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		int i = 0;
		int j = 0;
		double debit = 0.0;
		double credit = 0.0;
		double numericProp = 0.0;
		string stringProp = """";

		CompanyJournal eJournal = journalStore.GetCompanyJournalById(uniqueBookingId);
		CompanyJournalLineList eJournalLineList = eJournal.GetCompanyJournalLines();

		StringArray journalLineProperties = [""Account"",""company"",""Intercompany"",""Debit"",""Credit""];
		StringArray journalLinePropertyTypes = [""string"",""string"",""string"",""numeric"",""numeric""];

		foreach(CompanyJournalLine eJournalLine in eJournalLineList )
		{

			row = XMLCreateElement(""Row"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId + ""_"" + ToString(i));
			j= 0;
			foreach(string journalLineProperty in journalLineProperties)
			{
				if(journalLinePropertyTypes[j] == ""string"")
				{
					property = XMLCreateElement(""Property"");
					stringProp = ConsolidationGetCompanyJournalLineProperty(eJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", stringProp);
					XMLAddElement(row, property);
				}
				else
				{
					property = XMLCreateElement(""Property"");
					numericProp = ConsolidationGetCompanyJournalLineNumericProperty(eJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", numericProp.ToString());
					XMLAddElement(row, property);
				}
				j++;
			}
			i++;
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	130B4F9E-545E-4D71-B8A6-A69CB2A32E06	Get journal lines data for given journal ID	1	1	1	1694	NULL	0	45708.67504	0	0
E5863ACC-859C-48F4-93A0-0C07C3FDAEB0	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetGroupBranchForCompany	Helper	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The group company or an empty string"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapConnection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to run the rule for."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to run the rule for."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The scenario to run the rule for."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""The company to run the rule for."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""companyGroup"" parameter-type=""string"" parameter-description=""The group of the company to run the rule for."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""lookupComp2Branch"" parameter-type=""StringDictionary"" parameter-description=""a dictionary containing already cached results."" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""lookupComp2Group"" parameter-type=""StringDictionary"" parameter-description=""a dictionary containing already cached results."" parameter-order=""8"" />
  <dependencies>
    <process process-name=""CO_GetGroupForCompany"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetGroupForCompany"", ""*""

string CO_GetGroupBranchForCompany(OLAPConnection olapConnection, string configurationSet, string year, string period, string scenario, string company, string companyGroup,
                                StringDictionary lookupComp2Branch, StringDictionary lookupComp2Group)
@Description: ""Get branch of groups up to the root"";
@Category: ""Helper"";
@Parameter[olapConnection]: ""A connection to the OLAP database."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to run the rule for."";
@Parameter[period]: ""The period to run the rule for."";
@Parameter[scenario]: ""The scenario to run the rule for."";
@Parameter[company]: ""The company to run the rule for."";
@Parameter[companyGroup]: ""The group of the company to run the rule for."";
@Parameter[lookupComp2Branch]: ""a dictionary containing already cached results."";
@Parameter[lookupComp2Group]: ""a dictionary containing already cached results."";
@Returns: ""The group company or an empty string"";
{
	string branch = """";
	
	if (ContainsKey(lookupComp2Branch, company)) {
		return lookupComp2Branch[company];
	} else {
		string subgroupCompany = """";
		string subgroupCompanyGroup = companyGroup;
		bool reachedRoot = false;

		branch = company + "":"" + companyGroup;

		while(!reachedRoot) {
			subgroupCompany = cached OLAPCellReadString(olapConnection, ""TCOMPPA"", configurationSet, year, period, scenario, subgroupCompanyGroup, ""Subgroup Company"");
			if(StringTrim(subgroupCompany) == """") {
				reachedRoot = true;
			} else {
				subgroupCompanyGroup = CO_GetGroupForCompany(olapConnection, configurationSet, year, period, scenario, subgroupCompany, lookupComp2Group);

				branch = subgroupCompany + "":"" + subgroupCompanyGroup + ""|"" + branch;
			}
		}

		//store retrieved result
		lookupComp2Branch[company] = branch;
	}
	return branch;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetGroupForCompany"", ""*""

string CO_GetGroupBranchForCompany(OLAPConnection olapConnection, string configurationSet, string year, string period, string scenario, string company, string companyGroup,
                                StringDictionary lookupComp2Branch, StringDictionary lookupComp2Group)
@Description: ""Get branch of groups up to the root"";
@Category: ""Helper"";
@Parameter[olapConnection]: ""A connection to the OLAP database."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to run the rule for."";
@Parameter[period]: ""The period to run the rule for."";
@Parameter[scenario]: ""The scenario to run the rule for."";
@Parameter[company]: ""The company to run the rule for."";
@Parameter[companyGroup]: ""The group of the company to run the rule for."";
@Parameter[lookupComp2Branch]: ""a dictionary containing already cached results."";
@Parameter[lookupComp2Group]: ""a dictionary containing already cached results."";
@Returns: ""The group company or an empty string"";
{
	string branch = """";
	
	if (ContainsKey(lookupComp2Branch, company)) {
		return lookupComp2Branch[company];
	} else {
		string subgroupCompany = """";
		string subgroupCompanyGroup = companyGroup;
		bool reachedRoot = false;

		branch = company + "":"" + companyGroup;

		while(!reachedRoot) {
			subgroupCompany = cached OLAPCellReadString(olapConnection, ""TCOMPPA"", configurationSet, year, period, scenario, subgroupCompanyGroup, ""Subgroup Company"");
			if(StringTrim(subgroupCompany) == """") {
				reachedRoot = true;
			} else {
				subgroupCompanyGroup = CO_GetGroupForCompany(olapConnection, configurationSet, year, period, scenario, subgroupCompany, lookupComp2Group);

				branch = subgroupCompany + "":"" + subgroupCompanyGroup + ""|"" + branch;
			}
		}

		//store retrieved result
		lookupComp2Branch[company] = branch;
	}
	return branch;
}"	1	4AD395C4-C28D-4AF5-8957-25E56BE4A06B	Get branch of groups up to the root	1	1	1	1695	NULL	0	45708.67508	0	0
7B2AB25D-38B9-465A-B94D-81CD21C2DA9D	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetGroupCurrencies	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Group currencies assigned for given cycle/group"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""Group selected from list of consolidation groups"" parameter-order=""2"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupCurrencies(string server, string cycle, string group)
@Description: ""Get list of all group currencies"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Returns: ""Group currencies assigned for given cycle/group"";
{
	string functionName = ""CO_GetGroupCurrencies:"";
	string dimDGCURR = ""DGCURR"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList currencyOElelementList = OLAPGetElementList(olapConnection, dimDGCURR, true);
		StringList currencyStringList =  ConvertToStringList(currencyOElelementList);
		StringArray currencyStringArray  = CreateStringArray();
		
		foreach(string curr in currencyStringList)
		{
			if(curr != """" and !curr.EndsWith(""_RC""))
			{
				Append(currencyStringArray, ""[""+dimDGCURR+""].[""+curr+""].[1]"");
			}

		}
		string level  = StringJoin(currencyStringArray, "","");

		return level;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupCurrencies(string server, string cycle, string group)
@Description: ""Get list of all group currencies"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Returns: ""Group currencies assigned for given cycle/group"";
{
	string functionName = ""CO_GetGroupCurrencies:"";
	string dimDGCURR = ""DGCURR"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList currencyOElelementList = OLAPGetElementList(olapConnection, dimDGCURR, true);
		StringList currencyStringList =  ConvertToStringList(currencyOElelementList);
		StringArray currencyStringArray  = CreateStringArray();
		
		foreach(string curr in currencyStringList)
		{
			if(curr != """" and !curr.EndsWith(""_RC""))
			{
				Append(currencyStringArray, ""[""+dimDGCURR+""].[""+curr+""].[1]"");
			}

		}
		string level  = StringJoin(currencyStringArray, "","");

		return level;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	7E536946-1C7A-4687-9A6F-037CDBA68A1D	Get list of all group currencies	1	1	1	1696	NULL	0	45708.67507	0	0
DC99F67C-ABDD-49C1-8E01-1A8A31A41893	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetGroupForCompany	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The group company or an empty string"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""olapConnection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to run the rule for."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to run the rule for."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The scenario to run the rule for."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""The child company or intercompany."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""lookupComp2Group"" parameter-type=""StringDictionary"" parameter-description=""a dictionary containing already cached results."" parameter-order=""6"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupForCompany(OLAPConnection olapConnection, string configurationSet, string year, string period, string scenario, string company, StringDictionary lookupComp2Group)
@Description: ""Get group of specified company or intco (from settings cube)"";
@Category: ""Consolidation Base Process"";
@Parameter[olapConnection]: ""A connection to the OLAP database."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to run the rule for."";
@Parameter[period]: ""The period to run the rule for."";
@Parameter[scenario]: ""The scenario to run the rule for."";
@Parameter[company]: ""The child company or intercompany."";
@Parameter[lookupComp2Group]: ""a dictionary containing already cached results."";
@Returns: ""The group company or an empty string"";
{
	if (ContainsKey(lookupComp2Group, company)) {
		return lookupComp2Group[company];
	} else {
		string cubeSettings = ""TCONSPA"";
		string groupComp = """";

		OLAPDataArea groupArea = OLAPCreateDataArea(
			olapConnection, cubeSettings, OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
			configurationSet, year, period, scenario, OlapDataAreaBCells, company, ""global"", ""way of consolidation""
		);

		string strVal = """";
		int rowNum = 0;
		foreach (OLAPCell grCell in groupArea) {
			strVal = ToUpper(StringTrim(ToString(grCell)));
			
			if (strVal == ""FULL"" or strVal == ""QUOTAL"") {
				groupComp = OLAPCellGetElement(grCell, ""DGROUP"");
				rowNum = rowNum + 1;
			}
		}

		if (rowNum == 0) {
			WriteLine(""WARNING: Company &lt;"" + company + ""&gt;  - no group company configured in &lt;"" + cubeSettings + ""&gt;"");
		}
		if (rowNum &gt; 1) {
			WriteLine(""WARNING: Company &lt;"" + company + ""&gt;  - more than 1 group company configured in &lt;"" + cubeSettings + ""&gt;"");
		}
		if (rowNum == 1) {
			//store retrieved result
			lookupComp2Group[company] = groupComp;
		}

		return groupComp;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupForCompany(OLAPConnection olapConnection, string configurationSet, string year, string period, string scenario, string company, StringDictionary lookupComp2Group)
@Description: ""Get group of specified company or intco (from settings cube)"";
@Category: ""Consolidation Base Process"";
@Parameter[olapConnection]: ""A connection to the OLAP database."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to run the rule for."";
@Parameter[period]: ""The period to run the rule for."";
@Parameter[scenario]: ""The scenario to run the rule for."";
@Parameter[company]: ""The child company or intercompany."";
@Parameter[lookupComp2Group]: ""a dictionary containing already cached results."";
@Returns: ""The group company or an empty string"";
{
	if (ContainsKey(lookupComp2Group, company)) {
		return lookupComp2Group[company];
	} else {
		string cubeSettings = ""TCONSPA"";
		string groupComp = """";

		OLAPDataArea groupArea = OLAPCreateDataArea(
			olapConnection, cubeSettings, OlapDataAreaIncludeB | OlapDataAreaSuppressNull, OlapDataAreaOperatorNone, 0.0, OlapDataAreaOperatorNone, 0.0,
			configurationSet, year, period, scenario, OlapDataAreaBCells, company, ""global"", ""way of consolidation""
		);

		string strVal = """";
		int rowNum = 0;
		foreach (OLAPCell grCell in groupArea) {
			strVal = ToUpper(StringTrim(ToString(grCell)));
			
			if (strVal == ""FULL"" or strVal == ""QUOTAL"") {
				groupComp = OLAPCellGetElement(grCell, ""DGROUP"");
				rowNum = rowNum + 1;
			}
		}

		if (rowNum == 0) {
			WriteLine(""WARNING: Company <"" + company + "">  - no group company configured in <"" + cubeSettings + "">"");
		}
		if (rowNum > 1) {
			WriteLine(""WARNING: Company <"" + company + "">  - more than 1 group company configured in <"" + cubeSettings + "">"");
		}
		if (rowNum == 1) {
			//store retrieved result
			lookupComp2Group[company] = groupComp;
		}

		return groupComp;
	}
}"	1	D8036AE9-7492-4986-A004-4F1FD8658D81	Get group of specified company or intco (from settings cube)	1	1	1	1697	NULL	0	45708.67505	0	0
F7D682A8-83DA-4C95-90CF-D9F07BC397BD	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetGroupJournalLines	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with journal lines data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""uniqueBookingId"" parameter-type=""string"" parameter-description=""Unique indentificator of journal"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupJournalLines(string server, string uniqueBookingId)
@Description: ""Get journal lines data for given journal ID"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[uniqueBookingId]: ""Unique indentificator of journal"";
@Returns: ""XML with journal lines data"";
{
	string functionName = ""CO_GetGroupJournalLines:"";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);
		
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		int i = 0;
		int j = 0;
		double debit = 0.0;
		double credit = 0.0;
		double numericProp = 0.0;
		string stringProp = """";

		GroupJournal gJournal = journalStore.GetGroupJournalById(uniqueBookingId);
		GroupJournalLineList gJournalLineList = gJournal.GetGroupJournalLines();

		StringArray journalLineProperties = [""Account"",""company"",""Intercompany"",""Debit"",""Credit""];
		StringArray journalLinePropertyTypes = [""string"",""string"",""string"",""numeric"",""numeric""];

		foreach(GroupJournalLine gJournalLine in gJournalLineList )
		{

			row = XMLCreateElement(""Row"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId + ""_"" + ToString(i));
			j= 0;
			foreach(string journalLineProperty in journalLineProperties)
			{
				if(journalLinePropertyTypes[j] == ""string"")
				{
					property = XMLCreateElement(""Property"");
					stringProp = ConsolidationGetGroupJournalLineProperty(gJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", stringProp);
					XMLAddElement(row, property);
				}
				else
				{
					property = XMLCreateElement(""Property"");
					numericProp = ConsolidationGetGroupJournalLineNumericProperty(gJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", numericProp.ToString());
					XMLAddElement(row, property);
				}
				j++;
			}
			i++;
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetGroupJournalLines(string server, string uniqueBookingId)
@Description: ""Get journal lines data for given journal ID"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[uniqueBookingId]: ""Unique indentificator of journal"";
@Returns: ""XML with journal lines data"";
{
	string functionName = ""CO_GetGroupJournalLines:"";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);
		
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		int i = 0;
		int j = 0;
		double debit = 0.0;
		double credit = 0.0;
		double numericProp = 0.0;
		string stringProp = """";

		GroupJournal gJournal = journalStore.GetGroupJournalById(uniqueBookingId);
		GroupJournalLineList gJournalLineList = gJournal.GetGroupJournalLines();

		StringArray journalLineProperties = [""Account"",""company"",""Intercompany"",""Debit"",""Credit""];
		StringArray journalLinePropertyTypes = [""string"",""string"",""string"",""numeric"",""numeric""];

		foreach(GroupJournalLine gJournalLine in gJournalLineList )
		{

			row = XMLCreateElement(""Row"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId + ""_"" + ToString(i));
			j= 0;
			foreach(string journalLineProperty in journalLineProperties)
			{
				if(journalLinePropertyTypes[j] == ""string"")
				{
					property = XMLCreateElement(""Property"");
					stringProp = ConsolidationGetGroupJournalLineProperty(gJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", stringProp);
					XMLAddElement(row, property);
				}
				else
				{
					property = XMLCreateElement(""Property"");
					numericProp = ConsolidationGetGroupJournalLineNumericProperty(gJournalLine, journalLineProperty);
					XMLSetAttributeValue(property, ""name"", journalLineProperty);
					XMLSetAttributeValue(property, ""value"", numericProp.ToString());
					XMLAddElement(row, property);
				}
				j++;
			}
			i++;
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	4EC36E8E-76A1-4BE6-88E2-85E93CF8CD31	Get journal lines data for given journal ID	1	1	1	1698	NULL	0	45708.67505	0	0
CFA7BD1A-8681-4D21-8C64-3B0E0F9D67D3	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetICMatchingProcesses	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with matching processes, or empty string if no matching processes are defined"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetICMatchingProcesses(string server)
@Description: ""Create xml for given rules and their captions"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""XML with matching processes, or empty string if no matching processes are defined"";
{
	string functionName = ""CO_GetICMatchingProcesses:"";
	string errorMessage = """";
	string processesDimension = ""DCONSRL"";
	string accountDimension = ""DACOUNT"";

	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);

		StringArray processesArray = CreateStringArray();

		OLAPElementList dOlapList =  OLAPGetChildElementList(connection, processesDimension,""Cons. Debts"", true);
		OLAPElementList rOlapList =  OLAPGetChildElementList(connection, processesDimension,""Cons. Expenditures/Revenue"", true);
		StringDictionary parentDict = CreateStringDictionary();
		foreach(OLAPElement d in dOlapList)
		{
			Append(processesArray,d);
			string debt = ToString(d);
			parentDict[debt] = ""D"";
		}

		foreach(OLAPElement r in rOlapList)
		{
			Append(processesArray,r);
			string exp= ToString(r);
			parentDict[exp] = ""R"";
		}

		foreach(string proc in processesArray)
		{
			XMLElement row = XMLCreateElement(""Row"");
			XMLAddElement(table, row);
			XMLSetAttributeValue(row, ""name"",proc);

			XMLElement property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Caption"");
			string caption = OLAPGetStringAttribute(connection, accountDimension, proc, ""Name"");
			XMLSetAttributeValue(property, ""value"", caption);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""receivables"");
			OLAPElementList aROlapList =  OLAPGetChildElementList(connection, accountDimension,""100""+proc, true);
			StringArray receivablesArray = CreateStringArray();
			foreach(OLAPElement a in aROlapList)
			{
				Append(receivablesArray,""[DACOUNT].["" + a + ""].[1]"");
			}
			string receivables  = StringJoin(receivablesArray, "","");
			XMLSetAttributeValue(property, ""value"", receivables);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""payables"");
			OLAPElementList aPOlapList =  OLAPGetChildElementList(connection, accountDimension,""200""+proc, true);
			StringArray payablesArray = CreateStringArray();
			foreach(OLAPElement a in aPOlapList)
			{
				Append(payablesArray,""[DACOUNT].["" + a + ""].[1]"");
			}
			string payables  = StringJoin(payablesArray, "","");

			XMLSetAttributeValue(property, ""value"", payables);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Threshold"");
			string threshold = OLAPGetStringAttribute(connection, processesDimension, proc, ""Threshold"");
			XMLSetAttributeValue(property, ""value"", threshold);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Type"");
			XMLSetAttributeValue(property, ""value"", parentDict[proc]);
			XMLAddElement(row, property);
		}

		string result="""";
		if(Count(processesArray) != 0)
		{
			result = ToString(doc);
		}
		
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetICMatchingProcesses(string server)
@Description: ""Create xml for given rules and their captions"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""XML with matching processes, or empty string if no matching processes are defined"";
{
	string functionName = ""CO_GetICMatchingProcesses:"";
	string errorMessage = """";
	string processesDimension = ""DCONSRL"";
	string accountDimension = ""DACOUNT"";

	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);

		StringArray processesArray = CreateStringArray();

		OLAPElementList dOlapList =  OLAPGetChildElementList(connection, processesDimension,""Cons. Debts"", true);
		OLAPElementList rOlapList =  OLAPGetChildElementList(connection, processesDimension,""Cons. Expenditures/Revenue"", true);
		StringDictionary parentDict = CreateStringDictionary();
		foreach(OLAPElement d in dOlapList)
		{
			Append(processesArray,d);
			string debt = ToString(d);
			parentDict[debt] = ""D"";
		}

		foreach(OLAPElement r in rOlapList)
		{
			Append(processesArray,r);
			string exp= ToString(r);
			parentDict[exp] = ""R"";
		}

		foreach(string proc in processesArray)
		{
			XMLElement row = XMLCreateElement(""Row"");
			XMLAddElement(table, row);
			XMLSetAttributeValue(row, ""name"",proc);

			XMLElement property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Caption"");
			string caption = OLAPGetStringAttribute(connection, accountDimension, proc, ""Name"");
			XMLSetAttributeValue(property, ""value"", caption);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""receivables"");
			OLAPElementList aROlapList =  OLAPGetChildElementList(connection, accountDimension,""100""+proc, true);
			StringArray receivablesArray = CreateStringArray();
			foreach(OLAPElement a in aROlapList)
			{
				Append(receivablesArray,""[DACOUNT].["" + a + ""].[1]"");
			}
			string receivables  = StringJoin(receivablesArray, "","");
			XMLSetAttributeValue(property, ""value"", receivables);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""payables"");
			OLAPElementList aPOlapList =  OLAPGetChildElementList(connection, accountDimension,""200""+proc, true);
			StringArray payablesArray = CreateStringArray();
			foreach(OLAPElement a in aPOlapList)
			{
				Append(payablesArray,""[DACOUNT].["" + a + ""].[1]"");
			}
			string payables  = StringJoin(payablesArray, "","");

			XMLSetAttributeValue(property, ""value"", payables);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Threshold"");
			string threshold = OLAPGetStringAttribute(connection, processesDimension, proc, ""Threshold"");
			XMLSetAttributeValue(property, ""value"", threshold);
			XMLAddElement(row, property);

			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""Type"");
			XMLSetAttributeValue(property, ""value"", parentDict[proc]);
			XMLAddElement(row, property);
		}

		string result="""";
		if(Count(processesArray) != 0)
		{
			result = ToString(doc);
		}
		
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	5A4444D1-FCE2-4EE9-8F7F-ECABE4F8BD08	Create xml for given rules and their captions	1	1	1	1699	NULL	0	45708.67503	0	0
AC33E901-5E6A-436E-936D-DBB10700ABE3	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetJournalEntityData	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with journal data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""the entity to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""category"" parameter-type=""string"" parameter-description=""the category run the rule for"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""the account to run the rule for"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""level"" parameter-type=""string"" parameter-description=""the account to run the rule for"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""automatic"" parameter-type=""string"" parameter-description=""if true only automatic journals will be used"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, process will return canceled journals"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""loadJournalLines"" parameter-type=""bool"" parameter-description=""if true, process include journal lines"" parameter-order=""11"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetJournalEntityData(string server, string cycle, string year, string period, string scenario, string entity, string category, string account, string level, string automatic, bool cancel, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[entity]: ""the entity to run the rule for"";
@Parameter[category]: ""the category run the rule for"";
@Parameter[account]: ""the account to run the rule for"";
@Parameter[level]: ""the account to run the rule for"";
@Parameter[automatic]: ""if true only automatic journals will be used"";
@Parameter[cancel]: ""if true, process will return canceled journals"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalEntityData:"";
	string errorMessage = """";
	int errorCode = 0;
	//string bookingtext = """";
	// string stage = """";
	// string bookingNumber = """";
	// string description = """";
	// string journalType = """";
	// string id = """";
	// string carryForward = """";
	string uniqueBookingId = """";
	// string summary = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		entity = ResolveUniqueName(connection, entity);
		if(category !="""" and category !=""*"")
		{
			category = ResolveUniqueName(connection, category);
		}
		if(account !="""" and account !=""*"")
		{
			account = ResolveUniqueName(connection, account);

		}
		if(level !="""" and level !=""*"")
		{
			level = ResolveUniqueName(connection, level);
		}

		/*cycle = ""SET_001"";
		year = ""2020"";
		period = ""01"";
		scenario = ""V01"";
		category = ""*"";
		entity = ""RU0001"";
		account = ""*"";
		level = ""*"";
		automatic = true;
		cancel = false;*/

		CompanyJournalDictionary journalDict= CreateCompanyJournalDictionary();
		if(automatic != ""true"")
		{
			foreach(CompanyJournal eJournal in ConsolidationGetCompanyJournals(journalStore,cycle,year,period,scenario,entity,category,level,account,false,cancel))
			{
				journalDict.AddEntry(eJournal.GetCompanyJournalProperty(""JournalId""), eJournal);
			}
		}
		if(automatic == ""*"" or automatic == ""true"")
		{
			foreach(CompanyJournal eJournal in ConsolidationGetCompanyJournals(journalStore,cycle,year,period,scenario,entity,category,level,account,true,cancel))
			{
				journalDict.AddEntry(eJournal.GetCompanyJournalProperty(""JournalId""), eJournal);
			}
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		//XMLAddElement(doc, table);
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			CompanyJournal eJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = eJournal.GetCompanyJournalProperty(""JournalId"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = eJournal.GetCompanyJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			CompanyJournalLineList eJournalLineList = ConsolidationGetCompanyJournalLines(eJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(CompanyJournalLine eJournalLine in eJournalLineList )
			{
				double journalLineDebit = eJournalLine.GetCompanyJournalLineNumericProperty(""Debit"");
				double journalLineCredit = eJournalLine.GetCompanyJournalLineNumericProperty(""Credit"");
				if (eJournalLine.GetCompanyJournalLineProperty(""Account"") == account)
				{
					debit = debit + journalLineDebit;
					credit = credit +journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = eJournalLine.GetCompanyJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetJournalEntityData(string server, string cycle, string year, string period, string scenario, string entity, string category, string account, string level, string automatic, bool cancel, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[entity]: ""the entity to run the rule for"";
@Parameter[category]: ""the category run the rule for"";
@Parameter[account]: ""the account to run the rule for"";
@Parameter[level]: ""the account to run the rule for"";
@Parameter[automatic]: ""if true only automatic journals will be used"";
@Parameter[cancel]: ""if true, process will return canceled journals"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalEntityData:"";
	string errorMessage = """";
	int errorCode = 0;
	//string bookingtext = """";
	// string stage = """";
	// string bookingNumber = """";
	// string description = """";
	// string journalType = """";
	// string id = """";
	// string carryForward = """";
	string uniqueBookingId = """";
	// string summary = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		entity = ResolveUniqueName(connection, entity);
		if(category !="""" and category !=""*"")
		{
			category = ResolveUniqueName(connection, category);
		}
		if(account !="""" and account !=""*"")
		{
			account = ResolveUniqueName(connection, account);

		}
		if(level !="""" and level !=""*"")
		{
			level = ResolveUniqueName(connection, level);
		}

		/*cycle = ""SET_001"";
		year = ""2020"";
		period = ""01"";
		scenario = ""V01"";
		category = ""*"";
		entity = ""RU0001"";
		account = ""*"";
		level = ""*"";
		automatic = true;
		cancel = false;*/

		CompanyJournalDictionary journalDict= CreateCompanyJournalDictionary();
		if(automatic != ""true"")
		{
			foreach(CompanyJournal eJournal in ConsolidationGetCompanyJournals(journalStore,cycle,year,period,scenario,entity,category,level,account,false,cancel))
			{
				journalDict.AddEntry(eJournal.GetCompanyJournalProperty(""JournalId""), eJournal);
			}
		}
		if(automatic == ""*"" or automatic == ""true"")
		{
			foreach(CompanyJournal eJournal in ConsolidationGetCompanyJournals(journalStore,cycle,year,period,scenario,entity,category,level,account,true,cancel))
			{
				journalDict.AddEntry(eJournal.GetCompanyJournalProperty(""JournalId""), eJournal);
			}
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		//XMLAddElement(doc, table);
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			CompanyJournal eJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = eJournal.GetCompanyJournalProperty(""JournalId"");
			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = eJournal.GetCompanyJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			CompanyJournalLineList eJournalLineList = ConsolidationGetCompanyJournalLines(eJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(CompanyJournalLine eJournalLine in eJournalLineList )
			{
				double journalLineDebit = eJournalLine.GetCompanyJournalLineNumericProperty(""Debit"");
				double journalLineCredit = eJournalLine.GetCompanyJournalLineNumericProperty(""Credit"");
				if (eJournalLine.GetCompanyJournalLineProperty(""Account"") == account)
				{
					debit = debit + journalLineDebit;
					credit = credit +journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = eJournalLine.GetCompanyJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}
		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	BEFB7DB8-A17D-4BDC-B549-8BB78A7D5298	Get journal data for given context	1	1	1	1700	NULL	0	45708.67509	0	0
941590A1-0DAB-404B-A718-31FAC33EEDD9	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetJournalGroupData	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with journal data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""category"" parameter-type=""string"" parameter-description=""the category run the rule for"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""the account to run the rule for"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""level"" parameter-type=""string"" parameter-description=""the account to run the rule for"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""automatic"" parameter-type=""string"" parameter-description=""if true only automatic journals will be used"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, process will return canceled journals"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""loadJournalLines"" parameter-type=""bool"" parameter-description=""if true, process include journal lines"" parameter-order=""11"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetJournalGroupData(string server, string cycle, string year, string period, string scenario, string group, string category, string account, string level, string automatic, bool cancel, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[category]: ""the category run the rule for"";
@Parameter[account]: ""the account to run the rule for"";
@Parameter[level]: ""the account to run the rule for"";
@Parameter[automatic]: ""if true only automatic journals will be used"";
@Parameter[cancel]: ""if true, process will return canceled journals"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalGroupData:"";
	string errorMessage = """";
	int errorCode = 0;
	//string bookingtext = """";
	// string stage = """";
	// string bookingNumber = """";
	// string description = """";
	// string journalType = """";
	// string id = """";
	// string carryForward = """";
	string uniqueBookingId = """";
	// string summary = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		group = ResolveUniqueName(connection, group);
		if(category !="""" and category !=""*"")
		{
			category = ResolveUniqueName(connection, category);
		}
		if(account !="""" and account !=""*"")
		{
			account = ResolveUniqueName(connection, account);

		}
		if(level !="""" and level !=""*"")
		{
			level = ResolveUniqueName(connection, level);
		}

		/*cycle = ""SET_001"";
		year = ""2020"";
		period = ""12"";
		scenario = ""V01"";
		category = ""*"";
		group = ""GR0001"";
		account = ""A132110"";
		level = ""*"";
		automatic = false;
		cancel = false;*/

		GroupJournalDictionary journalDict= CreateGroupJournalDictionary();
		if(automatic != ""true"")
		{
			foreach(GroupJournal gJournal in ConsolidationGetGroupJournals(journalStore,cycle,year,period,scenario,group,category,level,account,false,cancel))
			{
				journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
			}
		}
		if(automatic == ""*"" or automatic == ""true"")
		{
			foreach(GroupJournal gJournal in ConsolidationGetGroupJournals(journalStore,cycle,year,period,scenario,group,category,level,account,true,cancel))
			{
				journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
			}
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		//XMLAddElement(doc, table);
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			GroupJournal gJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = gJournal.GetGroupJournalProperty(""JournalId"");

			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = gJournal.GetGroupJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			GroupJournalLineList gJournalLineList = ConsolidationGetGroupJournalLines(gJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(GroupJournalLine gJournalLine in gJournalLineList )
			{
				double journalLineDebit = gJournalLine.GetGroupJournalLineNumericProperty(""Debit"");
				double journalLineCredit = gJournalLine.GetGroupJournalLineNumericProperty(""Credit"");
				if (gJournalLine.GetGroupJournalLineProperty(""Account"") == account)
				{
					debit = debit + journalLineDebit;
					credit = credit +journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = gJournalLine.GetGroupJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}

		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetJournalGroupData(string server, string cycle, string year, string period, string scenario, string group, string category, string account, string level, string automatic, bool cancel, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[category]: ""the category run the rule for"";
@Parameter[account]: ""the account to run the rule for"";
@Parameter[level]: ""the account to run the rule for"";
@Parameter[automatic]: ""if true only automatic journals will be used"";
@Parameter[cancel]: ""if true, process will return canceled journals"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalGroupData:"";
	string errorMessage = """";
	int errorCode = 0;
	//string bookingtext = """";
	// string stage = """";
	// string bookingNumber = """";
	// string description = """";
	// string journalType = """";
	// string id = """";
	// string carryForward = """";
	string uniqueBookingId = """";
	// string summary = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		group = ResolveUniqueName(connection, group);
		if(category !="""" and category !=""*"")
		{
			category = ResolveUniqueName(connection, category);
		}
		if(account !="""" and account !=""*"")
		{
			account = ResolveUniqueName(connection, account);

		}
		if(level !="""" and level !=""*"")
		{
			level = ResolveUniqueName(connection, level);
		}

		/*cycle = ""SET_001"";
		year = ""2020"";
		period = ""12"";
		scenario = ""V01"";
		category = ""*"";
		group = ""GR0001"";
		account = ""A132110"";
		level = ""*"";
		automatic = false;
		cancel = false;*/

		GroupJournalDictionary journalDict= CreateGroupJournalDictionary();
		if(automatic != ""true"")
		{
			foreach(GroupJournal gJournal in ConsolidationGetGroupJournals(journalStore,cycle,year,period,scenario,group,category,level,account,false,cancel))
			{
				journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
			}
		}
		if(automatic == ""*"" or automatic == ""true"")
		{
			foreach(GroupJournal gJournal in ConsolidationGetGroupJournals(journalStore,cycle,year,period,scenario,group,category,level,account,true,cancel))
			{
				journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
			}
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		//XMLAddElement(doc, table);
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			GroupJournal gJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = gJournal.GetGroupJournalProperty(""JournalId"");

			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = gJournal.GetGroupJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			GroupJournalLineList gJournalLineList = ConsolidationGetGroupJournalLines(gJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(GroupJournalLine gJournalLine in gJournalLineList )
			{
				double journalLineDebit = gJournalLine.GetGroupJournalLineNumericProperty(""Debit"");
				double journalLineCredit = gJournalLine.GetGroupJournalLineNumericProperty(""Credit"");
				if (gJournalLine.GetGroupJournalLineProperty(""Account"") == account)
				{
					debit = debit + journalLineDebit;
					credit = credit +journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = gJournalLine.GetGroupJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}

		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	363559F4-610B-4D4D-ADEA-C9FA2DEB9306	Get journal data for given context	1	1	1	1701	NULL	0	45708.67502	0	0
FD2E2446-7BED-4B4C-AF1C-118FFBD441E1	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetJournalGroupDataFiltered	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with journal data"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""categories"" parameter-type=""string"" parameter-description=""the categories run the rule for"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""levels"" parameter-type=""string"" parameter-description=""the levels to run the rule for"" parameter-order=""7"" />
  <parameter-descriptor parameter-name=""accounts"" parameter-type=""string"" parameter-description=""the accounts to run the rule for"" parameter-order=""8"" />
  <parameter-descriptor parameter-name=""details"" parameter-type=""string"" parameter-description=""the details to run the rule for"" parameter-order=""9"" />
  <parameter-descriptor parameter-name=""entities"" parameter-type=""string"" parameter-description=""the entities to run the rule for"" parameter-order=""10"" />
  <parameter-descriptor parameter-name=""intercompanies"" parameter-type=""string"" parameter-description=""the intercompanies to run the rule for"" parameter-order=""11"" />
  <parameter-descriptor parameter-name=""loadJournalLines"" parameter-type=""bool"" parameter-description=""if true, process include journal lines"" parameter-order=""12"" />
  <dependencies>
    <process process-name=""ConvertElementNamesToKeys"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""ConvertElementNamesToKeys"", ""*""

string CO_GetJournalGroupDataFiltered(string server, string cycle, string year, string period, string scenario, string group, string categories, string levels, string accounts, string details, string entities, string intercompanies, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[categories]: ""the categories run the rule for"";
@Parameter[levels]: ""the levels to run the rule for"";
@Parameter[accounts]: ""the accounts to run the rule for"";
@Parameter[details]: ""the details to run the rule for"";
@Parameter[entities]: ""the entities to run the rule for"";
@Parameter[intercompanies]: ""the intercompanies to run the rule for"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalGroupData:"";
	string errorMessage = """";
	int errorCode = 0;
	string uniqueBookingId = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	/* cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	category = ""*"";
	group = ""GR0001"";
	entity = ""RU0001"";
	account = ""A110051"";
	level = ""*"";
	automatic = ""false"";
	cancel = false; */

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		group = ResolveUniqueName(connection, group);

		StringList categoriesParam = ConvertElementNamesToKeys(connection, categories);

		StringList levelsParam = ConvertElementNamesToKeys(connection, levels);

		StringList accountsParam = ConvertElementNamesToKeys(connection, accounts);

		StringList detailsParam = ConvertElementNamesToKeys(connection, details);

		StringList entitiesParam = ConvertElementNamesToKeys(connection, entities);

		StringList intercompaniesParam = ConvertElementNamesToKeys(connection, intercompanies);

		GroupJournalDictionary journalDict= CreateGroupJournalDictionary();

		GroupJournalList gJournals = ConsolidationGetGroupJournals(journalStore, cycle, year, period, scenario, group, categoriesParam, levelsParam, accountsParam, detailsParam, entitiesParam, intercompaniesParam);

		foreach(GroupJournal gJournal in gJournals)
		{
			journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			GroupJournal gJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = gJournal.GetGroupJournalProperty(""JournalId"");

			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = gJournal.GetGroupJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			GroupJournalLineList gJournalLineList = ConsolidationGetGroupJournalLines(gJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(GroupJournalLine gJournalLine in gJournalLineList )
			{
				double journalLineDebit = gJournalLine.GetGroupJournalLineNumericProperty(""Debit"");
				double journalLineCredit = gJournalLine.GetGroupJournalLineNumericProperty(""Credit"");
				if (accountsParam.Find(gJournalLine.GetGroupJournalLineProperty(""Account"")) != -1 or accounts == ""*"" or accounts == """")
				{
					debit = debit + journalLineDebit;
					credit = credit + journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = gJournalLine.GetGroupJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}

		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""ConvertElementNamesToKeys"", ""*""

string CO_GetJournalGroupDataFiltered(string server, string cycle, string year, string period, string scenario, string group, string categories, string levels, string accounts, string details, string entities, string intercompanies, bool loadJournalLines)
@Description: ""Get journal data for given context"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[categories]: ""the categories run the rule for"";
@Parameter[levels]: ""the levels to run the rule for"";
@Parameter[accounts]: ""the accounts to run the rule for"";
@Parameter[details]: ""the details to run the rule for"";
@Parameter[entities]: ""the entities to run the rule for"";
@Parameter[intercompanies]: ""the intercompanies to run the rule for"";
@Parameter[loadJournalLines]: ""if true, process include journal lines"";
@Returns: ""XML with journal data"";
{
	string functionName = ""CO_GetJournalGroupData:"";
	string errorMessage = """";
	int errorCode = 0;
	string uniqueBookingId = """";
	double debit = 0.0;
	double credit = 0.0;
	int i = 0;

	string stringProp = """";

	/* cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	category = ""*"";
	group = ""GR0001"";
	entity = ""RU0001"";
	account = ""A110051"";
	level = ""*"";
	automatic = ""false"";
	cancel = false; */

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(connection);

		cycle = ResolveUniqueName(connection, cycle);
		year = ResolveUniqueName(connection, year);
		period = ResolveUniqueName(connection, period);
		scenario = ResolveUniqueName(connection, scenario);
		group = ResolveUniqueName(connection, group);

		StringList categoriesParam = ConvertElementNamesToKeys(connection, categories);

		StringList levelsParam = ConvertElementNamesToKeys(connection, levels);

		StringList accountsParam = ConvertElementNamesToKeys(connection, accounts);

		StringList detailsParam = ConvertElementNamesToKeys(connection, details);

		StringList entitiesParam = ConvertElementNamesToKeys(connection, entities);

		StringList intercompaniesParam = ConvertElementNamesToKeys(connection, intercompanies);

		GroupJournalDictionary journalDict= CreateGroupJournalDictionary();

		GroupJournalList gJournals = ConsolidationGetGroupJournals(journalStore, cycle, year, period, scenario, group, categoriesParam, levelsParam, accountsParam, detailsParam, entitiesParam, intercompaniesParam);

		foreach(GroupJournal gJournal in gJournals)
		{
			journalDict.AddEntry(gJournal.GetGroupJournalProperty(""JournalId""), gJournal);
		}

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement journalLineRow = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		doc.AddElement(table);

		StringArray journalStringProperties = [""BookingNumber"",""Description"",""Summary"",""CarryForward"",""Cancelled"",""Level""];
		StringArray journalXmlStringProperties = [""BookingNumber"",""Description"",""Name"",""carryForward"",""Cancelled"",""LevelInfo""];
		StringArray journalLineStringProperties = [""Account"",""company"",""Intercompany""];

		foreach(string journalKey in journalDict.Keys())
		{
			GroupJournal gJournal = journalDict.GetEntry(journalKey);
			row = XMLCreateElement(""Row"");
			uniqueBookingId = gJournal.GetGroupJournalProperty(""JournalId"");

			table.AddElement(row);
			row.SetAttributeValue(""name"", uniqueBookingId);
			
			i = 0;
			foreach (string journalProperty in journalStringProperties)
			{
				property = XMLCreateElement(""Property"");
				stringProp = gJournal.GetGroupJournalProperty(journalProperty);
				property.SetAttributeValue(""name"", journalXmlStringProperties[i]);
				property.SetAttributeValue(""value"", stringProp);
				row.AddElement(property);
				i++;
			}

			GroupJournalLineList gJournalLineList = ConsolidationGetGroupJournalLines(gJournal);

			debit = 0.0;
			credit = 0.0;
			i = 0;
			foreach(GroupJournalLine gJournalLine in gJournalLineList )
			{
				double journalLineDebit = gJournalLine.GetGroupJournalLineNumericProperty(""Debit"");
				double journalLineCredit = gJournalLine.GetGroupJournalLineNumericProperty(""Credit"");
				if (accountsParam.Find(gJournalLine.GetGroupJournalLineProperty(""Account"")) != -1 or accounts == ""*"" or accounts == """")
				{
					debit = debit + journalLineDebit;
					credit = credit + journalLineCredit;
				}
				
				if (loadJournalLines)
				{
					journalLineRow = XMLCreateElement(""Row"");
					table.AddElement(journalLineRow);
					journalLineRow.SetAttributeValue(""name"", uniqueBookingId + ""_"" + i);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Debit"");
					property.SetAttributeValue(""value"", journalLineDebit.ToString());
					journalLineRow.AddElement(property);

					property = XMLCreateElement(""Property"");
					property.SetAttributeValue(""name"", ""Credit"");
					property.SetAttributeValue(""value"", journalLineCredit.ToString());
					journalLineRow.AddElement(property);

					foreach (string journalLineProperty in journalLineStringProperties)
					{
						property = XMLCreateElement(""Property"");
						stringProp = gJournalLine.GetGroupJournalLineProperty(journalLineProperty);
						property.SetAttributeValue(""name"", journalLineProperty);
						property.SetAttributeValue(""value"", stringProp);
						journalLineRow.AddElement(property);
					}
				}
				i++;
			}
			
			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Debit"");
			property.SetAttributeValue(""value"", debit.ToString());
			row.AddElement(property);

			property = XMLCreateElement(""Property"");
			property.SetAttributeValue(""name"", ""Credit"");
			property.SetAttributeValue(""value"", credit.ToString());
			row.AddElement(property);
		}

		string result  = ToString(doc);
		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	12518D1C-D542-4B5D-9BDC-EE7F6ED7A484	Get journal data for given context	1	1	1	1702	NULL	0	45708.67506	0	0
6D77F48E-BB08-484E-91FC-06681284CC6F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetListReadOnlyEntities	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of Entities"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <dependencies>
    <process process-name=""GetElementListWithReadPermission"" process-version=""*"" process-id="""" />
    <process process-name=""GetListEntitiesUsingXMLA"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetElementListWithReadPermission"", ""*""
#include ""GetListEntitiesUsingXMLA"", ""*""

string CO_GetListReadOnlyEntities(string server)
@Description: ""Return comma separated list of read only entities"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Comma separated list of Entities"";
{
	string functionName = ""CO_GetListReadOnlyEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	string entityDimension = ""DCOMPC"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string entities = GetListEntitiesUsingXMLA(connection,server);
		StringArray entityStringListHelp = StringSplit(entities , ""["");
		string readOnlyEntities = GetElementListWithReadPermission(server,entityDimension,entityStringListHelp);
		StringArray entityStringList = StringSplit(readOnlyEntities , ""["");
		StringArray resultArray = CreateStringArray();
		foreach(string s in entityStringList)
		{
			string st = ""[""+entityDimension+""].[""+ s + ""].[1]"";
			Append(resultArray,st);
		}


	string result = StringJoin(resultArray, ""["");
	return result;

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetElementListWithReadPermission"", ""*""
#include ""GetListEntitiesUsingXMLA"", ""*""

string CO_GetListReadOnlyEntities(string server)
@Description: ""Return comma separated list of read only entities"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Returns: ""Comma separated list of Entities"";
{
	string functionName = ""CO_GetListReadOnlyEntities:"";
	string errorMessage = """";
	int errorCode = 0;
	string entityDimension = ""DCOMPC"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string entities = GetListEntitiesUsingXMLA(connection,server);
		StringArray entityStringListHelp = StringSplit(entities , ""["");
		string readOnlyEntities = GetElementListWithReadPermission(server,entityDimension,entityStringListHelp);
		StringArray entityStringList = StringSplit(readOnlyEntities , ""["");
		StringArray resultArray = CreateStringArray();
		foreach(string s in entityStringList)
		{
			string st = ""[""+entityDimension+""].[""+ s + ""].[1]"";
			Append(resultArray,st);
		}


	string result = StringJoin(resultArray, ""["");
	return result;

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	184528BA-B3AA-410D-84CA-142E3F5C4283	Return comma separated list of read only entities	1	1	1	1703	NULL	0	45708.67507	0	0
1AFCC89D-2E44-497E-9B04-EC1C7A48D81A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetMappedCompanies	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""StringDictionary"" return-value-description=""List of company to company mappings."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The version to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""The group to query."" parameter-order=""5"" />
  <dependencies>
    <process process-name=""CO_IsSubgroupConsolidationUsed"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetOwnedCompanies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_SubgroupCompany"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Groups"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_IsSubgroupConsolidationUsed"", ""*""
#include ""CO_GetOwnedCompanies"", ""*""
#include ""CO_SubgroupCompany"", ""*""
#include ""CO_Groups"", ""*""

StringDictionary CO_GetMappedCompanies(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Description: ""Calculates list of mapped companies for the SumUpBalance process with subgroup consolidation."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to query."";
@Parameter[period]: ""The period to query."";
@Parameter[scenario]: ""The version to query."";
@Parameter[group]: ""The group to query."";
@Returns: ""List of company to company mappings."";
{
	bool log = false;
	if (log)
	{
		NotifyDebug(""CO_GetMappedCompanies started - current group: "" + group);
	}

	// the result
	StringDictionary mappedEntities = CreateStringDictionary();

	// only populate the dictionary when the current group uses subgroup consolidation
	if (CO_IsSubgroupConsolidationUsed(connection, configurationSet, year, period, scenario, group))
	{
		// this list will contain entities directly owned by the current group
		StringList directlyOwnedEntities = CO_GetOwnedCompanies(connection, configurationSet, year, period, scenario, group).ConvertToStringList();
		if (log)
		{
			NotifyDebug(""Directly owned companies:"");
			NotifyDebug(""-------------------------"");
			foreach (string key in directlyOwnedEntities)
			{
				NotifyDebug(key);
			}
			NotifyDebug(""-------------------------"");
		}

		// these dictionaries contain group to their subgroup entity mappings and vice versa; except for the current group
		StringDictionary dictionaryGroup2SubgroupEntity = CreateStringDictionary();
		StringDictionary dictionarySubgroupEntity2Group = CreateStringDictionary();

		// loop through all other groups
		StringList allOtherGroups = CO_Groups(connection, configurationSet).ToStringList();
		// exclude the current group
		allOtherGroups.RemoveAll(group);
		foreach (string subgroup in allOtherGroups)
		{
			// ...only consider the ones that use subgroup consolidation...
			if (CO_IsSubgroupConsolidationUsed(connection, configurationSet, year, period, scenario, subgroup))
			{
				// ...and are not the top groups (Subgroup Entity needs to be set)
				string subgroupEntity = CO_SubgroupCompany(connection, configurationSet, year, period, scenario, subgroup);
				if (StringTrim(subgroupEntity) != """")
				{
					// check for invalid configuration
					if (dictionarySubgroupEntity2Group.ContainsKey(subgroupEntity))
					{
						RaiseError(""Subgroup entity must not be assigned to multiple groups. The subgroup entity &lt;"" + subgroupEntity + ""&gt; is currently assigned to both &lt;"" + subgroup + ""&gt; and &lt;"" + dictionarySubgroupEntity2Group[subgroupEntity] + ""&gt; groups. Please review Group Parameters."", 0);
					}

					// populate the mapping dictionaries
					dictionaryGroup2SubgroupEntity[subgroup] = subgroupEntity;
					dictionarySubgroupEntity2Group[subgroupEntity] = subgroup;
				}
			}
		}

		if (log)
		{
			NotifyDebug(""All subgroups (except for current):"");
			NotifyDebug(""-----------------------------------"");
			foreach (string key in dictionaryGroup2SubgroupEntity.Keys())
			{
				NotifyDebug(key + "" =&gt; "" + dictionaryGroup2SubgroupEntity[key]);
			}
			NotifyDebug(""-----------------------------------"");
		}

		// this list will contain list of subgroups owned by other groups all the way up to the current group
		StringList ownedSubgroups = CreateStringList();

		// this dictionary will contain list of entities owned by the current group indirectly (via its subgroups) as a key; value will be the directly owning subgroup
		StringDictionary indirectlyOwnedEntities = CreateStringDictionary();

		// the lists are being filled gradually; we need to keep looping until there's nothing more to be added
		bool nextLoop = true;
		int counter = 0;
		while (nextLoop)
		{
			counter++;
			if (log)
			{
				NotifyDebug(""Iteration "" + counter);
			}

			nextLoop = false;
			foreach (string subgroup in dictionaryGroup2SubgroupEntity.Keys())
			{
				if (ownedSubgroups.Contains(subgroup))
				{
					// this group is already marked as owned by the current group (and has been processed) - skip it
					continue;
				}

				bool addToMappedEntities = false;
				// get the subgroup entity
				string subgroupEntity = dictionaryGroup2SubgroupEntity[subgroup];
				// check whether it is owned directly in the group
				if (directlyOwnedEntities.Contains(subgroupEntity))
				{
					// it is owned by the current group directly
					if (log)
					{
						NotifyDebug(""Found directly owned subgroup "" + subgroup);
					}

					// =&gt; its owned entities need to be added to the mapped entities
					addToMappedEntities = true;
				}
				// check whether it is owned indirectly in the group
				else if (indirectlyOwnedEntities.Keys().Contains(subgroupEntity))
				{
					// it is owned by the current group indirectly
					if (log)
					{
						NotifyDebug(""Found indirectly owned subgroup "" + subgroup);
					}

					// =&gt; its owned entities need to be added to the mapped entities
					addToMappedEntities = true;
				}

				// we need to process the entities of the subgroup
				if (addToMappedEntities)
				{
					// =&gt; add it to the collection so we do not process it multiple times
					ownedSubgroups.Append(subgroup);

					// get the list of entities owned by this subgroup
					StringList subgroupOwnedEntities = CO_GetOwnedCompanies(connection, configurationSet, year, period, scenario, subgroup).ConvertToStringList();
					// loop through the list and find indirectly owned entities of the current group
					foreach (string entity in subgroupOwnedEntities)
					{
						// check that the entity is not owned by the current group directly
						if (!directlyOwnedEntities.Contains(entity))
						{
							// add the entity to the collection of indirectly owned entitites
							indirectlyOwnedEntities[entity] = subgroup;
							if (log)
							{
								NotifyDebug(""Registering indirectly owned entity "" + entity + "" =&gt; "" + subgroup);
							}

							// and populate the mapping in case it hasn't been populated yet (from higher subgroup)
							if (!mappedEntities.ContainsKey(entity))
							{
								// find the target entity for the mapping
								string targetEntity = subgroupEntity;
								// it needs to be directly owned by the group
								while (!directlyOwnedEntities.Contains(targetEntity))
								{
									// go one level up
									string upperSubgroup = indirectlyOwnedEntities[targetEntity];
									// find the subgroup entity of the group
									targetEntity = dictionaryGroup2SubgroupEntity[upperSubgroup];
								}
								mappedEntities[entity] = targetEntity;
								if (log)
								{
									NotifyDebug(""Registering mapped entity "" + entity + "" =&gt; "" + targetEntity);
								}
							}
						}
						// and trigger next loop
						nextLoop = true;
					}
				}
			}
		}
		if (log)
		{
			NotifyDebug(""Iterating is finished; no more related subgroups found."");
		}

		if (log)
		{
			NotifyDebug(""Result:"");
			NotifyDebug(""Recognized owned subgroups:"");
			NotifyDebug(""---------------------------"");
			foreach (string key in ownedSubgroups)
			{
				NotifyDebug(key);
			}
			NotifyDebug(""---------------------------"");

			NotifyDebug(""Indirectly owned companies:"");
			NotifyDebug(""---------------------------"");
			foreach (string key in indirectlyOwnedEntities.Keys())
			{
				NotifyDebug(key + "" =&gt; "" + indirectlyOwnedEntities[key]);
			}
			NotifyDebug(""---------------------------"");

			NotifyDebug(""Mapped companies:"");
			NotifyDebug(""-----------------"");
			foreach (string key in mappedEntities.Keys())
			{
				NotifyDebug(key + "" =&gt; "" + mappedEntities[key]);
			}
			NotifyDebug(""-----------------"");
		}
	}
	else
	{
		if (log)
		{
			NotifyDebug(""Group is not configured for subgroup consolidation. Nothing to do."");
		}
	}

	if (log)
	{
		NotifyDebug(""CO_GetMappedCompanies finished"");
	}

	return mappedEntities;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_IsSubgroupConsolidationUsed"", ""*""
#include ""CO_GetOwnedCompanies"", ""*""
#include ""CO_SubgroupCompany"", ""*""
#include ""CO_Groups"", ""*""

StringDictionary CO_GetMappedCompanies(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Description: ""Calculates list of mapped companies for the SumUpBalance process with subgroup consolidation."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to query."";
@Parameter[period]: ""The period to query."";
@Parameter[scenario]: ""The version to query."";
@Parameter[group]: ""The group to query."";
@Returns: ""List of company to company mappings."";
{
	bool log = false;
	if (log)
	{
		NotifyDebug(""CO_GetMappedCompanies started - current group: "" + group);
	}

	// the result
	StringDictionary mappedEntities = CreateStringDictionary();

	// only populate the dictionary when the current group uses subgroup consolidation
	if (CO_IsSubgroupConsolidationUsed(connection, configurationSet, year, period, scenario, group))
	{
		// this list will contain entities directly owned by the current group
		StringList directlyOwnedEntities = CO_GetOwnedCompanies(connection, configurationSet, year, period, scenario, group).ConvertToStringList();
		if (log)
		{
			NotifyDebug(""Directly owned companies:"");
			NotifyDebug(""-------------------------"");
			foreach (string key in directlyOwnedEntities)
			{
				NotifyDebug(key);
			}
			NotifyDebug(""-------------------------"");
		}

		// these dictionaries contain group to their subgroup entity mappings and vice versa; except for the current group
		StringDictionary dictionaryGroup2SubgroupEntity = CreateStringDictionary();
		StringDictionary dictionarySubgroupEntity2Group = CreateStringDictionary();

		// loop through all other groups
		StringList allOtherGroups = CO_Groups(connection, configurationSet).ToStringList();
		// exclude the current group
		allOtherGroups.RemoveAll(group);
		foreach (string subgroup in allOtherGroups)
		{
			// ...only consider the ones that use subgroup consolidation...
			if (CO_IsSubgroupConsolidationUsed(connection, configurationSet, year, period, scenario, subgroup))
			{
				// ...and are not the top groups (Subgroup Entity needs to be set)
				string subgroupEntity = CO_SubgroupCompany(connection, configurationSet, year, period, scenario, subgroup);
				if (StringTrim(subgroupEntity) != """")
				{
					// check for invalid configuration
					if (dictionarySubgroupEntity2Group.ContainsKey(subgroupEntity))
					{
						RaiseError(""Subgroup entity must not be assigned to multiple groups. The subgroup entity <"" + subgroupEntity + ""> is currently assigned to both <"" + subgroup + ""> and <"" + dictionarySubgroupEntity2Group[subgroupEntity] + ""> groups. Please review Group Parameters."", 0);
					}

					// populate the mapping dictionaries
					dictionaryGroup2SubgroupEntity[subgroup] = subgroupEntity;
					dictionarySubgroupEntity2Group[subgroupEntity] = subgroup;
				}
			}
		}

		if (log)
		{
			NotifyDebug(""All subgroups (except for current):"");
			NotifyDebug(""-----------------------------------"");
			foreach (string key in dictionaryGroup2SubgroupEntity.Keys())
			{
				NotifyDebug(key + "" => "" + dictionaryGroup2SubgroupEntity[key]);
			}
			NotifyDebug(""-----------------------------------"");
		}

		// this list will contain list of subgroups owned by other groups all the way up to the current group
		StringList ownedSubgroups = CreateStringList();

		// this dictionary will contain list of entities owned by the current group indirectly (via its subgroups) as a key; value will be the directly owning subgroup
		StringDictionary indirectlyOwnedEntities = CreateStringDictionary();

		// the lists are being filled gradually; we need to keep looping until there's nothing more to be added
		bool nextLoop = true;
		int counter = 0;
		while (nextLoop)
		{
			counter++;
			if (log)
			{
				NotifyDebug(""Iteration "" + counter);
			}

			nextLoop = false;
			foreach (string subgroup in dictionaryGroup2SubgroupEntity.Keys())
			{
				if (ownedSubgroups.Contains(subgroup))
				{
					// this group is already marked as owned by the current group (and has been processed) - skip it
					continue;
				}

				bool addToMappedEntities = false;
				// get the subgroup entity
				string subgroupEntity = dictionaryGroup2SubgroupEntity[subgroup];
				// check whether it is owned directly in the group
				if (directlyOwnedEntities.Contains(subgroupEntity))
				{
					// it is owned by the current group directly
					if (log)
					{
						NotifyDebug(""Found directly owned subgroup "" + subgroup);
					}

					// => its owned entities need to be added to the mapped entities
					addToMappedEntities = true;
				}
				// check whether it is owned indirectly in the group
				else if (indirectlyOwnedEntities.Keys().Contains(subgroupEntity))
				{
					// it is owned by the current group indirectly
					if (log)
					{
						NotifyDebug(""Found indirectly owned subgroup "" + subgroup);
					}

					// => its owned entities need to be added to the mapped entities
					addToMappedEntities = true;
				}

				// we need to process the entities of the subgroup
				if (addToMappedEntities)
				{
					// => add it to the collection so we do not process it multiple times
					ownedSubgroups.Append(subgroup);

					// get the list of entities owned by this subgroup
					StringList subgroupOwnedEntities = CO_GetOwnedCompanies(connection, configurationSet, year, period, scenario, subgroup).ConvertToStringList();
					// loop through the list and find indirectly owned entities of the current group
					foreach (string entity in subgroupOwnedEntities)
					{
						// check that the entity is not owned by the current group directly
						if (!directlyOwnedEntities.Contains(entity))
						{
							// add the entity to the collection of indirectly owned entitites
							indirectlyOwnedEntities[entity] = subgroup;
							if (log)
							{
								NotifyDebug(""Registering indirectly owned entity "" + entity + "" => "" + subgroup);
							}

							// and populate the mapping in case it hasn't been populated yet (from higher subgroup)
							if (!mappedEntities.ContainsKey(entity))
							{
								// find the target entity for the mapping
								string targetEntity = subgroupEntity;
								// it needs to be directly owned by the group
								while (!directlyOwnedEntities.Contains(targetEntity))
								{
									// go one level up
									string upperSubgroup = indirectlyOwnedEntities[targetEntity];
									// find the subgroup entity of the group
									targetEntity = dictionaryGroup2SubgroupEntity[upperSubgroup];
								}
								mappedEntities[entity] = targetEntity;
								if (log)
								{
									NotifyDebug(""Registering mapped entity "" + entity + "" => "" + targetEntity);
								}
							}
						}
						// and trigger next loop
						nextLoop = true;
					}
				}
			}
		}
		if (log)
		{
			NotifyDebug(""Iterating is finished; no more related subgroups found."");
		}

		if (log)
		{
			NotifyDebug(""Result:"");
			NotifyDebug(""Recognized owned subgroups:"");
			NotifyDebug(""---------------------------"");
			foreach (string key in ownedSubgroups)
			{
				NotifyDebug(key);
			}
			NotifyDebug(""---------------------------"");

			NotifyDebug(""Indirectly owned companies:"");
			NotifyDebug(""---------------------------"");
			foreach (string key in indirectlyOwnedEntities.Keys())
			{
				NotifyDebug(key + "" => "" + indirectlyOwnedEntities[key]);
			}
			NotifyDebug(""---------------------------"");

			NotifyDebug(""Mapped companies:"");
			NotifyDebug(""-----------------"");
			foreach (string key in mappedEntities.Keys())
			{
				NotifyDebug(key + "" => "" + mappedEntities[key]);
			}
			NotifyDebug(""-----------------"");
		}
	}
	else
	{
		if (log)
		{
			NotifyDebug(""Group is not configured for subgroup consolidation. Nothing to do."");
		}
	}

	if (log)
	{
		NotifyDebug(""CO_GetMappedCompanies finished"");
	}

	return mappedEntities;
}"	1	BEABFF00-B3BE-4701-9A21-1545D9BDBFE2	Calculates list of mapped companies for the SumUpBalance process with subgroup consolidation.	1	1	1	1704	NULL	0	45708.67502	0	0
543F8DE9-D4DC-4EF6-B45A-005F9BBA316E	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedOrClosedPeriodsEntity	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of periods"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected from list of consolidation entities"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""ytd"" parameter-type=""string"" parameter-description=""if true, YTD periods will be returned, otherwise periodic one"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsEntity(string server, string cycle, string version, string entity, string ytd)
@Description: ""Get list of opened or closed periods used for given cycle/version/entity/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsEntity:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsEntity(string server, string cycle, string version, string entity, string ytd)
@Description: ""Get list of opened or closed periods used for given cycle/version/entity/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsEntity:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	15E9FA10-71EC-48E2-94C3-67C32A7EFEF0	Get list of opened or closed periods used for given cycle/version/entity/levels	1	1	1	1705	NULL	0	45708.67501	0	0
F0B56636-16ED-460F-ABCD-C81A4B74B8E8	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedOrClosedPeriodsEntityXML	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XMl with periods and statuses values inside"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""Configuration set selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected from list of consolidation entities"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsEntityXML(string server, string configurationSet, string version, string entity)
@Description: ""Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""Configuration set selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Returns: ""XMl with periods and statuses values inside"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsEntityXML:"";
	string dimDTIME = ""DTIME"";
	string statusECube = ""TSTATUSC"";
	string statusEDimension = ""DSTATUSC"";
	string period = """";
	string year = """";
	double totalEntityControl = 0;
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSet = ""SET_001"";
		version = ""V01"";
		entity = ""RU0001"";*/

		OLAPElementList dtimeOElelementList = OLAPGetElementList(connection, dimDTIME,true);
		StringList dtimeStringList =  ConvertToStringList(dtimeOElelementList);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		
		foreach(string dTime  in dtimeStringList)
		{
			if(dTime != """")
			{
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(row, ""name"",""[""+dimDTIME+""].[""+dTime+""].[1]"");
				period = StringSubstring(dTime, 0, 2);
				year= StringSubstring(dTime, 3, 4);
				totalEntityControl = OLAPCellReadNumber(connection, statusECube, 1.0, configurationSet, year,period, version,entity,""Total_Status"");
				XMLSetAttributeValue(property, ""name"", ""status"");
				XMLSetAttributeValue(property, ""value"", ToString(totalEntityControl));
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsEntityXML(string server, string configurationSet, string version, string entity)
@Description: ""Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""Configuration set selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Returns: ""XMl with periods and statuses values inside"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsEntityXML:"";
	string dimDTIME = ""DTIME"";
	string statusECube = ""TSTATUSC"";
	string statusEDimension = ""DSTATUSC"";
	string period = """";
	string year = """";
	double totalEntityControl = 0;
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSet = ""SET_001"";
		version = ""V01"";
		entity = ""RU0001"";*/

		OLAPElementList dtimeOElelementList = OLAPGetElementList(connection, dimDTIME,true);
		StringList dtimeStringList =  ConvertToStringList(dtimeOElelementList);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		
		foreach(string dTime  in dtimeStringList)
		{
			if(dTime != """")
			{
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(row, ""name"",""[""+dimDTIME+""].[""+dTime+""].[1]"");
				period = StringSubstring(dTime, 0, 2);
				year= StringSubstring(dTime, 3, 4);
				totalEntityControl = OLAPCellReadNumber(connection, statusECube, 1.0, configurationSet, year,period, version,entity,""Total_Status"");
				XMLSetAttributeValue(property, ""name"", ""status"");
				XMLSetAttributeValue(property, ""value"", ToString(totalEntityControl));
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	8382B7A1-1392-4042-AC52-68C896A51D51	Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element	1	1	1	1706	NULL	0	45708.67505	0	0
5643C88D-85DC-4E80-A32B-98AA96A80DBD	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedOrClosedPeriodsGroup	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of periods"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""Group selected from list of consolidation groups"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""ytd"" parameter-type=""string"" parameter-description=""if true, YTD periods will be returned, otherwise periodic one"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsGroup(string server, string cycle, string version, string group, string ytd)
@Description: ""Get list of opened or closed periods used for given cycle/version/group/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsGroup:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

					Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsGroup(string server, string cycle, string version, string group, string ytd)
@Description: ""Get list of opened or closed periods used for given cycle/version/group/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsGroup:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

					Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	6BFC4639-2446-44E5-BAAA-E41810EF033A	Get list of opened or closed periods used for given cycle/version/group/levels	1	1	1	1707	NULL	0	45708.67509	0	0
62711836-85C6-4653-B7C9-51999645C5E5	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedOrClosedPeriodsGroupXML	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XMl with periods and statuses values inside"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""Configuration set selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""Entity selected from list of consolidation groups"" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsGroupXML(string server, string configurationSet, string version, string group)
@Description: ""Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""Configuration set selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Entity selected from list of consolidation groups"";
@Returns: ""XMl with periods and statuses values inside"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsGroupXML:"";
	string dimDTIME = ""DTIME"";
	string statusGCube = ""TSTATUSG"";
	string statusGDimension = ""DSTATUSG"";
	string period = """";
	string year = """";
	double totalEntityControl = 0;
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSet = ""SET_001"";
		version = ""V01"";
		group = ""GR0001"";*/

		OLAPElementList dtimeOElelementList = OLAPGetElementList(connection, dimDTIME,true);
		StringList dtimeStringList =  ConvertToStringList(dtimeOElelementList);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		
		foreach(string dTime  in dtimeStringList)
		{
			if(dTime != """")
			{
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(row, ""name"",""[""+dimDTIME+""].[""+dTime+""].[1]"");
				period = StringSubstring(dTime, 0, 2);
				year= StringSubstring(dTime, 3, 4);
				totalEntityControl = OLAPCellReadNumber(connection, statusGCube, 1.0, configurationSet, year,period, version,group,""Total_Status"");
				XMLSetAttributeValue(property, ""name"", ""status"");
				XMLSetAttributeValue(property, ""value"", ToString(totalEntityControl));
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedOrClosedPeriodsGroupXML(string server, string configurationSet, string version, string group)
@Description: ""Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""Configuration set selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Entity selected from list of consolidation groups"";
@Returns: ""XMl with periods and statuses values inside"";
{
	string functionName = ""CO_GetOpenedOrClosedPeriodsGroupXML:"";
	string dimDTIME = ""DTIME"";
	string statusGCube = ""TSTATUSG"";
	string statusGDimension = ""DSTATUSG"";
	string period = """";
	string year = """";
	double totalEntityControl = 0;
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*configurationSet = ""SET_001"";
		version = ""V01"";
		group = ""GR0001"";*/

		OLAPElementList dtimeOElelementList = OLAPGetElementList(connection, dimDTIME,true);
		StringList dtimeStringList =  ConvertToStringList(dtimeOElelementList);
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		
		foreach(string dTime  in dtimeStringList)
		{
			if(dTime != """")
			{
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(row, ""name"",""[""+dimDTIME+""].[""+dTime+""].[1]"");
				period = StringSubstring(dTime, 0, 2);
				year= StringSubstring(dTime, 3, 4);
				totalEntityControl = OLAPCellReadNumber(connection, statusGCube, 1.0, configurationSet, year,period, version,group,""Total_Status"");
				XMLSetAttributeValue(property, ""name"", ""status"");
				XMLSetAttributeValue(property, ""value"", ToString(totalEntityControl));
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	BD88454A-FC87-41E4-83F2-A9ED91E37337	Get xml of opened or closed periods used for given cycle/version/entity/levels with statuses in TOTAL_STATUS element	1	1	1	1708	NULL	0	45708.67502	0	0
10BDA388-FBB8-4CC4-8275-5C25BAD24465	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedPeriodsEntity	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of periods"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity selected from list of consolidation entities"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""ytd"" parameter-type=""bool"" parameter-description=""if true, YTD periods will be returned, otherwise periodic one"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedPeriodsEntity(string server, string cycle, string version, string entity, bool ytd)
@Description: ""Get list of opened periods used for given cycle/version/entity/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedPeriodsEntity:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedPeriodsEntity(string server, string cycle, string version, string entity, bool ytd)
@Description: ""Get list of opened periods used for given cycle/version/entity/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[entity]: ""Entity selected from list of consolidation entities"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedPeriodsEntity:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	9BAFCD36-2F49-4577-9000-A33138AE13ED	Get list of opened periods used for given cycle/version/entity/levels	1	1	1	1709	NULL	0	45708.67502	0	0
D3D2A0A1-BD12-4297-BD0C-63AD3E8B3D21	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOpenedPeriodsGroup	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of periods"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""version"" parameter-type=""string"" parameter-description=""Version selected from list of consolidation version"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""Group selected from list of consolidation groups"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""ytd"" parameter-type=""bool"" parameter-description=""if true, YTD periods will be returned, otherwise periodic one"" parameter-order=""4"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedPeriodsGroup(string server, string cycle, string version, string group, bool ytd)
@Description: ""Get list of opened periods used for given cycle/version/group/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedPeriodsGroup:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetOpenedPeriodsGroup(string server, string cycle, string version, string group, bool ytd)
@Description: ""Get list of opened periods used for given cycle/version/group/levels"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[version]: ""Version selected from list of consolidation version"";
@Parameter[group]: ""Group selected from list of consolidation groups"";
@Parameter[ytd]: ""if true, YTD periods will be returned, otherwise periodic one"";
@Returns: ""Comma separated list of periods"";
{
	string functionName = ""CO_GetOpenedPeriodsGroup:"";
	string dimDTIME = ""DTIME"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList periodOElelementList = OLAPGetElementList(olapConnection, dimDTIME,true);
		StringList periodStringList =  ConvertToStringList(periodOElelementList);
		StringArray periodStringArray  = CreateStringArray();
		
		foreach(string period  in periodStringList)
		{
			if(period != """")
			{

				Append(periodStringArray, ""[""+dimDTIME+""].[""+period+""].[1]"");

			}

		}
		string periodresult  = StringJoin(periodStringArray, "","");

		return periodresult;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	77A67C05-49CB-427B-9AA2-9F7B65264DC9	Get list of opened periods used for given cycle/version/group/levels	1	1	1	1710	NULL	0	45708.67501	0	0
64AF25AA-130A-43FC-9AD6-674324D17703	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetOwnedCompanies	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""List of owned companies."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The version to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""The group to query."" parameter-order=""5"" />
  <dependencies>
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_IsDirectlyOwned"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_IsDirectlyOwned"", ""*""

OLAPElementList CO_GetOwnedCompanies(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Description: ""Gets list of companies directly owned by the given group in the given context."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to query."";
@Parameter[period]: ""The period to query."";
@Parameter[scenario]: ""The version to query."";
@Parameter[group]: ""The group to query."";
@Returns: ""List of owned companies."";
{
	OLAPElementList result = CreateOLAPElementList();

	OLAPElementList allEntities = CO_Companies(connection, configurationSet);
	foreach (OLAPElement entity in allEntities)
	{
		if (CO_IsDirectlyOwned(connection, configurationSet, year, period, scenario, group, entity))
		{
			result.ElementListAddElement(entity);
		}
	}
	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_Companies"", ""*""
#include ""CO_IsDirectlyOwned"", ""*""

OLAPElementList CO_GetOwnedCompanies(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Description: ""Gets list of companies directly owned by the given group in the given context."";
@Category: ""Consolidation Base Process"";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[year]: ""The year to query."";
@Parameter[period]: ""The period to query."";
@Parameter[scenario]: ""The version to query."";
@Parameter[group]: ""The group to query."";
@Returns: ""List of owned companies."";
{
	OLAPElementList result = CreateOLAPElementList();

	OLAPElementList allEntities = CO_Companies(connection, configurationSet);
	foreach (OLAPElement entity in allEntities)
	{
		if (CO_IsDirectlyOwned(connection, configurationSet, year, period, scenario, group, entity))
		{
			result.ElementListAddElement(entity);
		}
	}
	return result;
}"	1	2EA8CF6F-2AD2-47A3-9221-9AD68BFC8C34	Gets list of companies directly owned by the given group in the given context.	1	1	1	1711	NULL	0	45708.67509	0	0
C598B6FA-7E85-4362-9252-5A4D1013EF9B	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetProcessProperty	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Requested property value."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""processId"" parameter-type=""string"" parameter-description=""Name of element that specifies the process."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""propertyName"" parameter-type=""string"" parameter-description=""Name of property to retrieve."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetProcessProperty(OLAPConnection connection, string configurationSet, string processId, string propertyName)
@Category: ""Consolidation Base Process"";
@Description: ""Gets property of given process in configuration set."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[processId]: ""Name of element that specifies the process."";
@Parameter[propertyName]: ""Name of property to retrieve."";
@Returns: ""Requested property value."";
{
	OLAPElement processElement = OLAPGetDimensionElement(connection, ""DCONSRL"", processId);

	string attributeName = """";
	if (
		propertyName == ""Currency Translation Differences Account"" or
		propertyName == ""Non Controlling Interests Account"" or
		propertyName == ""Inventory Accounts"" or
		propertyName == ""Profit from Associated Entities"" or
		propertyName == ""Debit Differences Account""
	) {
		attributeName = ""Account1"";
	} else if (
		propertyName == ""Other Differences Account"" or
		propertyName == ""Non Controlling Interests Contra-Account"" or
		propertyName == ""Inventory Contra-Account"" or
		propertyName == ""Shares in Associated Entities"" or
		propertyName == ""Credit Differences Account""
	) {
		attributeName = ""Account2"";
	} else if (
		propertyName == ""Base Account"" or
		propertyName == ""Profit (Loss) from Associated Entities (calculation basis)""
	) {
		attributeName = ""Account3"";
	} else if (
		propertyName == ""Currency Translation Differences Detail"" or
		propertyName == ""Non Controlling Interests Account Detail"" or
		propertyName == ""Inventory Account Detail"" or
		propertyName == ""Profit from Associated Entities Detail"" or
		propertyName == ""Debit Differences Account Detail""
	) {
		attributeName = ""Detail1"";
	} else if (
		propertyName == ""Other Differences Detail"" or
		propertyName == ""Non Controlling Interests Contra-Account Detail"" or
		propertyName == ""Inventory Contra-Account Detail"" or
		propertyName == ""Shares in Associated Entities Detail for Increases"" or
		propertyName == ""Credit Differences Account Detail""
	) {
		attributeName = ""Detail2"";
	} else if (
		propertyName == ""Shares in Associated Entities Detail for Decreases""
	) {
		attributeName = ""Detail3"";
	} else if (
		propertyName == ""Account Set"" or
		propertyName == ""Investment Accounts""
	) {
		attributeName = ""Accounts"";
	} else if (
		propertyName == ""Contra-Account Set"" or
		propertyName == ""Equity Accounts of the Subsidiaries""
	) {
		attributeName = ""ContraAccounts"";
	} else if (
		propertyName == ""Loss from Associated Entities""
	) {
		attributeName = ""Account4"";
	} else if (
		propertyName == ""Loss from Associated Entities Detail""
	) {
		attributeName = ""Detail4"";
	} else if (
		propertyName == ""Dividends received from Associated Entities""
	) {
		attributeName = ""Account5"";
	} else if (
		propertyName == ""Dividends received from Associated Entities Detail""
	) {
		attributeName = ""Detail5"";
	} else if (
		propertyName == ""Generate Segment Journals""
	) {
		int value = cached OLAPGetIntAttribute(connection, processElement, ""BookingType"");
		return value.ToString();
	}
	if (attributeName == """")
	{
		return """";
	}
	else
	{
		return cached OLAPGetStringAttribute(connection, processElement, attributeName);
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetProcessProperty(OLAPConnection connection, string configurationSet, string processId, string propertyName)
@Category: ""Consolidation Base Process"";
@Description: ""Gets property of given process in configuration set."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[processId]: ""Name of element that specifies the process."";
@Parameter[propertyName]: ""Name of property to retrieve."";
@Returns: ""Requested property value."";
{
	OLAPElement processElement = OLAPGetDimensionElement(connection, ""DCONSRL"", processId);

	string attributeName = """";
	if (
		propertyName == ""Currency Translation Differences Account"" or
		propertyName == ""Non Controlling Interests Account"" or
		propertyName == ""Inventory Accounts"" or
		propertyName == ""Profit from Associated Entities"" or
		propertyName == ""Debit Differences Account""
	) {
		attributeName = ""Account1"";
	} else if (
		propertyName == ""Other Differences Account"" or
		propertyName == ""Non Controlling Interests Contra-Account"" or
		propertyName == ""Inventory Contra-Account"" or
		propertyName == ""Shares in Associated Entities"" or
		propertyName == ""Credit Differences Account""
	) {
		attributeName = ""Account2"";
	} else if (
		propertyName == ""Base Account"" or
		propertyName == ""Profit (Loss) from Associated Entities (calculation basis)""
	) {
		attributeName = ""Account3"";
	} else if (
		propertyName == ""Currency Translation Differences Detail"" or
		propertyName == ""Non Controlling Interests Account Detail"" or
		propertyName == ""Inventory Account Detail"" or
		propertyName == ""Profit from Associated Entities Detail"" or
		propertyName == ""Debit Differences Account Detail""
	) {
		attributeName = ""Detail1"";
	} else if (
		propertyName == ""Other Differences Detail"" or
		propertyName == ""Non Controlling Interests Contra-Account Detail"" or
		propertyName == ""Inventory Contra-Account Detail"" or
		propertyName == ""Shares in Associated Entities Detail for Increases"" or
		propertyName == ""Credit Differences Account Detail""
	) {
		attributeName = ""Detail2"";
	} else if (
		propertyName == ""Shares in Associated Entities Detail for Decreases""
	) {
		attributeName = ""Detail3"";
	} else if (
		propertyName == ""Account Set"" or
		propertyName == ""Investment Accounts""
	) {
		attributeName = ""Accounts"";
	} else if (
		propertyName == ""Contra-Account Set"" or
		propertyName == ""Equity Accounts of the Subsidiaries""
	) {
		attributeName = ""ContraAccounts"";
	} else if (
		propertyName == ""Loss from Associated Entities""
	) {
		attributeName = ""Account4"";
	} else if (
		propertyName == ""Loss from Associated Entities Detail""
	) {
		attributeName = ""Detail4"";
	} else if (
		propertyName == ""Dividends received from Associated Entities""
	) {
		attributeName = ""Account5"";
	} else if (
		propertyName == ""Dividends received from Associated Entities Detail""
	) {
		attributeName = ""Detail5"";
	} else if (
		propertyName == ""Generate Segment Journals""
	) {
		int value = cached OLAPGetIntAttribute(connection, processElement, ""BookingType"");
		return value.ToString();
	}
	if (attributeName == """")
	{
		return """";
	}
	else
	{
		return cached OLAPGetStringAttribute(connection, processElement, attributeName);
	}
}"	1	07EC0DEB-45DD-4426-9028-C79E43D557D1	Gets property of given process in configuration set.	1	1	1	1712	NULL	0	45708.67506	0	0
B8DA7F3A-5DDA-487E-94A6-A654398132D8	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetProcessPropertyAccountList	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""Requested property value as list of elements."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""processId"" parameter-type=""string"" parameter-description=""Name of element that specifies the process."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""propertyName"" parameter-type=""string"" parameter-description=""Name of property to retrieve."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_GetProcessPropertyAccountList(OLAPConnection connection, string configurationSet, string processId, string propertyName)
@Category: ""Consolidation Base Process"";
@Description: ""Gets property of given process in configuration set that is a list of accounts."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[processId]: ""Name of element that specifies the process."";
@Parameter[propertyName]: ""Name of property to retrieve."";
@Returns: ""Requested property value as list of elements."";
{
	if (
		propertyName == ""Account Set""
	) {
		return cached OLAPGetDirectChildrenList(connection, ""DACOUNT"", ""100"" + processId, true);
	} else if (
		propertyName == ""Contra-Account Set""
	) {
		return cached OLAPGetDirectChildrenList(connection, ""DACOUNT"", ""200"" + processId, true);
	}
	else
	{
		RaiseError(""Invalid property name."", 1);
		return CreateOLAPElementList();
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_GetProcessPropertyAccountList(OLAPConnection connection, string configurationSet, string processId, string propertyName)
@Category: ""Consolidation Base Process"";
@Description: ""Gets property of given process in configuration set that is a list of accounts."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[processId]: ""Name of element that specifies the process."";
@Parameter[propertyName]: ""Name of property to retrieve."";
@Returns: ""Requested property value as list of elements."";
{
	if (
		propertyName == ""Account Set""
	) {
		return cached OLAPGetDirectChildrenList(connection, ""DACOUNT"", ""100"" + processId, true);
	} else if (
		propertyName == ""Contra-Account Set""
	) {
		return cached OLAPGetDirectChildrenList(connection, ""DACOUNT"", ""200"" + processId, true);
	}
	else
	{
		RaiseError(""Invalid property name."", 1);
		return CreateOLAPElementList();
	}
}"	1	78EA1BA9-9617-4F75-9B48-3C2F900AD4D9	Gets property of given process in configuration set that is a list of accounts.	1	1	1	1713	NULL	0	45708.67505	0	0
A979E5F1-0228-49EB-9228-4F0958ADCD15	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetTopAccount	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Entities assigned for given cycle/group"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle selected from list of consolidation version"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""type"" parameter-type=""string"" parameter-description=""Type of top account to be returned A,L,PL"" parameter-order=""2"" />
  <dependencies>
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

string CO_GetTopAccount(string server, string cycle, string type)
@Description: ""Get assigned currencies for given cycle/group"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[type]: ""Type of top account to be returned A,L,PL"";
@Returns: ""Entities assigned for given cycle/group"";
{
	string functionName = ""CO_GetTopAccount:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		cycle = ResolveUniqueName(connection, cycle);

		string account ="""";

		if(type == ""A"")
		{
			string assetTopAccount = CO_TopAccount(connection, cycle, 1);

				account = ""[DACOUNT].[""+ assetTopAccount + ""].[1]"";

		}
		if(type == ""L"")
		{
			string liabilityTopAccount =  CO_TopAccount(connection, cycle, 2);
			account = ""[DACOUNT].[""+ liabilityTopAccount + ""].[1]"";

		}
		if(type == ""PL"")
		{
			string plTopAccount =  CO_TopAccount(connection, cycle, 3);
			account = ""[DACOUNT].[""+ plTopAccount + ""].[1]"";
		}
		return account;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

string CO_GetTopAccount(string server, string cycle, string type)
@Description: ""Get assigned currencies for given cycle/group"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle selected from list of consolidation version"";
@Parameter[type]: ""Type of top account to be returned A,L,PL"";
@Returns: ""Entities assigned for given cycle/group"";
{
	string functionName = ""CO_GetTopAccount:"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		cycle = ResolveUniqueName(connection, cycle);

		string account ="""";

		if(type == ""A"")
		{
			string assetTopAccount = CO_TopAccount(connection, cycle, 1);

				account = ""[DACOUNT].[""+ assetTopAccount + ""].[1]"";

		}
		if(type == ""L"")
		{
			string liabilityTopAccount =  CO_TopAccount(connection, cycle, 2);
			account = ""[DACOUNT].[""+ liabilityTopAccount + ""].[1]"";

		}
		if(type == ""PL"")
		{
			string plTopAccount =  CO_TopAccount(connection, cycle, 3);
			account = ""[DACOUNT].[""+ plTopAccount + ""].[1]"";
		}
		return account;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	2268DAC2-01AB-4ED9-9064-FE7DA3E732F0	Get assigned currencies for given cycle/group	1	1	1	1714	NULL	0	45708.67508	0	0
1B62759C-503B-41C2-AF9A-1479D1FEE637	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetTopAccountsXML	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Xml with infor about top accounts,profit and loss, liabilities, and assets"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies>
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

string CO_GetTopAccountsXML(string server,string configurationSet)
@Description: ""Create xml with top accounts for profit and loss, liabilities, and assets"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""Xml with infor about top accounts,profit and loss, liabilities, and assets"";
{
	string functionName = ""CO_GetTopAccountsXML:"";
	string errorMessage = """";
	int errorCode = 0;
	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//configurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		configurationSet = ResolveUniqueName(connection, configurationSet);

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		XMLAddElement(table, row);
		XMLSetAttributeValue(row, ""name"", ""TopAccounts"");

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""A"");
		string assets = CO_TopAccount(connection,configurationSet,1);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+assets+""].[1]"");
		XMLAddElement(row, property);

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""L"");
		string liabilities = CO_TopAccount(connection,configurationSet,2);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+liabilities+""].[1]"");
		XMLAddElement(row, property);

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""PL"");
		string profitAndLoss = CO_TopAccount(connection,configurationSet,3);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+profitAndLoss+""].[1]"");
		XMLAddElement(row, property);
		return ToString(doc);

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""

string CO_GetTopAccountsXML(string server,string configurationSet)
@Description: ""Create xml with top accounts for profit and loss, liabilities, and assets"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""Xml with infor about top accounts,profit and loss, liabilities, and assets"";
{
	string functionName = ""CO_GetTopAccountsXML:"";
	string errorMessage = """";
	int errorCode = 0;
	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//configurationSet = ""[BPDCYCLE].[SET_001].[1]"";
		configurationSet = ResolveUniqueName(connection, configurationSet);

		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		XMLAddElement(table, row);
		XMLSetAttributeValue(row, ""name"", ""TopAccounts"");

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""A"");
		string assets = CO_TopAccount(connection,configurationSet,1);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+assets+""].[1]"");
		XMLAddElement(row, property);

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""L"");
		string liabilities = CO_TopAccount(connection,configurationSet,2);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+liabilities+""].[1]"");
		XMLAddElement(row, property);

		property = XMLCreateElement(""Property"");
		XMLSetAttributeValue(property, ""name"", ""PL"");
		string profitAndLoss = CO_TopAccount(connection,configurationSet,3);
		XMLSetAttributeValue(property, ""value"", ""[DACOUNT].[""+profitAndLoss+""].[1]"");
		XMLAddElement(row, property);
		return ToString(doc);

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	0DB8C67E-E9D6-48D4-9754-7980AB12315E	Create xml with top accounts for profit and loss, liabilities, and assets	1	1	1	1715	NULL	0	45708.67501	0	0
DE8ED6FE-1C4F-497C-9420-C63B96488EE3	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GetVersions	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Comma separated list of versions used in consolidation"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""Cycle for which should be versions found"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetVersions(string server, string cycle)
@Description: ""Get list of active versions for cycle"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle for which should be versions found"";
@Returns: ""Comma separated list of versions used in consolidation"";
{
	string functionName = ""CO_GetVersions:"";
	string dimDVERSIO = ""DVERSIO"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList versionOElelementList = OLAPGetElementList(olapConnection, dimDVERSIO, true);
		StringList versionStringList =  ConvertToStringList(versionOElelementList);
		StringArray versionStringArray  = CreateStringArray();
		
		foreach(string ver  in versionStringList)
		{
			if(ver != """")
			{
				Append(versionStringArray, ""[""+dimDVERSIO+""].[""+ver+""].[1]"");
			}

		}
		string version  = StringJoin(versionStringArray, "","");

		return version;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GetVersions(string server, string cycle)
@Description: ""Get list of active versions for cycle"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[cycle]: ""Cycle for which should be versions found"";
@Returns: ""Comma separated list of versions used in consolidation"";
{
	string functionName = ""CO_GetVersions:"";
	string dimDVERSIO = ""DVERSIO"";
	string errorMessage = """";
	int errorCode = 0;

	try {
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		OLAPElementList versionOElelementList = OLAPGetElementList(olapConnection, dimDVERSIO, true);
		StringList versionStringList =  ConvertToStringList(versionOElelementList);
		StringArray versionStringArray  = CreateStringArray();
		
		foreach(string ver  in versionStringList)
		{
			if(ver != """")
			{
				Append(versionStringArray, ""[""+dimDVERSIO+""].[""+ver+""].[1]"");
			}

		}
		string version  = StringJoin(versionStringArray, "","");

		return version;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	FD4C4682-B47F-4FA9-A7EA-F72BD4BD6218	Get list of active versions for cycle	1	1	1	1716	NULL	0	45708.67501	0	0
52BE694F-90FF-4395-A2C2-66FDA3D323A5	CD491758-D9DF-4002-94C8-8006E1855F86	CO_GroupCurrency	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The group currency."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to get the group currency for."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to get the group currency for."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to get the group currency for."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The scenario to get the group currency for."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""The group to get the group currency for."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GroupCurrency(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the group currency."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the group currency for."";
@Parameter[year]: ""The year to get the group currency for."";
@Parameter[period]: ""The period to get the group currency for."";
@Parameter[scenario]: ""The scenario to get the group currency for."";
@Parameter[group]: ""The group to get the group currency for."";
@Returns: ""The group currency."";
{
	return cached OLAPCellReadString(connection, ""TCOMPPA"", configurationSet, year, period, scenario, group, ""Currency"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_GroupCurrency(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the group currency."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the group currency for."";
@Parameter[year]: ""The year to get the group currency for."";
@Parameter[period]: ""The period to get the group currency for."";
@Parameter[scenario]: ""The scenario to get the group currency for."";
@Parameter[group]: ""The group to get the group currency for."";
@Returns: ""The group currency."";
{
	return cached OLAPCellReadString(connection, ""TCOMPPA"", configurationSet, year, period, scenario, group, ""Currency"");
}"	1	D895B460-2DCF-4268-A7FA-8C966FB8B90A	Gets the group currency.	1	1	1	1717	NULL	0	45708.67502	0	0
9A5DAE8D-E21B-4B3F-947C-8C477186F901	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Groups	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of groups."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Groups(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of groups."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of groups."";
{
	return cached OLAPGetElementList(connection, ""DGROUP"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Groups(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of groups."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of groups."";
{
	return cached OLAPGetElementList(connection, ""DGROUP"", true);
}"	1	B0FC86FB-30F2-479D-AD7B-CCDABDEFD2FB	Gets the list of groups.	1	1	1	1718	NULL	0	45708.67509	0	0
B608CFFA-8A24-4CB7-97C4-09DBA8D271CA	CD491758-D9DF-4002-94C8-8006E1855F86	CO_HasSegment	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if the segment is used."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""segmentNumber"" parameter-type=""int"" parameter-description=""The number of the segment (1,2, or 3)."" parameter-order=""2"" />
  <dependencies>
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountHasSegment"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""
#include ""CO_AccountHasSegment"", ""*""


bool CO_HasSegment(OLAPConnection connection, string configurationSet, int segmentNumber)
@Category: ""Consolidation Base Process"";
@Description: ""Gets whether the specified segment is used."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[segmentNumber]: ""The number of the segment (1,2, or 3)."";
@Returns: ""True, if the segment is used."";
{
	// VL - get P&amp;L top account and read its segment attributes
	string totalPaL = CO_TopAccount(connection, configurationSet, 3);
	return CO_AccountHasSegment(connection, configurationSet, totalPaL,segmentNumber);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_TopAccount"", ""*""
#include ""CO_AccountHasSegment"", ""*""


bool CO_HasSegment(OLAPConnection connection, string configurationSet, int segmentNumber)
@Category: ""Consolidation Base Process"";
@Description: ""Gets whether the specified segment is used."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[segmentNumber]: ""The number of the segment (1,2, or 3)."";
@Returns: ""True, if the segment is used."";
{
	// VL - get P&L top account and read its segment attributes
	string totalPaL = CO_TopAccount(connection, configurationSet, 3);
	return CO_AccountHasSegment(connection, configurationSet, totalPaL,segmentNumber);
}"	1	B4AA6A5B-480C-4C36-ABFB-B36EDE188B39	Gets whether the specified segment is used.	1	1	1	1719	NULL	0	45708.67501	0	0
22C1FE61-A0A0-492A-A866-2304E617514A	CD491758-D9DF-4002-94C8-8006E1855F86	CO_HoldingCompany	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The holding company of the specified group"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to get the holding company for."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_HoldingCompany(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the holding company of a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the holding company for."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Returns: ""The holding company of the specified group"";
{
	return cached OLAPCellReadString(connection, ""TCONSPA"", configurationSet, year, period, scenario, group, ""global"", ""global"", ""holding company"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_HoldingCompany(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the holding company of a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the holding company for."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Returns: ""The holding company of the specified group"";
{
	return cached OLAPCellReadString(connection, ""TCONSPA"", configurationSet, year, period, scenario, group, ""global"", ""global"", ""holding company"");
}"	1	77722954-5374-4628-BFBE-A1096B1C8C00	Gets the holding company of a group for a specified context.	1	1	1	1720	NULL	0	45708.67504	0	0
BDFBAEC1-8C9D-4250-9D85-FEC6939C6215	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IntercompaniesWithoutExternal	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of intercompanies."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_IntercompaniesWithoutExternal(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of intercompanies excluding the External element, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of intercompanies."";
{
	return cached OLAPGetChildElementList(connection, ""DINTCO"", ""Group Companies"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_IntercompaniesWithoutExternal(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of intercompanies excluding the External element, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of intercompanies."";
{
	return cached OLAPGetChildElementList(connection, ""DINTCO"", ""Group Companies"", true);
}"	1	2C99383D-A8D3-4415-9E48-EC54838CF5C2	Gets the list of intercompanies excluding the External element, only base elements.	1	1	1	1721	NULL	0	45708.67502	0	0
B091F858-8F3D-4F92-8679-B0EE028CCC78	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IntercompanyProfitElimination	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountHasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CalculatedShares"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_CompanyTaxRate"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_TopAccount"" process-version=""*"" process-id="""" />
    <process process-name=""CO_HoldingCompany"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetAccountElementList"" process-version=""*"" process-id="""" />
    <process process-name=""ContextHasValues"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountHasSegment"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_CompanyTaxRate"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetAccountElementList"", ""*""
#include ""ContextHasValues"", ""*""

bool CO_IntercompanyProfitElimination(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCIntercompanyProfitElimination process..This process defines the consolidation process to eliminate the intercompany profit."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""I"";
	cancel = false;*/
	
	string processName = ""CO_IntercompanyProfitElimination"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			double counter1 = 0;
			double counter2 = 0;
			string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

			string accountsPropVal = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Accounts"");
			OLAPElementList inventoryAccounts = CO_GetAccountElementList(olapConnection, accountsPropVal);

			string inventoryAccountDetail = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Account Detail"");

			string inventoryContraAccount = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Contra-Account"");
			string inventoryContraAccountDetail = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Contra-Account Detail"");

			foreach (OLAPElement company in CO_Companies(olapConnection, cycle) where ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Full"") or (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Quotal""))) {
				double percentOfConsolidation = 1.0;
				if ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Quotal"")) {
					percentOfConsolidation = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), company);
				}
				
				foreach (OLAPElement intercompany in CO_Companies(olapConnection, cycle) where (((CO_ConsolidationMethod(olapConnection,cycle, year, period, scenario, group, intercompany) == ""Full"") or (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, intercompany) == ""Quotal"")) and (ContextHasValues(olapConnection,cycle, year, period, scenario, groupcurrency, ""HB III adjust"", group, company, intercompany) == true))) {
					double taxRateIntercompany = CO_CompanyTaxRate(olapConnection, cycle, year, period, scenario, intercompany);
					double deferredTax = 0;
					double percentOfConsolidationIntercompany = 1.0;
					if ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, intercompany) == ""Quotal"")) {
						percentOfConsolidationIntercompany = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), intercompany);
					}
					
					foreach (OLAPElement inventoryAccount in inventoryAccounts) {
						bool isAssetInventoryAccount = CO_AccountType(olapConnection, inventoryAccount) == ""Asset"";

						double accountValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", percentOfConsolidationIntercompany, cycle,year, period, scenario, groupcurrency, ""HB III"", group, company, intercompany, inventoryAccount);
						if (accountValue != 0) {
							double profitMargin = OLAPCellReadNumber(olapConnection, ""TCONSPA"", 1, cycle, year, period, scenario, ""global"", intercompany, company, ""Profit Margin"");
							if (profitMargin &gt; 0) {
								bool useSegments = false;
								if (CO_AccountHasSegment(olapConnection, cycle, inventoryAccount, 1) or CO_AccountHasSegment(olapConnection, cycle, inventoryAccount, 2) or CO_AccountHasSegment(olapConnection, cycle,  inventoryAccount, 3)) {
									useSegments = true;
								}

								if (!useSegments) {
									double rolloverValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", percentOfConsolidationIntercompany, cycle,year, period, scenario, groupcurrency, ""Rollover Total"", group, company, intercompany, inventoryAccount);
									double stockValue = accountValue * profitMargin + rolloverValue;
									GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Other"", ruleid, """", true);
									
									if ((isAssetInventoryAccount and stockValue &lt; 0) or (!isAssetInventoryAccount and stockValue &gt; 0)) {
										ConsolidationAddGroupJournalLine(journal, company, intercompany, inventoryAccount, inventoryAccountDetail, """", Abs(stockValue), 0.0);
									} else {
										ConsolidationAddGroupJournalLine(journal, company, intercompany, inventoryAccount, inventoryAccountDetail, """", 0.0, Abs(stockValue));
									}
									
									if ((isAssetInventoryAccount and stockValue &lt; 0) or (!isAssetInventoryAccount and stockValue &gt; 0)) {
										ConsolidationAddGroupJournalLine(journal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail, """", 0.0, Abs(stockValue));
									} else {
										ConsolidationAddGroupJournalLine(journal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail, """", Abs(stockValue), 0.0);
									}
									
									if (CO_TopAccount(olapConnection, cycle, 14) != """" and CO_TopAccount(olapConnection, cycle, 15) != """"
									    and CO_TopAccount(olapConnection, cycle, 16) != """" and CO_TopAccount(olapConnection, cycle, 17) != """") {
										
										deferredTax = stockValue * taxRateIntercompany;
										
										if ((isAssetInventoryAccount and deferredTax &lt; 0) or (!isAssetInventoryAccount and deferredTax &gt; 0)) {
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 14), CO_TopAccount(olapConnection, cycle, 114), """",  Abs(deferredTax), 0.0);
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 17), CO_TopAccount(olapConnection, cycle, 117), """", 0.0, Abs(deferredTax));
										} else {
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 15), CO_TopAccount(olapConnection, cycle, 115), """", 0.0,  Abs(deferredTax));
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 16), CO_TopAccount(olapConnection, cycle, 116), """", Abs(deferredTax), 0.0);
										}
									}
									
									if (!ConsolidationJournalIsEmpty(journal)) {
										if (ConsolidationJournalIsBalanced(journal)) {
											ConsolidationPostJournal(journalStore, journal);
											counter1 = counter1 + 1;
										} else {
											WriteLine(""Warning: The journal was not posted as it was unbalanced."");
										}
									}
								} else {
									GroupJournal segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Other"", ""Intersegment"", ruleid, """", true);
									
									OLAPElementList DGLEVEL = CreateOLAPElementList();
									OLAPElementListAddElement(DGLEVEL, OLAPGetDimensionElement(olapConnection, ""DGLEVEL"", ""HB III""));
									//OLAPElementListAddElement(DGLEVEL, OLAPGetDimensionElement(olapConnection, ""DGLEVEL"", ""Rollover Total""));

									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, year, period, scenario, groupcurrency, DGLEVEL, group, ""Consolidated Segments"", company, intercompany,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, inventoryAccount
									);

									foreach (OLAPCell cell in sourceArea)
									{
										accountValue = cell;
										accountValue = accountValue * percentOfConsolidationIntercompany;

										if (accountValue != 0) {
											string pPrimarySegment = OLAPCellGetElement(cell, ""DPSEGM"");
											string pSecondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
											string pTertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
											string pPrimaryPartnerSegment = OLAPCellGetElement(cell, ""DPRSEGM"");
											string pSecondaryPartnerSegment = OLAPCellGetElement(cell, ""DSRSEGM"");
											string pTertiaryPartnerSegment = OLAPCellGetElement(cell, ""DTRSEGM"");

											double rolloverValue = OLAPCellReadNumber(olapConnection, ""TSEGMG"", percentOfConsolidationIntercompany,
											                                          cycle, year, period, scenario, groupcurrency, ""Rollover Total"", group, ""Consolidated Segments"", company, intercompany,
											                                          pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
											                                          inventoryAccount);

											double stockValue = accountValue * profitMargin + rolloverValue;
											
											if ((isAssetInventoryAccount and stockValue &lt; 0) or (!isAssetInventoryAccount and stockValue &gt; 0)) {
												ConsolidationAddGroupJournalLine(segmentJournal, company, intercompany, inventoryAccount, inventoryAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", Abs(stockValue), 0.0);
											} else {
												ConsolidationAddGroupJournalLine(segmentJournal, company, intercompany, inventoryAccount, inventoryAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", 0.0, Abs(stockValue));
											}
											
											if ((isAssetInventoryAccount and stockValue &lt; 0) or (!isAssetInventoryAccount and stockValue &gt; 0)) {
												ConsolidationAddGroupJournalLine(segmentJournal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", 0.0, Abs(stockValue));
											} else {
												ConsolidationAddGroupJournalLine(segmentJournal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", Abs(stockValue), 0.0);
											}
											
											if (CO_TopAccount(olapConnection, cycle, 14) != """" and CO_TopAccount(olapConnection, cycle, 15) != """"
											    and CO_TopAccount(olapConnection, cycle, 16) != """" and CO_TopAccount(olapConnection, cycle, 17) != """") {
												
												deferredTax = stockValue * taxRateIntercompany;
												
												if ((isAssetInventoryAccount and deferredTax &lt; 0) or (!isAssetInventoryAccount and deferredTax &gt; 0)) {
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 14), CO_TopAccount(olapConnection, cycle, 114),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """",  Abs(deferredTax), 0.0);
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 17), CO_TopAccount(olapConnection, cycle, 117),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", 0.0, Abs(deferredTax));
												} else {
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 15), CO_TopAccount(olapConnection, cycle, 115),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", 0.0,  Abs(deferredTax));
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 16), CO_TopAccount(olapConnection, cycle, 116),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", Abs(deferredTax), 0.0);
												}
											}
										}
									}
									
									if (!ConsolidationJournalIsEmpty(segmentJournal)) {
										if (ConsolidationJournalIsBalanced(segmentJournal)) {
											ConsolidationPostJournal(journalStore, segmentJournal);
											counter2 = counter2 + 1;
										} else {
											WriteLine(""The journal was not posted as it was unbalanced."");
										}
									}
								}
							}
						}
					}
				}
			}
			WriteLine(""posted &lt;"" + counter1 + ""&gt; group journal(s)"");
			WriteLine(""posted &lt;"" + counter2 + ""&gt; group segment journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountHasSegment"", ""*""
#include ""CO_CalculatedShares"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_CompanyTaxRate"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_TopAccount"", ""*""
#include ""CO_HoldingCompany"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_GetAccountElementList"", ""*""
#include ""ContextHasValues"", ""*""

bool CO_IntercompanyProfitElimination(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCIntercompanyProfitElimination process..This process defines the consolidation process to eliminate the intercompany profit."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""SET_001"";
	year = ""2015"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""I"";
	cancel = false;*/
	
	string processName = ""CO_IntercompanyProfitElimination"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");
		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			double counter1 = 0;
			double counter2 = 0;
			string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

			string accountsPropVal = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Accounts"");
			OLAPElementList inventoryAccounts = CO_GetAccountElementList(olapConnection, accountsPropVal);

			string inventoryAccountDetail = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Account Detail"");

			string inventoryContraAccount = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Contra-Account"");
			string inventoryContraAccountDetail = CO_GetProcessProperty(olapConnection, cycle, ruleid, ""Inventory Contra-Account Detail"");

			foreach (OLAPElement company in CO_Companies(olapConnection, cycle) where ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Full"") or (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Quotal""))) {
				double percentOfConsolidation = 1.0;
				if ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company) == ""Quotal"")) {
					percentOfConsolidation = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), company);
				}
				
				foreach (OLAPElement intercompany in CO_Companies(olapConnection, cycle) where (((CO_ConsolidationMethod(olapConnection,cycle, year, period, scenario, group, intercompany) == ""Full"") or (CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, intercompany) == ""Quotal"")) and (ContextHasValues(olapConnection,cycle, year, period, scenario, groupcurrency, ""HB III adjust"", group, company, intercompany) == true))) {
					double taxRateIntercompany = CO_CompanyTaxRate(olapConnection, cycle, year, period, scenario, intercompany);
					double deferredTax = 0;
					double percentOfConsolidationIntercompany = 1.0;
					if ((CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, intercompany) == ""Quotal"")) {
						percentOfConsolidationIntercompany = CO_CalculatedShares(olapConnection, cycle, year, period, scenario, group, CO_HoldingCompany(olapConnection, cycle, year, period, scenario, group), intercompany);
					}
					
					foreach (OLAPElement inventoryAccount in inventoryAccounts) {
						bool isAssetInventoryAccount = CO_AccountType(olapConnection, inventoryAccount) == ""Asset"";

						double accountValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", percentOfConsolidationIntercompany, cycle,year, period, scenario, groupcurrency, ""HB III"", group, company, intercompany, inventoryAccount);
						if (accountValue != 0) {
							double profitMargin = OLAPCellReadNumber(olapConnection, ""TCONSPA"", 1, cycle, year, period, scenario, ""global"", intercompany, company, ""Profit Margin"");
							if (profitMargin > 0) {
								bool useSegments = false;
								if (CO_AccountHasSegment(olapConnection, cycle, inventoryAccount, 1) or CO_AccountHasSegment(olapConnection, cycle, inventoryAccount, 2) or CO_AccountHasSegment(olapConnection, cycle,  inventoryAccount, 3)) {
									useSegments = true;
								}

								if (!useSegments) {
									double rolloverValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", percentOfConsolidationIntercompany, cycle,year, period, scenario, groupcurrency, ""Rollover Total"", group, company, intercompany, inventoryAccount);
									double stockValue = accountValue * profitMargin + rolloverValue;
									GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Other"", ruleid, """", true);
									
									if ((isAssetInventoryAccount and stockValue < 0) or (!isAssetInventoryAccount and stockValue > 0)) {
										ConsolidationAddGroupJournalLine(journal, company, intercompany, inventoryAccount, inventoryAccountDetail, """", Abs(stockValue), 0.0);
									} else {
										ConsolidationAddGroupJournalLine(journal, company, intercompany, inventoryAccount, inventoryAccountDetail, """", 0.0, Abs(stockValue));
									}
									
									if ((isAssetInventoryAccount and stockValue < 0) or (!isAssetInventoryAccount and stockValue > 0)) {
										ConsolidationAddGroupJournalLine(journal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail, """", 0.0, Abs(stockValue));
									} else {
										ConsolidationAddGroupJournalLine(journal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail, """", Abs(stockValue), 0.0);
									}
									
									if (CO_TopAccount(olapConnection, cycle, 14) != """" and CO_TopAccount(olapConnection, cycle, 15) != """"
									    and CO_TopAccount(olapConnection, cycle, 16) != """" and CO_TopAccount(olapConnection, cycle, 17) != """") {
										
										deferredTax = stockValue * taxRateIntercompany;
										
										if ((isAssetInventoryAccount and deferredTax < 0) or (!isAssetInventoryAccount and deferredTax > 0)) {
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 14), CO_TopAccount(olapConnection, cycle, 114), """",  Abs(deferredTax), 0.0);
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 17), CO_TopAccount(olapConnection, cycle, 117), """", 0.0, Abs(deferredTax));
										} else {
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 15), CO_TopAccount(olapConnection, cycle, 115), """", 0.0,  Abs(deferredTax));
											ConsolidationAddGroupJournalLine(journal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 16), CO_TopAccount(olapConnection, cycle, 116), """", Abs(deferredTax), 0.0);
										}
									}
									
									if (!ConsolidationJournalIsEmpty(journal)) {
										if (ConsolidationJournalIsBalanced(journal)) {
											ConsolidationPostJournal(journalStore, journal);
											counter1 = counter1 + 1;
										} else {
											WriteLine(""Warning: The journal was not posted as it was unbalanced."");
										}
									}
								} else {
									GroupJournal segmentJournal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, ""Cons. Other"", ""Intersegment"", ruleid, """", true);
									
									OLAPElementList DGLEVEL = CreateOLAPElementList();
									OLAPElementListAddElement(DGLEVEL, OLAPGetDimensionElement(olapConnection, ""DGLEVEL"", ""HB III""));
									//OLAPElementListAddElement(DGLEVEL, OLAPGetDimensionElement(olapConnection, ""DGLEVEL"", ""Rollover Total""));

									OLAPDataArea sourceArea = OLAPCreateDataArea(
										olapConnection, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
										OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
										cycle, year, period, scenario, groupcurrency, DGLEVEL, group, ""Consolidated Segments"", company, intercompany,
										OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, OlapDataAreaBCells, inventoryAccount
									);

									foreach (OLAPCell cell in sourceArea)
									{
										accountValue = cell;
										accountValue = accountValue * percentOfConsolidationIntercompany;

										if (accountValue != 0) {
											string pPrimarySegment = OLAPCellGetElement(cell, ""DPSEGM"");
											string pSecondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
											string pTertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
											string pPrimaryPartnerSegment = OLAPCellGetElement(cell, ""DPRSEGM"");
											string pSecondaryPartnerSegment = OLAPCellGetElement(cell, ""DSRSEGM"");
											string pTertiaryPartnerSegment = OLAPCellGetElement(cell, ""DTRSEGM"");

											double rolloverValue = OLAPCellReadNumber(olapConnection, ""TSEGMG"", percentOfConsolidationIntercompany,
											                                          cycle, year, period, scenario, groupcurrency, ""Rollover Total"", group, ""Consolidated Segments"", company, intercompany,
											                                          pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
											                                          inventoryAccount);

											double stockValue = accountValue * profitMargin + rolloverValue;
											
											if ((isAssetInventoryAccount and stockValue < 0) or (!isAssetInventoryAccount and stockValue > 0)) {
												ConsolidationAddGroupJournalLine(segmentJournal, company, intercompany, inventoryAccount, inventoryAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", Abs(stockValue), 0.0);
											} else {
												ConsolidationAddGroupJournalLine(segmentJournal, company, intercompany, inventoryAccount, inventoryAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", 0.0, Abs(stockValue));
											}
											
											if ((isAssetInventoryAccount and stockValue < 0) or (!isAssetInventoryAccount and stockValue > 0)) {
												ConsolidationAddGroupJournalLine(segmentJournal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", 0.0, Abs(stockValue));
											} else {
												ConsolidationAddGroupJournalLine(segmentJournal, intercompany, company, inventoryContraAccount, inventoryContraAccountDetail,
												                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
												                                 """", Abs(stockValue), 0.0);
											}
											
											if (CO_TopAccount(olapConnection, cycle, 14) != """" and CO_TopAccount(olapConnection, cycle, 15) != """"
											    and CO_TopAccount(olapConnection, cycle, 16) != """" and CO_TopAccount(olapConnection, cycle, 17) != """") {
												
												deferredTax = stockValue * taxRateIntercompany;
												
												if ((isAssetInventoryAccount and deferredTax < 0) or (!isAssetInventoryAccount and deferredTax > 0)) {
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 14), CO_TopAccount(olapConnection, cycle, 114),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """",  Abs(deferredTax), 0.0);
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 17), CO_TopAccount(olapConnection, cycle, 117),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", 0.0, Abs(deferredTax));
												} else {
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 15), CO_TopAccount(olapConnection, cycle, 115),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", 0.0,  Abs(deferredTax));
													ConsolidationAddGroupJournalLine(segmentJournal, intercompany, ""External"", CO_TopAccount(olapConnection, cycle, 16), CO_TopAccount(olapConnection, cycle, 116),
													                                 pPrimarySegment, pPrimaryPartnerSegment, pSecondarySegment, pSecondaryPartnerSegment, pTertiarySegment, pTertiaryPartnerSegment,
													                                 """", Abs(deferredTax), 0.0);
												}
											}
										}
									}
									
									if (!ConsolidationJournalIsEmpty(segmentJournal)) {
										if (ConsolidationJournalIsBalanced(segmentJournal)) {
											ConsolidationPostJournal(journalStore, segmentJournal);
											counter2 = counter2 + 1;
										} else {
											WriteLine(""The journal was not posted as it was unbalanced."");
										}
									}
								}
							}
						}
					}
				}
			}
			WriteLine(""posted <"" + counter1 + ""> group journal(s)"");
			WriteLine(""posted <"" + counter2 + ""> group segment journal(s)"");
		}
		
		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	4F4A75CB-FA9D-48F8-A6F2-B8673AC67C6C	Former FCIntercompanyProfitElimination process..This process defines the consolidation process to eliminate the intercompany profit.	1	1	1	1722	NULL	0	45708.67506	0	0
AD5907AB-D13C-4076-BF7D-32090DB8EB92	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsAccount	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if the account is an account in rule; false, otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""processId"" parameter-type=""string"" parameter-description=""The process to query."" parameter-order=""3"" />
  <dependencies>
    <process process-name=""CO_GetProcessPropertyAccountList"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetProcessPropertyAccountList"", ""*""

bool CO_IsAccount(OLAPConnection connection, string configurationSet, string account, string processId)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified account is an account in rule."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[processId]: ""The process to query."";
@Returns: ""True, if the account is an account in rule; false, otherwise."";
{
	OLAPElementList accounts = CO_GetProcessPropertyAccountList(connection, configurationSet, processId, ""Account Set"");
	return OLAPElementListContainsElement(accounts, account);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetProcessPropertyAccountList"", ""*""

bool CO_IsAccount(OLAPConnection connection, string configurationSet, string account, string processId)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified account is an account in rule."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[processId]: ""The process to query."";
@Returns: ""True, if the account is an account in rule; false, otherwise."";
{
	OLAPElementList accounts = CO_GetProcessPropertyAccountList(connection, configurationSet, processId, ""Account Set"");
	return OLAPElementListContainsElement(accounts, account);
}"	1	D5BCB24A-66E0-4272-A0BB-9D4161F7AC96	Indicates whether the specified account is an account in rule.	1	1	1	1723	NULL	0	45708.67506	0	0
0F9391B1-A524-4AEE-A464-07CA4BCB1072	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsContraAccount	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if the account is a contra account in process; false, otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""string"" parameter-description=""The account to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""processId"" parameter-type=""string"" parameter-description=""The process to query."" parameter-order=""3"" />
  <dependencies>
    <process process-name=""CO_GetProcessPropertyAccountList"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetProcessPropertyAccountList"", ""*""

bool CO_IsContraAccount(OLAPConnection connection, string configurationSet, string account, string processId)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified account is a contra account in process."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[processId]: ""The process to query."";
@Returns: ""True, if the account is a contra account in process; false, otherwise."";
{
	OLAPElementList contraAccounts = CO_GetProcessPropertyAccountList(connection, configurationSet, processId, ""Contra-Account Set"");
	return OLAPElementListContainsElement(contraAccounts, account);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_GetProcessPropertyAccountList"", ""*""

bool CO_IsContraAccount(OLAPConnection connection, string configurationSet, string account, string processId)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified account is a contra account in process."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[account]: ""The account to query."";
@Parameter[processId]: ""The process to query."";
@Returns: ""True, if the account is a contra account in process; false, otherwise."";
{
	OLAPElementList contraAccounts = CO_GetProcessPropertyAccountList(connection, configurationSet, processId, ""Contra-Account Set"");
	return OLAPElementListContainsElement(contraAccounts, account);
}"	1	465CE0DF-9025-4501-B7F6-E7C253071C58	Indicates whether the specified account is a contra account in process.	1	1	1	1724	NULL	0	45708.67504	0	0
6D417404-C30C-4509-BF09-09501DDD27E4	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsDetailInAccountSchedule	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if the schedule detail is included in the account's schedule; false, otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""OLAPElement"" parameter-description=""The account to get the schedule for."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""detail"" parameter-type=""OLAPElement"" parameter-description=""The detail to query."" parameter-order=""2"" />
  <dependencies>
    <process process-name=""CO_ScheduleDetails"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ScheduleDetails"", ""*""

bool CO_IsDetailInAccountSchedule(OLAPConnection connection, OLAPElement account, OLAPElement detail)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified schedule detail is included in the schedule for group journals of the specified account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to get the schedule for."";
@Parameter[detail]: ""The detail to query."";
@Returns: ""True, if the schedule detail is included in the account's schedule; false, otherwise."";
{
	string schedule = cached OLAPGetStringAttribute(connection, account, ""Detail"");

	if (StringLength(schedule) &gt; 0)
	{
		// get the schedule element
		OLAPElementList schedules = cached OLAPGetElementList(connection, ""DDETPA"", false);
		OLAPElement scheduleElement = schedules[schedule];

		OLAPElementList scheduleDetails = CO_ScheduleDetails(connection, scheduleElement);

		// check whether the given detail is contained in the collection
		return OLAPElementListContainsElement(scheduleDetails, detail);
	}
	return false;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ScheduleDetails"", ""*""

bool CO_IsDetailInAccountSchedule(OLAPConnection connection, OLAPElement account, OLAPElement detail)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified schedule detail is included in the schedule for group journals of the specified account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to get the schedule for."";
@Parameter[detail]: ""The detail to query."";
@Returns: ""True, if the schedule detail is included in the account's schedule; false, otherwise."";
{
	string schedule = cached OLAPGetStringAttribute(connection, account, ""Detail"");

	if (StringLength(schedule) > 0)
	{
		// get the schedule element
		OLAPElementList schedules = cached OLAPGetElementList(connection, ""DDETPA"", false);
		OLAPElement scheduleElement = schedules[schedule];

		OLAPElementList scheduleDetails = CO_ScheduleDetails(connection, scheduleElement);

		// check whether the given detail is contained in the collection
		return OLAPElementListContainsElement(scheduleDetails, detail);
	}
	return false;
}"	1	E590363E-79AE-46F8-B2E6-2A48B0378783	Indicates whether the specified schedule detail is included in the schedule for group journals of the specified account.	1	1	1	1725	NULL	0	45708.67505	0	0
EC7CC235-D292-4D88-80F3-F681E86665BD	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsDirectlyOwned	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""Whether the entity is directly owned by the group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <dependencies>
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""

bool CO_IsDirectlyOwned(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company)
@Category: ""Consolidation Base Process"";
@Description: ""Returns whether the given entity is directly owned by the group in given context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""Whether the entity is directly owned by the group."";
{
	return
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Full"" or
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"";
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_ConsolidationMethod"", ""*""

bool CO_IsDirectlyOwned(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company)
@Category: ""Consolidation Base Process"";
@Description: ""Returns whether the given entity is directly owned by the group in given context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Returns: ""Whether the entity is directly owned by the group."";
{
	return
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Full"" or
		CO_ConsolidationMethod(connection, configurationSet, year, period, scenario, group, company) == ""Quotal"";
}"	1	EA131A98-4E5E-4BE2-82CA-86007F7A75DC	Returns whether the given entity is directly owned by the group in given context.	1	1	1	1726	NULL	0	45708.67506	0	0
D194C189-4A7B-473F-898D-B64E9F6A83DB	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsEntityReadOnly	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""true if entity is read only, otherwise false"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""entity"" parameter-type=""string"" parameter-description=""Entity to be checked"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""GetElementListWithReadPermission"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetElementListWithReadPermission"", ""*""

bool CO_IsEntityReadOnly(string server, string entity)
@Description: ""Check if given entity is read only, or not"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[entity]: ""Entity to be checked"";
@Returns: ""true if entity is read only, otherwise false"";
{
	string functionName = ""CO_IsEntityReadOnly:"";
	string errorMessage = """";
	int errorCode = 0;
	string entityDimension = ""DCOMPC"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		entity = ResolveUniqueName(connection, entity);
		StringArray eArray = CreateStringArray();
		Append(eArray,entity);

		string readOnlyEntity = GetElementListWithReadPermission(server,entityDimension,eArray);
		if(readOnlyEntity != entity)
		{
			return false;
		}
		else
		{
			return true;
		}

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""GetElementListWithReadPermission"", ""*""

bool CO_IsEntityReadOnly(string server, string entity)
@Description: ""Check if given entity is read only, or not"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[entity]: ""Entity to be checked"";
@Returns: ""true if entity is read only, otherwise false"";
{
	string functionName = ""CO_IsEntityReadOnly:"";
	string errorMessage = """";
	int errorCode = 0;
	string entityDimension = ""DCOMPC"";

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		entity = ResolveUniqueName(connection, entity);
		StringArray eArray = CreateStringArray();
		Append(eArray,entity);

		string readOnlyEntity = GetElementListWithReadPermission(server,entityDimension,eArray);
		if(readOnlyEntity != entity)
		{
			return false;
		}
		else
		{
			return true;
		}

	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return false;
	}
}"	1	329C81B2-D62F-44C3-9A47-568B1CF38BB3	Check if given entity is read only, or not	1	1	1	1727	NULL	0	45708.67503	0	0
1DE1DDA5-D031-411B-9193-BEE22CC374D7	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsRuleType	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if rule has the specified process; false, otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""process"" parameter-type=""OLAPElement"" parameter-description=""The process to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""processType"" parameter-type=""string"" parameter-description=""The process type to compare."" parameter-order=""3"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CO_IsRuleType(OLAPConnection connection, string configurationSet, OLAPElement process, string processType)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified process has a specific process type."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[process]: ""The process to query."";
@Parameter[processType]: ""The process type to compare."";
@Returns: ""True, if rule has the specified process; false, otherwise."";
{
	// VL - find a parent element in the DCONSRL dimension and check its name
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	if (Count(parentElements) &gt; 0)
	{
		OLAPElement parent = parentElements[0];
		return ToString(parent) == processType;
	}
	else
	{
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CO_IsRuleType(OLAPConnection connection, string configurationSet, OLAPElement process, string processType)
@Category: ""Consolidation Base Process"";
@Description: ""Indicates whether the specified process has a specific process type."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Parameter[process]: ""The process to query."";
@Parameter[processType]: ""The process type to compare."";
@Returns: ""True, if rule has the specified process; false, otherwise."";
{
	// VL - find a parent element in the DCONSRL dimension and check its name
	OLAPElementList parentElements = OLAPGetParentElementList(connection, process);
	if (Count(parentElements) > 0)
	{
		OLAPElement parent = parentElements[0];
		return ToString(parent) == processType;
	}
	else
	{
		return false;
	}
}"	1	F8BB8B9D-E39F-4331-9EB3-5D567EC79A2E	Indicates whether the specified process has a specific process type.	1	1	1	1728	NULL	0	45708.67504	0	0
487902CF-C929-4C1D-8424-855294C04557	CD491758-D9DF-4002-94C8-8006E1855F86	CO_IsSubgroupConsolidationUsed	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True for usage of subgroup consolidation, false for not using subgroup consolidation."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to get the group currency for."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""The year to get the group currency for."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""The period to get the group currency for."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""The scenario to get the group currency for."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""The group to get the group currency for."" parameter-order=""5"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CO_IsSubgroupConsolidationUsed(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Find if subgroup consolidation should be used."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the group currency for."";
@Parameter[year]: ""The year to get the group currency for."";
@Parameter[period]: ""The period to get the group currency for."";
@Parameter[scenario]: ""The scenario to get the group currency for."";
@Parameter[group]: ""The group to get the group currency for."";
@Returns: ""True for usage of subgroup consolidation, false for not using subgroup consolidation."";
{
	double useSCons =  OLAPCellReadNumber(connection, ""TCOMPPA"", 1.0, configurationSet, year, period, scenario, group, ""Use Subgroup Consolidation"");
	if(useSCons == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CO_IsSubgroupConsolidationUsed(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group)
@Category: ""Consolidation Base Process"";
@Description: ""Find if subgroup consolidation should be used."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to get the group currency for."";
@Parameter[year]: ""The year to get the group currency for."";
@Parameter[period]: ""The period to get the group currency for."";
@Parameter[scenario]: ""The scenario to get the group currency for."";
@Parameter[group]: ""The group to get the group currency for."";
@Returns: ""True for usage of subgroup consolidation, false for not using subgroup consolidation."";
{
	double useSCons =  OLAPCellReadNumber(connection, ""TCOMPPA"", 1.0, configurationSet, year, period, scenario, group, ""Use Subgroup Consolidation"");
	if(useSCons == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}"	1	CEEEAC36-C0B0-4D89-A7C9-B74A9D17E974	Find if subgroup consolidation should be used.	1	1	1	1729	NULL	0	45708.67503	0	0
2CAEA854-7AF8-4288-9977-6675B2CCB9B0	CD491758-D9DF-4002-94C8-8006E1855F86	CO_LandingPageLoad	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML string with landing page setting"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""param"" parameter-type=""string"" parameter-description=""Contex for what should be langing page loaded"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""OpenDialogSentence"" process-version=""*"" process-id="""" />
    <process process-name=""EvaluateStatus"" process-version=""*"" process-id="""" />
    <process process-name=""RowInLandingPageXML"" process-version=""*"" process-id="""" />
    <process process-name=""CreateCheckXML"" process-version=""*"" process-id="""" />
    <process process-name=""GetSortedUGElements"" process-version=""*"" process-id="""" />
    <process process-name=""GetElementListWithReadPermission"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OpenDialogSentence"", ""*""
#include ""EvaluateStatus"", ""*""
#include ""RowInLandingPageXML"", ""*""
#include ""CreateCheckXML"", ""*""
#include ""GetSortedUGElements"", ""*""
#include ""GetElementListWithReadPermission"", ""*""

string CO_LandingPageLoad(string server, string param)
@Description: ""Create xml for given contex for landing page"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[param]: ""Contex for what should be langing page loaded"";
@Returns: ""XML string with landing page setting"";
{
	string functionName = ""CO_LandingPageLoad:"";
	string errorMessage = """";
	int errorCode = 0;
	string UGDimension = ""DUSERGUIDANCE"";
	string statusECube = ""TSTATUSC"";
	string statusGCube = ""TSTATUSG"";
	string checkCube = ""TCHECKIC"";
	string navigationDimension = ""BPDNAVIGATION"";
	string entityDimension = ""DCOMPC"";
	string tempConfigUserCube = ""BPCTEMPCONFIGUSER"";
	string statusCube = """";
	string parentString ="""";
	string jumpType="""";
	string actionType="""";
	string targetUN="""";
	double submit = 10;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*param="""";
		param = ""&lt;Table&gt;"";
		param = param + ""&lt;Row name=\""config\""&gt;"";
		param = param + ""&lt;Property name=\""Mode\"" value=\""Entity\"" /&gt;"";
		param = param + ""&lt;Property name=\""Cycle\"" value=\""[BPDCYCLE].[SET_001].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Version\"" value=\""[DVERSIO].[V01].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Entity\"" value=\""[DCOMPC].[RU0001].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Group\"" value=\""[DGROUP].[GR0001].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Period\"" value=\""[DPERIOD].[12].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Year\"" value=\""[DYEAR].[2020].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Time\"" value=\""[DTIME].[12.2020].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Language\"" value=\""English\"" /&gt;"";
		param = param + ""&lt;Property name=\""ApplicationRoles\"" value=\""Group Accountant; Consolidation Modeler; Consolidation Auditor; Entity Accountant; Consolidation Read Only\"" /&gt;"";//Group Accountant; Consolidation Modeler; Consolidation Auditor; Entity Accountant; Consolidation Read Only
		param = param + ""&lt;/Row&gt;"";
		param = param + ""&lt;/Table&gt;"";*/


		string mode = """";
		string cycle = """";
		string version = """";
		string entity = """";
		string group = """";
		string period = """";
		string time = """";
		string year = """";
		string language = """";
		string applicationRoles = """";

		XMLDocument docIn =  XMLParseDocument(param);
		XMLElement tableIn = XMLGetRootElement(docIn);
		XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
		foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property"")) {
			string propName = XMLGetAttributeValue(prop,""name"");
			string propValue = XMLGetAttributeValue(prop,""value"");

			if(propName == ""Mode"") {
				mode = propValue;
			}
			if(propName == ""Language"") {
				language = propValue;
			}
			if(propName == ""ApplicationRoles"") {
				applicationRoles = propValue;
			}
			if(propName == ""Cycle"") {
				cycle = propValue;
				cycle = ResolveUniqueName(connection, cycle);
			}
			if(propName == ""Version"") {
				version = propValue;
				version = ResolveUniqueName(connection, version);
			}
			if(propName == ""Time"") {
				time = propValue;
				if(time !="""")
				{
					time = ResolveUniqueName(connection, time);
				}

			}
			if(propName == ""Entity"") {
				entity = propValue;
				if(entity !="""")
				{
					entity = ResolveUniqueName(connection, entity);
				}
			}
			if(propName == ""Group"") {
				group = propValue;
				if(group !="""")
				{
					group = ResolveUniqueName(connection, group);
					
				}
			}
			if(propName == ""Period"") {
				period = propValue;
				if(period !="""")
				{
					period = ResolveUniqueName(connection, period);
				}

			}
			if(propName == ""Year"") {
				year = propValue;
				if(year !="""")
				{
					year = ResolveUniqueName(connection, year);
				}

			}
		}
		if(time !="""")
		{
			period = StringSubstring(time, 0, 2);
			year= StringSubstring(time, 3, 4);
		}
		else
		{
			time = period +""."" + year;

		}

		string applicationRolesUpdated = StringReplace(applicationRoles, ""; "", "","" , false);
		StringArray applicationRolesArray = StringSplit(applicationRolesUpdated, "","");

		string result="""";
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		string parent ="""";
		string readOnlyEntity = """";

		if(mode == ""Entity"")
		{
			parent = ""ENTITY_UG"";
			StringArray eArray = CreateStringArray();
			Append(eArray,entity);

			readOnlyEntity = GetElementListWithReadPermission(server,entityDimension,eArray);

		}

		if(mode == ""Group"")
		{
			parent = ""GROUP_UG"";
		}
		StringDictionary dicUGName = CreateStringDictionary();
		StringDictionary dicUGLang = CreateStringDictionary();
		StringDictionary dicHide = CreateStringDictionary();
		StringDictionary dicSort = CreateStringDictionary();
		StringDictionary dicStatType = CreateStringDictionary();
		StringDictionary dicStatElement = CreateStringDictionary();
		StringDictionary dicCheckElement = CreateStringDictionary();
		StringDictionary dicNavElement = CreateStringDictionary();


		OLAPElementList ListOfUGElements = OLAPGetChildElementList(connection,UGDimension, parent,false);
		StringList UGStringListHelp = ToStringList(ListOfUGElements);
		StringList elAttaListHide =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Hide"");
		StringList elAttaListSort =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Sort"");
		StringList elAttaListStatType =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""StatusType"");
		StringList elAttaListStatElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""StatusElement"");
		StringList elAttaListCheckElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""CheckElement"");
		StringList elAttaListNavigationElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""NavigationElement"");
		StringList elAttaListName=  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Name"");
		StringList elAttaListLanguage =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, language);
		int index = 0;

		foreach(string UGOLAPElement in UGStringListHelp )
		{
			dicHide[UGOLAPElement] = GetElementByIndex(elAttaListHide,index);
			dicSort[UGOLAPElement] = GetElementByIndex(elAttaListSort,index);
			dicStatType[UGOLAPElement] = GetElementByIndex(elAttaListStatType,index);
			dicStatElement[UGOLAPElement] = GetElementByIndex(elAttaListStatElement,index);
			dicCheckElement[UGOLAPElement] = GetElementByIndex(elAttaListCheckElement,index);
			dicNavElement[UGOLAPElement] = GetElementByIndex(elAttaListNavigationElement,index);
			dicUGName[UGOLAPElement] = GetElementByIndex(elAttaListName,index);
			dicUGLang[UGOLAPElement] = GetElementByIndex(elAttaListLanguage,index);
			index = index + 1;
		}


		StringDictionary dicNavName = CreateStringDictionary();
		StringDictionary dicNavLang = CreateStringDictionary();
		StringDictionary dicReportUN= CreateStringDictionary();
		StringDictionary dicReportType = CreateStringDictionary();
		StringDictionary dicActive = CreateStringDictionary();

		OLAPElementList ListOfNavElements = OLAPGetElementList(connection,navigationDimension,false);
		StringList navStringListHelp = ToStringList(ListOfNavElements);
		StringList elAttaListReportUN =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""REPORTUN"");
		StringList elAttaListReportType =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""REPORTTYP"");
		StringList elAttaListNavName=  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""Name"");
		StringList elAttaListNavLanguage =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, language);
		StringList elAttaListNavActive =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""ACTIVE"");
		index = 0;
		StringList availableNavElements =CreateStringList();

		foreach(string navElement in navStringListHelp )
		{
			dicReportUN[navElement] = GetElementByIndex(elAttaListReportUN,index);
			dicReportType[navElement] = GetElementByIndex(elAttaListReportType,index);
			dicNavName[navElement] = GetElementByIndex(elAttaListNavName,index);
			dicNavLang[navElement] = GetElementByIndex(elAttaListNavLanguage,index);
			dicActive[navElement] = GetElementByIndex(elAttaListNavActive,index);

			Append(availableNavElements,navElement);
			index = index + 1;
		}
		StringDictionary UGParents = CreateStringDictionary();
		StringDictionary statCubes = CreateStringDictionary();
		StringDictionary globalDict = CreateStringDictionary();
		DoubleDictionary statValue = CreateDoubleDictionary();

		BoolDictionary hasRights = CreateBoolDictionary();

		foreach(OLAPElement UG in ListOfUGElements)
		{
			bool isUGbaseElement = OLAPIsBaseElement(connection, UG);
			string UGstring = ToString(UG);
			if(isUGbaseElement)
			{
				if(Contains(availableNavElements,dicNavElement[UGstring]))
				{
					if(dicActive[dicNavElement[UGstring]] == ""1"")
					{
						hasRights[UGstring] = true;

					}
					else
					{
						hasRights[UGstring] = false;
					}
				}
				else
				{
					hasRights[UGstring] = false;
				}

			}
			else
			{
				OLAPElementList ListOfBaseElements = OLAPGetChildElementList(connection,UGDimension, UGstring,true);
				bool isIN =false;
				foreach(OLAPElement ug in ListOfBaseElements)
				{
					string ugString = ToString(ug);
					if(Contains(availableNavElements,dicNavElement[ugString]))
					{
						if(dicActive[dicNavElement[ugString]] == ""1"")

						{
							isIN = true;
						}
					}
				}
				if(isIN)
				{
					hasRights[UGstring] = true;
				}
				else
				{
					hasRights[UGstring] = false;
				}

			}

			OLAPElementList parentUGList = OLAPGetParentElementList(connection, UG);
			double parentCount = Count(parentUGList);
			if(parentCount == 1)
			{
				foreach(OLAPElement par in parentUGList)
				{
					parentString = ToString(par);
					UGParents[UGstring] = ToString(par);
					if(parentString ==parent)
					{
						UGParents[UGstring] = """";
					}
				}
			}
			string statusElement = dicStatElement[UGstring];
			string status = dicStatType[UGstring];
			double statusValue = 0;
			if(statusElement != """")
			{
				if(status == ""E"")
				{
					statCubes[UGstring] = statusECube;
					statValue[UGstring] = OLAPCellReadNumber(connection, statusECube, 1.0, cycle, year,period, version,entity,statusElement);
					globalDict[UGstring]="""";
				}
				else
				{
					statCubes[UGstring]= statusGCube;
					if (statusElement == ""Standard Exchange Rates"" or statusElement == ""Ownership"" or statusElement == ""Cash Flow Parameter"" )
					{
						statValue[UGstring]= OLAPCellReadNumber(connection, statusGCube, 1.0, cycle, year,period, version,""global"",statusElement);
						globalDict[UGstring]=""global"";
					}
					else
					{
						statValue[UGstring]= OLAPCellReadNumber(connection, statusGCube, 1.0, cycle, year,period, version,group,statusElement);
						globalDict[UGstring]="""";
					}
				}
			}
			else
			{
				statCubes[UGstring]="""";
				globalDict[UGstring]="""";
				statValue[UGstring]=0;
			}

		}
		BoolDictionary visibleAndHide = CreateBoolDictionary();
		foreach(OLAPElement UG in ListOfUGElements)
		{
			string UGstring = ToString(UG);
			if(hasRights[UGstring] and dicHide[UGstring]==""False"")
			{
				visibleAndHide[UGstring] = true;
			}
			else
			{
				visibleAndHide[UGstring] = false;
			}
		}
		BoolDictionary partofXML = CreateBoolDictionary();

		foreach(OLAPElement UG in ListOfUGElements)
		{
			string UGstring = ToString(UG);
			bool isUGbaseElement = OLAPIsBaseElement(connection, UG);
			if(!ContainsKey(partofXML, UGstring))
			{
				if(visibleAndHide[UGstring])
				{
					if(isUGbaseElement)
					{
						partofXML[UGstring] = true;
					}
					else
					{
						OLAPElementList ListOfElements = OLAPGetDirectChildrenList(connection,UGDimension, UGstring,false);
						bool childisNotHide = false;
						foreach(OLAPElement ug in ListOfElements)
						{
							string childUG = ToString(ug);
							bool isUGChildBaseElement = OLAPIsBaseElement(connection, ug);
							if(isUGChildBaseElement)
							{
								if(visibleAndHide[childUG])
								{
									childisNotHide = true;
								}
							}
							else
							{
								if(visibleAndHide[childUG])
								{
									OLAPElementList ListOfchildElements = OLAPGetChildElementList(connection,UGDimension, childUG,true);
									foreach(OLAPElement ugChild in ListOfchildElements)
									{
										string ugchildE = ToString(ugChild);
										if(visibleAndHide[ugchildE])
										{
											childisNotHide = true;
										}
									}
								}
							}
						}

						if(childisNotHide)
						{
							partofXML[UGstring] = true;
						}
						else
						{
							partofXML[UGstring] = false;
						}
					}

				}
				else
				{
					partofXML[UGstring] = false;
					OLAPElementList ListOfElements = OLAPGetChildElementList(connection,UGDimension, UGstring,false);
					foreach(OLAPElement ug in ListOfElements)
					{
						string childUG = ToString(ug);
						partofXML[childUG] = false;

					}
				}
			}
		}
		StringArray sortedUG = GetSortedUGElements(connection, parent, dicSort);
		StringList coNawRowNames =CreateStringList();
		foreach(string UGstring in sortedUG)
		{
			OLAPElement UG = OLAPGetDimensionElement(connection, UGDimension, UGstring);

			if(partofXML[UGstring])
			{
				parentString = UGParents[ToString(UG)];
				string sortString = dicSort[UGstring];
				if(sortString == """")
				{
					sortString = ""99"";
				}

				int numberOfdigits = StringLength(sortString);
				string zerosString = """";

				int zeros = 3 - numberOfdigits;
				if(zeros ==2)
				{
					zerosString = ""00"";
				}

				if(zeros ==1)
				{
					zerosString = ""0"";
				}
				string statusElement = dicStatElement[UGstring];
				string status = dicStatType[UGstring];
				double statusValue = 0;
				string evaluateStat = """";
				string stat = """";
				string gr = """";
				string elname = dicUGLang[UGstring];
				if(elname == """")
				{
					elname = dicUGName[UGstring];
				}
				if(elname == """")
				{
					elname = UGstring;
				}

				statusCube = statCubes[UGstring];
				statusValue = statValue[UGstring];
				gr = globalDict[UGstring];


				if(statusElement != """")
				{
					evaluateStat = ToString(EvaluateStatus(statusValue,applicationRolesArray,mode));
					stat = ToString(statusValue);
				}

				jumpType="""";
				actionType="""";
				targetUN="""";
				string rowName = ToString(UG);
				string navigationElement = dicNavElement[UGstring];
				string navUN="""";
				if(navigationElement != """")
				{
					OLAPElement navOlapElement = OLAPGetDimensionElement(connection, navigationDimension, navigationElement);
					targetUN = dicReportUN[navigationElement];
					jumpType = dicReportType[navigationElement];
					rowName = ToString(navOlapElement);
					navUN = ""[""+navigationDimension+""].[""+navigationElement+""].[1]"";
					if(Contains(coNawRowNames,rowName))
					{
						int counter = 1;
						while(counter &lt;=10)
						{
							string rowNameHelp = rowName + ToString(counter);
							if(!Contains(coNawRowNames,rowNameHelp))
							{
								break;
							}
							counter = counter + 1;
						}
						string newPart = ToString(counter);
						rowName = rowName+newPart;
					}
					Append(coNawRowNames,rowName);

					statusCube = statCubes[parentString];
					statusValue = statValue[parentString];
					gr = globalDict[parentString];
					statusElement = dicStatElement[parentString];

					evaluateStat = ToString(EvaluateStatus(statusValue,applicationRolesArray,mode));
					stat = ToString(statusValue);

					if(jumpType == ""DGS"")
					{
						jumpType = ""D"";

						string reportParam = OLAPGetStringAttribute(connection,navOlapElement,""REPORTPARAM"");
						string entityOrGroup = """";
						if(mode == ""Entity"")
						{
							entityOrGroup = entity;
						}

						if(mode == ""Group"")
						{
							entityOrGroup = group;
						}
						targetUN = OpenDialogSentence(targetUN,reportParam,cycle,version,entityOrGroup,time);
					}

					
					actionType = ""jump"";
					elname = dicNavLang[navigationElement];
					if(elname == """")
					{
						elname = dicNavName[navigationElement];
					}
					if(elname == """")
					{
						elname = navigationElement;
					}
				}

				string checkElement = dicCheckElement[UGstring];
				string checkXML="""";
				bool totalCheckResult = true;
				if(checkElement !="""")
				{
					checkXML = CreateCheckXML(connection, cycle, year,period, version,entity,checkElement,language);
					XMLDocument checkDocXML =  XMLParseDocument(checkXML);
					XMLElement tableChecks = XMLGetRootElement(checkDocXML);
					foreach(XMLElement rowCheck in XMLGetChildElements(tableChecks, ""Row""))
					{
						string rowNameCheck = rowCheck.GetAttribute(""name"").GetValue();
						if(rowNameCheck == ""TC_IC"")
						{
							foreach(XMLElement prop in XMLGetChildElements(rowCheck, ""Property"")) {
								string checkPropName = prop.GetAttribute(""name"").GetValue();
								string checkPropValue = prop.GetAttribute(""value"").GetValue();
								if(checkPropName == ""value"")
								{
									if(checkPropValue == ""FALSE"")
									{
										totalCheckResult = false;
									}
								}
							}
						}
					}
				}

				row =RowInLandingPageXML(connection, rowName, elname, zerosString+sortString, parentString, statusElement, statusCube, jumpType, actionType, targetUN, evaluateStat, language, checkXML, """", """", gr, stat,navUN);
				XMLAddElement(table, row);
				
				double actionCheckValue = statValue[UGstring];

				if(submit ==actionCheckValue and parent == ""ENTITY_UG"")
				{
					if(statusElement != ""Total_Status"" and statusElement != ""Standard Exchange Rates"")
					{
						if(Contains(applicationRolesArray, ""Group Accountant"") or Contains(applicationRolesArray, ""Entity Accountant""))
						{
							if(readOnlyEntity != entity)
							{
								if(!totalCheckResult and statusElement == ""IC Matching"")
								{
									row =RowInLandingPageXML(connection, ToString(UG)+""_SUBMIT"", ""StatusSubmitWithWarning"", ""001"", ToString(UG), """", """", """", ""action"", """", """", language, """", ""21"", ""CO_LandingPageWrite"", """", """","""");
									XMLAddElement(table, row);
								}
								else
								{
									row =RowInLandingPageXML(connection, ToString(UG)+""_SUBMIT"", ""Submit"", ""001"", ToString(UG), """", """", """", ""action"", """", """", language, """", ""20"", ""CO_LandingPageWrite"", """", """","""");
									XMLAddElement(table, row);
								}
							}
						}
					}
				}
			}
		}
		
		result = ToString(doc);
		string userName = GetCurrentUserName();

		if(mode == ""Entity"")
		{
			OLAPCellWriteString(connection,tempConfigUserCube,result,""Parameter"",userName,""FEATURE_TEMP_CO_ENTITY_UG_XML"");

		}
		if(mode == ""Group"")
		{
			OLAPCellWriteString(connection,tempConfigUserCube,result,""Parameter"",userName,""FEATURE_TEMP_CO_GROUP_UG_XML"");
		}

		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""OpenDialogSentence"", ""*""
#include ""EvaluateStatus"", ""*""
#include ""RowInLandingPageXML"", ""*""
#include ""CreateCheckXML"", ""*""
#include ""GetSortedUGElements"", ""*""
#include ""GetElementListWithReadPermission"", ""*""

string CO_LandingPageLoad(string server, string param)
@Description: ""Create xml for given contex for landing page"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[param]: ""Contex for what should be langing page loaded"";
@Returns: ""XML string with landing page setting"";
{
	string functionName = ""CO_LandingPageLoad:"";
	string errorMessage = """";
	int errorCode = 0;
	string UGDimension = ""DUSERGUIDANCE"";
	string statusECube = ""TSTATUSC"";
	string statusGCube = ""TSTATUSG"";
	string checkCube = ""TCHECKIC"";
	string navigationDimension = ""BPDNAVIGATION"";
	string entityDimension = ""DCOMPC"";
	string tempConfigUserCube = ""BPCTEMPCONFIGUSER"";
	string statusCube = """";
	string parentString ="""";
	string jumpType="""";
	string actionType="""";
	string targetUN="""";
	double submit = 10;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		/*param="""";
		param = ""<Table>"";
		param = param + ""<Row name=\""config\"">"";
		param = param + ""<Property name=\""Mode\"" value=\""Entity\"" />"";
		param = param + ""<Property name=\""Cycle\"" value=\""[BPDCYCLE].[SET_001].[1]\"" />"";
		param = param + ""<Property name=\""Version\"" value=\""[DVERSIO].[V01].[1]\"" />"";
		param = param + ""<Property name=\""Entity\"" value=\""[DCOMPC].[RU0001].[1]\"" />"";
		param = param + ""<Property name=\""Group\"" value=\""[DGROUP].[GR0001].[1]\"" />"";
		param = param + ""<Property name=\""Period\"" value=\""[DPERIOD].[12].[1]\"" />"";
		param = param + ""<Property name=\""Year\"" value=\""[DYEAR].[2020].[1]\"" />"";
		param = param + ""<Property name=\""Time\"" value=\""[DTIME].[12.2020].[1]\"" />"";
		param = param + ""<Property name=\""Language\"" value=\""English\"" />"";
		param = param + ""<Property name=\""ApplicationRoles\"" value=\""Group Accountant; Consolidation Modeler; Consolidation Auditor; Entity Accountant; Consolidation Read Only\"" />"";//Group Accountant; Consolidation Modeler; Consolidation Auditor; Entity Accountant; Consolidation Read Only
		param = param + ""</Row>"";
		param = param + ""</Table>"";*/


		string mode = """";
		string cycle = """";
		string version = """";
		string entity = """";
		string group = """";
		string period = """";
		string time = """";
		string year = """";
		string language = """";
		string applicationRoles = """";

		XMLDocument docIn =  XMLParseDocument(param);
		XMLElement tableIn = XMLGetRootElement(docIn);
		XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
		foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property"")) {
			string propName = XMLGetAttributeValue(prop,""name"");
			string propValue = XMLGetAttributeValue(prop,""value"");

			if(propName == ""Mode"") {
				mode = propValue;
			}
			if(propName == ""Language"") {
				language = propValue;
			}
			if(propName == ""ApplicationRoles"") {
				applicationRoles = propValue;
			}
			if(propName == ""Cycle"") {
				cycle = propValue;
				cycle = ResolveUniqueName(connection, cycle);
			}
			if(propName == ""Version"") {
				version = propValue;
				version = ResolveUniqueName(connection, version);
			}
			if(propName == ""Time"") {
				time = propValue;
				if(time !="""")
				{
					time = ResolveUniqueName(connection, time);
				}

			}
			if(propName == ""Entity"") {
				entity = propValue;
				if(entity !="""")
				{
					entity = ResolveUniqueName(connection, entity);
				}
			}
			if(propName == ""Group"") {
				group = propValue;
				if(group !="""")
				{
					group = ResolveUniqueName(connection, group);
					
				}
			}
			if(propName == ""Period"") {
				period = propValue;
				if(period !="""")
				{
					period = ResolveUniqueName(connection, period);
				}

			}
			if(propName == ""Year"") {
				year = propValue;
				if(year !="""")
				{
					year = ResolveUniqueName(connection, year);
				}

			}
		}
		if(time !="""")
		{
			period = StringSubstring(time, 0, 2);
			year= StringSubstring(time, 3, 4);
		}
		else
		{
			time = period +""."" + year;

		}

		string applicationRolesUpdated = StringReplace(applicationRoles, ""; "", "","" , false);
		StringArray applicationRolesArray = StringSplit(applicationRolesUpdated, "","");

		string result="""";
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");
		string parent ="""";
		string readOnlyEntity = """";

		if(mode == ""Entity"")
		{
			parent = ""ENTITY_UG"";
			StringArray eArray = CreateStringArray();
			Append(eArray,entity);

			readOnlyEntity = GetElementListWithReadPermission(server,entityDimension,eArray);

		}

		if(mode == ""Group"")
		{
			parent = ""GROUP_UG"";
		}
		StringDictionary dicUGName = CreateStringDictionary();
		StringDictionary dicUGLang = CreateStringDictionary();
		StringDictionary dicHide = CreateStringDictionary();
		StringDictionary dicSort = CreateStringDictionary();
		StringDictionary dicStatType = CreateStringDictionary();
		StringDictionary dicStatElement = CreateStringDictionary();
		StringDictionary dicCheckElement = CreateStringDictionary();
		StringDictionary dicNavElement = CreateStringDictionary();


		OLAPElementList ListOfUGElements = OLAPGetChildElementList(connection,UGDimension, parent,false);
		StringList UGStringListHelp = ToStringList(ListOfUGElements);
		StringList elAttaListHide =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Hide"");
		StringList elAttaListSort =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Sort"");
		StringList elAttaListStatType =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""StatusType"");
		StringList elAttaListStatElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""StatusElement"");
		StringList elAttaListCheckElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""CheckElement"");
		StringList elAttaListNavigationElement =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""NavigationElement"");
		StringList elAttaListName=  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, ""Name"");
		StringList elAttaListLanguage =  OLAPGetElementsAttributeValues(connection, UGDimension, UGDimension, ListOfUGElements, language);
		int index = 0;

		foreach(string UGOLAPElement in UGStringListHelp )
		{
			dicHide[UGOLAPElement] = GetElementByIndex(elAttaListHide,index);
			dicSort[UGOLAPElement] = GetElementByIndex(elAttaListSort,index);
			dicStatType[UGOLAPElement] = GetElementByIndex(elAttaListStatType,index);
			dicStatElement[UGOLAPElement] = GetElementByIndex(elAttaListStatElement,index);
			dicCheckElement[UGOLAPElement] = GetElementByIndex(elAttaListCheckElement,index);
			dicNavElement[UGOLAPElement] = GetElementByIndex(elAttaListNavigationElement,index);
			dicUGName[UGOLAPElement] = GetElementByIndex(elAttaListName,index);
			dicUGLang[UGOLAPElement] = GetElementByIndex(elAttaListLanguage,index);
			index = index + 1;
		}


		StringDictionary dicNavName = CreateStringDictionary();
		StringDictionary dicNavLang = CreateStringDictionary();
		StringDictionary dicReportUN= CreateStringDictionary();
		StringDictionary dicReportType = CreateStringDictionary();
		StringDictionary dicActive = CreateStringDictionary();

		OLAPElementList ListOfNavElements = OLAPGetElementList(connection,navigationDimension,false);
		StringList navStringListHelp = ToStringList(ListOfNavElements);
		StringList elAttaListReportUN =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""REPORTUN"");
		StringList elAttaListReportType =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""REPORTTYP"");
		StringList elAttaListNavName=  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""Name"");
		StringList elAttaListNavLanguage =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, language);
		StringList elAttaListNavActive =  OLAPGetElementsAttributeValues(connection, navigationDimension, navigationDimension, ListOfNavElements, ""ACTIVE"");
		index = 0;
		StringList availableNavElements =CreateStringList();

		foreach(string navElement in navStringListHelp )
		{
			dicReportUN[navElement] = GetElementByIndex(elAttaListReportUN,index);
			dicReportType[navElement] = GetElementByIndex(elAttaListReportType,index);
			dicNavName[navElement] = GetElementByIndex(elAttaListNavName,index);
			dicNavLang[navElement] = GetElementByIndex(elAttaListNavLanguage,index);
			dicActive[navElement] = GetElementByIndex(elAttaListNavActive,index);

			Append(availableNavElements,navElement);
			index = index + 1;
		}
		StringDictionary UGParents = CreateStringDictionary();
		StringDictionary statCubes = CreateStringDictionary();
		StringDictionary globalDict = CreateStringDictionary();
		DoubleDictionary statValue = CreateDoubleDictionary();

		BoolDictionary hasRights = CreateBoolDictionary();

		foreach(OLAPElement UG in ListOfUGElements)
		{
			bool isUGbaseElement = OLAPIsBaseElement(connection, UG);
			string UGstring = ToString(UG);
			if(isUGbaseElement)
			{
				if(Contains(availableNavElements,dicNavElement[UGstring]))
				{
					if(dicActive[dicNavElement[UGstring]] == ""1"")
					{
						hasRights[UGstring] = true;

					}
					else
					{
						hasRights[UGstring] = false;
					}
				}
				else
				{
					hasRights[UGstring] = false;
				}

			}
			else
			{
				OLAPElementList ListOfBaseElements = OLAPGetChildElementList(connection,UGDimension, UGstring,true);
				bool isIN =false;
				foreach(OLAPElement ug in ListOfBaseElements)
				{
					string ugString = ToString(ug);
					if(Contains(availableNavElements,dicNavElement[ugString]))
					{
						if(dicActive[dicNavElement[ugString]] == ""1"")

						{
							isIN = true;
						}
					}
				}
				if(isIN)
				{
					hasRights[UGstring] = true;
				}
				else
				{
					hasRights[UGstring] = false;
				}

			}

			OLAPElementList parentUGList = OLAPGetParentElementList(connection, UG);
			double parentCount = Count(parentUGList);
			if(parentCount == 1)
			{
				foreach(OLAPElement par in parentUGList)
				{
					parentString = ToString(par);
					UGParents[UGstring] = ToString(par);
					if(parentString ==parent)
					{
						UGParents[UGstring] = """";
					}
				}
			}
			string statusElement = dicStatElement[UGstring];
			string status = dicStatType[UGstring];
			double statusValue = 0;
			if(statusElement != """")
			{
				if(status == ""E"")
				{
					statCubes[UGstring] = statusECube;
					statValue[UGstring] = OLAPCellReadNumber(connection, statusECube, 1.0, cycle, year,period, version,entity,statusElement);
					globalDict[UGstring]="""";
				}
				else
				{
					statCubes[UGstring]= statusGCube;
					if (statusElement == ""Standard Exchange Rates"" or statusElement == ""Ownership"" or statusElement == ""Cash Flow Parameter"" )
					{
						statValue[UGstring]= OLAPCellReadNumber(connection, statusGCube, 1.0, cycle, year,period, version,""global"",statusElement);
						globalDict[UGstring]=""global"";
					}
					else
					{
						statValue[UGstring]= OLAPCellReadNumber(connection, statusGCube, 1.0, cycle, year,period, version,group,statusElement);
						globalDict[UGstring]="""";
					}
				}
			}
			else
			{
				statCubes[UGstring]="""";
				globalDict[UGstring]="""";
				statValue[UGstring]=0;
			}

		}
		BoolDictionary visibleAndHide = CreateBoolDictionary();
		foreach(OLAPElement UG in ListOfUGElements)
		{
			string UGstring = ToString(UG);
			if(hasRights[UGstring] and dicHide[UGstring]==""False"")
			{
				visibleAndHide[UGstring] = true;
			}
			else
			{
				visibleAndHide[UGstring] = false;
			}
		}
		BoolDictionary partofXML = CreateBoolDictionary();

		foreach(OLAPElement UG in ListOfUGElements)
		{
			string UGstring = ToString(UG);
			bool isUGbaseElement = OLAPIsBaseElement(connection, UG);
			if(!ContainsKey(partofXML, UGstring))
			{
				if(visibleAndHide[UGstring])
				{
					if(isUGbaseElement)
					{
						partofXML[UGstring] = true;
					}
					else
					{
						OLAPElementList ListOfElements = OLAPGetDirectChildrenList(connection,UGDimension, UGstring,false);
						bool childisNotHide = false;
						foreach(OLAPElement ug in ListOfElements)
						{
							string childUG = ToString(ug);
							bool isUGChildBaseElement = OLAPIsBaseElement(connection, ug);
							if(isUGChildBaseElement)
							{
								if(visibleAndHide[childUG])
								{
									childisNotHide = true;
								}
							}
							else
							{
								if(visibleAndHide[childUG])
								{
									OLAPElementList ListOfchildElements = OLAPGetChildElementList(connection,UGDimension, childUG,true);
									foreach(OLAPElement ugChild in ListOfchildElements)
									{
										string ugchildE = ToString(ugChild);
										if(visibleAndHide[ugchildE])
										{
											childisNotHide = true;
										}
									}
								}
							}
						}

						if(childisNotHide)
						{
							partofXML[UGstring] = true;
						}
						else
						{
							partofXML[UGstring] = false;
						}
					}

				}
				else
				{
					partofXML[UGstring] = false;
					OLAPElementList ListOfElements = OLAPGetChildElementList(connection,UGDimension, UGstring,false);
					foreach(OLAPElement ug in ListOfElements)
					{
						string childUG = ToString(ug);
						partofXML[childUG] = false;

					}
				}
			}
		}
		StringArray sortedUG = GetSortedUGElements(connection, parent, dicSort);
		StringList coNawRowNames =CreateStringList();
		foreach(string UGstring in sortedUG)
		{
			OLAPElement UG = OLAPGetDimensionElement(connection, UGDimension, UGstring);

			if(partofXML[UGstring])
			{
				parentString = UGParents[ToString(UG)];
				string sortString = dicSort[UGstring];
				if(sortString == """")
				{
					sortString = ""99"";
				}

				int numberOfdigits = StringLength(sortString);
				string zerosString = """";

				int zeros = 3 - numberOfdigits;
				if(zeros ==2)
				{
					zerosString = ""00"";
				}

				if(zeros ==1)
				{
					zerosString = ""0"";
				}
				string statusElement = dicStatElement[UGstring];
				string status = dicStatType[UGstring];
				double statusValue = 0;
				string evaluateStat = """";
				string stat = """";
				string gr = """";
				string elname = dicUGLang[UGstring];
				if(elname == """")
				{
					elname = dicUGName[UGstring];
				}
				if(elname == """")
				{
					elname = UGstring;
				}

				statusCube = statCubes[UGstring];
				statusValue = statValue[UGstring];
				gr = globalDict[UGstring];


				if(statusElement != """")
				{
					evaluateStat = ToString(EvaluateStatus(statusValue,applicationRolesArray,mode));
					stat = ToString(statusValue);
				}

				jumpType="""";
				actionType="""";
				targetUN="""";
				string rowName = ToString(UG);
				string navigationElement = dicNavElement[UGstring];
				string navUN="""";
				if(navigationElement != """")
				{
					OLAPElement navOlapElement = OLAPGetDimensionElement(connection, navigationDimension, navigationElement);
					targetUN = dicReportUN[navigationElement];
					jumpType = dicReportType[navigationElement];
					rowName = ToString(navOlapElement);
					navUN = ""[""+navigationDimension+""].[""+navigationElement+""].[1]"";
					if(Contains(coNawRowNames,rowName))
					{
						int counter = 1;
						while(counter <=10)
						{
							string rowNameHelp = rowName + ToString(counter);
							if(!Contains(coNawRowNames,rowNameHelp))
							{
								break;
							}
							counter = counter + 1;
						}
						string newPart = ToString(counter);
						rowName = rowName+newPart;
					}
					Append(coNawRowNames,rowName);

					statusCube = statCubes[parentString];
					statusValue = statValue[parentString];
					gr = globalDict[parentString];
					statusElement = dicStatElement[parentString];

					evaluateStat = ToString(EvaluateStatus(statusValue,applicationRolesArray,mode));
					stat = ToString(statusValue);

					if(jumpType == ""DGS"")
					{
						jumpType = ""D"";

						string reportParam = OLAPGetStringAttribute(connection,navOlapElement,""REPORTPARAM"");
						string entityOrGroup = """";
						if(mode == ""Entity"")
						{
							entityOrGroup = entity;
						}

						if(mode == ""Group"")
						{
							entityOrGroup = group;
						}
						targetUN = OpenDialogSentence(targetUN,reportParam,cycle,version,entityOrGroup,time);
					}

					
					actionType = ""jump"";
					elname = dicNavLang[navigationElement];
					if(elname == """")
					{
						elname = dicNavName[navigationElement];
					}
					if(elname == """")
					{
						elname = navigationElement;
					}
				}

				string checkElement = dicCheckElement[UGstring];
				string checkXML="""";
				bool totalCheckResult = true;
				if(checkElement !="""")
				{
					checkXML = CreateCheckXML(connection, cycle, year,period, version,entity,checkElement,language);
					XMLDocument checkDocXML =  XMLParseDocument(checkXML);
					XMLElement tableChecks = XMLGetRootElement(checkDocXML);
					foreach(XMLElement rowCheck in XMLGetChildElements(tableChecks, ""Row""))
					{
						string rowNameCheck = rowCheck.GetAttribute(""name"").GetValue();
						if(rowNameCheck == ""TC_IC"")
						{
							foreach(XMLElement prop in XMLGetChildElements(rowCheck, ""Property"")) {
								string checkPropName = prop.GetAttribute(""name"").GetValue();
								string checkPropValue = prop.GetAttribute(""value"").GetValue();
								if(checkPropName == ""value"")
								{
									if(checkPropValue == ""FALSE"")
									{
										totalCheckResult = false;
									}
								}
							}
						}
					}
				}

				row =RowInLandingPageXML(connection, rowName, elname, zerosString+sortString, parentString, statusElement, statusCube, jumpType, actionType, targetUN, evaluateStat, language, checkXML, """", """", gr, stat,navUN);
				XMLAddElement(table, row);
				
				double actionCheckValue = statValue[UGstring];

				if(submit ==actionCheckValue and parent == ""ENTITY_UG"")
				{
					if(statusElement != ""Total_Status"" and statusElement != ""Standard Exchange Rates"")
					{
						if(Contains(applicationRolesArray, ""Group Accountant"") or Contains(applicationRolesArray, ""Entity Accountant""))
						{
							if(readOnlyEntity != entity)
							{
								if(!totalCheckResult and statusElement == ""IC Matching"")
								{
									row =RowInLandingPageXML(connection, ToString(UG)+""_SUBMIT"", ""StatusSubmitWithWarning"", ""001"", ToString(UG), """", """", """", ""action"", """", """", language, """", ""21"", ""CO_LandingPageWrite"", """", """","""");
									XMLAddElement(table, row);
								}
								else
								{
									row =RowInLandingPageXML(connection, ToString(UG)+""_SUBMIT"", ""Submit"", ""001"", ToString(UG), """", """", """", ""action"", """", """", language, """", ""20"", ""CO_LandingPageWrite"", """", """","""");
									XMLAddElement(table, row);
								}
							}
						}
					}
				}
			}
		}
		
		result = ToString(doc);
		string userName = GetCurrentUserName();

		if(mode == ""Entity"")
		{
			OLAPCellWriteString(connection,tempConfigUserCube,result,""Parameter"",userName,""FEATURE_TEMP_CO_ENTITY_UG_XML"");

		}
		if(mode == ""Group"")
		{
			OLAPCellWriteString(connection,tempConfigUserCube,result,""Parameter"",userName,""FEATURE_TEMP_CO_GROUP_UG_XML"");
		}

		return result;
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	B7BA2C27-5268-4AE9-8360-1DDB311D851F	Create xml for given contex for landing page	1	1	1	1730	NULL	0	45708.67506	0	0
F5CD86A5-6006-47EF-897F-C2C57268B4D0	CD491758-D9DF-4002-94C8-8006E1855F86	CO_LandingPageLoadTabs	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""XML with landing page tabs setting"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""userRoles"" parameter-type=""string"" parameter-description=""Comma separated string with roles"" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_LandingPageLoadTabs(string server, string userRoles)
@Description: ""Create xml for given contex for landing page tabs"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[userRoles]: ""Comma separated string with roles"";
@Returns: ""XML with landing page tabs setting"";
{
	string functionName = ""CO_LandingPageLoadTabs:"";
	string configCycleCube = ""BPCCONFIG_CYCLE"";
	string entityDimension = ""DCOMPC"";
	string groupDimension = ""DGROUP"";
	string periodDimension = ""DPERIOD"";
	string yearDimension = ""DYEAR"";

	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//userRoles = ""Entity Accountant"";//""Consolidation Auditor; Consolidation Read Only; Consolidation Modeler; Entity Accountant; Group Accountant"";
		string userRolesUpdated = StringReplace(userRoles, ""; "", "","" , false);
		StringArray userRolesArray = StringSplit(userRolesUpdated, "","");
		
		string result="""";
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		bool hasGroupAccountantRole = Contains(userRolesArray, ""Group Accountant"") or Contains(userRolesArray, ""Group Accountant Custom"");
		bool hasEntityAccountantRole = Contains(userRolesArray, ""Entity Accountant"");
		bool hasConsolidationReadOnlyRole = Contains(userRolesArray, ""Consolidation Read Only"") or Contains(userRolesArray, ""Consolidation Read Only Custom"") or Contains(userRolesArray, ""Consolidation Auditor"");
		bool hasConsolidationModelerRole = Contains(userRolesArray, ""Consolidation Modeler"");
		bool hasGroupRole = hasGroupAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole;
		bool hasAnyConsolidationRole = hasGroupAccountantRole or hasEntityAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole;
		bool hasEntityAccountRoleOnly = hasEntityAccountantRole and !(hasGroupAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole);

		if(!hasAnyConsolidationRole)
		{
			row = XMLCreateElement(""Row"");
			XMLAddElement(table, row);
			XMLSetAttributeValue(row, ""name"", ""empty"");
			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""caption"");
			XMLSetAttributeValue(property, ""value"", ""co_NoCORoles"");
			XMLAddElement(row, property);
			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""reportUN"");
			XMLSetAttributeValue(property, ""value"", ""wf_empty"");
			XMLAddElement(row, property);
		}
		else
		{
			double consActivated = 0;
			try
			{
				consActivated = OLAPCellReadNumber(connection,configCycleCube,1,NA,NA,""GLOBAL_ACTIVE_APP_CO"",""Value"");
			}
			catch(errorMessage, errorCode)
			{
				LogError(functionName + errorMessage + "" Error code: "" + errorCode);
			}

			if(consActivated == 1)
			{
				int numberOfGroups = 0;
				int numberOfEntities = 0;
				try
				{
					OLAPElementList entityDimOList = OLAPGetElementList(connection, entityDimension,  false);
					StringList entityDimStringList = ToStringList(entityDimOList);
					numberOfEntities = Count(entityDimStringList);
				}
				catch(errorMessage, errorCode)
				{
					LogError(functionName + errorMessage + "" Error code: "" + errorCode);
				}
				try
				{
					OLAPElementList groupDimOList = OLAPGetElementList(connection, groupDimension,  false);
					StringList groupDimStringList = ToStringList(groupDimOList);
					numberOfGroups = Count(groupDimStringList);
					// do not consider ""global"" a regular group
					if (groupDimStringList.Contains(""global""))
					{
						numberOfGroups--;
					}
				}
				catch(errorMessage, errorCode)
				{
					LogError(functionName + errorMessage + "" Error code: "" + errorCode);
				}

				// in case there are no entities
				if(numberOfEntities == 0)
				{
					// Consolidation is not ready
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""empty"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""co_NotReady"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""wf_empty"");
					XMLAddElement(row, property);
				}
				else
				{
					// show status monitor (always)
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""Monitor"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""co_StatusMonitor"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""co_StatusMonitor"");
					XMLAddElement(row, property);

					// show entity tab (always)
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""Entity"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""bap_Entity"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""co_UserGuidance"");
					XMLAddElement(row, property);

					// for user with group role when there is at least one group
					if(hasGroupRole and numberOfGroups &gt; 0)
					{
						// show group tab
						row = XMLCreateElement(""Row"");
						XMLAddElement(table, row);
						XMLSetAttributeValue(row, ""name"", ""Group"");
						property = XMLCreateElement(""Property"");
						XMLSetAttributeValue(property, ""name"", ""caption"");
						XMLSetAttributeValue(property, ""value"", ""co_Group"");
						XMLAddElement(row, property);
						property = XMLCreateElement(""Property"");
						XMLSetAttributeValue(property, ""name"", ""reportUN"");
						XMLSetAttributeValue(property, ""value"", ""co_UserGuidance"");
						XMLAddElement(row, property);
					}
				}
			}
			else
			{
				// Consolidation is not activated
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				XMLSetAttributeValue(row, ""name"", ""empty"");
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(property, ""name"", ""caption"");
				XMLSetAttributeValue(property, ""value"", ""co_NotActivated"");
				XMLAddElement(row, property);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(property, ""name"", ""reportUN"");
				XMLSetAttributeValue(property, ""value"", ""wf_empty"");
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_LandingPageLoadTabs(string server, string userRoles)
@Description: ""Create xml for given contex for landing page tabs"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[userRoles]: ""Comma separated string with roles"";
@Returns: ""XML with landing page tabs setting"";
{
	string functionName = ""CO_LandingPageLoadTabs:"";
	string configCycleCube = ""BPCCONFIG_CYCLE"";
	string entityDimension = ""DCOMPC"";
	string groupDimension = ""DGROUP"";
	string periodDimension = ""DPERIOD"";
	string yearDimension = ""DYEAR"";

	string NA = ""N.A."";
	string errorMessage = """";
	int errorCode = 0;

	try {

		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		//userRoles = ""Entity Accountant"";//""Consolidation Auditor; Consolidation Read Only; Consolidation Modeler; Entity Accountant; Group Accountant"";
		string userRolesUpdated = StringReplace(userRoles, ""; "", "","" , false);
		StringArray userRolesArray = StringSplit(userRolesUpdated, "","");
		
		string result="""";
		XMLDocument doc = XMLCreateDocument();
		XMLElement table = XMLCreateElement(""Table"");
		XMLAddElement(doc, table);
		XMLElement row = XMLCreateElement(""Row"");
		XMLElement property = XMLCreateElement(""Property"");

		bool hasGroupAccountantRole = Contains(userRolesArray, ""Group Accountant"") or Contains(userRolesArray, ""Group Accountant Custom"");
		bool hasEntityAccountantRole = Contains(userRolesArray, ""Entity Accountant"");
		bool hasConsolidationReadOnlyRole = Contains(userRolesArray, ""Consolidation Read Only"") or Contains(userRolesArray, ""Consolidation Read Only Custom"") or Contains(userRolesArray, ""Consolidation Auditor"");
		bool hasConsolidationModelerRole = Contains(userRolesArray, ""Consolidation Modeler"");
		bool hasGroupRole = hasGroupAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole;
		bool hasAnyConsolidationRole = hasGroupAccountantRole or hasEntityAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole;
		bool hasEntityAccountRoleOnly = hasEntityAccountantRole and !(hasGroupAccountantRole or hasConsolidationReadOnlyRole or hasConsolidationModelerRole);

		if(!hasAnyConsolidationRole)
		{
			row = XMLCreateElement(""Row"");
			XMLAddElement(table, row);
			XMLSetAttributeValue(row, ""name"", ""empty"");
			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""caption"");
			XMLSetAttributeValue(property, ""value"", ""co_NoCORoles"");
			XMLAddElement(row, property);
			property = XMLCreateElement(""Property"");
			XMLSetAttributeValue(property, ""name"", ""reportUN"");
			XMLSetAttributeValue(property, ""value"", ""wf_empty"");
			XMLAddElement(row, property);
		}
		else
		{
			double consActivated = 0;
			try
			{
				consActivated = OLAPCellReadNumber(connection,configCycleCube,1,NA,NA,""GLOBAL_ACTIVE_APP_CO"",""Value"");
			}
			catch(errorMessage, errorCode)
			{
				LogError(functionName + errorMessage + "" Error code: "" + errorCode);
			}

			if(consActivated == 1)
			{
				int numberOfGroups = 0;
				int numberOfEntities = 0;
				try
				{
					OLAPElementList entityDimOList = OLAPGetElementList(connection, entityDimension,  false);
					StringList entityDimStringList = ToStringList(entityDimOList);
					numberOfEntities = Count(entityDimStringList);
				}
				catch(errorMessage, errorCode)
				{
					LogError(functionName + errorMessage + "" Error code: "" + errorCode);
				}
				try
				{
					OLAPElementList groupDimOList = OLAPGetElementList(connection, groupDimension,  false);
					StringList groupDimStringList = ToStringList(groupDimOList);
					numberOfGroups = Count(groupDimStringList);
					// do not consider ""global"" a regular group
					if (groupDimStringList.Contains(""global""))
					{
						numberOfGroups--;
					}
				}
				catch(errorMessage, errorCode)
				{
					LogError(functionName + errorMessage + "" Error code: "" + errorCode);
				}

				// in case there are no entities
				if(numberOfEntities == 0)
				{
					// Consolidation is not ready
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""empty"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""co_NotReady"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""wf_empty"");
					XMLAddElement(row, property);
				}
				else
				{
					// show status monitor (always)
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""Monitor"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""co_StatusMonitor"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""co_StatusMonitor"");
					XMLAddElement(row, property);

					// show entity tab (always)
					row = XMLCreateElement(""Row"");
					XMLAddElement(table, row);
					XMLSetAttributeValue(row, ""name"", ""Entity"");
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""caption"");
					XMLSetAttributeValue(property, ""value"", ""bap_Entity"");
					XMLAddElement(row, property);
					property = XMLCreateElement(""Property"");
					XMLSetAttributeValue(property, ""name"", ""reportUN"");
					XMLSetAttributeValue(property, ""value"", ""co_UserGuidance"");
					XMLAddElement(row, property);

					// for user with group role when there is at least one group
					if(hasGroupRole and numberOfGroups > 0)
					{
						// show group tab
						row = XMLCreateElement(""Row"");
						XMLAddElement(table, row);
						XMLSetAttributeValue(row, ""name"", ""Group"");
						property = XMLCreateElement(""Property"");
						XMLSetAttributeValue(property, ""name"", ""caption"");
						XMLSetAttributeValue(property, ""value"", ""co_Group"");
						XMLAddElement(row, property);
						property = XMLCreateElement(""Property"");
						XMLSetAttributeValue(property, ""name"", ""reportUN"");
						XMLSetAttributeValue(property, ""value"", ""co_UserGuidance"");
						XMLAddElement(row, property);
					}
				}
			}
			else
			{
				// Consolidation is not activated
				row = XMLCreateElement(""Row"");
				XMLAddElement(table, row);
				XMLSetAttributeValue(row, ""name"", ""empty"");
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(property, ""name"", ""caption"");
				XMLSetAttributeValue(property, ""value"", ""co_NotActivated"");
				XMLAddElement(row, property);
				property = XMLCreateElement(""Property"");
				XMLSetAttributeValue(property, ""name"", ""reportUN"");
				XMLSetAttributeValue(property, ""value"", ""wf_empty"");
				XMLAddElement(row, property);
			}
		}
		return ToString(doc);
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	2C128624-D5F1-4405-89AD-82E793274E23	Create xml for given contex for landing page tabs	1	1	1	1731	NULL	0	45708.67505	0	0
2CB83091-3599-46F8-92D2-C83EFC9B2739	CD491758-D9DF-4002-94C8-8006E1855F86	CO_LandingPageWrite	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""true if succesfull"" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP server and database to interact with in the form server/database"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""param"" parameter-type=""string"" parameter-description=""Parameters where data should be written back"" parameter-order=""1"" />
  <dependencies>
    <process process-name=""CO_LandingPageLoad"" process-version=""*"" process-id="""" />
    <process process-name=""GetGlobalActivityConstant"" process-version=""*"" process-id="""" />
    <process process-name=""GetEntityActivityConstant"" process-version=""*"" process-id="""" />
    <process process-name=""GetGroupActivityConstant"" process-version=""*"" process-id="""" />
    <process process-name=""GetActivityStatus"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_LandingPageLoad"", ""*""
#include ""GetGlobalActivityConstant"", ""*""
#include ""GetEntityActivityConstant"", ""*""
#include ""GetGroupActivityConstant"", ""*""
#include ""GetActivityStatus"", ""*""

string CO_LandingPageWrite(string server, string param)
@Description: ""Do writeback of informations from xml to given parameters in status monitor report"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[param]: ""Parameters where data should be written back"";
@Returns: ""true if succesfull"";
{
	string functionName = ""CO_StatusMonitorLoad:"";
	string errorMessage = """";
	string groupStatusCube = ""TSTATUSG"";
	string entityStatusCube = ""TSTATUSC"";

	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string result = """";
		string application = GetCurrentApplicationName();

		/*param="""";
		param = ""&lt;Table&gt;"";
		param = param + ""&lt;Row name=\""config\""&gt;"";
		param = param + ""&lt;Property name=\""Mode\"" value=\""Entity\"" /&gt;"";
		param = param + ""&lt;Property name=\""Cycle\"" value=\""[BPDCYCLE].[SET_001].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Version\"" value=\""[DVERSIO].[V01].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Entity\"" value=\""[DCOMPC].[RU0010].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Group\"" value=\""[DGROUP].[global].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Period\"" value=\""[DPERIOD].[Total Periods].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""Time\"" value=\""[DTIME].[01.2012].[1]\"" /&gt;"";
		param = param + ""&lt;Property name=\""StatusName\"" value=\""Entity Parameter\"" /&gt;"";
		param = param + ""&lt;Property name=\""NewStatusValue\"" value=\""0\"" /&gt;"";
		param = param + ""&lt;Property name=\""Language\"" value=\""English\"" /&gt;"";
		param = param + ""&lt;/Row&gt;"";
		param = param + ""&lt;/Table&gt;"";*/

		string mode = """";
		string cycle = """";
		string version = """";
		string entity = """";
		string group = """";
		string period = """";
		string year = """";
		string time = """";
		string StatusName = """";
		string NewStatusValue = """";

		XMLDocument docIn =  XMLParseDocument(param);
		XMLElement tableIn = XMLGetRootElement(docIn);
		XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
		
		foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property"")) {
			string propName = XMLGetAttributeValue(prop,""name"");
			string propValue = XMLGetAttributeValue(prop,""value"");

			if(propName == ""Mode"") {
				mode = propValue;
			}
			if(propName == ""Cycle"") {
				cycle = propValue;
				cycle = ResolveUniqueName(connection, cycle);
			}
			if(propName == ""Version"") {
				version = propValue;
				version = ResolveUniqueName(connection, version);
			}
			if(propName == ""Time"") {
				time = propValue;
				if(time !="""")
				{
					time = ResolveUniqueName(connection, time);
				}
			}
			if(propName == ""Entity"") {
				entity = propValue;
				if(entity !="""")
				{
					if(StringContains(entity,""[""))
					{
						entity = ResolveUniqueName(connection, entity);
					}

				}
			}
			if(propName == ""Group"") {
				group = propValue;
				if(group !="""")
				{
					if(StringContains(group,""[""))
					{
						group = ResolveUniqueName(connection, group);
					}
				}
			}
			if(propName == ""Period"") {
				period = propValue;
				if(period !="""")
				{
					period = ResolveUniqueName(connection, period);
				}

			}
			if(propName == ""Year"") {
				year = propValue;
				if(year !="""")
				{
					year = ResolveUniqueName(connection, year);
				}
			}
			if(propName == ""StatusName"") {
				StatusName = propValue;
			}
			if(propName == ""NewStatusValue"") {
				NewStatusValue = propValue;
			}
		}

		if(time !="""")
		{
			period = StringSubstring(time, 0, 2);
			year= StringSubstring(time, 3, 4);
		}
		if(mode == ""Group"")
		{
			if(group == ""global"")
			{
				ModelingSetGlobalActivityStatus(application, cycle, version, time, GetGlobalActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
			}
			else
			{
				ModelingSetGroupActivityStatus(application, cycle, version, group, time, GetGroupActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
			}
		}

		if(mode == ""Entity"")
		{
			ModelingSetEntityActivityStatus(application, cycle, version, entity, time, GetEntityActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
		}
		return CO_LandingPageLoad(server, param);
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}</bisharp-code>
</process-descriptor>"	1	"/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */
#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_LandingPageLoad"", ""*""
#include ""GetGlobalActivityConstant"", ""*""
#include ""GetEntityActivityConstant"", ""*""
#include ""GetGroupActivityConstant"", ""*""
#include ""GetActivityStatus"", ""*""

string CO_LandingPageWrite(string server, string param)
@Description: ""Do writeback of informations from xml to given parameters in status monitor report"";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP server and database to interact with in the form server/database"";
@Parameter[param]: ""Parameters where data should be written back"";
@Returns: ""true if succesfull"";
{
	string functionName = ""CO_StatusMonitorLoad:"";
	string errorMessage = """";
	string groupStatusCube = ""TSTATUSG"";
	string entityStatusCube = ""TSTATUSC"";

	int errorCode = 0;

	try {
		OLAPConnection connection = OLAPCreatePooledNamedConnection(server);
		string result = """";
		string application = GetCurrentApplicationName();

		/*param="""";
		param = ""<Table>"";
		param = param + ""<Row name=\""config\"">"";
		param = param + ""<Property name=\""Mode\"" value=\""Entity\"" />"";
		param = param + ""<Property name=\""Cycle\"" value=\""[BPDCYCLE].[SET_001].[1]\"" />"";
		param = param + ""<Property name=\""Version\"" value=\""[DVERSIO].[V01].[1]\"" />"";
		param = param + ""<Property name=\""Entity\"" value=\""[DCOMPC].[RU0010].[1]\"" />"";
		param = param + ""<Property name=\""Group\"" value=\""[DGROUP].[global].[1]\"" />"";
		param = param + ""<Property name=\""Period\"" value=\""[DPERIOD].[Total Periods].[1]\"" />"";
		param = param + ""<Property name=\""Time\"" value=\""[DTIME].[01.2012].[1]\"" />"";
		param = param + ""<Property name=\""StatusName\"" value=\""Entity Parameter\"" />"";
		param = param + ""<Property name=\""NewStatusValue\"" value=\""0\"" />"";
		param = param + ""<Property name=\""Language\"" value=\""English\"" />"";
		param = param + ""</Row>"";
		param = param + ""</Table>"";*/

		string mode = """";
		string cycle = """";
		string version = """";
		string entity = """";
		string group = """";
		string period = """";
		string year = """";
		string time = """";
		string StatusName = """";
		string NewStatusValue = """";

		XMLDocument docIn =  XMLParseDocument(param);
		XMLElement tableIn = XMLGetRootElement(docIn);
		XMLElement rowIn = XMLGetChildElement(tableIn, ""Row"");
		
		foreach(XMLElement prop in XMLGetChildElements(rowIn, ""Property"")) {
			string propName = XMLGetAttributeValue(prop,""name"");
			string propValue = XMLGetAttributeValue(prop,""value"");

			if(propName == ""Mode"") {
				mode = propValue;
			}
			if(propName == ""Cycle"") {
				cycle = propValue;
				cycle = ResolveUniqueName(connection, cycle);
			}
			if(propName == ""Version"") {
				version = propValue;
				version = ResolveUniqueName(connection, version);
			}
			if(propName == ""Time"") {
				time = propValue;
				if(time !="""")
				{
					time = ResolveUniqueName(connection, time);
				}
			}
			if(propName == ""Entity"") {
				entity = propValue;
				if(entity !="""")
				{
					if(StringContains(entity,""[""))
					{
						entity = ResolveUniqueName(connection, entity);
					}

				}
			}
			if(propName == ""Group"") {
				group = propValue;
				if(group !="""")
				{
					if(StringContains(group,""[""))
					{
						group = ResolveUniqueName(connection, group);
					}
				}
			}
			if(propName == ""Period"") {
				period = propValue;
				if(period !="""")
				{
					period = ResolveUniqueName(connection, period);
				}

			}
			if(propName == ""Year"") {
				year = propValue;
				if(year !="""")
				{
					year = ResolveUniqueName(connection, year);
				}
			}
			if(propName == ""StatusName"") {
				StatusName = propValue;
			}
			if(propName == ""NewStatusValue"") {
				NewStatusValue = propValue;
			}
		}

		if(time !="""")
		{
			period = StringSubstring(time, 0, 2);
			year= StringSubstring(time, 3, 4);
		}
		if(mode == ""Group"")
		{
			if(group == ""global"")
			{
				ModelingSetGlobalActivityStatus(application, cycle, version, time, GetGlobalActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
			}
			else
			{
				ModelingSetGroupActivityStatus(application, cycle, version, group, time, GetGroupActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
			}
		}

		if(mode == ""Entity"")
		{
			ModelingSetEntityActivityStatus(application, cycle, version, entity, time, GetEntityActivityConstant(StatusName), GetActivityStatus(NewStatusValue));
		}
		return CO_LandingPageLoad(server, param);
	}
	catch(errorMessage, errorCode)
	{
		LogError(functionName + errorMessage + "" Error code: "" + errorCode);
		return """";
	}
}"	1	70C26D2C-B743-4E6C-A3D0-471D73874E4E	Do writeback of informations from xml to given parameters in status monitor report	1	1	1	1732	NULL	0	45708.67502	0	0
5CCE1204-923A-438B-85FF-795218A15DAB	CD491758-D9DF-4002-94C8-8006E1855F86	CO_LogGroupJournalLineInfo	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""Logged journal line information."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""groupJournalLine"" parameter-type=""GroupJournalLine"" parameter-description=""Group journal line object."" parameter-order=""0"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_LogGroupJournalLineInfo(GroupJournalLine groupJournalLine)
@Description: ""Logs the data about group journal line."";
@Category: ""Consolidation"";
@Parameter[groupJournalLine]: ""Group journal line object."";
@Returns: ""Logged journal line information."";
{
	StringArray journalLineInfoArray = CreateStringArray();

	string company =  ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Company"");
	Append(journalLineInfoArray, ""company"" + ""&lt;"" + company + ""&gt;"");

	string account = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Account"");
	Append(journalLineInfoArray, ""account"" + ""&lt;"" + account + ""&gt;"");

	string intercompany = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Intercompany"");
	Append(journalLineInfoArray, ""intercompany"" + ""&lt;"" + intercompany + ""&gt;"");

	string detail = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Detail"");
	Append(journalLineInfoArray, ""scheduleDetail"" + ""&lt;"" + detail + ""&gt;"");

	double credit= ConsolidationGetGroupJournalLineNumericProperty(groupJournalLine, ""Credit"");
	Append(journalLineInfoArray, ""credit"" + ""&lt;"" + credit + ""&gt;"");

	double debit = ConsolidationGetGroupJournalLineNumericProperty(groupJournalLine, ""Debit"");
	Append(journalLineInfoArray, ""debit"" + ""&lt;"" + debit + ""&gt;"");

	string primarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment1"");
	Append(journalLineInfoArray, ""segment1"" + ""&lt;"" + primarySegment + ""&gt;"");

	string primaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment1"");
	Append(journalLineInfoArray, ""partnerSegment1"" + ""&lt;"" + primaryPartnerSegment + ""&gt;"");

	string secondarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment2"");
	Append(journalLineInfoArray, ""segment2"" + ""&lt;"" + secondarySegment + ""&gt;"");

	string secondaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment2"");
	Append(journalLineInfoArray, ""partnerSegment2"" + ""&lt;"" + secondaryPartnerSegment + ""&gt;"");

	string tertiarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment3"");
	Append(journalLineInfoArray, ""segment3"" + ""&lt;"" + tertiarySegment + ""&gt;"");

	string tertiaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment3"");
	Append(journalLineInfoArray, ""partnerSegment3"" + ""&lt;"" + tertiaryPartnerSegment + ""&gt;"");
	
	string description =  ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Description"");
	Append(journalLineInfoArray, ""description"" + ""&lt;"" + description + ""&gt;"");

	string journalLineInfoCombined = StringJoin(journalLineInfoArray, "", "");
	NotifyError(journalLineInfoCombined);
	return journalLineInfoCombined;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_LogGroupJournalLineInfo(GroupJournalLine groupJournalLine)
@Description: ""Logs the data about group journal line."";
@Category: ""Consolidation"";
@Parameter[groupJournalLine]: ""Group journal line object."";
@Returns: ""Logged journal line information."";
{
	StringArray journalLineInfoArray = CreateStringArray();

	string company =  ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Company"");
	Append(journalLineInfoArray, ""company"" + ""<"" + company + "">"");

	string account = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Account"");
	Append(journalLineInfoArray, ""account"" + ""<"" + account + "">"");

	string intercompany = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Intercompany"");
	Append(journalLineInfoArray, ""intercompany"" + ""<"" + intercompany + "">"");

	string detail = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Detail"");
	Append(journalLineInfoArray, ""scheduleDetail"" + ""<"" + detail + "">"");

	double credit= ConsolidationGetGroupJournalLineNumericProperty(groupJournalLine, ""Credit"");
	Append(journalLineInfoArray, ""credit"" + ""<"" + credit + "">"");

	double debit = ConsolidationGetGroupJournalLineNumericProperty(groupJournalLine, ""Debit"");
	Append(journalLineInfoArray, ""debit"" + ""<"" + debit + "">"");

	string primarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment1"");
	Append(journalLineInfoArray, ""segment1"" + ""<"" + primarySegment + "">"");

	string primaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment1"");
	Append(journalLineInfoArray, ""partnerSegment1"" + ""<"" + primaryPartnerSegment + "">"");

	string secondarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment2"");
	Append(journalLineInfoArray, ""segment2"" + ""<"" + secondarySegment + "">"");

	string secondaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment2"");
	Append(journalLineInfoArray, ""partnerSegment2"" + ""<"" + secondaryPartnerSegment + "">"");

	string tertiarySegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Segment3"");
	Append(journalLineInfoArray, ""segment3"" + ""<"" + tertiarySegment + "">"");

	string tertiaryPartnerSegment = ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""PSegment3"");
	Append(journalLineInfoArray, ""partnerSegment3"" + ""<"" + tertiaryPartnerSegment + "">"");
	
	string description =  ConsolidationGetGroupJournalLineProperty(groupJournalLine, ""Description"");
	Append(journalLineInfoArray, ""description"" + ""<"" + description + "">"");

	string journalLineInfoCombined = StringJoin(journalLineInfoArray, "", "");
	NotifyError(journalLineInfoCombined);
	return journalLineInfoCombined;
}"	1	C48E74EA-B39A-47AC-99CB-F16BD37D307B	Logs the data about group journal line.	1	1	1	1733	NULL	0	45708.67506	0	0
6CA38096-6C2A-4967-BE51-362A082DB45F	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Minorities	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""the group to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies>
    <process process-name=""CO_AccountHasSegment"" process-version=""*"" process-id="""" />
    <process process-name=""CO_Companies"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GroupCurrency"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationMethod"" process-version=""*"" process-id="""" />
    <process process-name=""CO_MinorityDirect"" process-version=""*"" process-id="""" />
    <process process-name=""CO_MinorityIndirect"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ConsolidationBasis"" process-version=""*"" process-id="""" />
    <process process-name=""CO_AccountType"" process-version=""*"" process-id="""" />
    <process process-name=""CO_GetProcessProperty"" process-version=""*"" process-id="""" />
    <process process-name=""CO_ValidateProcessConfiguration"" process-version=""*"" process-id="""" />
  </dependencies>
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountHasSegment"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_MinorityDirect"", ""*""
#include ""CO_MinorityIndirect"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_ValidateProcessConfiguration"", ""*""

bool CO_Minorities(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCMinorities process.This process calculates the minorities in profit and loss."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""M1"";
	cancel = false;*/
	
	string processName = ""CO_Minorities"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process &lt;"" + processName + ""&gt; for year&lt;"" + year + ""&gt; period&lt;"" + period + ""&gt; scenario&lt;"" + scenario + ""&gt; group&lt;"" + group + ""&gt; ruleid&lt;"" + ruleid + ""&gt; cancel&lt;"" + cancel + ""&gt;."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		string CONSOLIDATION_TYPE = ""Cons. Capital"";
		string consolidationRule = ruleid; // todo: confirm if we still need to validate the ruleid

		// Group Parametrization
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

		OLAPElementList companiesFull = CreateOLAPElementList();
		int ownershipCtr = 0;
		foreach (OLAPElement company in CO_Companies(olapConnection, cycle))
		{
			string consMethod = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company);
			if (consMethod != """")
			{
				ownershipCtr = ownershipCtr + 1;
				if (consMethod == ""Full"")
				{
					companiesFull.ElementListAddElement(company);
				}
			}
		}

		// validate Group Parametrization
        
		StringList groupParamErrors = CreateStringList();
		if (groupcurrency == """")
		{
			groupParamErrors.Append(""Group Currency should be configured."");
		}
		if (ownershipCtr == 0)
		{
			groupParamErrors.Append(""Missing entity ownership configuration and/or group ownership calculation."");
		}
		if (groupParamErrors.Count() &gt; 0)
		{
			WriteLine(""Group Parametrization Issues:"");
			foreach (string error in groupParamErrors) {
				WriteLine(error);
			}
		}

		// Process Configuration property names
		string PROP_BASE_ACCOUNT = ""Base Account"";
		string PROP_NON_CONTROLLING_INTERESTS_ACCOUNT = ""Non Controlling Interests Account"";
		string PROP_NON_CONTROLLING_INTERESTS_DETAIL = ""Non Controlling Interests Account Detail"";
		string PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT = ""Non Controlling Interests Contra-Account"";
		string PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL = ""Non Controlling Interests Contra-Account Detail"";

		// get and validate the Process Configuration
		StringDictionary accountsConfig = CreateStringDictionary();
		accountsConfig[PROP_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_BASE_ACCOUNT);
		accountsConfig[PROP_NON_CONTROLLING_INTERESTS_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_ACCOUNT);
		accountsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT);

		StringDictionary detailsConfig = CreateStringDictionary();
		detailsConfig[PROP_NON_CONTROLLING_INTERESTS_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_DETAIL);
		detailsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL);
		
		StringDictionary detailToAccount = CreateStringDictionary();
		detailToAccount[PROP_NON_CONTROLLING_INTERESTS_DETAIL] = PROP_NON_CONTROLLING_INTERESTS_ACCOUNT;
		detailToAccount[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL] = PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT;

		bool isValidConfig = CO_ValidateProcessConfiguration(olapConnection, accountsConfig, detailsConfig, detailToAccount);
		// stop the process if there are Process Config or Group Parametrization issues
		if (!isValidConfig or groupParamErrors.Count() &gt; 0) {
			ExitProcess(""Cannot execute the process"");
		}
		// end of validation

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			bool useSegments = false;
			double counter1 = 0;
			double counter2 = 0;

			string consolidationBase = CO_ConsolidationBasis(olapConnection, cycle, CONSOLIDATION_TYPE);
			string account = accountsConfig[PROP_NON_CONTROLLING_INTERESTS_ACCOUNT];
			string contraAccount = accountsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT];
			string accountDetail = detailsConfig[PROP_NON_CONTROLLING_INTERESTS_DETAIL];
			string contraAccountDetail = detailsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL];
			string baseAccount = accountsConfig[PROP_BASE_ACCOUNT];

			OLAPElement baseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", baseAccount);
			bool isExpenditureBaseAccount = CO_AccountType(olapConnection, baseAccountElement) == ""Expenditure"";

			if (CO_AccountHasSegment(olapConnection, cycle, baseAccount, 1) or CO_AccountHasSegment(olapConnection, cycle, baseAccount, 2) or CO_AccountHasSegment(olapConnection, cycle,  baseAccount, 3))
			{
				string generateSegmentJournalsString = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Generate Segment Journals"");
				useSegments = generateSegmentJournalsString == ""0"";
			}

			foreach (OLAPElement company in companiesFull)
			{
				double mdirect = CO_MinorityDirect(olapConnection, cycle, year, period, scenario, group, company, ""sum"");
				double mindirect = CO_MinorityIndirect(olapConnection, cycle, year, period, scenario, group, company, ""sum"");
				
				if (!useSegments)
				{
					double baseValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBase, group, company, ""sum"", baseAccount);
					
					double value = baseValue * (mdirect + mindirect);
					
					if (value != 0) {
						GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, CONSOLIDATION_TYPE, ruleid, """", true);
						
						if ((isExpenditureBaseAccount and value &lt; 0) or (!isExpenditureBaseAccount and value &gt; 0)) {
							ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, """", Abs(value), 0.0);
							ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, """", 0.0, Abs(value));
						} else {
							ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, """", 0.0, Abs(value));
							ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, """", Abs(value), 0.0);
						}
						
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter1 = counter1 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
				else
				{
					OLAPElement accountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
					string accType = cached OLAPGetStringAttribute(olapConnection, accountElement, ""ALRE"");
					if (accType == ""R"" or accType == ""E"") {
						GroupJournal journal = ConsolidationCreateGroupJournal(journalStore,cycle,  year, period, scenario, group, CONSOLIDATION_TYPE, ""Intersegment"", ruleid, """", true);
						
						OLAPDataArea sourceArea = OLAPCreateDataArea(
							olapConnection, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBase, group, ""Consolidated Segments"", company, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", baseAccount
						);
						
						foreach (OLAPCell cell in sourceArea) {
							string pPrimarySegment = OLAPCellGetElement(cell, ""DPSEGM"");
							string pSecondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
							string pTertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
							
							double baseValue = cell;
							
							double value = baseValue * (mdirect + mindirect);
							
							if (value != 0.0) {
								
								if ((isExpenditureBaseAccount and value &lt; 0) or (!isExpenditureBaseAccount and value &gt; 0)) {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(value), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(value));
								} else {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(value));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(value), 0.0);
								}
							}
						}
						
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter2 = counter2 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
			}
			WriteLine(""posted &lt;"" + counter1 + ""&gt; group journal(s)"");
			WriteLine(""posted &lt;"" + counter2 + ""&gt; group segment journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured &lt;"" + errorMessage + ""&gt;&lt;"" + errorCode + ""&gt;"");
	}

	WriteLine(""finished calculations &lt;"" + processName + ""&gt;&lt;"" + result + ""&gt;"");

	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

#include ""CO_AccountHasSegment"", ""*""
#include ""CO_Companies"", ""*""
#include ""CO_GroupCurrency"", ""*""
#include ""CO_ConsolidationMethod"", ""*""
#include ""CO_MinorityDirect"", ""*""
#include ""CO_MinorityIndirect"", ""*""
#include ""CO_ConsolidationBasis"", ""*""
#include ""CO_AccountType"", ""*""
#include ""CO_GetProcessProperty"", ""*""
#include ""CO_ValidateProcessConfiguration"", ""*""

bool CO_Minorities(string server, string cycle, string year, string period, string scenario, string group, string ruleid, bool cancel)
@Description: ""Former FCMinorities process.This process calculates the minorities in profit and loss."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[group]: ""the group to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for journals"";
@Parameter[cancel]: ""if true, the rule will only cancel its journals or other old data"";
@Returns: ""True, if successful; false otherwise."";
{
	//DEBUG
	/*cycle = ""SET_001"";
	year = ""2020"";
	period = ""12"";
	scenario = ""V01"";
	group = ""GR0001"";
	ruleid = ""M1"";
	cancel = false;*/
	
	string processName = ""CO_Minorities"";
	bool result = false;
	string errorMessage = """";
	int errorCode = 0;

	try {
		WriteLine(""Starting process <"" + processName + ""> for year<"" + year + ""> period<"" + period + ""> scenario<"" + scenario + ""> group<"" + group + ""> ruleid<"" + ruleid + ""> cancel<"" + cancel + "">."");

		OLAPConnection olapConnection = OLAPCreatePooledNamedConnection(server);
		JournalStore journalStore = ConsolidationCreateJournalStore(olapConnection);

		string CONSOLIDATION_TYPE = ""Cons. Capital"";
		string consolidationRule = ruleid; // todo: confirm if we still need to validate the ruleid

		// Group Parametrization
		string groupcurrency = CO_GroupCurrency(olapConnection, cycle, year, period, scenario, group);

		OLAPElementList companiesFull = CreateOLAPElementList();
		int ownershipCtr = 0;
		foreach (OLAPElement company in CO_Companies(olapConnection, cycle))
		{
			string consMethod = CO_ConsolidationMethod(olapConnection, cycle, year, period, scenario, group, company);
			if (consMethod != """")
			{
				ownershipCtr = ownershipCtr + 1;
				if (consMethod == ""Full"")
				{
					companiesFull.ElementListAddElement(company);
				}
			}
		}

		// validate Group Parametrization
		StringList groupParamErrors = CreateStringList();
		if (groupcurrency == """")
		{
			groupParamErrors.Append(""Group Currency should be configured."");
		}
		if (ownershipCtr == 0)
		{
			groupParamErrors.Append(""Missing entity ownership configuration and/or group ownership calculation."");
		}
		if (groupParamErrors.Count() > 0)
		{
			WriteLine(""Group Parametrization Issues:"");
			foreach (string error in groupParamErrors) {
				WriteLine(error);
			}
		}

		// Process Configuration property names
		string PROP_BASE_ACCOUNT = ""Base Account"";
		string PROP_NON_CONTROLLING_INTERESTS_ACCOUNT = ""Non Controlling Interests Account"";
		string PROP_NON_CONTROLLING_INTERESTS_DETAIL = ""Non Controlling Interests Account Detail"";
		string PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT = ""Non Controlling Interests Contra-Account"";
		string PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL = ""Non Controlling Interests Contra-Account Detail"";

		// get and validate the Process Configuration
		StringDictionary accountsConfig = CreateStringDictionary();
		accountsConfig[PROP_BASE_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_BASE_ACCOUNT);
		accountsConfig[PROP_NON_CONTROLLING_INTERESTS_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_ACCOUNT);
		accountsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT);

		StringDictionary detailsConfig = CreateStringDictionary();
		detailsConfig[PROP_NON_CONTROLLING_INTERESTS_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_DETAIL);
		detailsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL] = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL);
		
		StringDictionary detailToAccount = CreateStringDictionary();
		detailToAccount[PROP_NON_CONTROLLING_INTERESTS_DETAIL] = PROP_NON_CONTROLLING_INTERESTS_ACCOUNT;
		detailToAccount[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL] = PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT;

		bool isValidConfig = CO_ValidateProcessConfiguration(olapConnection, accountsConfig, detailsConfig, detailToAccount);
		// stop the process if there are Process Config or Group Parametrization issues
		if (!isValidConfig or groupParamErrors.Count() > 0) {
			ExitProcess(""Cannot execute the process"");
		}
		// end of validation

		WriteLine(""cancelling journals"");

		if (!ConsolidationCancelGroupJournals(journalStore, cycle, year, period, scenario, group, ruleid, """")) {
			RaiseError(""Error cancelling group journals"", 1000);
		}

		WriteLine(""cancelled journals"");

		if (!cancel) {
			bool useSegments = false;
			double counter1 = 0;
			double counter2 = 0;

			string consolidationBase = CO_ConsolidationBasis(olapConnection, cycle, CONSOLIDATION_TYPE);
			string account = accountsConfig[PROP_NON_CONTROLLING_INTERESTS_ACCOUNT];
			string contraAccount = accountsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_ACCOUNT];
			string accountDetail = detailsConfig[PROP_NON_CONTROLLING_INTERESTS_DETAIL];
			string contraAccountDetail = detailsConfig[PROP_NON_CONTROLLING_INTERESTS_CONTRA_DETAIL];
			string baseAccount = accountsConfig[PROP_BASE_ACCOUNT];

			OLAPElement baseAccountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", baseAccount);
			bool isExpenditureBaseAccount = CO_AccountType(olapConnection, baseAccountElement) == ""Expenditure"";

			if (CO_AccountHasSegment(olapConnection, cycle, baseAccount, 1) or CO_AccountHasSegment(olapConnection, cycle, baseAccount, 2) or CO_AccountHasSegment(olapConnection, cycle,  baseAccount, 3))
			{
				string generateSegmentJournalsString = CO_GetProcessProperty(olapConnection, cycle, consolidationRule, ""Generate Segment Journals"");
				useSegments = generateSegmentJournalsString == ""0"";
			}

			foreach (OLAPElement company in companiesFull)
			{
				double mdirect = CO_MinorityDirect(olapConnection, cycle, year, period, scenario, group, company, ""sum"");
				double mindirect = CO_MinorityIndirect(olapConnection, cycle, year, period, scenario, group, company, ""sum"");
				
				if (!useSegments)
				{
					double baseValue = OLAPCellReadNumber(olapConnection, ""TFINANG"", 1.0, cycle, year, period, scenario, groupcurrency, consolidationBase, group, company, ""sum"", baseAccount);
					
					double value = baseValue * (mdirect + mindirect);
					
					if (value != 0) {
						GroupJournal journal = ConsolidationCreateGroupJournal(journalStore, cycle, year, period, scenario, group, CONSOLIDATION_TYPE, ruleid, """", true);
						
						if ((isExpenditureBaseAccount and value < 0) or (!isExpenditureBaseAccount and value > 0)) {
							ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, """", Abs(value), 0.0);
							ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, """", 0.0, Abs(value));
						} else {
							ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, """", 0.0, Abs(value));
							ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, """", Abs(value), 0.0);
						}
						
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter1 = counter1 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
				else
				{
					OLAPElement accountElement = OLAPGetDimensionElement(olapConnection, ""DACOUNT"", account);
					string accType = cached OLAPGetStringAttribute(olapConnection, accountElement, ""ALRE"");
					if (accType == ""R"" or accType == ""E"") {
						GroupJournal journal = ConsolidationCreateGroupJournal(journalStore,cycle,  year, period, scenario, group, CONSOLIDATION_TYPE, ""Intersegment"", ruleid, """", true);
						
						OLAPDataArea sourceArea = OLAPCreateDataArea(
							olapConnection, ""TSEGMG"", OlapDataAreaIncludeB | OlapDataAreaIncludeC | OlapDataAreaSuppressNull,
							OlapDataAreaOperatorNotEqual, 0.0, OlapDataAreaOperatorNone, 0,
							cycle, year, period, scenario, groupcurrency, consolidationBase, group, ""Consolidated Segments"", company, ""Sum"",
							OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", OlapDataAreaBCells, ""Sum"", baseAccount
						);
						
						foreach (OLAPCell cell in sourceArea) {
							string pPrimarySegment = OLAPCellGetElement(cell, ""DPSEGM"");
							string pSecondarySegment = OLAPCellGetElement(cell, ""DSSEGM"");
							string pTertiarySegment = OLAPCellGetElement(cell, ""DTSEGM"");
							
							double baseValue = cell;
							
							double value = baseValue * (mdirect + mindirect);
							
							if (value != 0.0) {
								
								if ((isExpenditureBaseAccount and value < 0) or (!isExpenditureBaseAccount and value > 0)) {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(value), 0.0);
									ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(value));
								} else {
									ConsolidationAddGroupJournalLine(journal, company, ""External"", account, accountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", 0.0, Abs(value));
									ConsolidationAddGroupJournalLine(journal, company, ""External"", contraAccount, contraAccountDetail, pPrimarySegment, ""External"", pSecondarySegment, ""External"", pTertiarySegment, ""External"", """", Abs(value), 0.0);
								}
							}
						}
						
						if (!ConsolidationJournalIsEmpty(journal)) {
							if (ConsolidationJournalIsBalanced(journal)) {
								ConsolidationPostJournal(journalStore, journal);
								counter2 = counter2 + 1;
							} else {
								WriteLine(""The journal was not posted as it was unbalanced."");
							}
						}
					}
				}
			}
			WriteLine(""posted <"" + counter1 + ""> group journal(s)"");
			WriteLine(""posted <"" + counter2 + ""> group segment journal(s)"");
		}

		result = true;

	} catch (errorMessage, errorCode) {
		WriteLine(""ERROR occured <"" + errorMessage + ""><"" + errorCode + "">"");
	}

	WriteLine(""finished calculations <"" + processName + ""><"" + result + "">"");

	return result;
}"	1	493C2588-C150-4A10-92F7-7BD4FB47E056	Former FCMinorities process.This process calculates the minorities in profit and loss.	1	1	1	1734	NULL	0	45708.67508	0	0
0CF60F4D-17E2-4AEE-AA5D-90CDE91DD038	CD491758-D9DF-4002-94C8-8006E1855F86	CO_MinoritiesAccount	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""string"" return-value-description=""The minorities account of the account."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""account"" parameter-type=""OLAPElement"" parameter-description=""The account to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_MinoritiesAccount(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the account to be used for the minorities of an account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The minorities account of the account."";
{
	string result = cached OLAPGetStringAttribute(connection, account, ""Minorities"");
	return result;
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

string CO_MinoritiesAccount(OLAPConnection connection, OLAPElement account)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the account to be used for the minorities of an account."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[account]: ""The account to query."";
@Returns: ""The minorities account of the account."";
{
	string result = cached OLAPGetStringAttribute(connection, account, ""Minorities"");
	return result;
}"	1	D2282F46-8379-448E-BE3F-92D73B607E80	Gets the account to be used for the minorities of an account.	1	1	1	1735	NULL	0	45708.67504	0	0
7FF8FB15-D2F5-4346-8797-CA154B8222DE	CD491758-D9DF-4002-94C8-8006E1855F86	CO_MinorityDirect	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The direct minorities for the specified company on intercompany in group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""An element that specifies the intercompany to query."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_MinorityDirect(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the direct minorities of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The direct minorities for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""minority direct"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_MinorityDirect(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the direct minorities of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The direct minorities for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""minority direct"");
}"	1	E2A9954F-EB3F-4FFE-9F6A-C867A7530B83	Gets the direct minorities of a company on an intercompany in a group for a specified context.	1	1	1	1736	NULL	0	45708.67504	0	0
99FF9DEB-D798-4DBF-8653-88A481D3DAA4	CD491758-D9DF-4002-94C8-8006E1855F86	CO_MinorityIndirect	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The indirect minorities for the specified company on intercompany in group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""An element that specifies the intercompany to query."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_MinorityIndirect(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the indirect minorities of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The indirect minorities for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""minority indirect"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_MinorityIndirect(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the indirect minorities of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The indirect minorities for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""minority indirect"");
}"	1	958C5824-67F8-47E5-BB88-8B5746D340FC	Gets the indirect minorities of a company on an intercompany in a group for a specified context.	1	1	1	1737	NULL	0	45708.67503	0	0
A9DC1A90-5D7D-453D-AE80-1992414073EE	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Ownership	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""double"" return-value-description=""The direct ownership for the specified company on intercompany in group."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""An element that specifies the configuration set to query."" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""An element that specifies the year to query."" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""An element that specifies the period to query."" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""An element that specifies the scenario to query."" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""group"" parameter-type=""string"" parameter-description=""An element that specifies the group to query."" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""An element that specifies the company to query."" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""intercompany"" parameter-type=""string"" parameter-description=""An element that specifies the intercompany to query."" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_Ownership(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the direct ownership of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The direct ownership for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""equity participation"");
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

double CO_Ownership(OLAPConnection connection, string configurationSet, string year, string period, string scenario, string group, string company, string intercompany)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the direct ownership of a company on an intercompany in a group for a specified context."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""An element that specifies the configuration set to query."";
@Parameter[year]: ""An element that specifies the year to query."";
@Parameter[period]: ""An element that specifies the period to query."";
@Parameter[scenario]: ""An element that specifies the scenario to query."";
@Parameter[group]: ""An element that specifies the group to query."";
@Parameter[company]: ""An element that specifies the company to query."";
@Parameter[intercompany]: ""An element that specifies the intercompany to query."";
@Returns: ""The direct ownership for the specified company on intercompany in group."";
{
	return cached OLAPCellReadNumber(connection, ""TCONSPA"", 1.0, configurationSet, year, period, scenario, group, company, intercompany, ""equity participation"");
}"	1	3AA3AF01-BE5F-4FEC-B3DC-0E7B743FA129	Gets the direct ownership of a company on an intercompany in a group for a specified context.	1	1	1	1738	NULL	0	45708.67504	0	0
5C5268DA-E3C5-436B-9551-8AC6E07AE581	CD491758-D9DF-4002-94C8-8006E1855F86	CO_PrimaryPartnerSegments	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of primary partner segments."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_PrimaryPartnerSegments(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of primary partner segments, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of primary partner segments."";
{
	return cached OLAPGetElementList(connection, ""DPRSEGM"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_PrimaryPartnerSegments(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of primary partner segments, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of primary partner segments."";
{
	return cached OLAPGetElementList(connection, ""DPRSEGM"", true);
}"	1	1FAC5B45-EA29-4002-8493-FB7554E82A09	Gets the list of primary partner segments, only base elements.	1	1	1	1739	NULL	0	45708.67503	0	0
F729A2B5-0282-47FE-A4FE-37C9741FFFD0	CD491758-D9DF-4002-94C8-8006E1855F86	CO_PrimarySegments	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of primary segments."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_PrimarySegments(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of primary segments, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of primary segments."";
{
	return cached OLAPGetElementList(connection, ""DPSEGM"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_PrimarySegments(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of primary segments, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of primary segments."";
{
	return cached OLAPGetElementList(connection, ""DPSEGM"", true);
}"	1	5916DCB7-B9F5-48B0-81FE-8AAE51EE0BF2	Gets the list of primary segments, only base elements.	1	1	1	1740	NULL	0	45708.67503	0	0
7F2B2703-E44F-48CF-88AD-99D73BB872BF	CD491758-D9DF-4002-94C8-8006E1855F86	CO_Processes	Consolidation Base Process	5.0	5.0	1	1	"<process-descriptor return-type=""OLAPElementList"" return-value-description=""The list of consolidation processes."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""connection"" parameter-type=""OLAPConnection"" parameter-description=""A connection to the OLAP database to be used."" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""configurationSet"" parameter-type=""string"" parameter-description=""The configuration set to query."" parameter-order=""1"" />
  <dependencies />
  <bisharp-code>#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Processes(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of consolidation processes, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of consolidation processes."";
{
	return cached OLAPGetElementList(connection, ""DCONSRL"", true);
}</bisharp-code>
</process-descriptor>"	1	"#define EngineVersion 5.0
#define RuntimeVersion 5.0

OLAPElementList CO_Processes(OLAPConnection connection, string configurationSet)
@Category: ""Consolidation Base Process"";
@Description: ""Gets the list of consolidation processes, only base elements."";
@Parameter[connection]: ""A connection to the OLAP database to be used."";
@Parameter[configurationSet]: ""The configuration set to query."";
@Returns: ""The list of consolidation processes."";
{
	return cached OLAPGetElementList(connection, ""DCONSRL"", true);
}"	1	FAC36CEE-D8C0-42AD-B200-1CA693C3C2F9	Gets the list of consolidation processes, only base elements.	1	1	1	1741	NULL	0	45708.67501	0	0
228508EB-90D9-42B0-8BF6-98D8E243D8EA	CD491758-D9DF-4002-94C8-8006E1855F86	CO_RecurringJournalsCompany	Consolidation	5.0	5.0	1	1	"<process-descriptor return-type=""bool"" return-value-description=""True, if successful; false otherwise."" process-is-protected=""True"">
  <parameter-descriptor parameter-name=""server"" parameter-type=""string"" parameter-description=""OLAP Data Connection Name"" parameter-order=""0"" />
  <parameter-descriptor parameter-name=""cycle"" parameter-type=""string"" parameter-description=""the Configuration set element to run the rule for"" parameter-order=""1"" />
  <parameter-descriptor parameter-name=""year"" parameter-type=""string"" parameter-description=""the year to run the rule for"" parameter-order=""2"" />
  <parameter-descriptor parameter-name=""period"" parameter-type=""string"" parameter-description=""the period to run the rule for"" parameter-order=""3"" />
  <parameter-descriptor parameter-name=""scenario"" parameter-type=""string"" parameter-description=""the scenario to run the rule for"" parameter-order=""4"" />
  <parameter-descriptor parameter-name=""company"" parameter-type=""string"" parameter-description=""the company to run the rule for"" parameter-order=""5"" />
  <parameter-descriptor parameter-name=""ruleid"" parameter-type=""string"" parameter-description=""the id that will be used for journals"" parameter-order=""6"" />
  <parameter-descriptor parameter-name=""cancel"" parameter-type=""bool"" parameter-description=""if true, the rule will only cancel its journals or other old data"" parameter-order=""7"" />
  <dependencies />
  <bisharp-code>/*
 ***************************************************************
 *                                                             *
 *                           NOTICE                            *
 *                                                             *
 *   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
 *   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
 *   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
 *   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
 *   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
 *   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
 *   ALL OTHER RIGHTS RESERVED.                                *
 *                                                             *
 *   (c) COPYRIGHT 2015 INFOR.  ALL RIGHTS RESERVED.           *
 *   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
 *   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
 *   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
 *   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
 *   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
 *                                                             *
 ***************************************************************
 */

#define EngineVersion 5.0
#define RuntimeVersion 5.0

bool CO_RecurringJournalsCompany(string server, string cycle, string year, string period, string scenario, string company, string ruleid, bool cancel)
@Description: ""Former FCRecurringJournalsCompany process. Creates recurring journal bookings for all companies."";
@Category: ""Consolidation"";
@Parameter[server]: ""OLAP Data Connection Name"";
@Parameter[cycle]: ""the Configuration set element to run the rule for"";
@Parameter[year]: ""the year to run the rule for"";
@Parameter[period]: ""the period to run the rule for"";
@Parameter[scenario]: ""the scenario to run the rule for"";
@Parameter[company]: ""the company to run the rule for"";
@Parameter[ruleid]: ""the id that will be used for"														
